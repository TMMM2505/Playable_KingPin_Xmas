if ( TRACE ) { TRACE( JSON.parse( '["AnimKing#Awake","AnimKing#SetAnim","Bag#OnIdle","Bag#OnWin","Bag#OnLose","CameraAnchor#init","CameraAnchor#Start","CameraAnchor#UpdateAnchorAsync","CameraAnchor#UpdateAnchor","CameraAnchor#SetAnchor","Constant#init","DG.Tweening.DOTweenCYInstruction.WaitForCompletion#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForCompletion#ctor","DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#ctor","DG.Tweening.DOTweenCYInstruction.WaitForKill#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForKill#ctor","DG.Tweening.DOTweenCYInstruction.WaitForPosition#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForPosition#ctor","DG.Tweening.DOTweenCYInstruction.WaitForRewind#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForRewind#ctor","DG.Tweening.DOTweenCYInstruction.WaitForStart#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForStart#ctor","DG.Tweening.DOTweenModuleAudio#DOFade","DG.Tweening.DOTweenModuleAudio#DOPitch","DG.Tweening.DOTweenModuleAudio#DOSetFloat","DG.Tweening.DOTweenModuleAudio#DOComplete","DG.Tweening.DOTweenModuleAudio#DOKill","DG.Tweening.DOTweenModuleAudio#DOFlip","DG.Tweening.DOTweenModuleAudio#DOGoto","DG.Tweening.DOTweenModuleAudio#DOPause","DG.Tweening.DOTweenModuleAudio#DOPlay","DG.Tweening.DOTweenModuleAudio#DOPlayBackwards","DG.Tweening.DOTweenModuleAudio#DOPlayForward","DG.Tweening.DOTweenModuleAudio#DORestart","DG.Tweening.DOTweenModuleAudio#DORewind","DG.Tweening.DOTweenModuleAudio#DOSmoothRewind","DG.Tweening.DOTweenModuleAudio#DOTogglePause","DG.Tweening.DOTweenModulePhysics#DOMove","DG.Tweening.DOTweenModulePhysics#DOMoveX","DG.Tweening.DOTweenModulePhysics#DOMoveY","DG.Tweening.DOTweenModulePhysics#DOMoveZ","DG.Tweening.DOTweenModulePhysics#DORotate","DG.Tweening.DOTweenModulePhysics#DOLookAt","DG.Tweening.DOTweenModulePhysics#DOJump","DG.Tweening.DOTweenModulePhysics#DOPath","DG.Tweening.DOTweenModulePhysics#DOPath$1","DG.Tweening.DOTweenModulePhysics#DOLocalPath","DG.Tweening.DOTweenModulePhysics#DOLocalPath$1","DG.Tweening.DOTweenModulePhysics2D#DOMove","DG.Tweening.DOTweenModulePhysics2D#DOMoveX","DG.Tweening.DOTweenModulePhysics2D#DOMoveY","DG.Tweening.DOTweenModulePhysics2D#DORotate","DG.Tweening.DOTweenModulePhysics2D#DOJump","DG.Tweening.DOTweenModulePhysics2D#DOPath","DG.Tweening.DOTweenModulePhysics2D#DOPath$1","DG.Tweening.DOTweenModulePhysics2D#DOLocalPath","DG.Tweening.DOTweenModulePhysics2D#DOLocalPath$1","DG.Tweening.DOTweenModuleSprite#DOColor","DG.Tweening.DOTweenModuleSprite#DOFade","DG.Tweening.DOTweenModuleSprite#DOGradientColor","DG.Tweening.DOTweenModuleSprite#DOBlendableColor","DG.Tweening.DOTweenModuleUI#DOFade","DG.Tweening.DOTweenModuleUI#DOFade$1","DG.Tweening.DOTweenModuleUI#DOFade$2","DG.Tweening.DOTweenModuleUI#DOFade$3","DG.Tweening.DOTweenModuleUI#DOFade$4","DG.Tweening.DOTweenModuleUI#DOColor","DG.Tweening.DOTweenModuleUI#DOColor$1","DG.Tweening.DOTweenModuleUI#DOColor$2","DG.Tweening.DOTweenModuleUI#DOColor$3","DG.Tweening.DOTweenModuleUI#DOFillAmount","DG.Tweening.DOTweenModuleUI#DOGradientColor","DG.Tweening.DOTweenModuleUI#DOFlexibleSize","DG.Tweening.DOTweenModuleUI#DOMinSize","DG.Tweening.DOTweenModuleUI#DOPreferredSize","DG.Tweening.DOTweenModuleUI#DOScale","DG.Tweening.DOTweenModuleUI#DOAnchorPos","DG.Tweening.DOTweenModuleUI#DOAnchorPosX","DG.Tweening.DOTweenModuleUI#DOAnchorPosY","DG.Tweening.DOTweenModuleUI#DOAnchorPos3D","DG.Tweening.DOTweenModuleUI#DOAnchorPos3DX","DG.Tweening.DOTweenModuleUI#DOAnchorPos3DY","DG.Tweening.DOTweenModuleUI#DOAnchorPos3DZ","DG.Tweening.DOTweenModuleUI#DOAnchorMax","DG.Tweening.DOTweenModuleUI#DOAnchorMin","DG.Tweening.DOTweenModuleUI#DOPivot","DG.Tweening.DOTweenModuleUI#DOPivotX","DG.Tweening.DOTweenModuleUI#DOPivotY","DG.Tweening.DOTweenModuleUI#DOSizeDelta","DG.Tweening.DOTweenModuleUI#DOPunchAnchorPos","DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos","DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos$1","DG.Tweening.DOTweenModuleUI#DOJumpAnchorPos","DG.Tweening.DOTweenModuleUI#DONormalizedPos","DG.Tweening.DOTweenModuleUI#DOHorizontalNormalizedPos","DG.Tweening.DOTweenModuleUI#DOVerticalNormalizedPos","DG.Tweening.DOTweenModuleUI#DOValue","DG.Tweening.DOTweenModuleUI#DOCounter","DG.Tweening.DOTweenModuleUI#DOText","DG.Tweening.DOTweenModuleUI#DOBlendableColor","DG.Tweening.DOTweenModuleUI#DOBlendableColor$1","DG.Tweening.DOTweenModuleUI#DOBlendableColor$2","DG.Tweening.DOTweenModuleUI#DOShapeCircle","DG.Tweening.DOTweenModuleUI.Utils#SwitchToRectTransform","DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor","DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor$1","DG.Tweening.DOTweenModuleUnityVersion#WaitForCompletion","DG.Tweening.DOTweenModuleUnityVersion#WaitForRewind","DG.Tweening.DOTweenModuleUnityVersion#WaitForKill","DG.Tweening.DOTweenModuleUnityVersion#WaitForElapsedLoops","DG.Tweening.DOTweenModuleUnityVersion#WaitForPosition","DG.Tweening.DOTweenModuleUnityVersion#WaitForStart","DG.Tweening.DOTweenModuleUnityVersion#DOOffset","DG.Tweening.DOTweenModuleUnityVersion#DOTiling","DG.Tweening.DOTweenModuleUtils#Init","DG.Tweening.DOTweenModuleUtils#Preserver","DG.Tweening.DOTweenModuleUtils.Physics#SetOrientationOnPath","DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody2D","DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody","DG.Tweening.DOTweenModuleUtils.Physics#CreateDOTweenPathTween","InputReceiver#FirstClick#get","InputReceiver#FirstClick#set","InputReceiver#init","InputReceiver#Update","InputReceiver#HandleTarget","InputReceiver#TriggerCTA","King#Start","Pin#ActivePin","SkeletonGraphicPlayAnimationAtEvent#init","SkeletonGraphicPlayAnimationAtEvent#PlayAnimationLooping","SkeletonGraphicPlayAnimationAtEvent#PlayAnimationOnce","SkeletonGraphicPlayAnimationAtEvent#ClearTrack","SoundClick#Start","SoundClick#AudioReplay","Spine.BoneMatrix#CalculateSetupWorld","Spine.BoneMatrix#GetInheritedInternal","Spine.BoneMatrix#getDefaultValue","Spine.BoneMatrix#$ctor2","Spine.BoneMatrix#$ctor1","Spine.BoneMatrix#ctor","Spine.BoneMatrix#TransformMatrix","Spine.BoneMatrix#getHashCode","Spine.BoneMatrix#equals","Spine.BoneMatrix#$clone","Spine.SpineSkeletonExtensions#IsWeighted","Spine.SpineSkeletonExtensions#InheritsRotation","Spine.SpineSkeletonExtensions#InheritsScale","Spine.Unity.ActivateBasedOnFlipDirection#init","Spine.Unity.ActivateBasedOnFlipDirection#Start","Spine.Unity.ActivateBasedOnFlipDirection#FixedUpdate","Spine.Unity.ActivateBasedOnFlipDirection#HandleFlip","Spine.Unity.ActivateBasedOnFlipDirection#ResetJointPositions","Spine.Unity.ActivateBasedOnFlipDirection#CompensateMovementAfterFlipX","Spine.Unity.AnimationTools.TimelineExtensions#Evaluate$1","Spine.Unity.AnimationTools.TimelineExtensions#Evaluate$2","Spine.Unity.AnimationTools.TimelineExtensions#Evaluate","Spine.Unity.AnimationTools.TimelineExtensions#EvaluateTranslateXYMix","Spine.Unity.AnimationTools.TimelineExtensions#EvaluateRotateMix","Spine.Unity.AnimationTools.TimelineExtensions#FindTranslateTimelineForBone","Spine.Unity.AnimationTools.TimelineExtensions#FindTimelineForBone","Spine.Unity.AnimationTools.TimelineExtensions#FindTransformConstraintTimeline","Spine.Unity.AtlasAssetBase#TextureLoadingMode#get","Spine.Unity.AtlasAssetBase#TextureLoadingMode#set","Spine.Unity.AtlasAssetBase#OnDemandTextureLoader#get","Spine.Unity.AtlasAssetBase#OnDemandTextureLoader#set","Spine.Unity.AtlasAssetBase#init","Spine.Unity.AtlasAssetBase#BeginCustomTextureLoading","Spine.Unity.AtlasAssetBase#EndCustomTextureLoading","Spine.Unity.AtlasAssetBase#RequireTexturesLoaded","Spine.Unity.AtlasAssetBase#RequireTextureLoaded","Spine.Unity.AttachmentTools.AtlasUtilities#init","Spine.Unity.AttachmentTools.AtlasUtilities#Init","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$2","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$3","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$1","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$4","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone$2","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone$3","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone$1","Spine.Unity.AttachmentTools.AtlasUtilities#ToSpineAtlasPage","Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedAttachments","Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedAttachments$1","Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedSkin","Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedSkin$1","Spine.Unity.AttachmentTools.AtlasUtilities#ToSprite","Spine.Unity.AttachmentTools.AtlasUtilities#ClearCache","Spine.Unity.AttachmentTools.AtlasUtilities#ToTexture","Spine.Unity.AttachmentTools.AtlasUtilities#ToTexture$1","Spine.Unity.AttachmentTools.AtlasUtilities#GetClone","Spine.Unity.AttachmentTools.AtlasUtilities#CopyTexture","Spine.Unity.AttachmentTools.AtlasUtilities#CopyTextureApplyPMA","Spine.Unity.AttachmentTools.AtlasUtilities#IsRenderable","Spine.Unity.AttachmentTools.AtlasUtilities#SpineUnityFlipRect","Spine.Unity.AttachmentTools.AtlasUtilities#GetUnityRect","Spine.Unity.AttachmentTools.AtlasUtilities#GetUnityRect$1","Spine.Unity.AttachmentTools.AtlasUtilities#GetSpineAtlasRect","Spine.Unity.AttachmentTools.AtlasUtilities#UVRectToTextureRect","Spine.Unity.AttachmentTools.AtlasUtilities#TextureRectToUVRect","Spine.Unity.AttachmentTools.AtlasUtilities#UVRectToAtlasRegion","Spine.Unity.AttachmentTools.AtlasUtilities#GetMainTexture","Spine.Unity.AttachmentTools.AtlasUtilities#GetTexture$1","Spine.Unity.AttachmentTools.AtlasUtilities#GetTexture","Spine.Unity.AttachmentTools.AtlasUtilities#CopyTextureAttributesFrom","Spine.Unity.AttachmentTools.AtlasUtilities#InverseLerp","Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#getDefaultValue","Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#$ctor1","Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#ctor","Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#getHashCode","Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#equals","Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#$clone","Spine.Unity.AttachmentTools.AttachmentCloneExtensions#GetRemappedClone$1","Spine.Unity.AttachmentTools.AttachmentCloneExtensions#GetRemappedClone","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachment$2","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachment$1","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachment","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachmentPMAClone$1","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachmentPMAClone","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetScale$1","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetScale","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetPositionOffset$1","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetPositionOffset","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetRotation","Spine.Unity.BlendModeMaterials#RequiresBlendModeMaterials#get","Spine.Unity.BlendModeMaterials#RequiresBlendModeMaterials#set","Spine.Unity.BlendModeMaterials#init","Spine.Unity.BlendModeMaterials#BlendModeForMaterial","Spine.Unity.BlendModeMaterials#ApplyMaterials","Spine.Unity.BlendModeMaterials#CloneAtlasRegionWithMaterial","Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#init","Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#CloneAtlasRegionWithMaterial","Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#GetAtlasPageWithMaterial","Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#Dispose","Spine.Unity.BoneFollower#SkeletonRenderer#get","Spine.Unity.BoneFollower#SkeletonRenderer#set","Spine.Unity.BoneFollower#init","Spine.Unity.BoneFollower#SetBone","Spine.Unity.BoneFollower#Awake","Spine.Unity.BoneFollower#HandleRebuildRenderer","Spine.Unity.BoneFollower#Initialize","Spine.Unity.BoneFollower#OnDestroy","Spine.Unity.BoneFollower#LateUpdate","Spine.Unity.BoneFollowerGraphic#SkeletonGraphic#get","Spine.Unity.BoneFollowerGraphic#SkeletonGraphic#set","Spine.Unity.BoneFollowerGraphic#init","Spine.Unity.BoneFollowerGraphic#SetBone","Spine.Unity.BoneFollowerGraphic#Awake","Spine.Unity.BoneFollowerGraphic#Initialize","Spine.Unity.BoneFollowerGraphic#LateUpdate","Spine.Unity.BoundingBoxFollower#init","Spine.Unity.BoundingBoxFollower#Slot#get","Spine.Unity.BoundingBoxFollower#CurrentAttachment#get","Spine.Unity.BoundingBoxFollower#CurrentAttachmentName#get","Spine.Unity.BoundingBoxFollower#CurrentCollider#get","Spine.Unity.BoundingBoxFollower#IsTrigger#get","Spine.Unity.BoundingBoxFollower#init","Spine.Unity.BoundingBoxFollower#Start","Spine.Unity.BoundingBoxFollower#OnEnable","Spine.Unity.BoundingBoxFollower#HandleRebuild","Spine.Unity.BoundingBoxFollower#Initialize","Spine.Unity.BoundingBoxFollower#AddCollidersForSkin","Spine.Unity.BoundingBoxFollower#OnDisable","Spine.Unity.BoundingBoxFollower#ClearState","Spine.Unity.BoundingBoxFollower#DisposeExcessCollidersAfter","Spine.Unity.BoundingBoxFollower#LateUpdate","Spine.Unity.BoundingBoxFollower#MatchAttachment","Spine.Unity.BoundingBoxFollowerGraphic#init","Spine.Unity.BoundingBoxFollowerGraphic#Slot#get","Spine.Unity.BoundingBoxFollowerGraphic#CurrentAttachment#get","Spine.Unity.BoundingBoxFollowerGraphic#CurrentAttachmentName#get","Spine.Unity.BoundingBoxFollowerGraphic#CurrentCollider#get","Spine.Unity.BoundingBoxFollowerGraphic#IsTrigger#get","Spine.Unity.BoundingBoxFollowerGraphic#init","Spine.Unity.BoundingBoxFollowerGraphic#Start","Spine.Unity.BoundingBoxFollowerGraphic#OnEnable","Spine.Unity.BoundingBoxFollowerGraphic#HandleRebuild","Spine.Unity.BoundingBoxFollowerGraphic#Initialize","Spine.Unity.BoundingBoxFollowerGraphic#AddCollidersForSkin","Spine.Unity.BoundingBoxFollowerGraphic#OnDisable","Spine.Unity.BoundingBoxFollowerGraphic#ClearState","Spine.Unity.BoundingBoxFollowerGraphic#DisposeExcessCollidersAfter","Spine.Unity.BoundingBoxFollowerGraphic#LateUpdate","Spine.Unity.BoundingBoxFollowerGraphic#MatchAttachment","Spine.Unity.DoubleBuffered$1#init","Spine.Unity.DoubleBuffered$1#GetCurrent","Spine.Unity.DoubleBuffered$1#GetNext","Spine.Unity.EventDataReferenceAsset#init","Spine.Unity.EventDataReferenceAsset#op_Implicit","Spine.Unity.EventDataReferenceAsset#EventData#get","Spine.Unity.EventDataReferenceAsset#Initialize","Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools#MatchAnimationTimelines","Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools#GetFillerTimeline$12","Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools#GetFillerTimeline$9","Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools#GetFillerTimeline$14","Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools#GetFillerTimeline$10","Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools#GetFillerTimeline$11","Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools#GetFillerTimeline","Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools#GetFillerTimeline$8","Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools#GetFillerTimeline$7","Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools#GetFillerTimeline$1","Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools#GetFillerTimeline$2","Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools#GetFillerTimeline$3","Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools#GetFillerTimeline$13","Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools#GetFillerTimeline$5","Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools#GetFillerTimeline$6","Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools#GetFillerTimeline$4","Spine.Unity.Examples.AtlasRegionAttacher#init","Spine.Unity.Examples.AtlasRegionAttacher#Awake","Spine.Unity.Examples.AtlasRegionAttacher#Apply","Spine.Unity.Examples.AttackSpineboy#init","Spine.Unity.Examples.AttackSpineboy#init","Spine.Unity.Examples.AttackSpineboy#Update","Spine.Unity.Examples.BasicPlatformerController#init","Spine.Unity.Examples.BasicPlatformerController#Update","Spine.Unity.Examples.BasicPlatformerController#HandleStateChanged","Spine.Unity.Examples.BoneLocalOverride#init","Spine.Unity.Examples.BoneLocalOverride#Awake","Spine.Unity.Examples.BoneLocalOverride#OverrideLocal","Spine.Unity.Examples.CombinedSkin#Start","Spine.Unity.Examples.DummyMecanimControllerExample#init","Spine.Unity.Examples.DummyMecanimControllerExample#Awake","Spine.Unity.Examples.DummyMecanimControllerExample#Update","Spine.Unity.Examples.DummyMecanimControllerExample#FakeJump","Spine.Unity.Examples.EquipButtonExample#OnValidate","Spine.Unity.Examples.EquipButtonExample#MatchImage","Spine.Unity.Examples.EquipButtonExample#Start","Spine.Unity.Examples.EquipsVisualsComponentExample#Start","Spine.Unity.Examples.EquipsVisualsComponentExample#Equip","Spine.Unity.Examples.EquipsVisualsComponentExample#OptimizeSkin","Spine.Unity.Examples.EquipsVisualsComponentExample#RefreshSkeletonAttachments","Spine.Unity.Examples.FootSoldierExample#init","Spine.Unity.Examples.FootSoldierExample#Awake","Spine.Unity.Examples.FootSoldierExample#Apply","Spine.Unity.Examples.FootSoldierExample#Update","Spine.Unity.Examples.FootSoldierExample#Blink","Spine.Unity.Examples.Goblins#Start","Spine.Unity.Examples.Goblins#UpdateLocal","Spine.Unity.Examples.Goblins#OnMouseDown","Spine.Unity.Examples.HandleEventWithAudioExample#init","Spine.Unity.Examples.HandleEventWithAudioExample#OnValidate","Spine.Unity.Examples.HandleEventWithAudioExample#Start","Spine.Unity.Examples.HandleEventWithAudioExample#HandleAnimationStateEvent","Spine.Unity.Examples.HandleEventWithAudioExample#Play","Spine.Unity.Examples.HeroEffectsHandlerExample#Awake","Spine.Unity.Examples.JitterEffectExample#init","Spine.Unity.Examples.JitterEffectExample#OnEnable","Spine.Unity.Examples.JitterEffectExample#ProcessVertices","Spine.Unity.Examples.JitterEffectExample#OnDisable","Spine.Unity.Examples.MaterialReplacementExample#init","Spine.Unity.Examples.MaterialReplacementExample#Start","Spine.Unity.Examples.MaterialReplacementExample#Update","Spine.Unity.Examples.MaterialReplacementExample#SetReplacementEnabled","Spine.Unity.Examples.MecanimToAnimationHandleExample#OnStateEnter","Spine.Unity.Examples.MixAndMatch#init","Spine.Unity.Examples.MixAndMatch#OnValidate","Spine.Unity.Examples.MixAndMatch#Start","Spine.Unity.Examples.MixAndMatch#Apply","Spine.Unity.Examples.MixAndMatchGraphic#init","Spine.Unity.Examples.MixAndMatchGraphic#OnValidate","Spine.Unity.Examples.MixAndMatchGraphic#Start","Spine.Unity.Examples.MixAndMatchGraphic#Apply","Spine.Unity.Examples.MixAndMatchSkinsButtonExample#Start","Spine.Unity.Examples.MixAndMatchSkinsExample#init","Spine.Unity.Examples.MixAndMatchSkinsExample#Awake","Spine.Unity.Examples.MixAndMatchSkinsExample#Start","Spine.Unity.Examples.MixAndMatchSkinsExample#NextHairSkin","Spine.Unity.Examples.MixAndMatchSkinsExample#PrevHairSkin","Spine.Unity.Examples.MixAndMatchSkinsExample#NextEyesSkin","Spine.Unity.Examples.MixAndMatchSkinsExample#PrevEyesSkin","Spine.Unity.Examples.MixAndMatchSkinsExample#NextNoseSkin","Spine.Unity.Examples.MixAndMatchSkinsExample#PrevNoseSkin","Spine.Unity.Examples.MixAndMatchSkinsExample#Equip","Spine.Unity.Examples.MixAndMatchSkinsExample#OptimizeSkin","Spine.Unity.Examples.MixAndMatchSkinsExample#UpdateCharacterSkin","Spine.Unity.Examples.MixAndMatchSkinsExample#AddEquipmentSkinsTo","Spine.Unity.Examples.MixAndMatchSkinsExample#UpdateCombinedSkin","Spine.Unity.Examples.OutlineSkeletonGraphic#OnEnable","Spine.Unity.Examples.OutlineSkeletonGraphic#EnableOutlineRendering","Spine.Unity.Examples.OutlineSkeletonGraphic#DisableOutlineRendering","Spine.Unity.Examples.RaggedySpineboy#init","Spine.Unity.Examples.RaggedySpineboy#Start","Spine.Unity.Examples.RaggedySpineboy#AddRigidbody","Spine.Unity.Examples.RaggedySpineboy#RemoveRigidbody","Spine.Unity.Examples.RaggedySpineboy#OnMouseUp","Spine.Unity.Examples.RaggedySpineboy#Launch","Spine.Unity.Examples.RaggedySpineboy#Restore","Spine.Unity.Examples.RaggedySpineboy#WaitUntilStopped","Spine.Unity.Examples.Raptor#Start","Spine.Unity.Examples.Raptor#GunGrabRoutine","Spine.Unity.Examples.RenderExistingMesh#init","Spine.Unity.Examples.RenderExistingMesh#Awake","Spine.Unity.Examples.RenderExistingMesh#LateUpdate","Spine.Unity.Examples.RenderExistingMesh#UpdateOnCallback","Spine.Unity.Examples.RenderExistingMesh#UpdateMaterials","Spine.Unity.Examples.RenderExistingMesh#InitializeDict","Spine.Unity.Examples.RenderExistingMesh.MaterialReplacement#getDefaultValue","Spine.Unity.Examples.RenderExistingMesh.MaterialReplacement#ctor","Spine.Unity.Examples.RenderExistingMesh.MaterialReplacement#getHashCode","Spine.Unity.Examples.RenderExistingMesh.MaterialReplacement#equals","Spine.Unity.Examples.RenderExistingMesh.MaterialReplacement#$clone","Spine.Unity.Examples.RenderTextureFadeoutExample#init","Spine.Unity.Examples.RenderTextureFadeoutExample#Start","Spine.Unity.Examples.RenderTextureFadeoutExample#Update","Spine.Unity.Examples.RenderTextureFadeoutExample#UpdateBadFadeOutAlpha","Spine.Unity.Examples.RenderTextureFadeoutExample#StartFadeoutBad","Spine.Unity.Examples.RenderTextureFadeoutExample#StartFadeoutGood","Spine.Unity.Examples.RenderTextureFadeoutExample#DisableGameObject","Spine.Unity.Examples.RootMotionDeltaCompensation#init","Spine.Unity.Examples.RootMotionDeltaCompensation#Start","Spine.Unity.Examples.RootMotionDeltaCompensation#Update","Spine.Unity.Examples.RootMotionDeltaCompensation#OnDisable","Spine.Unity.Examples.RootMotionDeltaCompensation#AdjustDelta","Spine.Unity.Examples.RuntimeLoadFromExportsExample#init","Spine.Unity.Examples.RuntimeLoadFromExportsExample#CreateRuntimeAssetsAndGameObject","Spine.Unity.Examples.RuntimeLoadFromExportsExample#Start","Spine.Unity.Examples.SkeletonAnimationHandleExample#init","Spine.Unity.Examples.SkeletonAnimationHandleExample#Awake","Spine.Unity.Examples.SkeletonAnimationHandleExample#SetFlip","Spine.Unity.Examples.SkeletonAnimationHandleExample#PlayAnimationForState$1","Spine.Unity.Examples.SkeletonAnimationHandleExample#PlayAnimationForState","Spine.Unity.Examples.SkeletonAnimationHandleExample#GetAnimationForState$1","Spine.Unity.Examples.SkeletonAnimationHandleExample#GetAnimationForState","Spine.Unity.Examples.SkeletonAnimationHandleExample#PlayNewAnimation","Spine.Unity.Examples.SkeletonAnimationHandleExample#PlayOneShot","Spine.Unity.Examples.SkeletonAnimationHandleExample#TryGetTransition","Spine.Unity.Examples.SkeletonAnimationHandleExample#GetCurrentAnimation","Spine.Unity.Examples.SkeletonAnimationHandleExample#StringToHash","Spine.Unity.Examples.SkeletonGhost#init","Spine.Unity.Examples.SkeletonGhost#HexToColor","Spine.Unity.Examples.SkeletonGhost#init","Spine.Unity.Examples.SkeletonGhost#Start","Spine.Unity.Examples.SkeletonGhost#Initialize","Spine.Unity.Examples.SkeletonGhost#OnEvent","Spine.Unity.Examples.SkeletonGhost#Ghosting","Spine.Unity.Examples.SkeletonGhost#Update","Spine.Unity.Examples.SkeletonGhost#OnDestroy","Spine.Unity.Examples.SkeletonGhostRenderer#init","Spine.Unity.Examples.SkeletonGhostRenderer#init","Spine.Unity.Examples.SkeletonGhostRenderer#Awake","Spine.Unity.Examples.SkeletonGhostRenderer#Initialize","Spine.Unity.Examples.SkeletonGhostRenderer#Fade","Spine.Unity.Examples.SkeletonGhostRenderer#FadeAdditive","Spine.Unity.Examples.SkeletonGhostRenderer#Cleanup","Spine.Unity.Examples.SkeletonGraphicMirror#init","Spine.Unity.Examples.SkeletonGraphicMirror#Awake","Spine.Unity.Examples.SkeletonGraphicMirror#Start","Spine.Unity.Examples.SkeletonGraphicMirror#LateUpdate","Spine.Unity.Examples.SkeletonGraphicMirror#OnDisable","Spine.Unity.Examples.SkeletonGraphicMirror#StartMirroring","Spine.Unity.Examples.SkeletonGraphicMirror#UpdateTexture","Spine.Unity.Examples.SkeletonGraphicMirror#RestoreIndependentSkeleton","Spine.Unity.Examples.SkeletonRenderTextureBase#init","Spine.Unity.Examples.SkeletonRenderTextureBase#Awake","Spine.Unity.Examples.SkeletonRenderTextureBase#OnDestroy","Spine.Unity.Examples.SkeletonRenderTextureBase#PrepareTextureMapping","Spine.Unity.Examples.SkeletonRenderTextureBase#PrepareRenderTexture","Spine.Unity.Examples.SkeletonRenderTextureBase#AssignAtQuad","Spine.Unity.Examples.SkeletonGraphicRenderTexture.TextureMaterialPair#getDefaultValue","Spine.Unity.Examples.SkeletonGraphicRenderTexture.TextureMaterialPair#$ctor1","Spine.Unity.Examples.SkeletonGraphicRenderTexture.TextureMaterialPair#ctor","Spine.Unity.Examples.SkeletonGraphicRenderTexture.TextureMaterialPair#getHashCode","Spine.Unity.Examples.SkeletonGraphicRenderTexture.TextureMaterialPair#equals","Spine.Unity.Examples.SkeletonGraphicRenderTexture.TextureMaterialPair#$clone","Spine.Unity.Examples.SkeletonRagdoll#RootOffset#get","Spine.Unity.Examples.SkeletonRagdoll#IsActive#get","Spine.Unity.Examples.SkeletonRagdoll#RigidbodyArray#get","Spine.Unity.Examples.SkeletonRagdoll#EstimatedSkeletonPosition#get","Spine.Unity.Examples.SkeletonRagdoll#init","Spine.Unity.Examples.SkeletonRagdoll#Start","Spine.Unity.Examples.SkeletonRagdoll#Apply","Spine.Unity.Examples.SkeletonRagdoll#SmoothMix","Spine.Unity.Examples.SkeletonRagdoll#SmoothMixCoroutine","Spine.Unity.Examples.SkeletonRagdoll#SetSkeletonPosition","Spine.Unity.Examples.SkeletonRagdoll#Remove","Spine.Unity.Examples.SkeletonRagdoll#GetRigidbody","Spine.Unity.Examples.SkeletonRagdoll#RecursivelyCreateBoneProxies","Spine.Unity.Examples.SkeletonRagdoll#UpdateSpineSkeleton","Spine.Unity.Examples.SkeletonRagdoll#GetStartBoneParentFlipState","Spine.Unity.Examples.SkeletonRagdoll#AttachBoundingBoxRagdollColliders","Spine.Unity.Examples.SkeletonRagdoll.BoneFlipEntry#getDefaultValue","Spine.Unity.Examples.SkeletonRagdoll.BoneFlipEntry#$ctor1","Spine.Unity.Examples.SkeletonRagdoll.BoneFlipEntry#ctor","Spine.Unity.Examples.SkeletonRagdoll.BoneFlipEntry#getHashCode","Spine.Unity.Examples.SkeletonRagdoll.BoneFlipEntry#equals","Spine.Unity.Examples.SkeletonRagdoll.BoneFlipEntry#$clone","Spine.Unity.Examples.SkeletonRagdoll2D#AttachBoundingBoxRagdollColliders","Spine.Unity.Examples.SkeletonRagdoll2D#FlipScale","Spine.Unity.Examples.SkeletonRagdoll2D#RootOffset#get","Spine.Unity.Examples.SkeletonRagdoll2D#IsActive#get","Spine.Unity.Examples.SkeletonRagdoll2D#RigidbodyArray#get","Spine.Unity.Examples.SkeletonRagdoll2D#EstimatedSkeletonPosition#get","Spine.Unity.Examples.SkeletonRagdoll2D#init","Spine.Unity.Examples.SkeletonRagdoll2D#Start","Spine.Unity.Examples.SkeletonRagdoll2D#Apply","Spine.Unity.Examples.SkeletonRagdoll2D#SmoothMix","Spine.Unity.Examples.SkeletonRagdoll2D#SmoothMixCoroutine","Spine.Unity.Examples.SkeletonRagdoll2D#SetSkeletonPosition","Spine.Unity.Examples.SkeletonRagdoll2D#Remove","Spine.Unity.Examples.SkeletonRagdoll2D#GetRigidbody","Spine.Unity.Examples.SkeletonRagdoll2D#RecursivelyCreateBoneProxies","Spine.Unity.Examples.SkeletonRagdoll2D#UpdateSpineSkeleton","Spine.Unity.Examples.SkeletonRagdoll2D#GetStartBoneParentFlipState","Spine.Unity.Examples.SkeletonRagdoll2D.BoneFlipEntry#getDefaultValue","Spine.Unity.Examples.SkeletonRagdoll2D.BoneFlipEntry#$ctor1","Spine.Unity.Examples.SkeletonRagdoll2D.BoneFlipEntry#ctor","Spine.Unity.Examples.SkeletonRagdoll2D.BoneFlipEntry#getHashCode","Spine.Unity.Examples.SkeletonRagdoll2D.BoneFlipEntry#equals","Spine.Unity.Examples.SkeletonRagdoll2D.BoneFlipEntry#$clone","Spine.Unity.Examples.SkeletonRenderTextureFadeout#init","Spine.Unity.Examples.SkeletonRenderTextureFadeout#Awake","Spine.Unity.Examples.SkeletonRenderTextureFadeout#OnEnable","Spine.Unity.Examples.SkeletonRenderTextureFadeout#Update","Spine.Unity.SkeletonUtilityConstraint#OnEnable","Spine.Unity.SkeletonUtilityConstraint#OnDisable","Spine.Unity.Examples.SkeletonUtilityKinematicShadow#DestroyComponents","Spine.Unity.Examples.SkeletonUtilityKinematicShadow#init","Spine.Unity.Examples.SkeletonUtilityKinematicShadow#Start","Spine.Unity.Examples.SkeletonUtilityKinematicShadow#FixedUpdate","Spine.Unity.Examples.SkeletonUtilityKinematicShadow.TransformPair#getDefaultValue","Spine.Unity.Examples.SkeletonUtilityKinematicShadow.TransformPair#ctor","Spine.Unity.Examples.SkeletonUtilityKinematicShadow.TransformPair#getHashCode","Spine.Unity.Examples.SkeletonUtilityKinematicShadow.TransformPair#equals","Spine.Unity.Examples.SkeletonUtilityKinematicShadow.TransformPair#$clone","Spine.Unity.Examples.SlotTintBlackFollower#init","Spine.Unity.Examples.SlotTintBlackFollower#Start","Spine.Unity.Examples.SlotTintBlackFollower#Initialize","Spine.Unity.Examples.SlotTintBlackFollower#Update","Spine.Unity.Examples.SlotTintBlackFollower#OnDisable","Spine.Unity.Examples.SpawnFromSkeletonDataExample#init","Spine.Unity.Examples.SpawnFromSkeletonDataExample#Start","Spine.Unity.Examples.SpawnFromSkeletonDataExample#DoExtraStuff","Spine.Unity.Examples.SpawnSkeletonGraphicExample#init","Spine.Unity.Examples.SpawnSkeletonGraphicExample#Start","Spine.Unity.Examples.SpineAnimationTesterTool.AnimationControl#getDefaultValue","Spine.Unity.Examples.SpineAnimationTesterTool.AnimationControl#ctor","Spine.Unity.Examples.SpineAnimationTesterTool.AnimationControl#getHashCode","Spine.Unity.Examples.SpineAnimationTesterTool.AnimationControl#equals","Spine.Unity.Examples.SpineAnimationTesterTool.AnimationControl#$clone","Spine.Unity.Examples.SpineAnimationTesterTool.ControlledTrack#init","Spine.Unity.Examples.SpineBeginnerTwo#init","Spine.Unity.Examples.SpineBeginnerTwo#Start","Spine.Unity.Examples.SpineBeginnerTwo#DoDemoRoutine","Spine.Unity.Examples.SpineBlinkPlayer#init","Spine.Unity.Examples.SpineBlinkPlayer#init","Spine.Unity.Examples.SpineBlinkPlayer#Start","Spine.Unity.Examples.Spineboy#Start","Spine.Unity.Examples.Spineboy#HandleEvent","Spine.Unity.Examples.Spineboy#OnMouseDown","Spine.Unity.Examples.SpineboyBeginnerInput#init","Spine.Unity.Examples.SpineboyBeginnerInput#OnValidate","Spine.Unity.Examples.SpineboyBeginnerInput#Update","Spine.Unity.Examples.SpineboyBeginnerModel#init","Spine.Unity.Examples.SpineboyBeginnerModel#TryJump","Spine.Unity.Examples.SpineboyBeginnerModel#TryShoot","Spine.Unity.Examples.SpineboyBeginnerModel#StartAim","Spine.Unity.Examples.SpineboyBeginnerModel#StopAim","Spine.Unity.Examples.SpineboyBeginnerModel#TryMove","Spine.Unity.Examples.SpineboyBeginnerModel#JumpRoutine","Spine.Unity.Examples.SpineboyBeginnerView#init","Spine.Unity.Examples.SpineboyBeginnerView#Start","Spine.Unity.Examples.SpineboyBeginnerView#HandleEvent","Spine.Unity.Examples.SpineboyBeginnerView#Update","Spine.Unity.Examples.SpineboyBeginnerView#PlayNewStableAnimation","Spine.Unity.Examples.SpineboyBeginnerView#PlayFootstepSound","Spine.Unity.Examples.SpineboyBeginnerView#CheckTracks","Spine.Unity.Examples.SpineboyBeginnerView#PlayShoot","Spine.Unity.Examples.SpineboyBeginnerView#StartPlayingAim","Spine.Unity.Examples.SpineboyBeginnerView#StopPlayingAim","Spine.Unity.Examples.SpineboyBeginnerView#Turn","Spine.Unity.Examples.SpineboyBeginnerView#GetRandomPitch","Spine.Unity.Examples.SpineboyBeginnerViewGraphic#init","Spine.Unity.Examples.SpineboyBeginnerViewGraphic#Start","Spine.Unity.Examples.SpineboyBeginnerViewGraphic#HandleEvent","Spine.Unity.Examples.SpineboyBeginnerViewGraphic#Update","Spine.Unity.Examples.SpineboyBeginnerViewGraphic#PlayNewStableAnimation","Spine.Unity.Examples.SpineboyBeginnerViewGraphic#PlayFootstepSound","Spine.Unity.Examples.SpineboyBeginnerViewGraphic#CheckTracks","Spine.Unity.Examples.SpineboyBeginnerViewGraphic#PlayShoot","Spine.Unity.Examples.SpineboyBeginnerViewGraphic#StartPlayingAim","Spine.Unity.Examples.SpineboyBeginnerViewGraphic#StopPlayingAim","Spine.Unity.Examples.SpineboyBeginnerViewGraphic#Turn","Spine.Unity.Examples.SpineboyBeginnerViewGraphic#GetRandomPitch","Spine.Unity.Examples.SpineboyBodyTilt#init","Spine.Unity.Examples.SpineboyBodyTilt#Start","Spine.Unity.Examples.SpineboyBodyTilt#UpdateLocal","Spine.Unity.Examples.SpineboyFacialExpression#init","Spine.Unity.Examples.SpineboyFacialExpression#Start","Spine.Unity.Examples.SpineboyFacialExpression#Update","Spine.Unity.Examples.SpineboyFootplanter#Balance#get","Spine.Unity.Examples.SpineboyFootplanter#init","Spine.Unity.Examples.SpineboyFootplanter#Start","Spine.Unity.Examples.SpineboyFootplanter#UpdateLocal","Spine.Unity.Examples.SpineboyFootplanter#OnDrawGizmos","Spine.Unity.Examples.SpineboyFootplanter.Foot#GetNewDisplacement","Spine.Unity.Examples.SpineboyFootplanter.Foot#IsStepInProgress#get","Spine.Unity.Examples.SpineboyFootplanter.Foot#IsPrettyMuchDoneStepping#get","Spine.Unity.Examples.SpineboyFootplanter.Foot#init","Spine.Unity.Examples.SpineboyFootplanter.Foot#UpdateDistance","Spine.Unity.Examples.SpineboyFootplanter.Foot#StartNewStep","Spine.Unity.Examples.SpineboyFootplanter.Foot#UpdateStepProgress","Spine.Unity.Examples.SpineboyFreeze#init","Spine.Unity.Examples.SpineboyFreeze#Start","Spine.Unity.Examples.SpineboyPole#init","Spine.Unity.Examples.SpineboyPole#Start","Spine.Unity.Examples.SpineboyPole#SetXPosition","Spine.Unity.Examples.SpineboyPoleGraphic#init","Spine.Unity.Examples.SpineboyPoleGraphic#Start","Spine.Unity.Examples.SpineboyPoleGraphic#SetXPosition","Spine.Unity.Examples.SpineboyTargetController#OnValidate","Spine.Unity.Examples.SpineboyTargetController#Start","Spine.Unity.Examples.SpineboyTargetController#Update","Spine.Unity.Examples.SpineboyTargetControllerGraphic#OnValidate","Spine.Unity.Examples.SpineboyTargetControllerGraphic#Start","Spine.Unity.Examples.SpineboyTargetControllerGraphic#Update","Spine.Unity.Examples.SpineGauge#init","Spine.Unity.Examples.SpineGauge#Awake","Spine.Unity.Examples.SpineGauge#Update","Spine.Unity.Examples.SpineGauge#SetGaugePercent","Spine.Unity.Examples.SpriteAttacher#init","Spine.Unity.Examples.SpriteAttacher#GetPageFor","Spine.Unity.Examples.SpriteAttacher#init","Spine.Unity.Examples.SpriteAttacher#Start","Spine.Unity.Examples.SpriteAttacher#AnimationOverrideSpriteAttach","Spine.Unity.Examples.SpriteAttacher#Initialize","Spine.Unity.Examples.SpriteAttacher#OnDestroy","Spine.Unity.Examples.SpriteAttacher#Attach","Spine.Unity.Examples.SpriteAttachmentExtensions#AttachUnitySprite","Spine.Unity.Examples.SpriteAttachmentExtensions#AttachUnitySprite$1","Spine.Unity.Examples.SpriteAttachmentExtensions#AddUnitySprite","Spine.Unity.Examples.SpriteAttachmentExtensions#AddUnitySprite$1","Spine.Unity.Examples.TransitionDictionaryExample#init","Spine.Unity.Examples.TransitionDictionaryExample#Start","Spine.Unity.Examples.TransitionDictionaryExample#GetTransition","Spine.Unity.Examples.TransitionDictionaryExample.SerializedEntry#getDefaultValue","Spine.Unity.Examples.TransitionDictionaryExample.SerializedEntry#ctor","Spine.Unity.Examples.TransitionDictionaryExample.SerializedEntry#getHashCode","Spine.Unity.Examples.TransitionDictionaryExample.SerializedEntry#equals","Spine.Unity.Examples.TransitionDictionaryExample.SerializedEntry#$clone","Spine.Unity.Examples.TwoByTwoTransformEffectExample#init","Spine.Unity.Examples.TwoByTwoTransformEffectExample#OnEnable","Spine.Unity.Examples.TwoByTwoTransformEffectExample#ProcessVertices","Spine.Unity.Examples.TwoByTwoTransformEffectExample#OnDisable","Spine.Unity.ISpineComponentExtensions#IsNullOrDestroyed","Spine.Unity.MaterialsTextureLoader#ctor","Spine.Unity.MaterialsTextureLoader#Load","Spine.Unity.MaterialsTextureLoader#Unload","Spine.Unity.MathUtilities#InverseLerp","Spine.Unity.MathUtilities#InverseLerp$1","Spine.Unity.MathUtilities#InverseLerp$2","Spine.Unity.MathUtilities#InverseLerp$3","Spine.Unity.MeshGenerator#init","Spine.Unity.MeshGenerator#GenerateSingleSubmeshInstruction","Spine.Unity.MeshGenerator#RequiresMultipleSubmeshesByDrawOrder","Spine.Unity.MeshGenerator#GenerateSkeletonRendererInstruction","Spine.Unity.MeshGenerator#TryReplaceMaterials","Spine.Unity.MeshGenerator#SolveTangents2DEnsureSize","Spine.Unity.MeshGenerator#SolveTangents2DTriangles","Spine.Unity.MeshGenerator#SolveTangents2DBuffer","Spine.Unity.MeshGenerator#FillMeshLocal$1","Spine.Unity.MeshGenerator#FillMeshLocal","Spine.Unity.MeshGenerator#VertexCount#get","Spine.Unity.MeshGenerator#Buffers#get","Spine.Unity.MeshGenerator#init","Spine.Unity.MeshGenerator#ctor","Spine.Unity.MeshGenerator#SubmeshIndexCount","Spine.Unity.MeshGenerator#Begin","Spine.Unity.MeshGenerator#AddSubmesh","Spine.Unity.MeshGenerator#BuildMesh","Spine.Unity.MeshGenerator#BuildMeshWithArrays","Spine.Unity.MeshGenerator#ScaleVertexData","Spine.Unity.MeshGenerator#GetMeshBounds","Spine.Unity.MeshGenerator#AddAttachmentTintBlack","Spine.Unity.MeshGenerator#FillVertexData","Spine.Unity.MeshGenerator#FillLateVertexData","Spine.Unity.MeshGenerator#FillTriangles","Spine.Unity.MeshGenerator#EnsureVertexCapacity","Spine.Unity.MeshGenerator#TrimExcess","Spine.Unity.MeshGenerator.Settings#Default#get","Spine.Unity.MeshGenerator.Settings#getDefaultValue","Spine.Unity.MeshGenerator.Settings#ctor","Spine.Unity.MeshGenerator.Settings#getHashCode","Spine.Unity.MeshGenerator.Settings#equals","Spine.Unity.MeshGenerator.Settings#$clone","Spine.Unity.MeshGeneratorBuffers#getDefaultValue","Spine.Unity.MeshGeneratorBuffers#ctor","Spine.Unity.MeshGeneratorBuffers#getHashCode","Spine.Unity.MeshGeneratorBuffers#equals","Spine.Unity.MeshGeneratorBuffers#$clone","Spine.Unity.MeshRendererBuffers#init","Spine.Unity.MeshRendererBuffers#Initialize","Spine.Unity.MeshRendererBuffers#GetUpdatedSharedMaterialsArray","Spine.Unity.MeshRendererBuffers#MaterialsChangedInLastUpdate","Spine.Unity.MeshRendererBuffers#UpdateSharedMaterials","Spine.Unity.MeshRendererBuffers#GetNextMesh","Spine.Unity.MeshRendererBuffers#Clear","Spine.Unity.MeshRendererBuffers#Dispose","Spine.Unity.MeshRendererBuffers.SmartMesh#init","Spine.Unity.MeshRendererBuffers.SmartMesh#Clear","Spine.Unity.MeshRendererBuffers.SmartMesh#Dispose","Spine.Unity.NoOpTextureLoader#Load","Spine.Unity.NoOpTextureLoader#Unload","Spine.Unity.OnDemandTextureLoader#addTextureRequested","Spine.Unity.OnDemandTextureLoader#removeTextureRequested","Spine.Unity.OnDemandTextureLoader#addTextureLoaded","Spine.Unity.OnDemandTextureLoader#removeTextureLoaded","Spine.Unity.OnDemandTextureLoader#addTextureUnloaded","Spine.Unity.OnDemandTextureLoader#removeTextureUnloaded","Spine.Unity.OnDemandTextureLoader#HasNullMainTexturesAssigned","Spine.Unity.OnDemandTextureLoader#OnTextureRequested","Spine.Unity.OnDemandTextureLoader#OnTextureLoaded","Spine.Unity.OnDemandTextureLoader#OnTextureUnloaded","Spine.Unity.Prototyping.SkeletonColorInitialize#init","Spine.Unity.Prototyping.SkeletonColorInitialize#Start","Spine.Unity.Prototyping.SkeletonColorInitialize#ApplySettings","Spine.Unity.Prototyping.SkeletonColorInitialize.SlotSettings#init","Spine.Unity.Prototyping.SpineEventUnityHandler#init","Spine.Unity.Prototyping.SpineEventUnityHandler#Start","Spine.Unity.Prototyping.SpineEventUnityHandler#OnDestroy","Spine.Unity.RegionlessAttachmentLoader#EmptyRegion#get","Spine.Unity.RegionlessAttachmentLoader#NewRegionAttachment","Spine.Unity.RegionlessAttachmentLoader#NewMeshAttachment","Spine.Unity.RegionlessAttachmentLoader#NewBoundingBoxAttachment","Spine.Unity.RegionlessAttachmentLoader#NewPathAttachment","Spine.Unity.RegionlessAttachmentLoader#NewPointAttachment","Spine.Unity.RegionlessAttachmentLoader#NewClippingAttachment","Spine.Unity.SkeletonAnimationFixedTimestep#init","Spine.Unity.SkeletonAnimationFixedTimestep#OnValidate","Spine.Unity.SkeletonAnimationFixedTimestep#Awake","Spine.Unity.SkeletonAnimationFixedTimestep#Update","Spine.Unity.SkeletonAnimationFixedTimestep#LateUpdate","Spine.Unity.SkeletonAnimationMulti#init","Spine.Unity.SkeletonAnimationMulti#AnimationSkeletonTable#get","Spine.Unity.SkeletonAnimationMulti#AnimationNameTable#get","Spine.Unity.SkeletonAnimationMulti#CurrentSkeletonAnimation#get","Spine.Unity.SkeletonAnimationMulti#SkeletonAnimations#get","Spine.Unity.SkeletonAnimationMulti#init","Spine.Unity.SkeletonAnimationMulti#Clear","Spine.Unity.SkeletonAnimationMulti#SetActiveSkeleton$1","Spine.Unity.SkeletonAnimationMulti#SetActiveSkeleton","Spine.Unity.SkeletonAnimationMulti#Awake","Spine.Unity.SkeletonAnimationMulti#Initialize","Spine.Unity.SkeletonAnimationMulti#FindAnimation","Spine.Unity.SkeletonAnimationMulti#SetAnimation$1","Spine.Unity.SkeletonAnimationMulti#SetAnimation","Spine.Unity.SkeletonAnimationMulti#SetEmptyAnimation","Spine.Unity.SkeletonAnimationMulti#ClearAnimation","Spine.Unity.SkeletonAnimationMulti#GetCurrent","Spine.Unity.SkeletonDataAsset#CreateRuntimeInstance","Spine.Unity.SkeletonDataAsset#CreateRuntimeInstance$1","Spine.Unity.SkeletonDataAsset#ReadSkeletonData","Spine.Unity.SkeletonDataAsset#ReadSkeletonData$1","Spine.Unity.SkeletonDataAsset#IsLoaded#get","Spine.Unity.SkeletonDataAsset#init","Spine.Unity.SkeletonDataAsset#Reset","Spine.Unity.SkeletonDataAsset#Clear","Spine.Unity.SkeletonDataAsset#GetAnimationStateData","Spine.Unity.SkeletonDataAsset#GetSkeletonData","Spine.Unity.SkeletonDataAsset#InitializeWithData","Spine.Unity.SkeletonDataAsset#FillStateData","Spine.Unity.SkeletonDataAsset#GetAtlasArray","Spine.Unity.SkeletonDataCompatibility.CompatibilityProblemInfo#DescriptionString","Spine.Unity.SkeletonExtensions#init","Spine.Unity.SkeletonExtensions#GetColor$2","Spine.Unity.SkeletonExtensions#GetColor$1","Spine.Unity.SkeletonExtensions#GetColor","Spine.Unity.SkeletonExtensions#GetColor$3","Spine.Unity.SkeletonExtensions#GetColorTintBlack","Spine.Unity.SkeletonExtensions#SetColor$4","Spine.Unity.SkeletonExtensions#SetColor$5","Spine.Unity.SkeletonExtensions#SetColor$6","Spine.Unity.SkeletonExtensions#SetColor$7","Spine.Unity.SkeletonExtensions#SetColor$2","Spine.Unity.SkeletonExtensions#SetColor$3","Spine.Unity.SkeletonExtensions#SetColor","Spine.Unity.SkeletonExtensions#SetColor$1","Spine.Unity.SkeletonExtensions#SetLocalScale","Spine.Unity.SkeletonExtensions#GetMatrix4x4","Spine.Unity.SkeletonExtensions#SetLocalPosition","Spine.Unity.SkeletonExtensions#SetLocalPosition$1","Spine.Unity.SkeletonExtensions#GetLocalPosition","Spine.Unity.SkeletonExtensions#GetSkeletonSpacePosition","Spine.Unity.SkeletonExtensions#GetSkeletonSpacePosition$1","Spine.Unity.SkeletonExtensions#GetWorldPosition","Spine.Unity.SkeletonExtensions#GetWorldPosition$1","Spine.Unity.SkeletonExtensions#GetWorldPosition$3","Spine.Unity.SkeletonExtensions#GetWorldPosition$2","Spine.Unity.SkeletonExtensions#GetQuaternion","Spine.Unity.SkeletonExtensions#GetLocalQuaternion","Spine.Unity.SkeletonExtensions#GetLocalScale","Spine.Unity.SkeletonExtensions#GetWorldToLocalMatrix","Spine.Unity.SkeletonExtensions#WorldToLocal","Spine.Unity.SkeletonExtensions#SetPositionSkeletonSpace","Spine.Unity.SkeletonExtensions#GetMaterial","Spine.Unity.SkeletonExtensions#GetLocalVertices","Spine.Unity.SkeletonExtensions#GetWorldVertices","Spine.Unity.SkeletonGraphicCustomMaterials#init","Spine.Unity.SkeletonGraphicCustomMaterials#SetCustomMaterialOverrides","Spine.Unity.SkeletonGraphicCustomMaterials#RemoveCustomMaterialOverrides","Spine.Unity.SkeletonGraphicCustomMaterials#SetCustomTextureOverrides","Spine.Unity.SkeletonGraphicCustomMaterials#RemoveCustomTextureOverrides","Spine.Unity.SkeletonGraphicCustomMaterials#OnEnable","Spine.Unity.SkeletonGraphicCustomMaterials#OnDisable","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#inherits","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#getDefaultValue","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#ctor","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#equalsT","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#getHashCode","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#$clone","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#inherits","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#getDefaultValue","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#ctor","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#equalsT","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#getHashCode","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#$clone","Spine.Unity.SkeletonMecanim.MecanimTranslator#init","Spine.Unity.SkeletonMecanim.MecanimTranslator#AnimationTime","Spine.Unity.SkeletonMecanim.MecanimTranslator#ToSpineAnimationTime","Spine.Unity.SkeletonMecanim.MecanimTranslator#Animator#get","Spine.Unity.SkeletonMecanim.MecanimTranslator#MecanimLayerCount#get","Spine.Unity.SkeletonMecanim.MecanimTranslator#MecanimLayerNames#get","Spine.Unity.SkeletonMecanim.MecanimTranslator#init","Spine.Unity.SkeletonMecanim.MecanimTranslator#addOnClipApplied","Spine.Unity.SkeletonMecanim.MecanimTranslator#removeOnClipApplied","Spine.Unity.SkeletonMecanim.MecanimTranslator#Initialize","Spine.Unity.SkeletonMecanim.MecanimTranslator#ApplyAnimation","Spine.Unity.SkeletonMecanim.MecanimTranslator#ApplyInterruptionAnimation","Spine.Unity.SkeletonMecanim.MecanimTranslator#OnClipAppliedCallback","Spine.Unity.SkeletonMecanim.MecanimTranslator#Apply","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetActiveAnimationAndTime","Spine.Unity.SkeletonMecanim.MecanimTranslator#InitClipInfosForLayers","Spine.Unity.SkeletonMecanim.MecanimTranslator#ClearClipInfosForLayers","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetMixMode","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetStateUpdatesFromAnimator","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimatorClipInfos","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimatorStateInfos","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimation","Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#init","Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#equals2","Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#getHashCode2","Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos#init","Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#init","Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#equals2","Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#getHashCode2","Spine.Unity.SkeletonRootMotionBase#RootMotionBone#get","Spine.Unity.SkeletonRootMotionBase#UsesRigidbody#get","Spine.Unity.SkeletonRootMotionBase#PreviousRigidbodyRootMotion2D#get","Spine.Unity.SkeletonRootMotionBase#PreviousRigidbodyRootMotion3D#get","Spine.Unity.SkeletonRootMotionBase#AdditionalRigidbody2DMovement#get","Spine.Unity.SkeletonRootMotionBase#AdditionalRigidbody2DMovement#set","Spine.Unity.SkeletonRootMotionBase#SkeletonAnimationUsesFixedUpdate#get","Spine.Unity.SkeletonRootMotionBase#AdditionalScale#get","Spine.Unity.SkeletonRootMotionBase#TargetSkeletonComponent#get","Spine.Unity.SkeletonRootMotionBase#TargetSkeletonAnimationComponent#get","Spine.Unity.SkeletonRootMotionBase#init","Spine.Unity.SkeletonRootMotionBase#Reset","Spine.Unity.SkeletonRootMotionBase#Start","Spine.Unity.SkeletonRootMotionBase#FixedUpdate","Spine.Unity.SkeletonRootMotionBase#PhysicsUpdate","Spine.Unity.SkeletonRootMotionBase#OnDisable","Spine.Unity.SkeletonRootMotionBase#FindRigidbodyComponent","Spine.Unity.SkeletonRootMotionBase#CalculateAnimationsRotationDelta","Spine.Unity.SkeletonRootMotionBase#SetRootMotionBone","Spine.Unity.SkeletonRootMotionBase#AdjustRootMotionToDistance","Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotion","Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotion$1","Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotionRotation","Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotionRotation$1","Spine.Unity.SkeletonRootMotionBase#ApplyConstraintToPos","Spine.Unity.SkeletonRootMotionBase#ApplyConstraintToRotation","Spine.Unity.SkeletonRootMotionBase#UpdateLastConstraintPos","Spine.Unity.SkeletonRootMotionBase#UpdateLastConstraintRotation","Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotionInfo","Spine.Unity.SkeletonRootMotionBase#GetConstraintLastPosIndex","Spine.Unity.SkeletonRootMotionBase#FindTransformConstraintsAffectingBone","Spine.Unity.SkeletonRootMotionBase#GetTimelineMovementDelta","Spine.Unity.SkeletonRootMotionBase#GatherTopLevelBones","Spine.Unity.SkeletonRootMotionBase#HandleUpdateLocal","Spine.Unity.SkeletonRootMotionBase#ApplyRootMotion","Spine.Unity.SkeletonRootMotionBase#ApplyTransformConstraints","Spine.Unity.SkeletonRootMotionBase#GetScaleAffectingRootMotion","Spine.Unity.SkeletonRootMotionBase#GetScaleAffectingRootMotion$1","Spine.Unity.SkeletonRootMotionBase#GetSkeletonSpaceMovementDelta","Spine.Unity.SkeletonRootMotionBase#GetSkeletonSpaceRotationDelta","Spine.Unity.SkeletonRootMotionBase#SetEffectiveBoneOffsetsTo","Spine.Unity.SkeletonRootMotionBase#ClearEffectiveBoneOffsets","Spine.Unity.SkeletonRootMotionBase#ClearRigidbodyTempMovement","Spine.Unity.SkeletonPartsRenderer#NewPartsRendererGameObject","Spine.Unity.SkeletonPartsRenderer#MeshGenerator#get","Spine.Unity.SkeletonPartsRenderer#MeshRenderer#get","Spine.Unity.SkeletonPartsRenderer#MeshFilter#get","Spine.Unity.SkeletonPartsRenderer#init","Spine.Unity.SkeletonPartsRenderer#LazyIntialize","Spine.Unity.SkeletonPartsRenderer#OnDestroy","Spine.Unity.SkeletonPartsRenderer#ClearMesh","Spine.Unity.SkeletonPartsRenderer#RenderParts","Spine.Unity.SkeletonPartsRenderer#SetPropertyBlock","Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials#AnyMaterialCreated#get","Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials#init","Spine.Unity.SkeletonRendererCustomMaterials#init","Spine.Unity.SkeletonRendererCustomMaterials#SetCustomSlotMaterials","Spine.Unity.SkeletonRendererCustomMaterials#RemoveCustomSlotMaterials","Spine.Unity.SkeletonRendererCustomMaterials#SetCustomMaterialOverrides","Spine.Unity.SkeletonRendererCustomMaterials#RemoveCustomMaterialOverrides","Spine.Unity.SkeletonRendererCustomMaterials#OnEnable","Spine.Unity.SkeletonRendererCustomMaterials#OnDisable","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#inherits","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#getDefaultValue","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#ctor","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#equalsT","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#getHashCode","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#$clone","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#inherits","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#getDefaultValue","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#ctor","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#equalsT","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#getHashCode","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#$clone","Spine.Unity.SkeletonRendererInstruction#GeometryNotEqual","Spine.Unity.SkeletonRendererInstruction#init","Spine.Unity.SkeletonRendererInstruction#Clear","Spine.Unity.SkeletonRendererInstruction#Dispose","Spine.Unity.SkeletonRendererInstruction#SetWithSubset","Spine.Unity.SkeletonRendererInstruction#Set","Spine.Unity.SkeletonRenderSeparator#init","Spine.Unity.SkeletonRenderSeparator#AddToSkeletonRenderer","Spine.Unity.SkeletonRenderSeparator#SkeletonRenderer#get","Spine.Unity.SkeletonRenderSeparator#SkeletonRenderer#set","Spine.Unity.SkeletonRenderSeparator#init","Spine.Unity.SkeletonRenderSeparator#AddPartsRenderer","Spine.Unity.SkeletonRenderSeparator#OnEnable","Spine.Unity.SkeletonRenderSeparator#OnDisable","Spine.Unity.SkeletonRenderSeparator#HandleRender","Spine.Unity.SkeletonRenderSeparator#ClearPartsRendererMeshes","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#getDefaultValue","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#init","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#ctor","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#getHashCode","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#equals","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#$clone","Spine.Unity.SkeletonSubmeshGraphic#SetMaterialDirty","Spine.Unity.SkeletonSubmeshGraphic#SetVerticesDirty","Spine.Unity.SkeletonSubmeshGraphic#OnPopulateMesh","Spine.Unity.SkeletonSubmeshGraphic#OnDisable","Spine.Unity.SkeletonSubmeshGraphic#OnEnable","Spine.Unity.SkeletonUtility#AddBoundingBoxGameObject","Spine.Unity.SkeletonUtility#AddBoundingBoxGameObject$1","Spine.Unity.SkeletonUtility#AddBoundingBoxAsComponent","Spine.Unity.SkeletonUtility#SetColliderPointsLocal","Spine.Unity.SkeletonUtility#GetBoundingBoxBounds","Spine.Unity.SkeletonUtility#AddBoneRigidbody2D","Spine.Unity.SkeletonUtility#SkeletonComponent#get","Spine.Unity.SkeletonUtility#Skeleton#get","Spine.Unity.SkeletonUtility#IsValid#get","Spine.Unity.SkeletonUtility#PositionScale#get","Spine.Unity.SkeletonUtility#init","Spine.Unity.SkeletonUtility#Update","Spine.Unity.SkeletonUtility#ResubscribeEvents","Spine.Unity.SkeletonUtility#OnEnable","Spine.Unity.SkeletonUtility#Start","Spine.Unity.SkeletonUtility#OnDisable","Spine.Unity.SkeletonUtility#HandleRendererReset$1","Spine.Unity.SkeletonUtility#HandleRendererReset","Spine.Unity.SkeletonUtility#RegisterBone","Spine.Unity.SkeletonUtility#UnregisterBone","Spine.Unity.SkeletonUtility#RegisterConstraint","Spine.Unity.SkeletonUtility#UnregisterConstraint","Spine.Unity.SkeletonUtility#CollectBones","Spine.Unity.SkeletonUtility#UpdateLocal","Spine.Unity.SkeletonUtility#UpdateWorld","Spine.Unity.SkeletonUtility#UpdateComplete","Spine.Unity.SkeletonUtility#UpdateAllBones","Spine.Unity.SkeletonUtility#GetBoneRoot","Spine.Unity.SkeletonUtility#SpawnRoot","Spine.Unity.SkeletonUtility#SpawnHierarchy","Spine.Unity.SkeletonUtility#SpawnBoneRecursively","Spine.Unity.SkeletonUtility#SpawnBone","Spine.Unity.SkeletonUtilityBone#BoneTransformModeIncompatible","Spine.Unity.SkeletonUtilityBone#IncompatibleTransformMode#get","Spine.Unity.SkeletonUtilityBone#init","Spine.Unity.SkeletonUtilityBone#Reset","Spine.Unity.SkeletonUtilityBone#OnEnable","Spine.Unity.SkeletonUtilityBone#HandleOnReset","Spine.Unity.SkeletonUtilityBone#OnDisable","Spine.Unity.SkeletonUtilityBone#DoUpdate","Spine.Unity.SkeletonUtilityBone#AddBoundingBox","Spine.Unity.SpineAttributeBase#init","Spine.Unity.SpineAtlasRegion#ctor","Spine.Unity.SpineAttachment.Hierarchy#getDefaultValue","Spine.Unity.SpineAttachment.Hierarchy#$ctor1","Spine.Unity.SpineAttachment.Hierarchy#ctor","Spine.Unity.SpineAttachment.Hierarchy#getHashCode","Spine.Unity.SpineAttachment.Hierarchy#equals","Spine.Unity.SpineAttachment.Hierarchy#$clone","Spine.Unity.SpineMesh#init","Spine.Unity.SpineMesh#NewSkeletonMesh","Spine.Unity.SubmeshInstruction#getDefaultValue","Spine.Unity.SubmeshInstruction#SlotCount#get","Spine.Unity.SubmeshInstruction#ctor","Spine.Unity.SubmeshInstruction#toString","Spine.Unity.SubmeshInstruction#getHashCode","Spine.Unity.SubmeshInstruction#equals","Spine.Unity.SubmeshInstruction#$clone","Spine.Unity.WaitForSpineAnimation#System$Collections$IEnumerator$Current#get","Spine.Unity.WaitForSpineAnimation#init","Spine.Unity.WaitForSpineAnimation#ctor","Spine.Unity.WaitForSpineAnimation#NowWaitFor","Spine.Unity.WaitForSpineAnimation#System$Collections$IEnumerator$moveNext","Spine.Unity.WaitForSpineAnimation#System$Collections$IEnumerator$reset","Spine.Unity.WaitForSpineAnimation#SafeSubscribe","Spine.Unity.WaitForSpineAnimation#HandleComplete","Spine.Unity.WaitForSpineEvent#WillUnsubscribeAfterFiring#get","Spine.Unity.WaitForSpineEvent#WillUnsubscribeAfterFiring#set","Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$Current#get","Spine.Unity.WaitForSpineEvent#init","Spine.Unity.WaitForSpineEvent#ctor","Spine.Unity.WaitForSpineEvent#$ctor2","Spine.Unity.WaitForSpineEvent#$ctor1","Spine.Unity.WaitForSpineEvent#$ctor3","Spine.Unity.WaitForSpineEvent#Subscribe","Spine.Unity.WaitForSpineEvent#SubscribeByName","Spine.Unity.WaitForSpineEvent#HandleAnimationStateEventByName","Spine.Unity.WaitForSpineEvent#HandleAnimationStateEvent","Spine.Unity.WaitForSpineEvent#NowWaitFor","Spine.Unity.WaitForSpineEvent#NowWaitFor$1","Spine.Unity.WaitForSpineEvent#Clear","Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$moveNext","Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$reset","ViewportHandler#Width#get","ViewportHandler#Height#get","ViewportHandler#BottomLeft#get","ViewportHandler#BottomCenter#get","ViewportHandler#BottomRight#get","ViewportHandler#MiddleLeft#get","ViewportHandler#MiddleCenter#get","ViewportHandler#MiddleRight#get","ViewportHandler#TopLeft#get","ViewportHandler#TopCenter#get","ViewportHandler#TopRight#get","ViewportHandler#init","ViewportHandler#Awake","ViewportHandler#ComputeResolution","ViewportHandler#Update","ViewportHandler#OnDrawGizmos","Spine.Unity.BlendModeMaterialsAsset#ApplyMaterials","Spine.Unity.BlendModeMaterialsAsset#init","Spine.Unity.BlendModeMaterialsAsset#Apply","Spine.Unity.Examples.AnimationMatchModifierAsset#init","Spine.Unity.Examples.AnimationMatchModifierAsset#Apply","Spine.Unity.Examples.SkeletonGraphicRenderTexture#init","Spine.Unity.Examples.SkeletonGraphicRenderTexture#Awake","Spine.Unity.Examples.SkeletonGraphicRenderTexture#CreateQuadChild","Spine.Unity.Examples.SkeletonGraphicRenderTexture#Reset","Spine.Unity.Examples.SkeletonGraphicRenderTexture#OnEnable","Spine.Unity.Examples.SkeletonGraphicRenderTexture#OnDisable","Spine.Unity.Examples.SkeletonGraphicRenderTexture#PrepareQuad","Spine.Unity.Examples.SkeletonGraphicRenderTexture#RenderOntoQuad","Spine.Unity.Examples.SkeletonGraphicRenderTexture#PrepareForMesh","Spine.Unity.Examples.SkeletonGraphicRenderTexture#MeshRendererMaterialForTexture","Spine.Unity.Examples.SkeletonGraphicRenderTexture#RenderSingleMeshToRenderTexture","Spine.Unity.Examples.SkeletonGraphicRenderTexture#RenderMultipleMeshesToRenderTexture","Spine.Unity.Examples.SkeletonGraphicRenderTexture#SetupQuad","Spine.Unity.Examples.SkeletonGraphicRenderTexture#PrepareCommandBuffer","Spine.Unity.Examples.SkeletonGraphicRenderTexture#AssignMeshAtRenderer","Spine.Unity.Examples.SkeletonRenderTexture#init","Spine.Unity.Examples.SkeletonRenderTexture#Awake","Spine.Unity.Examples.SkeletonRenderTexture#CreateQuadChild","Spine.Unity.Examples.SkeletonRenderTexture#OnEnable","Spine.Unity.Examples.SkeletonRenderTexture#OnDisable","Spine.Unity.Examples.SkeletonRenderTexture#RenderOntoQuad","Spine.Unity.Examples.SkeletonRenderTexture#PrepareForMesh","Spine.Unity.Examples.SkeletonRenderTexture#PrepareCommandBuffer","Spine.Unity.Examples.SkeletonRenderTexture#RenderToRenderTexture","Spine.Unity.Examples.SkeletonRenderTexture#AssignMeshAtRenderer","Spine.Unity.Examples.SkeletonUtilityEyeConstraint#init","Spine.Unity.Examples.SkeletonUtilityEyeConstraint#OnEnable","Spine.Unity.Examples.SkeletonUtilityEyeConstraint#OnDisable","Spine.Unity.Examples.SkeletonUtilityEyeConstraint#DoUpdate","Spine.Unity.Examples.SkeletonUtilityGroundConstraint#init","Spine.Unity.Examples.SkeletonUtilityGroundConstraint#OnEnable","Spine.Unity.Examples.SkeletonUtilityGroundConstraint#DoUpdate","Spine.Unity.Examples.SkeletonUtilityGroundConstraint#OnDrawGizmos","Spine.Unity.SkeletonMecanimRootMotion#init","Spine.Unity.SkeletonMecanimRootMotion#SkeletonMecanim#get","Spine.Unity.SkeletonMecanimRootMotion#init","Spine.Unity.SkeletonMecanimRootMotion#GetRemainingRootMotion","Spine.Unity.SkeletonMecanimRootMotion#GetRootMotionInfo","Spine.Unity.SkeletonMecanimRootMotion#Reset","Spine.Unity.SkeletonMecanimRootMotion#Start","Spine.Unity.SkeletonMecanimRootMotion#OnClipApplied","Spine.Unity.SkeletonMecanimRootMotion#CalculateAnimationsMovementDelta","Spine.Unity.SkeletonMecanimRootMotion#CalculateAnimationsRotationDelta","Spine.Unity.SkeletonRootMotion#init","Spine.Unity.SkeletonRootMotion#AdditionalScale#get","Spine.Unity.SkeletonRootMotion#init","Spine.Unity.SkeletonRootMotion#GetRemainingRootMotion","Spine.Unity.SkeletonRootMotion#GetRootMotionInfo","Spine.Unity.SkeletonRootMotion#Reset","Spine.Unity.SkeletonRootMotion#Start","Spine.Unity.SkeletonRootMotion#CalculateAnimationsMovementDelta","Spine.Unity.SkeletonRootMotion#CalculateAnimationsRotationDelta","Spine.Unity.SkeletonRootMotion#ApplyMixAlphaToDelta$1","Spine.Unity.SkeletonRootMotion#ApplyMixAlphaToDelta","Spine.Unity.SkeletonRootMotion#GetMixAlpha","Spine.Unity.SpineAnimation#ctor","Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance","Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance$1","Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance$2","Spine.Unity.SpineAtlasAsset#IsLoaded#get","Spine.Unity.SpineAtlasAsset#Materials#get","Spine.Unity.SpineAtlasAsset#MaterialCount#get","Spine.Unity.SpineAtlasAsset#PrimaryMaterial#get","Spine.Unity.SpineAtlasAsset#Reset","Spine.Unity.SpineAtlasAsset#Clear","Spine.Unity.SpineAtlasAsset#GetAtlas","Spine.Unity.SpineAtlasAsset#GenerateMesh","Spine.Unity.SpineAttachment#getHierarchy","Spine.Unity.SpineAttachment#getAttachment","Spine.Unity.SpineAttachment#getAttachment$1","Spine.Unity.SpineAttachment#init","Spine.Unity.SpineAttachment#ctor","Spine.Unity.SpineBone#getBone","Spine.Unity.SpineBone#getBoneData","Spine.Unity.SpineBone#ctor","Spine.Unity.SpineEvent#init","Spine.Unity.SpineEvent#ctor","Spine.Unity.SpineIkConstraint#ctor","Spine.Unity.SpinePathConstraint#ctor","Spine.Unity.SpineSkin#init","Spine.Unity.SpineSkin#ctor","Spine.Unity.SpineSlot#init","Spine.Unity.SpineSlot#ctor","Spine.Unity.SpineSpriteAtlasAsset#CreateRuntimeInstance","Spine.Unity.SpineSpriteAtlasAsset#AccessPackedTexture","Spine.Unity.SpineSpriteAtlasAsset#AccessPackedSprites","Spine.Unity.SpineSpriteAtlasAsset#IsLoaded#get","Spine.Unity.SpineSpriteAtlasAsset#Materials#get","Spine.Unity.SpineSpriteAtlasAsset#MaterialCount#get","Spine.Unity.SpineSpriteAtlasAsset#PrimaryMaterial#get","Spine.Unity.SpineSpriteAtlasAsset#Reset","Spine.Unity.SpineSpriteAtlasAsset#Clear","Spine.Unity.SpineSpriteAtlasAsset#GetAtlas","Spine.Unity.SpineSpriteAtlasAsset#AssignRegionsFromSavedRegions","Spine.Unity.SpineSpriteAtlasAsset#LoadAtlas","Spine.Unity.SpineTransformConstraint#ctor","Spine.Unity.WaitForSpineAnimationComplete#ctor","Spine.Unity.WaitForSpineAnimationComplete#NowWaitFor$1","Spine.Unity.WaitForSpineAnimationEnd#ctor","Spine.Unity.WaitForSpineAnimationEnd#NowWaitFor$1","Spine.Unity.AnimationReferenceAsset#init","Spine.Unity.AnimationReferenceAsset#op_Implicit","Spine.Unity.AnimationReferenceAsset#SkeletonDataAsset#get","Spine.Unity.AnimationReferenceAsset#Animation#get","Spine.Unity.AnimationReferenceAsset#Clear","Spine.Unity.AnimationReferenceAsset#Initialize","Spine.Unity.Examples.EquipSystemExample#Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset#get","Spine.Unity.Examples.EquipSystemExample#init","Spine.Unity.Examples.EquipSystemExample#Equip","Spine.Unity.Examples.EquipSystemExample#GenerateAttachmentFromEquipAsset","Spine.Unity.Examples.EquipSystemExample#Done","Spine.Unity.Examples.SpineAnimationTesterTool#SkeletonDataAsset#get","Spine.Unity.Examples.SpineAnimationTesterTool#SkeletonComponent#get","Spine.Unity.Examples.SpineAnimationTesterTool#init","Spine.Unity.Examples.SpineAnimationTesterTool#OnValidate","Spine.Unity.Examples.SpineAnimationTesterTool#Start","Spine.Unity.Examples.SpineAnimationTesterTool#Update","Spine.Unity.PointFollower#SkeletonRenderer#get","Spine.Unity.PointFollower#SkeletonComponent#get","Spine.Unity.PointFollower#IsValid#get","Spine.Unity.PointFollower#init","Spine.Unity.PointFollower#Initialize","Spine.Unity.PointFollower#HandleRebuildRenderer","Spine.Unity.PointFollower#UpdateReferences","Spine.Unity.PointFollower#OnDestroy","Spine.Unity.PointFollower#LateUpdate","Spine.Unity.SkeletonRenderer#init","Spine.Unity.SkeletonRenderer#NewSpineGameObject","Spine.Unity.SkeletonRenderer#AddSpineComponent","Spine.Unity.SkeletonRenderer#UpdateMode#get","Spine.Unity.SkeletonRenderer#UpdateMode#set","Spine.Unity.SkeletonRenderer#CustomMaterialOverride#get","Spine.Unity.SkeletonRenderer#CustomSlotMaterials#get","Spine.Unity.SkeletonRenderer#Skeleton#get","Spine.Unity.SkeletonRenderer#SkeletonDataAsset#get","Spine.Unity.SkeletonRenderer#init","Spine.Unity.SkeletonRenderer#addGenerateMeshOverride","Spine.Unity.SkeletonRenderer#removeGenerateMeshOverride","Spine.Unity.SkeletonRenderer#SetMeshSettings","Spine.Unity.SkeletonRenderer#Awake","Spine.Unity.SkeletonRenderer#OnDisable","Spine.Unity.SkeletonRenderer#OnDestroy","Spine.Unity.SkeletonRenderer#ClearState","Spine.Unity.SkeletonRenderer#EnsureMeshGeneratorCapacity","Spine.Unity.SkeletonRenderer#Initialize","Spine.Unity.SkeletonRenderer#LateUpdate","Spine.Unity.SkeletonRenderer#LateUpdateMesh","Spine.Unity.SkeletonRenderer#OnBecameVisible","Spine.Unity.SkeletonRenderer#OnBecameInvisible","Spine.Unity.SkeletonRenderer#FindAndApplySeparatorSlots$1","Spine.Unity.SkeletonRenderer#FindAndApplySeparatorSlots","Spine.Unity.SkeletonRenderer#ReapplySeparatorSlotNames","Spine.Unity.SkeletonRenderer#AssignSpriteMaskMaterials","Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsInsideMask","Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsOutsideMask","Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsForMaskType","Spine.Unity.SkeletonRenderer#HandleOnDemandLoading","Spine.Unity.SkeletonRenderer#SetMaterialSettingsToFixDrawOrder","Spine.Unity.SkeletonGraphic#init","Spine.Unity.SkeletonGraphic#NewSkeletonGraphicGameObject","Spine.Unity.SkeletonGraphic#AddSkeletonGraphicComponent","Spine.Unity.SkeletonGraphic#SetRectTransformSize$1","Spine.Unity.SkeletonGraphic#SetRectTransformSize","Spine.Unity.SkeletonGraphic#SkeletonDataAsset#get","Spine.Unity.SkeletonGraphic#MeshScale#get","Spine.Unity.SkeletonGraphic#UpdateMode#get","Spine.Unity.SkeletonGraphic#UpdateMode#set","Spine.Unity.SkeletonGraphic#SeparatorParts#get","Spine.Unity.SkeletonGraphic#CustomTextureOverride#get","Spine.Unity.SkeletonGraphic#CustomMaterialOverride#get","Spine.Unity.SkeletonGraphic#OverrideTexture#get","Spine.Unity.SkeletonGraphic#OverrideTexture#set","Spine.Unity.SkeletonGraphic#mainTexture#get","Spine.Unity.SkeletonGraphic#Skeleton#get","Spine.Unity.SkeletonGraphic#Skeleton#set","Spine.Unity.SkeletonGraphic#SkeletonData#get","Spine.Unity.SkeletonGraphic#IsValid#get","Spine.Unity.SkeletonGraphic#AnimationState#get","Spine.Unity.SkeletonGraphic#MeshGenerator#get","Spine.Unity.SkeletonGraphic#MeshesMultipleCanvasRenderers#get","Spine.Unity.SkeletonGraphic#MaterialsMultipleCanvasRenderers#get","Spine.Unity.SkeletonGraphic#TexturesMultipleCanvasRenderers#get","Spine.Unity.SkeletonGraphic#UpdateTiming#get","Spine.Unity.SkeletonGraphic#UpdateTiming#set","Spine.Unity.SkeletonGraphic#UnscaledTime#get","Spine.Unity.SkeletonGraphic#UnscaledTime#set","Spine.Unity.SkeletonGraphic#init","Spine.Unity.SkeletonGraphic#addAssignMeshOverrideSingleRenderer","Spine.Unity.SkeletonGraphic#removeAssignMeshOverrideSingleRenderer","Spine.Unity.SkeletonGraphic#addAssignMeshOverrideMultipleRenderers","Spine.Unity.SkeletonGraphic#removeAssignMeshOverrideMultipleRenderers","Spine.Unity.SkeletonGraphic#Awake","Spine.Unity.SkeletonGraphic#OnDestroy","Spine.Unity.SkeletonGraphic#Rebuild","Spine.Unity.SkeletonGraphic#OnDisable","Spine.Unity.SkeletonGraphic#Update","Spine.Unity.SkeletonGraphic#Update$1","Spine.Unity.SkeletonGraphic#FixedUpdate","Spine.Unity.SkeletonGraphic#SyncSubmeshGraphicsWithCanvasRenderers","Spine.Unity.SkeletonGraphic#UpdateAnimationStatus","Spine.Unity.SkeletonGraphic#ApplyAnimation","Spine.Unity.SkeletonGraphic#AfterAnimationApplied","Spine.Unity.SkeletonGraphic#LateUpdate","Spine.Unity.SkeletonGraphic#OnCullStateChanged","Spine.Unity.SkeletonGraphic#OnBecameVisible","Spine.Unity.SkeletonGraphic#OnBecameInvisible","Spine.Unity.SkeletonGraphic#ReapplySeparatorSlotNames","Spine.Unity.SkeletonGraphic#GetLastMesh","Spine.Unity.SkeletonGraphic#MatchRectTransformWithBounds","Spine.Unity.SkeletonGraphic#MatchRectTransformSingleRenderer","Spine.Unity.SkeletonGraphic#MatchRectTransformMultipleRenderers","Spine.Unity.SkeletonGraphic#SetRectTransformBounds","Spine.Unity.SkeletonGraphic#Clear","Spine.Unity.SkeletonGraphic#TrimRenderers","Spine.Unity.SkeletonGraphic#Initialize","Spine.Unity.SkeletonGraphic#PrepareInstructionsAndRenderers","Spine.Unity.SkeletonGraphic#UpdateMesh","Spine.Unity.SkeletonGraphic#UpdateMeshToInstructions","Spine.Unity.SkeletonGraphic#HasMultipleSubmeshInstructions","Spine.Unity.SkeletonGraphic#InitMeshBuffers","Spine.Unity.SkeletonGraphic#DisposeMeshBuffers","Spine.Unity.SkeletonGraphic#UpdateMeshSingleCanvasRenderer","Spine.Unity.SkeletonGraphic#UpdateMaterialsMultipleCanvasRenderers","Spine.Unity.SkeletonGraphic#UpdateMeshMultipleCanvasRenderers","Spine.Unity.SkeletonGraphic#HandleOnDemandLoading","Spine.Unity.SkeletonGraphic#EnsureCanvasRendererCount","Spine.Unity.SkeletonGraphic#PrepareRendererGameObjects","Spine.Unity.SkeletonGraphic#DisableUnusedCanvasRenderers","Spine.Unity.SkeletonGraphic#EnsureMeshesCount","Spine.Unity.SkeletonGraphic#EnsureUsedTexturesAndMaterialsCount","Spine.Unity.SkeletonGraphic#DestroyMeshes","Spine.Unity.SkeletonGraphic#EnsureSeparatorPartCount","Spine.Unity.SkeletonGraphic#UpdateSeparatorPartParents","Spine.Unity.SkeletonGraphic#GetLayoutScale","Spine.Unity.SkeletonGraphic#GetCurrentRectSize","Spine.Unity.SkeletonAnimation#AddToGameObject","Spine.Unity.SkeletonAnimation#NewSkeletonAnimationGameObject","Spine.Unity.SkeletonAnimation#AnimationState#get","Spine.Unity.SkeletonAnimation#UpdateTiming#get","Spine.Unity.SkeletonAnimation#UpdateTiming#set","Spine.Unity.SkeletonAnimation#UnscaledTime#get","Spine.Unity.SkeletonAnimation#UnscaledTime#set","Spine.Unity.SkeletonAnimation#AnimationName#get","Spine.Unity.SkeletonAnimation#AnimationName#set","Spine.Unity.SkeletonAnimation#init","Spine.Unity.SkeletonAnimation#addOnAnimationRebuild","Spine.Unity.SkeletonAnimation#removeOnAnimationRebuild","Spine.Unity.SkeletonAnimation#addBeforeApply","Spine.Unity.SkeletonAnimation#removeBeforeApply","Spine.Unity.SkeletonAnimation#addUpdateLocal","Spine.Unity.SkeletonAnimation#removeUpdateLocal","Spine.Unity.SkeletonAnimation#addUpdateWorld","Spine.Unity.SkeletonAnimation#removeUpdateWorld","Spine.Unity.SkeletonAnimation#addUpdateComplete","Spine.Unity.SkeletonAnimation#removeUpdateComplete","Spine.Unity.SkeletonAnimation#ClearState","Spine.Unity.SkeletonAnimation#Initialize","Spine.Unity.SkeletonAnimation#Update$1","Spine.Unity.SkeletonAnimation#Update","Spine.Unity.SkeletonAnimation#FixedUpdate","Spine.Unity.SkeletonAnimation#UpdateAnimationStatus","Spine.Unity.SkeletonAnimation#ApplyAnimation","Spine.Unity.SkeletonAnimation#AfterAnimationApplied","Spine.Unity.SkeletonAnimation#LateUpdate","Spine.Unity.SkeletonAnimation#OnBecameVisible","Spine.Unity.SkeletonMecanim#Translator#get","Spine.Unity.SkeletonMecanim#UpdateTiming#get","Spine.Unity.SkeletonMecanim#UpdateTiming#set","Spine.Unity.SkeletonMecanim#init","Spine.Unity.SkeletonMecanim#addOnAnimationRebuild","Spine.Unity.SkeletonMecanim#removeOnAnimationRebuild","Spine.Unity.SkeletonMecanim#addBeforeApply","Spine.Unity.SkeletonMecanim#removeBeforeApply","Spine.Unity.SkeletonMecanim#addUpdateLocal","Spine.Unity.SkeletonMecanim#removeUpdateLocal","Spine.Unity.SkeletonMecanim#addUpdateWorld","Spine.Unity.SkeletonMecanim#removeUpdateWorld","Spine.Unity.SkeletonMecanim#addUpdateComplete","Spine.Unity.SkeletonMecanim#removeUpdateComplete","Spine.Unity.SkeletonMecanim#Initialize","Spine.Unity.SkeletonMecanim#Update","Spine.Unity.SkeletonMecanim#Update$1","Spine.Unity.SkeletonMecanim#FixedUpdate","Spine.Unity.SkeletonMecanim#UpdateAnimation","Spine.Unity.SkeletonMecanim#ApplyAnimation","Spine.Unity.SkeletonMecanim#LateUpdate","Spine.Unity.SkeletonMecanim#OnBecameVisible"]' ) ); }
/**
 * @version 1.0.9133.21240
 * @copyright anton
 * @compiler Bridge.NET 17.9.42-luna
 */
Bridge.assembly("UnityScriptsCompiler", function ($asm, globals) {
    "use strict";

    /*AnimClip start.*/
    Bridge.define("AnimClip", {
        fields: {
            Index: 0,
            Name: null
        }
    });
    /*AnimClip end.*/

    /*AnimKing start.*/
    Bridge.define("AnimKing", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            anim: null,
            clips: null
        },
        methods: {
            /*AnimKing.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "AnimKing#Awake", this ); }

                this.anim = this.GetComponent(Spine.Unity.SkeletonAnimation);
            },
            /*AnimKing.Awake end.*/

            /*AnimKing.SetAnim start.*/
            SetAnim: function (animName, loop) {
if ( TRACE ) { TRACE( "AnimKing#SetAnim", this ); }

                var index = this.clips.Find(function (x) {
                    return Bridge.referenceEquals(x.Name, animName);
                }).Index;
                this.anim.AnimationState.setAnimation(index, animName, loop);
            },
            /*AnimKing.SetAnim end.*/


        }
    });
    /*AnimKing end.*/

    /*Bag start.*/
    Bridge.define("Bag", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            model: null,
            idlePosition: null,
            winPosition: null,
            losePosition: null
        },
        methods: {
            /*Bag.OnIdle start.*/
            OnIdle: function () {
if ( TRACE ) { TRACE( "Bag#OnIdle", this ); }

                this.model.position = this.idlePosition.position.$clone();
                DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMove(this.transform, UnityEngine.Vector3.FromVector2(new pc.Vec2( this.transform.position.x, this.transform.position.y + 0.1 )), 0.2, false), DG.Tweening.Ease.Linear), -1, DG.Tweening.LoopType.Yoyo);
            },
            /*Bag.OnIdle end.*/

            /*Bag.OnWin start.*/
            OnWin: function () {
if ( TRACE ) { TRACE( "Bag#OnWin", this ); }

                DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMove(this.transform, this.winPosition.position.$clone(), 0.2, false), DG.Tweening.Ease.Linear);
            },
            /*Bag.OnWin end.*/

            /*Bag.OnLose start.*/
            OnLose: function () {
if ( TRACE ) { TRACE( "Bag#OnLose", this ); }

                DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMove(this.transform, this.losePosition.position.$clone(), 0.2, false), DG.Tweening.Ease.Linear);
            },
            /*Bag.OnLose end.*/


        }
    });
    /*Bag end.*/

    /*CameraAnchor start.*/
    Bridge.define("CameraAnchor", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            anchorType: 0,
            anchorOffset: null,
            updateAnchorRoutine: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "CameraAnchor#init", this ); }

                this.anchorOffset = new UnityEngine.Vector3();
            }
        },
        methods: {
            /*CameraAnchor.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "CameraAnchor#Start", this ); }

                this.updateAnchorRoutine = this.UpdateAnchorAsync();
                this.StartCoroutine$1(this.updateAnchorRoutine);
            },
            /*CameraAnchor.Start end.*/

            /*CameraAnchor.UpdateAnchorAsync start.*/
            /**
             * Coroutine to update the anchor only once ViewportHandler.Instance is not null.
             *
             * @instance
             * @private
             * @this CameraAnchor
             * @memberof CameraAnchor
             * @return  {System.Collections.IEnumerator}
             */
            UpdateAnchorAsync: function () {
if ( TRACE ) { TRACE( "CameraAnchor#UpdateAnchorAsync", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    cameraWaitCycles,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    cameraWaitCycles = 0;
                                    $step = 1;
                                    continue;
                                }
                                case 1: {
                                    if ( UnityEngine.MonoBehaviour.op_Equality(ViewportHandler.Instance, null) ) {
                                            $step = 2;
                                            continue;
                                        } 
                                        $step = 4;
                                        continue;
                                }
                                case 2: {
                                    cameraWaitCycles = (cameraWaitCycles + 1) >>> 0;
                                        $enumerator.current = new UnityEngine.WaitForEndOfFrame();
                                        $step = 3;
                                        return true;
                                }
                                case 3: {
                                    
                                        $step = 1;
                                        continue;
                                }
                                case 4: {
                                    if (cameraWaitCycles > 0) {
                                            UnityEngine.MonoBehaviour.print(System.String.format("CameraAnchor found ViewportHandler instance after waiting {0} frame(s). You might want to check that ViewportHandler has an earlie execution order.", [Bridge.box(cameraWaitCycles, System.UInt32)]));
                                        }
                                        this.UpdateAnchor();
                                        this.updateAnchorRoutine = null;

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*CameraAnchor.UpdateAnchorAsync end.*/

            /*CameraAnchor.UpdateAnchor start.*/
            UpdateAnchor: function () {
if ( TRACE ) { TRACE( "CameraAnchor#UpdateAnchor", this ); }

                switch (this.anchorType) {
                    case CameraAnchor.AnchorType.BottomLeft: 
                        this.SetAnchor(ViewportHandler.Instance.BottomLeft.$clone());
                        break;
                    case CameraAnchor.AnchorType.BottomCenter: 
                        this.SetAnchor(ViewportHandler.Instance.BottomCenter.$clone());
                        break;
                    case CameraAnchor.AnchorType.BottomRight: 
                        this.SetAnchor(ViewportHandler.Instance.BottomRight.$clone());
                        break;
                    case CameraAnchor.AnchorType.MiddleLeft: 
                        this.SetAnchor(ViewportHandler.Instance.MiddleLeft.$clone());
                        break;
                    case CameraAnchor.AnchorType.MiddleCenter: 
                        this.SetAnchor(ViewportHandler.Instance.MiddleCenter.$clone());
                        break;
                    case CameraAnchor.AnchorType.MiddleRight: 
                        this.SetAnchor(ViewportHandler.Instance.MiddleRight.$clone());
                        break;
                    case CameraAnchor.AnchorType.TopLeft: 
                        this.SetAnchor(ViewportHandler.Instance.TopLeft.$clone());
                        break;
                    case CameraAnchor.AnchorType.TopCenter: 
                        this.SetAnchor(ViewportHandler.Instance.TopCenter.$clone());
                        break;
                    case CameraAnchor.AnchorType.TopRight: 
                        this.SetAnchor(ViewportHandler.Instance.TopRight.$clone());
                        break;
                }
            },
            /*CameraAnchor.UpdateAnchor end.*/

            /*CameraAnchor.SetAnchor start.*/
            SetAnchor: function (anchor) {
if ( TRACE ) { TRACE( "CameraAnchor#SetAnchor", this ); }

                var newPos = anchor.$clone().add( this.anchorOffset );
                if (!this.transform.position.strictEquals( newPos.$clone() )) {
                    this.transform.position = newPos.$clone();
                }
            },
            /*CameraAnchor.SetAnchor end.*/


        }
    });
    /*CameraAnchor end.*/

    /*CameraAnchor+AnchorType start.*/
    Bridge.define("CameraAnchor.AnchorType", {
        $kind: 1006,
        statics: {
            fields: {
                BottomLeft: 0,
                BottomCenter: 1,
                BottomRight: 2,
                MiddleLeft: 3,
                MiddleCenter: 4,
                MiddleRight: 5,
                TopLeft: 6,
                TopCenter: 7,
                TopRight: 8
            }
        }
    });
    /*CameraAnchor+AnchorType end.*/

    /*Constant start.*/
    Bridge.define("Constant", {
        statics: {
            fields: {
                animKingIdle: null,
                animKingWin: null,
                animKingLose: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Constant#init", this ); }

                    this.animKingIdle = "CollectCoin_Idle";
                    this.animKingWin = "CollectCoin_Win";
                    this.animKingLose = "CollectCoin_Lose";
                }
            }
        }
    });
    /*Constant end.*/

    /*DG.Tweening.DOTweenCYInstruction start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction");
    /*DG.Tweening.DOTweenCYInstruction end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForCompletion", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForCompletion#keepWaiting#get", this ); }

                    return this.t.active && !DG.Tweening.TweenExtensions.IsComplete(this.t);
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForCompletion#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null,
            elapsedLoops: 0
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#keepWaiting#get", this ); }

                    return this.t.active && DG.Tweening.TweenExtensions.CompletedLoops(this.t) < this.elapsedLoops;
                }
            }
        },
        ctors: {
            ctor: function (tween, elapsedLoops) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
                this.elapsedLoops = elapsedLoops;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForKill start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForKill", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForKill#keepWaiting#get", this ); }

                    return this.t.active;
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForKill#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForKill end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForPosition", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null,
            position: 0
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForPosition#keepWaiting#get", this ); }

                    return this.t.active && this.t.position * (((DG.Tweening.TweenExtensions.CompletedLoops(this.t) + 1) | 0)) < this.position;
                }
            }
        },
        ctors: {
            ctor: function (tween, position) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForPosition#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
                this.position = position;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForRewind", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForRewind#keepWaiting#get", this ); }

                    return this.t.active && (!this.t.playedOnce || this.t.position * (((DG.Tweening.TweenExtensions.CompletedLoops(this.t) + 1) | 0)) > 0);
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForRewind#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForStart start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForStart", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForStart#keepWaiting#get", this ); }

                    return this.t.active && !this.t.playedOnce;
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForStart#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForStart end.*/

    /*DG.Tweening.DOTweenModuleAudio start.*/
    Bridge.define("DG.Tweening.DOTweenModuleAudio", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleAudio.DOFade:static start.*/
                /**
                 * Tweens an AudioSource's volume to the given value.
                 Also stores the AudioSource as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.AudioSource}           target      
                 * @param   {number}                            endValue    The end value to reach (0 to 1)
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOFade", this ); }

                    if (endValue < 0) {
                        endValue = 0;
                    } else {
                        if (endValue > 1) {
                            endValue = 1;
                        }
                    }
                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.volume;
                    }, function (x) {
                        target.volume = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleAudio.DOFade:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPitch:static start.*/
                /**
                 * Tweens an AudioSource's pitch to the given value.
                 Also stores the AudioSource as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.AudioSource}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPitch: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPitch", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.pitch;
                    }, function (x) {
                        target.pitch = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPitch:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOSetFloat:static start.*/
                /**
                 * Tweens an AudioMixer's exposed float to the given value.
                 Also stores the AudioMixer as the tween's target so it can be used for filtered operations.
                 Note that you need to manually expose a float in an AudioMixerGroup in order to be able to tween it from an AudioMixer.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}      target       
                 * @param   {string}                            floatName    Name given to the exposed float to set
                 * @param   {number}                            endValue     The end value to reach
                 * @param   {number}                            duration     The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOSetFloat: function (target, floatName, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOSetFloat", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        var currVal = { };
                        target.GetFloat(floatName, currVal);
                        return currVal.v;
                    }, function (x) {
                        target.SetFloat(floatName, x);
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleAudio.DOSetFloat:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOComplete:static start.*/
                /**
                 * Completes all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens completed
                 (meaning the tweens that don't have infinite loops and were not already complete)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target           
                 * @param   {boolean}                         withCallbacks    For Sequences only: if TRUE also internal Sequence callbacks will be fired,
                 otherwise they will be ignored
                 * @return  {number}
                 */
                DOComplete: function (target, withCallbacks) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOComplete", this ); }

                    if (withCallbacks === void 0) { withCallbacks = false; }
                    return DG.Tweening.DOTween.Complete(target, withCallbacks);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOComplete:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOKill:static start.*/
                /**
                 * Kills all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens killed.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target      
                 * @param   {boolean}                         complete    If TRUE completes the tween before killing it
                 * @return  {number}
                 */
                DOKill: function (target, complete) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOKill", this ); }

                    if (complete === void 0) { complete = false; }
                    return DG.Tweening.DOTween.Kill(target, complete);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOKill:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOFlip:static start.*/
                /**
                 * Flips the direction (backwards if it was going forward or viceversa) of all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens flipped.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOFlip: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOFlip", this ); }

                    return DG.Tweening.DOTween.Flip(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOFlip:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOGoto:static start.*/
                /**
                 * Sends to the given position all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens involved.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target     
                 * @param   {number}                          to         Time position to reach
                 (if higher than the whole tween duration the tween will simply reach its end)
                 * @param   {boolean}                         andPlay    If TRUE will play the tween after reaching the given position, otherwise it will pause it
                 * @return  {number}
                 */
                DOGoto: function (target, to, andPlay) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOGoto", this ); }

                    if (andPlay === void 0) { andPlay = false; }
                    return DG.Tweening.DOTween.Goto(target, to, andPlay);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOGoto:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPause:static start.*/
                /**
                 * Pauses all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens paused.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOPause: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPause", this ); }

                    return DG.Tweening.DOTween.Pause(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPause:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPlay:static start.*/
                /**
                 * Plays all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens played.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOPlay: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPlay", this ); }

                    return DG.Tweening.DOTween.Play(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPlay:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPlayBackwards:static start.*/
                /**
                 * Plays backwards all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens played.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOPlayBackwards: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPlayBackwards", this ); }

                    return DG.Tweening.DOTween.PlayBackwards(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPlayBackwards:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPlayForward:static start.*/
                /**
                 * Plays forward all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens played.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOPlayForward: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPlayForward", this ); }

                    return DG.Tweening.DOTween.PlayForward(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPlayForward:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DORestart:static start.*/
                /**
                 * Restarts all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens restarted.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DORestart: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DORestart", this ); }

                    return DG.Tweening.DOTween.Restart(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DORestart:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DORewind:static start.*/
                /**
                 * Rewinds all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens rewinded.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DORewind: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DORewind", this ); }

                    return DG.Tweening.DOTween.Rewind(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DORewind:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOSmoothRewind:static start.*/
                /**
                 * Smoothly rewinds all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens rewinded.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOSmoothRewind: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOSmoothRewind", this ); }

                    return DG.Tweening.DOTween.SmoothRewind(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOSmoothRewind:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOTogglePause:static start.*/
                /**
                 * Toggles the paused state (plays if it was paused, pauses if it was playing) of all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens involved.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOTogglePause: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOTogglePause", this ); }

                    return DG.Tweening.DOTween.TogglePause(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOTogglePause:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleAudio end.*/

    /*DG.Tweening.DOTweenModulePhysics start.*/
    Bridge.define("DG.Tweening.DOTweenModulePhysics", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModulePhysics.DOMove:static start.*/
                /**
                 * Tweens a Rigidbody's position to the given value.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target      
                 * @param   {UnityEngine.Vector3}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMove: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOMove", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$13(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOMove:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOMoveX:static start.*/
                /**
                 * Tweens a Rigidbody's X position to the given value.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOMoveX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( endValue, 0, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOMoveX:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOMoveY:static start.*/
                /**
                 * Tweens a Rigidbody's Y position to the given value.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOMoveY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( 0, endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOMoveY:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOMoveZ:static start.*/
                /**
                 * Tweens a Rigidbody's Z position to the given value.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveZ: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOMoveZ", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( 0, 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Z, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOMoveZ:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DORotate:static start.*/
                /**
                 * Tweens a Rigidbody's rotation to the given value.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target      
                 * @param   {UnityEngine.Vector3}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {DG.Tweening.RotateMode}            mode        Rotation mode
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DORotate: function (target, endValue, duration, mode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DORotate", this ); }

                    if (mode === void 0) { mode = 0; }
                    var t = DG.Tweening.DOTween.To$9(function () {
                        return target.rotation;
                    }, Bridge.fn.cacheBind(target, target.MoveRotation), endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), t, target);
                    t.plugOptions.rotateMode = mode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DORotate:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOLookAt:static start.*/
                /**
                 * Tweens a Rigidbody's rotation so that it will look towards the given position.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target            
                 * @param   {UnityEngine.Vector3}               towards           The position to look at
                 * @param   {number}                            duration          The duration of the tween
                 * @param   {DG.Tweening.AxisConstraint}        axisConstraint    Eventual axis constraint for the rotation
                 * @param   {?UnityEngine.Vector3}              up                The vector that defines in which direction up is (default: Vector3.up)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOLookAt: function (target, towards, duration, axisConstraint, up) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOLookAt", this ); }

                    if (axisConstraint === void 0) { axisConstraint = 0; }
                    if (up === void 0) { up = null; }
                    var t = DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.DOTween.To$9(function () {
                        return target.rotation;
                    }, Bridge.fn.cacheBind(target, target.MoveRotation), towards.$clone(), duration), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetLookAt);
                    t.plugOptions.axisConstraint = axisConstraint;
                    t.plugOptions.up = (pc.Vec3.equals( up, null )) ? pc.Vec3.UP.clone() : System.Nullable.getValue(up);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOLookAt:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOJump:static start.*/
                /**
                 * Tweens a Rigidbody's position to the given value, while also applying a jump effect along the Y axis.
                 Returns a Sequence instead of a Tweener.
                 Also stores the Rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}    target       
                 * @param   {UnityEngine.Vector3}      endValue     The end value to reach
                 * @param   {number}                   jumpPower    Power of the jump (the max height of the jump is represented by this plus the final Y offset)
                 * @param   {number}                   numJumps     Total number of jumps
                 * @param   {number}                   duration     The duration of the tween
                 * @param   {boolean}                  snapping     If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Sequence}
                 */
                DOJump: function (target, endValue, jumpPower, numJumps, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOJump", this ); }

                    if (snapping === void 0) { snapping = false; }
                    if (numJumps < 1) {
                        numJumps = 1;
                    }
                    var startPosY = 0;
                    var offsetY = -1;
                    var offsetYSet = false;
                    var s = DG.Tweening.DOTween.Sequence();
                    var yTween = DG.Tweening.TweenSettingsExtensions.OnStart(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetRelative(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( 0, jumpPower, 0 ), duration / (Bridge.Int.mul(numJumps, 2))), DG.Tweening.AxisConstraint.Y, snapping), DG.Tweening.Ease.OutQuad)), Bridge.Int.mul(numJumps, 2), DG.Tweening.LoopType.Yoyo), function () {
                        startPosY = target.position.y;
                    });
                    DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( endValue.x, 0, 0 ), duration), DG.Tweening.AxisConstraint.X, snapping), DG.Tweening.Ease.Linear)), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( 0, 0, endValue.z ), duration), DG.Tweening.AxisConstraint.Z, snapping), DG.Tweening.Ease.Linear)), yTween), target), DG.Tweening.DOTween.defaultEaseType);
                    DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Tween, yTween, function () {
                        if (!offsetYSet) {
                            offsetYSet = true;
                            offsetY = s.isRelative ? endValue.y : endValue.y - startPosY;
                        }
                        var pos = target.position.$clone();
                        pos.y += DG.Tweening.DOVirtual.EasedValue(0, offsetY, DG.Tweening.TweenExtensions.ElapsedPercentage(yTween), DG.Tweening.Ease.OutQuad);
                        target.MovePosition(pos);
                    });
                    return s;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOJump:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOPath:static start.*/
                /**
                 * Tweens a Rigidbody's position through the given path waypoints, using the chosen path algorithm.
                 Also stores the Rigidbody as the tween's target so it can be used for filtered operations.
                 <p>NOTE: to tween a rigidbody correctly it should be set to kinematic at least while being tweened.</p><p>BEWARE: doesn't work on Windows Phone store (waiting for Unity to fix their own bug).
                 If you plan to publish there you should use a regular transform.DOPath.</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target        
                 * @param   {Array.<UnityEngine.Vector3>}       path          The waypoints to go through
                 * @param   {number}                            duration      The duration of the tween
                 * @param   {DG.Tweening.PathType}              pathType      The type of path: Linear (straight path), CatmullRom (curved CatmullRom path) or CubicBezier (curved with control points)
                 * @param   {DG.Tweening.PathMode}              pathMode      The path mode: 3D, side-scroller 2D, top-down 2D
                 * @param   {number}                            resolution    The resolution of the path (useless in case of Linear paths): higher resolutions make for more detailed curved paths but are more expensive.
                 Defaults to 10, but a value of 5 is usually enough if you don't have dramatic long curves between waypoints
                 * @param   {?UnityEngine.Color}                gizmoColor    The color of the path (shown when gizmos are active in the Play panel and the tween is running)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPath: function (target, path, duration, pathType, pathMode, resolution, gizmoColor) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOPath", this ); }

                    if (pathType === void 0) { pathType = 0; }
                    if (pathMode === void 0) { pathMode = 1; }
                    if (resolution === void 0) { resolution = 10; }
                    if (gizmoColor === void 0) { gizmoColor = null; }
                    if (resolution < 1) {
                        resolution = 1;
                    }
                    var t = DG.Tweening.TweenSettingsExtensions.SetUpdate$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new DG.Tweening.Plugins.Core.PathCore.Path.$ctor1(pathType, path, resolution, System.Nullable.lift1("$clone", gizmoColor)), duration), target), DG.Tweening.UpdateType.Fixed);

                    t.plugOptions.isRigidbody = true;
                    t.plugOptions.mode = pathMode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOPath:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOPath$1:static start.*/
                DOPath$1: function (target, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOPath$1", this ); }

                    if (pathMode === void 0) { pathMode = 1; }
                    var t = DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), path, duration), target);

                    t.plugOptions.isRigidbody = true;
                    t.plugOptions.mode = pathMode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOPath$1:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOLocalPath:static start.*/
                /**
                 * Tweens a Rigidbody's localPosition through the given path waypoints, using the chosen path algorithm.
                 Also stores the Rigidbody as the tween's target so it can be used for filtered operations
                 <p>NOTE: to tween a rigidbody correctly it should be set to kinematic at least while being tweened.</p><p>BEWARE: doesn't work on Windows Phone store (waiting for Unity to fix their own bug).
                 If you plan to publish there you should use a regular transform.DOLocalPath.</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target        
                 * @param   {Array.<UnityEngine.Vector3>}       path          The waypoint to go through
                 * @param   {number}                            duration      The duration of the tween
                 * @param   {DG.Tweening.PathType}              pathType      The type of path: Linear (straight path), CatmullRom (curved CatmullRom path) or CubicBezier (curved with control points)
                 * @param   {DG.Tweening.PathMode}              pathMode      The path mode: 3D, side-scroller 2D, top-down 2D
                 * @param   {number}                            resolution    The resolution of the path: higher resolutions make for more detailed curved paths but are more expensive.
                 Defaults to 10, but a value of 5 is usually enough if you don't have dramatic long curves between waypoints
                 * @param   {?UnityEngine.Color}                gizmoColor    The color of the path (shown when gizmos are active in the Play panel and the tween is running)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOLocalPath: function (target, path, duration, pathType, pathMode, resolution, gizmoColor) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOLocalPath", this ); }

                    if (pathType === void 0) { pathType = 0; }
                    if (pathMode === void 0) { pathMode = 1; }
                    if (resolution === void 0) { resolution = 10; }
                    if (gizmoColor === void 0) { gizmoColor = null; }
                    if (resolution < 1) {
                        resolution = 1;
                    }
                    var trans = target.transform;
                    var t = DG.Tweening.TweenSettingsExtensions.SetUpdate$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return trans.localPosition;
                    }, function (x) {
                        target.MovePosition(UnityEngine.Component.op_Equality(trans.parent, null) ? x.$clone() : trans.parent.TransformPoint$1(x));
                    }, new DG.Tweening.Plugins.Core.PathCore.Path.$ctor1(pathType, path, resolution, System.Nullable.lift1("$clone", gizmoColor)), duration), target), DG.Tweening.UpdateType.Fixed);

                    t.plugOptions.isRigidbody = true;
                    t.plugOptions.mode = pathMode;
                    t.plugOptions.useLocalPosition = true;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOLocalPath:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOLocalPath$1:static start.*/
                DOLocalPath$1: function (target, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOLocalPath$1", this ); }

                    if (pathMode === void 0) { pathMode = 1; }
                    var trans = target.transform;
                    var t = DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return trans.localPosition;
                    }, function (x) {
                        target.MovePosition(UnityEngine.Component.op_Equality(trans.parent, null) ? x.$clone() : trans.parent.TransformPoint$1(x));
                    }, path, duration), target);

                    t.plugOptions.isRigidbody = true;
                    t.plugOptions.mode = pathMode;
                    t.plugOptions.useLocalPosition = true;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOLocalPath$1:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModulePhysics end.*/

    /*DG.Tweening.DOTweenModulePhysics2D start.*/
    Bridge.define("DG.Tweening.DOTweenModulePhysics2D", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModulePhysics2D.DOMove:static start.*/
                /**
                 * Tweens a Rigidbody2D's position to the given value.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMove: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOMove", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOMove:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOMoveX:static start.*/
                /**
                 * Tweens a Rigidbody2D's X position to the given value.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOMoveX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec2( endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOMoveX:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOMoveY:static start.*/
                /**
                 * Tweens a Rigidbody2D's Y position to the given value.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOMoveY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec2( 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOMoveY:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DORotate:static start.*/
                /**
                 * Tweens a Rigidbody2D's rotation to the given value.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DORotate: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DORotate", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.rotation;
                    }, Bridge.fn.cacheBind(target, target.MoveRotation), endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DORotate:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOJump:static start.*/
                /**
                 * Tweens a Rigidbody2D's position to the given value, while also applying a jump effect along the Y axis.
                 Returns a Sequence instead of a Tweener.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations.
                 <p>IMPORTANT: a rigidbody2D can't be animated in a jump arc using MovePosition, so the tween will directly set the position</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}    target       
                 * @param   {UnityEngine.Vector2}        endValue     The end value to reach
                 * @param   {number}                     jumpPower    Power of the jump (the max height of the jump is represented by this plus the final Y offset)
                 * @param   {number}                     numJumps     Total number of jumps
                 * @param   {number}                     duration     The duration of the tween
                 * @param   {boolean}                    snapping     If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Sequence}
                 */
                DOJump: function (target, endValue, jumpPower, numJumps, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOJump", this ); }

                    if (snapping === void 0) { snapping = false; }
                    if (numJumps < 1) {
                        numJumps = 1;
                    }
                    var startPosY = 0;
                    var offsetY = -1;
                    var offsetYSet = false;
                    var s = DG.Tweening.DOTween.Sequence();
                    var yTween = DG.Tweening.TweenSettingsExtensions.OnStart(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetRelative(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, function (x) {
                        target.position = x.$clone();
                    }, new pc.Vec2( 0, jumpPower ), duration / (Bridge.Int.mul(numJumps, 2))), DG.Tweening.AxisConstraint.Y, snapping), DG.Tweening.Ease.OutQuad)), Bridge.Int.mul(numJumps, 2), DG.Tweening.LoopType.Yoyo), function () {
                        startPosY = target.position.y;
                    });
                    DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, function (x) {
                        target.position = x.$clone();
                    }, new pc.Vec2( endValue.x, 0 ), duration), DG.Tweening.AxisConstraint.X, snapping), DG.Tweening.Ease.Linear)), yTween), target), DG.Tweening.DOTween.defaultEaseType);
                    DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Tween, yTween, function () {
                        if (!offsetYSet) {
                            offsetYSet = true;
                            offsetY = s.isRelative ? endValue.y : endValue.y - startPosY;
                        }
                        var pos = UnityEngine.Vector3.FromVector2(target.position.$clone());
                        pos.y += DG.Tweening.DOVirtual.EasedValue(0, offsetY, DG.Tweening.TweenExtensions.ElapsedPercentage(yTween), DG.Tweening.Ease.OutQuad);
                        target.MovePosition$1(pos);
                    });
                    return s;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOJump:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOPath:static start.*/
                /**
                 * Tweens a Rigidbody2D's position through the given path waypoints, using the chosen path algorithm.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations.
                 <p>NOTE: to tween a Rigidbody2D correctly it should be set to kinematic at least while being tweened.</p><p>BEWARE: doesn't work on Windows Phone store (waiting for Unity to fix their own bug).
                 If you plan to publish there you should use a regular transform.DOPath.</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target        
                 * @param   {Array.<UnityEngine.Vector2>}       path          The waypoints to go through
                 * @param   {number}                            duration      The duration of the tween
                 * @param   {DG.Tweening.PathType}              pathType      The type of path: Linear (straight path), CatmullRom (curved CatmullRom path) or CubicBezier (curved with control points)
                 * @param   {DG.Tweening.PathMode}              pathMode      The path mode: 3D, side-scroller 2D, top-down 2D
                 * @param   {number}                            resolution    The resolution of the path (useless in case of Linear paths): higher resolutions make for more detailed curved paths but are more expensive.
                 Defaults to 10, but a value of 5 is usually enough if you don't have dramatic long curves between waypoints
                 * @param   {?UnityEngine.Color}                gizmoColor    The color of the path (shown when gizmos are active in the Play panel and the tween is running)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPath: function (target, path, duration, pathType, pathMode, resolution, gizmoColor) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOPath", this ); }

                    if (pathType === void 0) { pathType = 0; }
                    if (pathMode === void 0) { pathMode = 1; }
                    if (resolution === void 0) { resolution = 10; }
                    if (gizmoColor === void 0) { gizmoColor = null; }
                    if (resolution < 1) {
                        resolution = 1;
                    }
                    var len = path.length;
                    var path3D = System.Array.init(len, function (){
                        return new UnityEngine.Vector3();
                    }, UnityEngine.Vector3);
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        path3D[i] = UnityEngine.Vector3.FromVector2(path[i].$clone());
                    }
                    var t = DG.Tweening.TweenSettingsExtensions.SetUpdate$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return UnityEngine.Vector3.FromVector2(target.position);
                    }, function (x) {
                        target.MovePosition$1(x);
                    }, new DG.Tweening.Plugins.Core.PathCore.Path.$ctor1(pathType, path3D, resolution, System.Nullable.lift1("$clone", gizmoColor)), duration), target), DG.Tweening.UpdateType.Fixed);

                    t.plugOptions.isRigidbody2D = true;
                    t.plugOptions.mode = pathMode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOPath:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOPath$1:static start.*/
                DOPath$1: function (target, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOPath$1", this ); }

                    if (pathMode === void 0) { pathMode = 1; }
                    var t = DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return UnityEngine.Vector3.FromVector2(target.position);
                    }, function (x) {
                        target.MovePosition$1(x);
                    }, path, duration), target);

                    t.plugOptions.isRigidbody2D = true;
                    t.plugOptions.mode = pathMode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOPath$1:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOLocalPath:static start.*/
                /**
                 * Tweens a Rigidbody2D's localPosition through the given path waypoints, using the chosen path algorithm.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
                 <p>NOTE: to tween a Rigidbody2D correctly it should be set to kinematic at least while being tweened.</p><p>BEWARE: doesn't work on Windows Phone store (waiting for Unity to fix their own bug).
                 If you plan to publish there you should use a regular transform.DOLocalPath.</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target        
                 * @param   {Array.<UnityEngine.Vector2>}       path          The waypoint to go through
                 * @param   {number}                            duration      The duration of the tween
                 * @param   {DG.Tweening.PathType}              pathType      The type of path: Linear (straight path), CatmullRom (curved CatmullRom path) or CubicBezier (curved with control points)
                 * @param   {DG.Tweening.PathMode}              pathMode      The path mode: 3D, side-scroller 2D, top-down 2D
                 * @param   {number}                            resolution    The resolution of the path: higher resolutions make for more detailed curved paths but are more expensive.
                 Defaults to 10, but a value of 5 is usually enough if you don't have dramatic long curves between waypoints
                 * @param   {?UnityEngine.Color}                gizmoColor    The color of the path (shown when gizmos are active in the Play panel and the tween is running)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOLocalPath: function (target, path, duration, pathType, pathMode, resolution, gizmoColor) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOLocalPath", this ); }

                    if (pathType === void 0) { pathType = 0; }
                    if (pathMode === void 0) { pathMode = 1; }
                    if (resolution === void 0) { resolution = 10; }
                    if (gizmoColor === void 0) { gizmoColor = null; }
                    if (resolution < 1) {
                        resolution = 1;
                    }
                    var len = path.length;
                    var path3D = System.Array.init(len, function (){
                        return new UnityEngine.Vector3();
                    }, UnityEngine.Vector3);
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        path3D[i] = UnityEngine.Vector3.FromVector2(path[i].$clone());
                    }
                    var trans = target.transform;
                    var t = DG.Tweening.TweenSettingsExtensions.SetUpdate$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return trans.localPosition;
                    }, function (x) {
                        target.MovePosition$1(UnityEngine.Component.op_Equality(trans.parent, null) ? x.$clone() : trans.parent.TransformPoint$1(x));
                    }, new DG.Tweening.Plugins.Core.PathCore.Path.$ctor1(pathType, path3D, resolution, System.Nullable.lift1("$clone", gizmoColor)), duration), target), DG.Tweening.UpdateType.Fixed);

                    t.plugOptions.isRigidbody2D = true;
                    t.plugOptions.mode = pathMode;
                    t.plugOptions.useLocalPosition = true;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOLocalPath:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOLocalPath$1:static start.*/
                DOLocalPath$1: function (target, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOLocalPath$1", this ); }

                    if (pathMode === void 0) { pathMode = 1; }
                    var trans = target.transform;
                    var t = DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return trans.localPosition;
                    }, function (x) {
                        target.MovePosition$1(UnityEngine.Component.op_Equality(trans.parent, null) ? x.$clone() : trans.parent.TransformPoint$1(x));
                    }, path, duration), target);

                    t.plugOptions.isRigidbody2D = true;
                    t.plugOptions.mode = pathMode;
                    t.plugOptions.useLocalPosition = true;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOLocalPath$1:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModulePhysics2D end.*/

    /*DG.Tweening.DOTweenModuleSprite start.*/
    Bridge.define("DG.Tweening.DOTweenModuleSprite", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleSprite.DOColor:static start.*/
                /**
                 * Tweens a SpriteRenderer's color to the given value.
                 Also stores the spriteRenderer as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleSprite
                 * @memberof DG.Tweening.DOTweenModuleSprite
                 * @param   {UnityEngine.SpriteRenderer}        target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOColor", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleSprite.DOColor:static end.*/

                /*DG.Tweening.DOTweenModuleSprite.DOFade:static start.*/
                /**
                 * Tweens a Material's alpha color to the given value.
                 Also stores the spriteRenderer as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleSprite
                 * @memberof DG.Tweening.DOTweenModuleSprite
                 * @param   {UnityEngine.SpriteRenderer}        target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOFade", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleSprite.DOFade:static end.*/

                /*DG.Tweening.DOTweenModuleSprite.DOGradientColor:static start.*/
                /**
                 * Tweens a SpriteRenderer's color using the given gradient
                 (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleSprite
                 * @memberof DG.Tweening.DOTweenModuleSprite
                 * @param   {UnityEngine.SpriteRenderer}    target      
                 * @param   {pc.ColorGradient}              gradient    The gradient to use
                 * @param   {number}                        duration    The duration of the tween
                 * @return  {DG.Tweening.Sequence}
                 */
                DOGradientColor: function (target, gradient, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOGradientColor", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0) {
                            target.color = c.color.$clone();
                            continue;
                        }
                        var colorDuration = i === ((len - 1) | 0) ? duration - DG.Tweening.TweenExtensions.Duration(s, false) : duration * (i === 0 ? c.time : c.time - colors[((i - 1) | 0)].time);
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.DOTweenModuleSprite.DOColor(target, c.color.$clone(), colorDuration), DG.Tweening.Ease.Linear));
                    }
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, s, target);
                    return s;
                },
                /*DG.Tweening.DOTweenModuleSprite.DOGradientColor:static end.*/

                /*DG.Tweening.DOTweenModuleSprite.DOBlendableColor:static start.*/
                /**
                 * Tweens a SpriteRenderer's color to the given value,
                 in a way that allows other DOBlendableColor tweens to work together on the same target,
                 instead than fight each other as multiple DOColor would do.
                 Also stores the SpriteRenderer as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleSprite
                 * @memberof DG.Tweening.DOTweenModuleSprite
                 * @param   {UnityEngine.SpriteRenderer}    target      
                 * @param   {UnityEngine.Color}             endValue    The value to tween to
                 * @param   {number}                        duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOBlendableColor", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleSprite.DOBlendableColor:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleSprite end.*/

    /*DG.Tweening.DOTweenModuleUI start.*/
    Bridge.define("DG.Tweening.DOTweenModuleUI", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUI.DOFade:static start.*/
                /**
                 * Tweens a CanvasGroup's alpha color to the given value.
                 Also stores the canvasGroup as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.CanvasGroup}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.alpha;
                    }, function (x) {
                        target.alpha = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$1:static start.*/
                /**
                 * Tweens an Graphic's alpha color to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Graphic}            target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$1: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$1", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$2:static start.*/
                /**
                 * Tweens an Image's alpha color to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}              target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$2: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$2", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$2:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$3:static start.*/
                /**
                 * Tweens a Outline's effectColor alpha to the given value.
                 Also stores the Outline as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Outline}            target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$3: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$3", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.effectColor;
                    }, function (x) {
                        target.effectColor = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$3:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$4:static start.*/
                /**
                 * Tweens a Text's alpha color to the given value.
                 Also stores the Text as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}               target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$4: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$4", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$4:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor:static start.*/
                /**
                 * Tweens an Graphic's color to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Graphic}            target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor$1:static start.*/
                /**
                 * Tweens an Image's color to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}              target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor$1: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor$1", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor$2:static start.*/
                /**
                 * Tweens a Outline's effectColor to the given value.
                 Also stores the Outline as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Outline}            target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor$2: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor$2", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.effectColor;
                    }, function (x) {
                        target.effectColor = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor$2:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor$3:static start.*/
                /**
                 * Tweens a Text's color to the given value.
                 Also stores the Text as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}               target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor$3: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor$3", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor$3:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFillAmount:static start.*/
                /**
                 * Tweens an Image's fillAmount to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}              target      
                 * @param   {number}                            endValue    The end value to reach (0 to 1)
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFillAmount: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFillAmount", this ); }

                    if (endValue > 1) {
                        endValue = 1;
                    } else {
                        if (endValue < 0) {
                            endValue = 0;
                        }
                    }
                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.fillAmount;
                    }, function (x) {
                        target.fillAmount = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFillAmount:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOGradientColor:static start.*/
                /**
                 * Tweens an Image's colors using the given gradient
                 (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}    target      
                 * @param   {pc.ColorGradient}        gradient    The gradient to use
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Sequence}
                 */
                DOGradientColor: function (target, gradient, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOGradientColor", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0) {
                            target.color = c.color.$clone();
                            continue;
                        }
                        var colorDuration = i === ((len - 1) | 0) ? duration - DG.Tweening.TweenExtensions.Duration(s, false) : duration * (i === 0 ? c.time : c.time - colors[((i - 1) | 0)].time);
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.DOTweenModuleUI.DOColor$1(target, c.color.$clone(), colorDuration), DG.Tweening.Ease.Linear));
                    }
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, s, target);
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUI.DOGradientColor:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFlexibleSize:static start.*/
                /**
                 * Tweens an LayoutElement's flexibleWidth/Height to the given value.
                 Also stores the LayoutElement as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.LayoutElement}      target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFlexibleSize: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFlexibleSize", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.flexibleWidth, target.flexibleHeight );
                    }, function (x) {
                        target.flexibleWidth = x.x;
                        target.flexibleHeight = x.y;
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFlexibleSize:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOMinSize:static start.*/
                /**
                 * Tweens an LayoutElement's minWidth/Height to the given value.
                 Also stores the LayoutElement as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.LayoutElement}      target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMinSize: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOMinSize", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.minWidth, target.minHeight );
                    }, function (x) {
                        target.minWidth = x.x;
                        target.minHeight = x.y;
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOMinSize:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPreferredSize:static start.*/
                /**
                 * Tweens an LayoutElement's preferredWidth/Height to the given value.
                 Also stores the LayoutElement as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.LayoutElement}      target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPreferredSize: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPreferredSize", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.preferredWidth, target.preferredHeight );
                    }, function (x) {
                        target.preferredWidth = x.x;
                        target.preferredHeight = x.y;
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPreferredSize:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOScale:static start.*/
                /**
                 * Tweens a Outline's effectDistance to the given value.
                 Also stores the Outline as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Outline}            target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOScale: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOScale", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.effectDistance;
                    }, function (x) {
                        target.effectDistance = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOScale:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosX:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition X to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPosX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPosX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosX:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosY:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition Y to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPosY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPosY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosY:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3D:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition3D to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector3}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos3D: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3D", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$13(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3D:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DX:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition3D X to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos3DX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3DX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, new pc.Vec3( endValue, 0, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DX:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DY:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition3D Y to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos3DY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3DY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, new pc.Vec3( 0, endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DY:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DZ:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition3D Z to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos3DZ: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3DZ", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, new pc.Vec3( 0, 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Z, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DZ:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorMax:static start.*/
                /**
                 * Tweens a RectTransform's anchorMax to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorMax: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorMax", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchorMax;
                    }, function (x) {
                        target.anchorMax = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorMax:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorMin:static start.*/
                /**
                 * Tweens a RectTransform's anchorMin to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorMin: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorMin", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchorMin;
                    }, function (x) {
                        target.anchorMin = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorMin:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPivot:static start.*/
                /**
                 * Tweens a RectTransform's pivot to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPivot: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPivot", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.pivot;
                    }, function (x) {
                        target.pivot = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPivot:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPivotX:static start.*/
                /**
                 * Tweens a RectTransform's pivot X to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPivotX: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPivotX", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.pivot;
                    }, function (x) {
                        target.pivot = x.$clone();
                    }, new pc.Vec2( endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.X), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPivotX:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPivotY:static start.*/
                /**
                 * Tweens a RectTransform's pivot Y to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPivotY: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPivotY", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.pivot;
                    }, function (x) {
                        target.pivot = x.$clone();
                    }, new pc.Vec2( 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.Y), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPivotY:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOSizeDelta:static start.*/
                /**
                 * Tweens a RectTransform's sizeDelta to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOSizeDelta: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOSizeDelta", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.sizeDelta;
                    }, function (x) {
                        target.sizeDelta = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOSizeDelta:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPunchAnchorPos:static start.*/
                /**
                 * Punches a RectTransform's anchoredPosition towards the given direction and then back to the starting one
                 as if it was connected to the starting position via an elastic.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}    target        
                 * @param   {UnityEngine.Vector2}          punch         The direction and strength of the punch (added to the RectTransform's current position)
                 * @param   {number}                       duration      The duration of the tween
                 * @param   {number}                       vibrato       Indicates how much will the punch vibrate
                 * @param   {number}                       elasticity    Represents how much (0 to 1) the vector will go beyond the starting position when bouncing backwards.
                 1 creates a full oscillation between the punch direction and the opposite direction,
                 while 0 oscillates only between the punch and the start position
                 * @param   {boolean}                      snapping      If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DOPunchAnchorPos: function (target, punch, duration, vibrato, elasticity, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPunchAnchorPos", this ); }

                    if (vibrato === void 0) { vibrato = 10; }
                    if (elasticity === void 0) { elasticity = 1.0; }
                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetOptions$11(DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Punch(function () {
                        return UnityEngine.Vector3.FromVector2(target.anchoredPosition);
                    }, function (x) {
                        target.anchoredPosition = UnityEngine.Vector2.FromVector3(x.$clone());
                    }, UnityEngine.Vector3.FromVector2(punch.$clone()), duration, vibrato, elasticity), target), snapping);
                },
                /*DG.Tweening.DOTweenModuleUI.DOPunchAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos:static start.*/
                /**
                 * Shakes a RectTransform's anchoredPosition with the given values.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}          target            
                 * @param   {number}                             duration          The duration of the tween
                 * @param   {number}                             strength          The shake strength
                 * @param   {number}                             vibrato           Indicates how much will the shake vibrate
                 * @param   {number}                             randomness        Indicates how much the shake will be random (0 to 180 - values higher than 90 kind of suck, so beware). 
                 Setting it to 0 will shake along a single direction.
                 * @param   {boolean}                            snapping          If TRUE the tween will smoothly snap all values to integers
                 * @param   {boolean}                            fadeOut           If TRUE the shake will automatically fadeOut smoothly within the tween's duration, otherwise it will not
                 * @param   {DG.Tweening.ShakeRandomnessMode}    randomnessMode    Randomness mode
                 * @return  {DG.Tweening.Tweener}
                 */
                DOShakeAnchorPos: function (target, duration, strength, vibrato, randomness, snapping, fadeOut, randomnessMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos", this ); }

                    if (strength === void 0) { strength = 100.0; }
                    if (vibrato === void 0) { vibrato = 10; }
                    if (randomness === void 0) { randomness = 90.0; }
                    if (snapping === void 0) { snapping = false; }
                    if (fadeOut === void 0) { fadeOut = true; }
                    if (randomnessMode === void 0) { randomnessMode = 0; }
                    return DG.Tweening.TweenSettingsExtensions.SetOptions$11(DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Shake(function () {
                        return UnityEngine.Vector3.FromVector2(target.anchoredPosition);
                    }, function (x) {
                        target.anchoredPosition = UnityEngine.Vector2.FromVector3(x.$clone());
                    }, duration, strength, vibrato, randomness, true, fadeOut, randomnessMode), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetShake), snapping);
                },
                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos$1:static start.*/
                /**
                 * Shakes a RectTransform's anchoredPosition with the given values.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}          target            
                 * @param   {number}                             duration          The duration of the tween
                 * @param   {UnityEngine.Vector2}                strength          The shake strength on each axis
                 * @param   {number}                             vibrato           Indicates how much will the shake vibrate
                 * @param   {number}                             randomness        Indicates how much the shake will be random (0 to 180 - values higher than 90 kind of suck, so beware). 
                 Setting it to 0 will shake along a single direction.
                 * @param   {boolean}                            snapping          If TRUE the tween will smoothly snap all values to integers
                 * @param   {boolean}                            fadeOut           If TRUE the shake will automatically fadeOut smoothly within the tween's duration, otherwise it will not
                 * @param   {DG.Tweening.ShakeRandomnessMode}    randomnessMode    Randomness mode
                 * @return  {DG.Tweening.Tweener}
                 */
                DOShakeAnchorPos$1: function (target, duration, strength, vibrato, randomness, snapping, fadeOut, randomnessMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos$1", this ); }

                    if (vibrato === void 0) { vibrato = 10; }
                    if (randomness === void 0) { randomness = 90.0; }
                    if (snapping === void 0) { snapping = false; }
                    if (fadeOut === void 0) { fadeOut = true; }
                    if (randomnessMode === void 0) { randomnessMode = 0; }
                    return DG.Tweening.TweenSettingsExtensions.SetOptions$11(DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Shake$1(function () {
                        return UnityEngine.Vector3.FromVector2(target.anchoredPosition);
                    }, function (x) {
                        target.anchoredPosition = UnityEngine.Vector2.FromVector3(x.$clone());
                    }, duration, UnityEngine.Vector3.FromVector2(strength.$clone()), vibrato, randomness, fadeOut, randomnessMode), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetShake), snapping);
                },
                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOJumpAnchorPos:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition to the given value, while also applying a jump effect along the Y axis.
                 Returns a Sequence instead of a Tweener.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}    target       
                 * @param   {UnityEngine.Vector2}          endValue     The end value to reach
                 * @param   {number}                       jumpPower    Power of the jump (the max height of the jump is represented by this plus the final Y offset)
                 * @param   {number}                       numJumps     Total number of jumps
                 * @param   {number}                       duration     The duration of the tween
                 * @param   {boolean}                      snapping     If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Sequence}
                 */
                DOJumpAnchorPos: function (target, endValue, jumpPower, numJumps, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOJumpAnchorPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    if (numJumps < 1) {
                        numJumps = 1;
                    }
                    var startPosY = 0;
                    var offsetY = -1;
                    var offsetYSet = false;

                    // Separate Y Tween so we can elaborate elapsedPercentage on that insted of on the Sequence
                    // (in case users add a delay or other elements to the Sequence)
                    var s = DG.Tweening.DOTween.Sequence();
                    var yTween = DG.Tweening.TweenSettingsExtensions.OnStart(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetRelative(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( 0, jumpPower ), duration / (Bridge.Int.mul(numJumps, 2))), DG.Tweening.AxisConstraint.Y, snapping), DG.Tweening.Ease.OutQuad)), Bridge.Int.mul(numJumps, 2), DG.Tweening.LoopType.Yoyo), function () {
                        startPosY = target.anchoredPosition.y;
                    });
                    DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( endValue.x, 0 ), duration), DG.Tweening.AxisConstraint.X, snapping), DG.Tweening.Ease.Linear)), yTween), target), DG.Tweening.DOTween.defaultEaseType);
                    DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Sequence, s, function () {
                        if (!offsetYSet) {
                            offsetYSet = true;
                            offsetY = s.isRelative ? endValue.y : endValue.y - startPosY;
                        }
                        var pos = target.anchoredPosition.$clone();
                        pos.y += DG.Tweening.DOVirtual.EasedValue(0, offsetY, DG.Tweening.TweenExtensions.ElapsedDirectionalPercentage(s), DG.Tweening.Ease.OutQuad);
                        target.anchoredPosition = pos.$clone();
                    });
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUI.DOJumpAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DONormalizedPos:static start.*/
                /**
                 * Tweens a ScrollRect's horizontal/verticalNormalizedPosition to the given value.
                 Also stores the ScrollRect as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.ScrollRect}    target      
                 * @param   {UnityEngine.Vector2}          endValue    The end value to reach
                 * @param   {number}                       duration    The duration of the tween
                 * @param   {boolean}                      snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DONormalizedPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DONormalizedPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.horizontalNormalizedPosition, target.verticalNormalizedPosition );
                    }, function (x) {
                        target.horizontalNormalizedPosition = x.x;
                        target.verticalNormalizedPosition = x.y;
                    }, endValue.$clone(), duration), snapping), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DONormalizedPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOHorizontalNormalizedPos:static start.*/
                /**
                 * Tweens a ScrollRect's horizontalNormalizedPosition to the given value.
                 Also stores the ScrollRect as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.ScrollRect}    target      
                 * @param   {number}                       endValue    The end value to reach
                 * @param   {number}                       duration    The duration of the tween
                 * @param   {boolean}                      snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DOHorizontalNormalizedPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOHorizontalNormalizedPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$2(DG.Tweening.DOTween.To$4(function () {
                        return target.horizontalNormalizedPosition;
                    }, function (x) {
                        target.horizontalNormalizedPosition = x;
                    }, endValue, duration), snapping), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOHorizontalNormalizedPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOVerticalNormalizedPos:static start.*/
                /**
                 * Tweens a ScrollRect's verticalNormalizedPosition to the given value.
                 Also stores the ScrollRect as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.ScrollRect}    target      
                 * @param   {number}                       endValue    The end value to reach
                 * @param   {number}                       duration    The duration of the tween
                 * @param   {boolean}                      snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DOVerticalNormalizedPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOVerticalNormalizedPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$2(DG.Tweening.DOTween.To$4(function () {
                        return target.verticalNormalizedPosition;
                    }, function (x) {
                        target.verticalNormalizedPosition = x;
                    }, endValue, duration), snapping), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOVerticalNormalizedPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOValue:static start.*/
                /**
                 * Tweens a Slider's value to the given value.
                 Also stores the Slider as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Slider}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOValue: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOValue", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.value;
                    }, function (x) {
                        target.value = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$2(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOValue:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOCounter:static start.*/
                /**
                 * Tweens a Text's text from one integer to another, with options for thousands separators
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}                 target                   
                 * @param   {number}                              fromValue                The value to start from
                 * @param   {number}                              endValue                 The end value to reach
                 * @param   {number}                              duration                 The duration of the tween
                 * @param   {boolean}                             addThousandsSeparator    If TRUE (default) also adds thousands separators
                 * @param   {System.Globalization.CultureInfo}    culture                  The {@link } to use (InvariantCulture if NULL)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOCounter: function (target, fromValue, endValue, duration, addThousandsSeparator, culture) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOCounter", this ); }

                    if (addThousandsSeparator === void 0) { addThousandsSeparator = true; }
                    if (culture === void 0) { culture = null; }
                    var v = fromValue;
                    var cInfo = !addThousandsSeparator ? null : culture || System.Globalization.CultureInfo.invariantCulture;
                    var t = DG.Tweening.DOTween.To$2(function () {
                        return v;
                    }, function (x) {
                        v = x;
                        target.text = addThousandsSeparator ? System.Int32.format(v, "N0", cInfo) : Bridge.toString(v);
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Int32,System.Int32,DG.Tweening.Plugins.Options.NoOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOCounter:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOText:static start.*/
                /**
                 * Tweens a Text's text to the given value.
                 Also stores the Text as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}               target             
                 * @param   {string}                            endValue           The end string to tween to
                 * @param   {number}                            duration           The duration of the tween
                 * @param   {boolean}                           richTextEnabled    If TRUE (default), rich text will be interpreted correctly while animated,
                 otherwise all tags will be considered as normal text
                 * @param   {DG.Tweening.ScrambleMode}          scrambleMode       The type of scramble mode to use, if any
                 * @param   {string}                            scrambleChars      A string containing the characters to use for scrambling.
                 Use as many characters as possible (minimum 10) because DOTween uses a fast scramble mode which gives better results with more characters.
                 Leave it to NULL (default) to use default ones
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOText: function (target, endValue, duration, richTextEnabled, scrambleMode, scrambleChars) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOText", this ); }

                    if (richTextEnabled === void 0) { richTextEnabled = true; }
                    if (scrambleMode === void 0) { scrambleMode = 0; }
                    if (scrambleChars === void 0) { scrambleChars = null; }
                    if (endValue == null) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogWarning("You can't pass a NULL string to DOText: an empty string will be used instead to avoid errors");
                        }
                        endValue = "";
                    }
                    var t = DG.Tweening.DOTween.To$5(function () {
                        return target.text;
                    }, function (x) {
                        target.text = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$3(t, richTextEnabled, scrambleMode, scrambleChars), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOText:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor:static start.*/
                /**
                 * Tweens a Graphic's color to the given value,
                 in a way that allows other DOBlendableColor tweens to work together on the same target,
                 instead than fight each other as multiple DOColor would do.
                 Also stores the Graphic as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Graphic}    target      
                 * @param   {UnityEngine.Color}         endValue    The value to tween to
                 * @param   {number}                    duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOBlendableColor", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$1:static start.*/
                /**
                 * Tweens a Image's color to the given value,
                 in a way that allows other DOBlendableColor tweens to work together on the same target,
                 instead than fight each other as multiple DOColor would do.
                 Also stores the Image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}    target      
                 * @param   {UnityEngine.Color}       endValue    The value to tween to
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor$1: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOBlendableColor$1", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$2:static start.*/
                /**
                 * Tweens a Text's color BY the given value,
                 in a way that allows other DOBlendableColor tweens to work together on the same target,
                 instead than fight each other as multiple DOColor would do.
                 Also stores the Text as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}    target      
                 * @param   {UnityEngine.Color}      endValue    The value to tween to
                 * @param   {number}                 duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor$2: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOBlendableColor$2", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$2:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOShapeCircle:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition so that it draws a circle around the given center.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations.<p />
                 IMPORTANT: SetFrom(value) requires a {@link } instead of a float, where the X property represents the "from degrees value"
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target             
                 * @param   {UnityEngine.Vector2}               center             Circle-center/pivot around which to rotate (in UI anchoredPosition coordinates)
                 * @param   {number}                            endValueDegrees    The end value degrees to reach (to rotate counter-clockwise pass a negative value)
                 * @param   {number}                            duration           The duration of the tween
                 * @param   {boolean}                           relativeCenter     If TRUE the {@link } coordinates will be considered as relative to the target's current anchoredPosition
                 * @param   {boolean}                           snapping           If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOShapeCircle: function (target, center, endValueDegrees, duration, relativeCenter, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOShapeCircle", this ); }

                    if (relativeCenter === void 0) { relativeCenter = false; }
                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To(UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.CircleOptions, DG.Tweening.Plugins.CirclePlugin.Get(), function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, center.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$7(t, endValueDegrees, relativeCenter, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOShapeCircle:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUI end.*/

    /*DG.Tweening.DOTweenModuleUI+Utils start.*/
    Bridge.define("DG.Tweening.DOTweenModuleUI.Utils", {
        $kind: 1002,
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUI+Utils.SwitchToRectTransform:static start.*/
                /**
                 * Converts the anchoredPosition of the first RectTransform to the second RectTransform,
                 taking into consideration offset, anchors and pivot, and returns the new anchoredPosition
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI.Utils
                 * @memberof DG.Tweening.DOTweenModuleUI.Utils
                 * @param   {UnityEngine.RectTransform}    from    
                 * @param   {UnityEngine.RectTransform}    to
                 * @return  {UnityEngine.Vector2}
                 */
                SwitchToRectTransform: function (from, to) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI.Utils#SwitchToRectTransform", this ); }

                    var localPoint = { v : new UnityEngine.Vector2() };
                    var fromPivotDerivedOffset = new pc.Vec2( from.rect.width * 0.5 + from.rect.xMin, from.rect.height * 0.5 + from.rect.yMin );
                    var screenP = UnityEngine.RectTransformUtility.WorldToScreenPoint(null, from.position);
                    screenP = screenP.$clone().add( fromPivotDerivedOffset.$clone() );
                    UnityEngine.RectTransformUtility.ScreenPointToLocalPointInRectangle(to, screenP, null, localPoint);
                    var pivotDerivedOffset = new pc.Vec2( to.rect.width * 0.5 + to.rect.xMin, to.rect.height * 0.5 + to.rect.yMin );
                    return to.anchoredPosition.$clone().add( localPoint.v ).sub( pivotDerivedOffset );
                },
                /*DG.Tweening.DOTweenModuleUI+Utils.SwitchToRectTransform:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUI+Utils end.*/

    /*DG.Tweening.DOTweenModuleUnityVersion start.*/
    /** @namespace DG.Tweening */

    /**
     * Shortcuts/functions that are not strictly related to specific Modules
     but are available only on some Unity versions
     *
     * @static
     * @abstract
     * @public
     * @class DG.Tweening.DOTweenModuleUnityVersion
     */
    Bridge.define("DG.Tweening.DOTweenModuleUnityVersion", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor:static start.*/
                /**
                 * Tweens a Material's color using the given gradient
                 (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {UnityEngine.Material}    target      
                 * @param   {pc.ColorGradient}        gradient    The gradient to use
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Sequence}
                 */
                DOGradientColor: function (target, gradient, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0) {
                            target.color = c.color.$clone();
                            continue;
                        }
                        var colorDuration = i === ((len - 1) | 0) ? duration - DG.Tweening.TweenExtensions.Duration(s, false) : duration * (i === 0 ? c.time : c.time - colors[((i - 1) | 0)].time);
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.ShortcutExtensions.DOColor$3(target, c.color.$clone(), colorDuration), DG.Tweening.Ease.Linear));
                    }
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, s, target);
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor$1:static start.*/
                /**
                 * Tweens a Material's named color property using the given gradient
                 (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {UnityEngine.Material}    target      
                 * @param   {pc.ColorGradient}        gradient    The gradient to use
                 * @param   {string}                  property    The name of the material property to tween (like _Tint or _SpecColor)
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Sequence}
                 */
                DOGradientColor$1: function (target, gradient, property, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor$1", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0) {
                            target.SetColor$1(property, c.color);
                            continue;
                        }
                        var colorDuration = i === ((len - 1) | 0) ? duration - DG.Tweening.TweenExtensions.Duration(s, false) : duration * (i === 0 ? c.time : c.time - colors[((i - 1) | 0)].time);
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.ShortcutExtensions.DOColor$4(target, c.color.$clone(), property, colorDuration), DG.Tweening.Ease.Linear));
                    }
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, s, target);
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor$1:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForCompletion:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or complete.
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForCompletion(true);</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForCompletion: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForCompletion", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForCompletion(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForCompletion:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForRewind:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or rewinded.
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForRewind();</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForRewind: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForRewind", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForRewind(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForRewind:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForKill:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed.
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForKill();</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForKill: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForKill", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForKill(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForKill:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForElapsedLoops:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or has gone through the given amount of loops.
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForElapsedLoops(2);</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {number}                                elapsedLoops                    Elapsed loops to wait for
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForElapsedLoops: function (t, elapsedLoops, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForElapsedLoops", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops(t, elapsedLoops);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForElapsedLoops:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForPosition:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed
                 or has reached the given time position (loops included, delays excluded).
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForPosition(2.5f);</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {number}                                position                        Position (loops included, delays excluded) to wait for
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForPosition: function (t, position, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForPosition", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForPosition(t, position);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForPosition:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForStart:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or started
                 (meaning when the tween is set in a playing state the first time, after any eventual delay).
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForStart();</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForStart: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForStart", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForStart(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForStart:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.DOOffset:static start.*/
                /**
                 * Tweens a Material's named texture offset property with the given ID to the given value.
                 Also stores the material as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {UnityEngine.Material}              target        
                 * @param   {UnityEngine.Vector2}               endValue      The end value to reach
                 * @param   {number}                            propertyID    The ID of the material property to tween (also called nameID in Unity's manual)
                 * @param   {number}                            duration      The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOOffset: function (target, endValue, propertyID, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOOffset", this ); }

                    if (!target.HasProperty(propertyID)) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogMissingMaterialProperty(propertyID);
                        }
                        return null;
                    }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.GetTextureOffset(propertyID);
                    }, function (x) {
                        target.SetTextureOffset(propertyID, x);
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOOffset:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.DOTiling:static start.*/
                /**
                 * Tweens a Material's named texture scale property with the given ID to the given value.
                 Also stores the material as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {UnityEngine.Material}              target        
                 * @param   {UnityEngine.Vector2}               endValue      The end value to reach
                 * @param   {number}                            propertyID    The ID of the material property to tween (also called nameID in Unity's manual)
                 * @param   {number}                            duration      The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOTiling: function (target, endValue, propertyID, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOTiling", this ); }

                    if (!target.HasProperty(propertyID)) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogMissingMaterialProperty(propertyID);
                        }
                        return null;
                    }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.GetTextureScale(propertyID);
                    }, function (x) {
                        target.SetTextureScale(propertyID, x);
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOTiling:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUnityVersion end.*/

    /*DG.Tweening.DOTweenModuleUtils start.*/
    /**
     * Utility functions that deal with available Modules.
     Modules defines:
     - DOTAUDIO
     - DOTPHYSICS
     - DOTPHYSICS2D
     - DOTSPRITE
     - DOTUI
     Extra defines set and used for implementation of external assets:
     - DOTWEEN_TMP ► TextMesh Pro
     - DOTWEEN_TK2D ► 2D Toolkit
     *
     * @static
     * @abstract
     * @public
     * @class DG.Tweening.DOTweenModuleUtils
     */
    Bridge.define("DG.Tweening.DOTweenModuleUtils", {
        statics: {
            fields: {
                _initialized: false
            },
            methods: {
                /*DG.Tweening.DOTweenModuleUtils.Init:static start.*/
                /**
                 * Called via Reflection by DOTweenComponent on Awake
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUtils
                 * @memberof DG.Tweening.DOTweenModuleUtils
                 * @return  {void}
                 */
                Init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils#Init", this ); }

                    if (DG.Tweening.DOTweenModuleUtils._initialized) {
                        return;
                    }

                    DG.Tweening.DOTweenModuleUtils._initialized = true;
                    DG.Tweening.Core.DOTweenExternalCommand.addSetOrientationOnPath(DG.Tweening.DOTweenModuleUtils.Physics.SetOrientationOnPath);

                },
                /*DG.Tweening.DOTweenModuleUtils.Init:static end.*/

                /*DG.Tweening.DOTweenModuleUtils.Preserver:static start.*/
                Preserver: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils#Preserver", this ); }

                    var loadedAssemblies = System.AppDomain.getAssemblies();
                    var mi = Bridge.Reflection.getMembers(UnityEngine.MonoBehaviour, 8, 284, "Stub");
                },
                /*DG.Tweening.DOTweenModuleUtils.Preserver:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUtils end.*/

    /*DG.Tweening.DOTweenModuleUtils+Physics start.*/
    Bridge.define("DG.Tweening.DOTweenModuleUtils.Physics", {
        $kind: 1002,
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUtils+Physics.SetOrientationOnPath:static start.*/
                SetOrientationOnPath: function (options, t, newRot, trans) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#SetOrientationOnPath", this ); }

                    if (options.isRigidbody) {
                        Bridge.cast(t.target, UnityEngine.Rigidbody).rotation = newRot.$clone();
                    } else {
                        trans.rotation = newRot.$clone();
                    }
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.SetOrientationOnPath:static end.*/

                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody2D:static start.*/
                HasRigidbody2D: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody2D", this ); }

                    return UnityEngine.Component.op_Inequality(target.GetComponent(UnityEngine.Rigidbody2D), null);
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody2D:static end.*/

                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody:static start.*/
                HasRigidbody: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody", this ); }

                    return UnityEngine.Component.op_Inequality(target.GetComponent(UnityEngine.Rigidbody), null);
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody:static end.*/

                /*DG.Tweening.DOTweenModuleUtils+Physics.CreateDOTweenPathTween:static start.*/
                CreateDOTweenPathTween: function (target, tweenRigidbody, isLocal, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#CreateDOTweenPathTween", this ); }

                    var t = null;
                    var rBodyFoundAndTweened = false;
                    if (tweenRigidbody) {
                        var rBody = target.GetComponent(UnityEngine.Rigidbody);
                        if (UnityEngine.Component.op_Inequality(rBody, null)) {
                            rBodyFoundAndTweened = true;
                            t = isLocal ? DG.Tweening.DOTweenModulePhysics.DOLocalPath$1(rBody, path, duration, pathMode) : DG.Tweening.DOTweenModulePhysics.DOPath$1(rBody, path, duration, pathMode);
                        }
                    }
                    if (!rBodyFoundAndTweened && tweenRigidbody) {
                        var rBody2D = target.GetComponent(UnityEngine.Rigidbody2D);
                        if (UnityEngine.Component.op_Inequality(rBody2D, null)) {
                            rBodyFoundAndTweened = true;
                            t = isLocal ? DG.Tweening.DOTweenModulePhysics2D.DOLocalPath$1(rBody2D, path, duration, pathMode) : DG.Tweening.DOTweenModulePhysics2D.DOPath$1(rBody2D, path, duration, pathMode);
                        }
                    }
                    if (!rBodyFoundAndTweened) {
                        t = isLocal ? DG.Tweening.ShortcutExtensions.DOLocalPath(target.transform, path, duration, pathMode) : DG.Tweening.ShortcutExtensions.DOPath(target.transform, path, duration, pathMode);
                    }
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.CreateDOTweenPathTween:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUtils+Physics end.*/

    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty start.*/
    Bridge.define("IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty", {
        inherits: [UnityEngine.MonoBehaviour]
    });
    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty end.*/

    /*InputReceiver start.*/
    Bridge.define("InputReceiver", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            firstClick: false
        },
        props: {
            FirstClick: {
                get: function () {
if ( TRACE ) { TRACE( "InputReceiver#FirstClick#get", this ); }

                    return this.firstClick;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "InputReceiver#FirstClick#set", this ); }

                    this.firstClick = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "InputReceiver#init", this ); }

                this.firstClick = true;
            }
        },
        methods: {
            /*InputReceiver.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "InputReceiver#Update", this ); }

                if (UnityEngine.Input.GetMouseButtonDown(0)) {
                    this.TriggerCTA();
                }
            },
            /*InputReceiver.Update end.*/

            /*InputReceiver.HandleTarget start.*/
            HandleTarget: function () {
if ( TRACE ) { TRACE( "InputReceiver#HandleTarget", this ); }

                var mousePos = UnityEngine.Input.mousePosition.$clone();
                mousePos = UnityEngine.Camera.main.ScreenToWorldPoint(new pc.Vec3( mousePos.x, mousePos.y, -10 ));

                var direction = mousePos.$clone().sub( UnityEngine.Camera.main.transform.position );

                var hit = UnityEngine.Physics2D.Raycast$2(UnityEngine.Vector2.FromVector3(mousePos), UnityEngine.Vector2.FromVector3(direction), window.Infinity);
                var hits = UnityEngine.Physics2D.RaycastAll(hit.point, pc.Vec2.ZERO.clone(), window.Infinity);
                for (var i = 0; i < hits.length; i = (i + 1) | 0) {
                    if (UnityEngine.Object.op_Implicit(hits[i].collider) && UnityEngine.Object.op_Implicit(hits[i].collider.GetComponent(Pin))) {
                        var pin = hits[i].collider.gameObject.GetComponent(Pin);
                        // if (firstClick)
                        // {
                        //     // if (pin.Tutorial)
                        //     // {
                        //     //     pin.ActivePin();
                        //     //     firstClick = false;
                        //     // }
                        // }
                        // else 
                        if (UnityEngine.Object.op_Implicit(pin)) {
                            pin.ActivePin();
                        }
                    }
                }
            },
            /*InputReceiver.HandleTarget end.*/

            /*InputReceiver.TriggerCTA start.*/
            TriggerCTA: function () {
if ( TRACE ) { TRACE( "InputReceiver#TriggerCTA", this ); }

                UnityEngine.Debug.Log$1("triggerCTA");
                Luna.Unity.Playable.InstallFullGame("https://play.google.com/store/apps/details?id=com.gamee.dragon.kingdom.castle.match.story.puzzle&pcampaignid=web_share");
                Luna.Unity.LifeCycle.GameEnded();
            },
            /*InputReceiver.TriggerCTA end.*/


        }
    });
    /*InputReceiver end.*/

    /*King start.*/
    Bridge.define("King", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            anim: null,
            bag: null
        },
        methods: {
            /*King.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "King#Start", this ); }

                this.anim.SetAnim(Constant.animKingIdle, true);
                this.bag.OnIdle();
            },
            /*King.Start end.*/


        }
    });
    /*King end.*/

    /*Pin start.*/
    Bridge.define("Pin", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            head: null,
            end: null
        },
        methods: {
            /*Pin.ActivePin start.*/
            ActivePin: function () {
if ( TRACE ) { TRACE( "Pin#ActivePin", this ); }

                var direction = UnityEngine.Vector2.FromVector3(this.end.position.$clone().sub( this.head.position ));
                direction.normalize();
                DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMove(this.transform, UnityEngine.Vector3.FromVector2(UnityEngine.Vector2.FromVector3(this.transform.position).add( direction.$clone().scale( 5.0 ) )), 0.5, false), DG.Tweening.Ease.Linear), Bridge.fn.bind(this, function () {
                    this.gameObject.SetActive(false);
                }));
            },
            /*Pin.ActivePin end.*/


        }
    });
    /*Pin end.*/

    /*SkeletonGraphicPlayAnimationAtEvent start.*/
    Bridge.define("SkeletonGraphicPlayAnimationAtEvent", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonGraphic: null,
            trackIndex: 0,
            playbackSpeed: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "SkeletonGraphicPlayAnimationAtEvent#init", this ); }

                this.trackIndex = 0;
                this.playbackSpeed = 1.0;
            }
        },
        methods: {
            /*SkeletonGraphicPlayAnimationAtEvent.PlayAnimationLooping start.*/
            PlayAnimationLooping: function (animation) {
if ( TRACE ) { TRACE( "SkeletonGraphicPlayAnimationAtEvent#PlayAnimationLooping", this ); }

                var entry = this.skeletonGraphic.AnimationState.setAnimation(this.trackIndex, animation, true);
                entry.timeScale = this.playbackSpeed;
            },
            /*SkeletonGraphicPlayAnimationAtEvent.PlayAnimationLooping end.*/

            /*SkeletonGraphicPlayAnimationAtEvent.PlayAnimationOnce start.*/
            PlayAnimationOnce: function (animation) {
if ( TRACE ) { TRACE( "SkeletonGraphicPlayAnimationAtEvent#PlayAnimationOnce", this ); }

                var entry = this.skeletonGraphic.AnimationState.setAnimation(this.trackIndex, animation, false);
                entry.timeScale = this.playbackSpeed;
            },
            /*SkeletonGraphicPlayAnimationAtEvent.PlayAnimationOnce end.*/

            /*SkeletonGraphicPlayAnimationAtEvent.ClearTrack start.*/
            ClearTrack: function () {
if ( TRACE ) { TRACE( "SkeletonGraphicPlayAnimationAtEvent#ClearTrack", this ); }

                this.skeletonGraphic.AnimationState.clearTrack(this.trackIndex);
            },
            /*SkeletonGraphicPlayAnimationAtEvent.ClearTrack end.*/


        }
    });
    /*SkeletonGraphicPlayAnimationAtEvent end.*/

    /*SoundClick start.*/
    Bridge.define("SoundClick", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            loopTime: 0,
            sound: null
        },
        methods: {
            /*SoundClick.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "SoundClick#Start", this ); }

                this.StartCoroutine$1(this.AudioReplay());
            },
            /*SoundClick.Start end.*/

            /*SoundClick.AudioReplay start.*/
            AudioReplay: function () {
if ( TRACE ) { TRACE( "SoundClick#AudioReplay", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if ( true ) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 3;
                                        continue;
                                }
                                case 1: {
                                    $enumerator.current = new UnityEngine.WaitForSeconds(this.loopTime);
                                        $step = 2;
                                        return true;
                                }
                                case 2: {
                                    this.sound.Play();

                                        $step = 0;
                                        continue;
                                }
                                case 3: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*SoundClick.AudioReplay end.*/


        }
    });
    /*SoundClick end.*/

    /*Spine.BoneMatrix start.*/
    Bridge.define("Spine.BoneMatrix", {
        $kind: 4,
        statics: {
            methods: {
                /*Spine.BoneMatrix.CalculateSetupWorld:static start.*/
                /**
                 * Recursively calculates a worldspace bone matrix based on BoneData.
                 *
                 * @static
                 * @public
                 * @this Spine.BoneMatrix
                 * @memberof Spine.BoneMatrix
                 * @param   {spine.BoneData}      boneData
                 * @return  {Spine.BoneMatrix}
                 */
                CalculateSetupWorld: function (boneData) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#CalculateSetupWorld", this ); }

                    if (boneData == null) {
                        return Bridge.getDefaultValue(Spine.BoneMatrix);
                    }

                    // End condition: isRootBone
                    if (boneData.parent == null) {
                        return Spine.BoneMatrix.GetInheritedInternal(boneData, Bridge.getDefaultValue(Spine.BoneMatrix));
                    }

                    var result = Spine.BoneMatrix.CalculateSetupWorld(boneData.parent);
                    return Spine.BoneMatrix.GetInheritedInternal(boneData, result.$clone());
                },
                /*Spine.BoneMatrix.CalculateSetupWorld:static end.*/

                /*Spine.BoneMatrix.GetInheritedInternal:static start.*/
                GetInheritedInternal: function (boneData, parentMatrix) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#GetInheritedInternal", this ); }

                    var parent = boneData.parent;
                    if (parent == null) {
                        return new Spine.BoneMatrix.$ctor2(boneData);
                    } // isRootBone

                    var pa = parentMatrix.a, pb = parentMatrix.b, pc = parentMatrix.c, pd = parentMatrix.d;
                    var result = Bridge.getDefaultValue(Spine.BoneMatrix);
                    result.x = pa * boneData.x + pb * boneData.y + parentMatrix.x;
                    result.y = pc * boneData.x + pd * boneData.y + parentMatrix.y;

                    switch (boneData.transformMode) {
                        case spine.BoneData.Normal: 
                            {
                                var rotationY = boneData.rotation + 90 + boneData.shearY;
                                var la = Spine.MathUtils.CosDeg(boneData.rotation + boneData.shearX) * boneData.scaleX;
                                var lb = Spine.MathUtils.CosDeg(rotationY) * boneData.scaleY;
                                var lc = Spine.MathUtils.SinDeg(boneData.rotation + boneData.shearX) * boneData.scaleX;
                                var ld = Spine.MathUtils.SinDeg(rotationY) * boneData.scaleY;
                                result.a = pa * la + pb * lc;
                                result.b = pa * lb + pb * ld;
                                result.c = pc * la + pd * lc;
                                result.d = pc * lb + pd * ld;
                                break;
                            }
                        case spine.BoneData.OnlyTranslation: 
                            {
                                var rotationY1 = boneData.rotation + 90 + boneData.shearY;
                                result.a = Spine.MathUtils.CosDeg(boneData.rotation + boneData.shearX) * boneData.scaleX;
                                result.b = Spine.MathUtils.CosDeg(rotationY1) * boneData.scaleY;
                                result.c = Spine.MathUtils.SinDeg(boneData.rotation + boneData.shearX) * boneData.scaleX;
                                result.d = Spine.MathUtils.SinDeg(rotationY1) * boneData.scaleY;
                                break;
                            }
                        case spine.BoneData.NoRotationOrReflection: 
                            {
                                var s = pa * pa + pc * pc, prx;
                                if (s > 0.0001) {
                                    s = Math.abs(pa * pd - pb * pc) / s;
                                    pb = pc * s;
                                    pd = pa * s;
                                    prx = Spine.MathUtils.Atan2(pc, pa) * Spine.MathUtils.RadDeg;
                                } else {
                                    pa = 0;
                                    pc = 0;
                                    prx = 90 - Spine.MathUtils.Atan2(pd, pb) * Spine.MathUtils.RadDeg;
                                }
                                var rx = boneData.rotation + boneData.shearX - prx;
                                var ry = boneData.rotation + boneData.shearY - prx + 90;
                                var la1 = Spine.MathUtils.CosDeg(rx) * boneData.scaleX;
                                var lb1 = Spine.MathUtils.CosDeg(ry) * boneData.scaleY;
                                var lc1 = Spine.MathUtils.SinDeg(rx) * boneData.scaleX;
                                var ld1 = Spine.MathUtils.SinDeg(ry) * boneData.scaleY;
                                result.a = pa * la1 - pb * lc1;
                                result.b = pa * lb1 - pb * ld1;
                                result.c = pc * la1 + pd * lc1;
                                result.d = pc * lb1 + pd * ld1;
                                break;
                            }
                        case spine.BoneData.NoScale: 
                        case spine.BoneData.NoScaleOrReflection: 
                            {
                                var cos = Spine.MathUtils.CosDeg(boneData.rotation), sin = Spine.MathUtils.SinDeg(boneData.rotation);
                                var za = pa * cos + pb * sin;
                                var zc = pc * cos + pd * sin;
                                var s1 = Math.sqrt(za * za + zc * zc);
                                if (s1 > 1E-05) {
                                    s1 = 1 / s1;
                                }
                                za *= s1;
                                zc *= s1;
                                s1 = Math.sqrt(za * za + zc * zc);
                                var r = 1.57079637 + Spine.MathUtils.Atan2(zc, za);
                                var zb = Spine.MathUtils.Cos(r) * s1;
                                var zd = Spine.MathUtils.Sin(r) * s1;
                                var la2 = Spine.MathUtils.CosDeg(boneData.shearX) * boneData.scaleX;
                                var lb2 = Spine.MathUtils.CosDeg(90 + boneData.shearY) * boneData.scaleY;
                                var lc2 = Spine.MathUtils.SinDeg(boneData.shearX) * boneData.scaleX;
                                var ld2 = Spine.MathUtils.SinDeg(90 + boneData.shearY) * boneData.scaleY;
                                if (boneData.transformMode !== spine.BoneData.NoScaleOrReflection ? pa * pd - pb * pc < 0 : false) {
                                    zb = -zb;
                                    zd = -zd;
                                }
                                result.a = za * la2 + zb * lc2;
                                result.b = za * lb2 + zb * ld2;
                                result.c = zc * la2 + zd * lc2;
                                result.d = zc * lb2 + zd * ld2;
                                break;
                            }
                    }

                    return result.$clone();
                },
                /*Spine.BoneMatrix.GetInheritedInternal:static end.*/

                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#getDefaultValue", this ); }
 return new Spine.BoneMatrix(); }
            }
        },
        fields: {
            a: 0,
            b: 0,
            c: 0,
            d: 0,
            x: 0,
            y: 0
        },
        ctors: {
            /**
             * Constructor for a local bone matrix based on Setup Pose BoneData.
             *
             * @instance
             * @public
             * @this Spine.BoneMatrix
             * @memberof Spine.BoneMatrix
             * @param   {spine.BoneData}    boneData
             * @return  {void}
             */
            $ctor2: function (boneData) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#$ctor2", this ); }

                this.$initialize();
                var rotationY = boneData.rotation + 90 + boneData.shearY;
                var rotationX = boneData.rotation + boneData.shearX;

                this.a = Spine.MathUtils.CosDeg(rotationX) * boneData.scaleX;
                this.c = Spine.MathUtils.SinDeg(rotationX) * boneData.scaleX;
                this.b = Spine.MathUtils.CosDeg(rotationY) * boneData.scaleY;
                this.d = Spine.MathUtils.SinDeg(rotationY) * boneData.scaleY;
                this.x = boneData.x;
                this.y = boneData.y;
            },
            /**
             * Constructor for a local bone matrix based on a bone instance's current pose.
             *
             * @instance
             * @public
             * @this Spine.BoneMatrix
             * @memberof Spine.BoneMatrix
             * @param   {Spine.Bone}    bone
             * @return  {void}
             */
            $ctor1: function (bone) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#$ctor1", this ); }

                this.$initialize();
                var rotationY = bone.rotation + 90 + bone.shearY;
                var rotationX = bone.rotation + bone.shearX;

                this.a = Spine.MathUtils.CosDeg(rotationX) * bone.scaleX;
                this.c = Spine.MathUtils.SinDeg(rotationX) * bone.scaleX;
                this.b = Spine.MathUtils.CosDeg(rotationY) * bone.scaleY;
                this.d = Spine.MathUtils.SinDeg(rotationY) * bone.scaleY;
                this.x = bone.x;
                this.y = bone.y;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.BoneMatrix.TransformMatrix start.*/
            TransformMatrix: function (local) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#TransformMatrix", this ); }

                var $t;
                return ($t = new Spine.BoneMatrix.ctor(), $t.a = this.a * local.a + this.b * local.c, $t.b = this.a * local.b + this.b * local.d, $t.c = this.c * local.a + this.d * local.c, $t.d = this.c * local.b + this.d * local.d, $t.x = this.a * local.x + this.b * local.y + this.x, $t.y = this.c * local.x + this.d * local.y + this.y, $t);
            },
            /*Spine.BoneMatrix.TransformMatrix end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#getHashCode", this ); }

                var h = Bridge.addHash([3621996792, this.a, this.b, this.c, this.d, this.x, this.y]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#equals", this ); }

                if (!Bridge.is(o, Spine.BoneMatrix)) {
                    return false;
                }
                return Bridge.equals(this.a, o.a) && Bridge.equals(this.b, o.b) && Bridge.equals(this.c, o.c) && Bridge.equals(this.d, o.d) && Bridge.equals(this.x, o.x) && Bridge.equals(this.y, o.y);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#$clone", this ); }

                var s = to || new Spine.BoneMatrix();
                s.a = this.a;
                s.b = this.b;
                s.c = this.c;
                s.d = this.d;
                s.x = this.x;
                s.y = this.y;
                return s;
            }
        }
    });
    /*Spine.BoneMatrix end.*/

    /*Spine.SpineSkeletonExtensions start.*/
    Bridge.define("Spine.SpineSkeletonExtensions", {
        statics: {
            methods: {
                /*Spine.SpineSkeletonExtensions.IsWeighted:static start.*/
                IsWeighted: function (va) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#IsWeighted", this ); }

                    return va.bones != null && va.bones.length > 0;
                },
                /*Spine.SpineSkeletonExtensions.IsWeighted:static end.*/

                /*Spine.SpineSkeletonExtensions.InheritsRotation:static start.*/
                InheritsRotation: function (mode) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#InheritsRotation", this ); }

                    var RotationBit = 0;
                    return (System.Int64(mode).and(System.Int64((1)))).equals(System.Int64(0));
                },
                /*Spine.SpineSkeletonExtensions.InheritsRotation:static end.*/

                /*Spine.SpineSkeletonExtensions.InheritsScale:static start.*/
                InheritsScale: function (mode) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#InheritsScale", this ); }

                    var ScaleBit = 1;
                    return (System.Int64(mode).and(System.Int64((2)))).equals(System.Int64(0));
                },
                /*Spine.SpineSkeletonExtensions.InheritsScale:static end.*/


            }
        }
    });
    /*Spine.SpineSkeletonExtensions end.*/

    /*Spine.Unity.ActivateBasedOnFlipDirection start.*/
    /** @namespace Spine.Unity */

    /**
     * Utility component to support flipping of 2D hinge chains (chains of HingeJoint2D objects) along
     with the parent skeleton by activating the respective mirrored versions of the hinge chain.
     Note: This component is automatically attached when calling "Create Hinge Chain 2D" at {@link },
     do not attempt to use this component for other purposes.
     *
     * @public
     * @class Spine.Unity.ActivateBasedOnFlipDirection
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.ActivateBasedOnFlipDirection", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonRenderer: null,
            skeletonGraphic: null,
            activeOnNormalX: null,
            activeOnFlippedX: null,
            jointsNormalX: null,
            jointsFlippedX: null,
            skeletonComponent: null,
            wasFlippedXBefore: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#init", this ); }

                this.wasFlippedXBefore = false;
            }
        },
        methods: {
            /*Spine.Unity.ActivateBasedOnFlipDirection.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#Start", this ); }

                this.jointsNormalX = this.activeOnNormalX.GetComponentsInChildren(UnityEngine.HingeJoint2D);
                this.jointsFlippedX = this.activeOnFlippedX.GetComponentsInChildren(UnityEngine.HingeJoint2D);
                this.skeletonComponent = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) ? Bridge.cast(this.skeletonRenderer, Spine.Unity.ISkeletonComponent) : Bridge.cast(this.skeletonGraphic, Spine.Unity.ISkeletonComponent);
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.Start end.*/

            /*Spine.Unity.ActivateBasedOnFlipDirection.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#FixedUpdate", this ); }

                var isFlippedX = (this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.scaleX < 0);
                if (isFlippedX !== this.wasFlippedXBefore) {
                    this.HandleFlip(isFlippedX);
                }
                this.wasFlippedXBefore = isFlippedX;
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.FixedUpdate end.*/

            /*Spine.Unity.ActivateBasedOnFlipDirection.HandleFlip start.*/
            HandleFlip: function (isFlippedX) {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#HandleFlip", this ); }

                var gameObjectToActivate = isFlippedX ? this.activeOnFlippedX : this.activeOnNormalX;
                var gameObjectToDeactivate = isFlippedX ? this.activeOnNormalX : this.activeOnFlippedX;

                gameObjectToActivate.SetActive(true);
                gameObjectToDeactivate.SetActive(false);

                this.ResetJointPositions(isFlippedX ? this.jointsFlippedX : this.jointsNormalX);
                this.ResetJointPositions(isFlippedX ? this.jointsNormalX : this.jointsFlippedX);
                this.CompensateMovementAfterFlipX(gameObjectToActivate.transform, gameObjectToDeactivate.transform);
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.HandleFlip end.*/

            /*Spine.Unity.ActivateBasedOnFlipDirection.ResetJointPositions start.*/
            ResetJointPositions: function (joints) {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#ResetJointPositions", this ); }

                for (var i = 0; i < joints.length; i = (i + 1) | 0) {
                    var joint = joints[i];
                    var parent = joint.connectedBody.transform;
                    joint.transform.position = parent.TransformPoint$1(UnityEngine.Vector3.FromVector2(joint.connectedAnchor));
                }
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.ResetJointPositions end.*/

            /*Spine.Unity.ActivateBasedOnFlipDirection.CompensateMovementAfterFlipX start.*/
            CompensateMovementAfterFlipX: function (toActivate, toDeactivate) {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#CompensateMovementAfterFlipX", this ); }

                var targetLocation = toDeactivate.GetChild(0);
                var currentLocation = toActivate.GetChild(0);
                toActivate.position = toActivate.position.$clone().add( targetLocation.position.$clone().sub( currentLocation.position ) );
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.CompensateMovementAfterFlipX end.*/


        }
    });
    /*Spine.Unity.ActivateBasedOnFlipDirection end.*/

    /*Spine.Unity.ISpineComponent start.*/
    Bridge.define("Spine.Unity.ISpineComponent", {
        $kind: 3
    });
    /*Spine.Unity.ISpineComponent end.*/

    /*Spine.Unity.AnimationTools.TimelineExtensions start.*/
    Bridge.define("Spine.Unity.AnimationTools.TimelineExtensions", {
        statics: {
            methods: {
                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1:static start.*/
                /**
                 * Evaluates the resulting value of a TranslateTimeline at a given time.
                 SkeletonData can be accessed from Skeleton.Data or from SkeletonDataAsset.GetSkeletonData.
                 If no SkeletonData is provided, values are returned as difference to setup pose
                 instead of absolute values.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {spine.TranslateTimeline}    timeline        
                 * @param   {number}                     time            
                 * @param   {Spine.SkeletonData}         skeletonData
                 * @return  {UnityEngine.Vector2}
                 */
                Evaluate$1: function (timeline, time, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#Evaluate$1", this ); }

                    var $t, $t1;
                    if (skeletonData === void 0) { skeletonData = null; }
                    if (time < ($t = timeline.frames)[0]) {
                        return pc.Vec2.ZERO.clone();
                    }

                    var x = { }, y = { };
                    timeline.getCurveValue(x, y, time);

                    if (skeletonData == null) {
                        return new pc.Vec2( x.v, y.v );
                    } else {
                        var boneData = ($t1 = skeletonData.Bones.Items)[timeline.boneIndex];
                        return new pc.Vec2( boneData.x + x.v, boneData.y + y.v );
                    }
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2:static start.*/
                /**
                 * Evaluates the resulting value of a pair of split translate timelines at a given time.
                 SkeletonData can be accessed from Skeleton.Data or from SkeletonDataAsset.GetSkeletonData.
                 If no SkeletonData is given, values are returned as difference to setup pose
                 instead of absolute values.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {spine.TranslateXTimeline}    xTimeline       
                 * @param   {spine.TranslateYTimeline}    yTimeline       
                 * @param   {number}                      time            
                 * @param   {Spine.SkeletonData}          skeletonData
                 * @return  {UnityEngine.Vector2}
                 */
                Evaluate$2: function (xTimeline, yTimeline, time, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#Evaluate$2", this ); }

                    var $t, $t1;
                    if (skeletonData === void 0) { skeletonData = null; }

                    var x = 0, y = 0;
                    if (xTimeline != null && time > ($t = xTimeline.frames)[0]) {
                        x = xTimeline.getCurveValue(time);
                    }
                    if (yTimeline != null && time > ($t1 = yTimeline.frames)[0]) {
                        y = yTimeline.getCurveValue(time);
                    }

                    if (skeletonData == null) {
                        return new pc.Vec2( x, y );
                    } else {
                        var bonesItems = skeletonData.Bones.Items;
                        var boneDataX = bonesItems[xTimeline.boneIndex];
                        var boneDataY = bonesItems[yTimeline.boneIndex];
                        return new pc.Vec2( boneDataX.x + x, boneDataY.y + y );
                    }
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate:static start.*/
                /**
                 * Evaluates the resulting value of a RotateTimeline at a given time.
                 SkeletonData can be accessed from Skeleton.Data or from SkeletonDataAsset.GetSkeletonData.
                 If no SkeletonData is given, values are returned as difference to setup pose
                 instead of absolute values.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {spine.RotateTimeline}    timeline        
                 * @param   {number}                  time            
                 * @param   {Spine.SkeletonData}      skeletonData
                 * @return  {number}
                 */
                Evaluate: function (timeline, time, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#Evaluate", this ); }

                    var $t, $t1;
                    if (skeletonData === void 0) { skeletonData = null; }
                    if (time < ($t = timeline.frames)[0]) {
                        return 0.0;
                    }

                    var rotation = timeline.getCurveValue(time);
                    if (skeletonData == null) {
                        return rotation;
                    } else {
                        var boneData = ($t1 = skeletonData.Bones.Items)[timeline.boneIndex];
                        return (boneData.rotation + rotation);
                    }
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.EvaluateTranslateXYMix:static start.*/
                /**
                 * Evaluates the resulting X and Y translate mix values of a
                 TransformConstraintTimeline at a given time.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {spine.TransformConstraintTimeline}    timeline    
                 * @param   {number}                               time
                 * @return  {UnityEngine.Vector2}
                 */
                EvaluateTranslateXYMix: function (timeline, time) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#EvaluateTranslateXYMix", this ); }

                    var $t;
                    if (time < ($t = timeline.frames)[0]) {
                        return pc.Vec2.ZERO.clone();
                    }

                    var rotate = { }, mixX = { }, mixY = { }, scaleX = { }, scaleY = { }, shearY = { };
                    timeline.getCurveValue(rotate, mixX, mixY, scaleX, scaleY, shearY, time);
                    return new pc.Vec2( mixX.v, mixY.v );
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.EvaluateTranslateXYMix:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.EvaluateRotateMix:static start.*/
                /**
                 * Evaluates the resulting rotate mix values of a
                 TransformConstraintTimeline at a given time.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {spine.TransformConstraintTimeline}    timeline    
                 * @param   {number}                               time
                 * @return  {number}
                 */
                EvaluateRotateMix: function (timeline, time) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#EvaluateRotateMix", this ); }

                    var $t;
                    if (time < ($t = timeline.frames)[0]) {
                        return 0;
                    }

                    var rotate = { }, mixX = { }, mixY = { }, scaleX = { }, scaleY = { }, shearY = { };
                    timeline.getCurveValue(rotate, mixX, mixY, scaleX, scaleY, shearY, time);
                    return rotate.v;
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.EvaluateRotateMix:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTranslateTimelineForBone:static start.*/
                /**
                 * Gets the translate timeline for a given boneIndex.
                 You can get the boneIndex using SkeletonData.FindBone().Index.
                 The root bone is always boneIndex 0.
                 This will return null if a TranslateTimeline is not found.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {Spine.Animation}            a            
                 * @param   {number}                     boneIndex
                 * @return  {spine.TranslateTimeline}
                 */
                FindTranslateTimelineForBone: function (a, boneIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#FindTranslateTimelineForBone", this ); }

                    var $t;
                    $t = Bridge.getEnumerator(a.Timelines);
                    try {
                        while ($t.moveNext()) {
                            var timeline = $t.Current;
                            if ((Bridge.getType(timeline).prototype instanceof spine.TranslateTimeline)) {
                                continue;
                            }

                            var translateTimeline = Bridge.as(timeline, spine.TranslateTimeline);
                            if (translateTimeline != null && translateTimeline.boneIndex === boneIndex) {
                                return translateTimeline;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return null;
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTranslateTimelineForBone:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone:static start.*/
                /**
                 * Gets the IBoneTimeline timeline of a given type for a given boneIndex.
                 You can get the boneIndex using SkeletonData.FindBoneIndex.
                 The root bone is always boneIndex 0.
                 This will return null if a timeline of the given type is not found.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {Function}           T            
                 * @param   {Spine.Animation}    a            
                 * @param   {number}             boneIndex
                 * @return  {T}
                 */
                FindTimelineForBone: function (T, a, boneIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#FindTimelineForBone", this ); }

                    var $t;
                    $t = Bridge.getEnumerator(a.Timelines);
                    try {
                        while ($t.moveNext()) {
                            var timeline = $t.Current;
                            var translateTimeline = Bridge.as(timeline, T);
                            if (Bridge.rValue(translateTimeline) != null && Bridge.rValue(translateTimeline).Spine$IBoneTimeline$BoneIndex === boneIndex) {
                                return Bridge.rValue(translateTimeline);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return null;
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTransformConstraintTimeline:static start.*/
                /**
                 * Gets the transform constraint timeline for a given boneIndex.
                 You can get the boneIndex using SkeletonData.FindBone().Index.
                 The root bone is always boneIndex 0.
                 This will return null if a TranslateTimeline is not found.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {Spine.Animation}                      a                           
                 * @param   {number}                               transformConstraintIndex
                 * @return  {spine.TransformConstraintTimeline}
                 */
                FindTransformConstraintTimeline: function (a, transformConstraintIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#FindTransformConstraintTimeline", this ); }

                    var $t;
                    $t = Bridge.getEnumerator(a.Timelines);
                    try {
                        while ($t.moveNext()) {
                            var timeline = $t.Current;
                            if ((Bridge.getType(timeline).prototype instanceof spine.TransformConstraintTimeline)) {
                                continue;
                            }

                            var transformConstraintTimeline = Bridge.as(timeline, spine.TransformConstraintTimeline);
                            if (transformConstraintTimeline != null && transformConstraintTimeline.transformConstraintIndex === transformConstraintIndex) {
                                return transformConstraintTimeline;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return null;
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTransformConstraintTimeline:static end.*/


            }
        }
    });
    /*Spine.Unity.AnimationTools.TimelineExtensions end.*/

    /*Spine.Unity.AtlasAssetBase start.*/
    Bridge.define("Spine.Unity.AtlasAssetBase", {
        inherits: [UnityEngine.ScriptableObject],
        fields: {
            textureLoadingMode: 0,
            onDemandTextureLoader: null
        },
        props: {
            TextureLoadingMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AtlasAssetBase#TextureLoadingMode#get", this ); }

                    return this.textureLoadingMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.AtlasAssetBase#TextureLoadingMode#set", this ); }

                    this.textureLoadingMode = value;
                }
            },
            OnDemandTextureLoader: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AtlasAssetBase#OnDemandTextureLoader#get", this ); }

                    return this.onDemandTextureLoader;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.AtlasAssetBase#OnDemandTextureLoader#set", this ); }

                    this.onDemandTextureLoader = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AtlasAssetBase#init", this ); }

                this.textureLoadingMode = Spine.Unity.AtlasAssetBase.LoadingMode.Normal;
            }
        },
        methods: {
            /*Spine.Unity.AtlasAssetBase.BeginCustomTextureLoading start.*/
            BeginCustomTextureLoading: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AtlasAssetBase#BeginCustomTextureLoading", this ); }

                if (UnityEngine.Object.op_Implicit(this.onDemandTextureLoader)) {
                    this.onDemandTextureLoader.BeginCustomTextureLoading();
                }
            },
            /*Spine.Unity.AtlasAssetBase.BeginCustomTextureLoading end.*/

            /*Spine.Unity.AtlasAssetBase.EndCustomTextureLoading start.*/
            EndCustomTextureLoading: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AtlasAssetBase#EndCustomTextureLoading", this ); }

                if (UnityEngine.Object.op_Implicit(this.onDemandTextureLoader)) {
                    this.onDemandTextureLoader.EndCustomTextureLoading();
                }
            },
            /*Spine.Unity.AtlasAssetBase.EndCustomTextureLoading end.*/

            /*Spine.Unity.AtlasAssetBase.RequireTexturesLoaded start.*/
            RequireTexturesLoaded: function (material, overrideMaterial) {
if ( TRACE ) { TRACE( "Spine.Unity.AtlasAssetBase#RequireTexturesLoaded", this ); }

                if (UnityEngine.Object.op_Implicit(this.onDemandTextureLoader)) {
                    this.onDemandTextureLoader.RequestLoadMaterialTextures(material, overrideMaterial);
                }
            },
            /*Spine.Unity.AtlasAssetBase.RequireTexturesLoaded end.*/

            /*Spine.Unity.AtlasAssetBase.RequireTextureLoaded start.*/
            RequireTextureLoaded: function (placeholderTexture, replacementTexture, onTextureLoaded) {
if ( TRACE ) { TRACE( "Spine.Unity.AtlasAssetBase#RequireTextureLoaded", this ); }

                if (UnityEngine.Object.op_Implicit(this.onDemandTextureLoader)) {
                    this.onDemandTextureLoader.RequestLoadTexture(placeholderTexture, replacementTexture, onTextureLoaded);
                }
            },
            /*Spine.Unity.AtlasAssetBase.RequireTextureLoaded end.*/


        }
    });
    /*Spine.Unity.AtlasAssetBase end.*/

    /*Spine.Unity.AtlasAssetBase+LoadingMode start.*/
    Bridge.define("Spine.Unity.AtlasAssetBase.LoadingMode", {
        $kind: 1006,
        statics: {
            fields: {
                Normal: 0,
                OnDemand: 1
            }
        }
    });
    /*Spine.Unity.AtlasAssetBase+LoadingMode end.*/

    /*Spine.Unity.AttachmentTools.AtlasUtilities start.*/
    Bridge.define("Spine.Unity.AttachmentTools.AtlasUtilities", {
        statics: {
            fields: {
                SpineTextureFormat: 0,
                DefaultMipmapBias: 0,
                UseMipMaps: false,
                DefaultScale: 0,
                NonrenderingRegion: 0,
                existingRegions: null,
                regionIndices: null,
                originalRegions: null,
                repackedRegions: null,
                texturesToPackAtParam: null,
                inoutAttachments: null,
                CachedRegionTextures: null,
                CachedRegionTexturesList: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#init", this ); }

                    this.SpineTextureFormat = UnityEngine.TextureFormat.RGBA32;
                    this.DefaultMipmapBias = -0.5;
                    this.UseMipMaps = false;
                    this.DefaultScale = 0.01;
                    this.NonrenderingRegion = -1;
                    this.existingRegions = new (System.Collections.Generic.Dictionary$2(Spine.AtlasRegion,System.Int32)).ctor();
                    this.regionIndices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                    this.originalRegions = new (System.Collections.Generic.List$1(Spine.AtlasRegion)).ctor();
                    this.repackedRegions = new (System.Collections.Generic.List$1(Spine.AtlasRegion)).ctor();
                    this.texturesToPackAtParam = System.Array.init(1, null, System.Collections.Generic.List$1(UnityEngine.Texture2D));
                    this.inoutAttachments = new (System.Collections.Generic.List$1(spine.Attachment)).ctor();
                    this.CachedRegionTextures = new (System.Collections.Generic.Dictionary$2(Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey,UnityEngine.Texture2D)).ctor();
                    this.CachedRegionTexturesList = new (System.Collections.Generic.List$1(UnityEngine.Texture2D)).ctor();
                }
            },
            methods: {
                /*Spine.Unity.AttachmentTools.AtlasUtilities.Init:static start.*/
                Init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#Init", this ); }

                    // handle disabled domain reload
                    Spine.Unity.AttachmentTools.AtlasUtilities.ClearCache();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.Init:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$2:static start.*/
                ToAtlasRegion$2: function (t, materialPropertySource, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$2", this ); }

                    if (scale === void 0) { scale = 0.01; }
                    return Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$3(t, materialPropertySource.shader, scale, materialPropertySource);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$2:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$3:static start.*/
                ToAtlasRegion$3: function (t, shader, scale, materialPropertySource) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$3", this ); }

                    if (scale === void 0) { scale = 0.01; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    var material = new UnityEngine.Material.$ctor2(shader);
                    if (materialPropertySource != null) {
                        material.CopyPropertiesFromMaterial(materialPropertySource);
                        material.shaderKeywords = materialPropertySource.shaderKeywords;
                    }

                    material.mainTexture = t;
                    var page = Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(material);

                    var width = t.width;
                    var height = t.height;

                    var region = new Spine.AtlasRegion();
                    region.name = t.name;

                    // World space units
                    var boundsMin = pc.Vec2.ZERO.clone(), boundsMax = new pc.Vec2( width, height ).scale( scale );

                    // Texture space/pixel units
                    region.width = Bridge.Int.clip32(width);
                    region.originalWidth = Bridge.Int.clip32(width);
                    region.height = Bridge.Int.clip32(height);
                    region.originalHeight = Bridge.Int.clip32(height);
                    region.offsetX = width * (0.5 - Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp(boundsMin.x, boundsMax.x, 0));
                    region.offsetY = height * (0.5 - Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp(boundsMin.y, boundsMax.y, 0));

                    // Use the full area of the texture.
                    region.u = 0;
                    region.v = 1;
                    region.u2 = 1;
                    region.v2 = 0;
                    region.x = 0;
                    region.y = 0;

                    region.page = page;

                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$3:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion:static start.*/
                /**
                 * Creates a Spine.AtlasRegion from a UnityEngine.Sprite.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Sprite}    s       
                 * @param   {Spine.AtlasPage}       page
                 * @return  {Spine.AtlasRegion}
                 */
                ToAtlasRegion: function (s, page) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion", this ); }

                    if (page == null) {
                        throw new System.ArgumentNullException.$ctor3("page", "page cannot be null. AtlasPage determines which texture region belongs and how it should be rendered. You can use material.ToSpineAtlasPage() to get a shareable AtlasPage from a Material, or use the sprite.ToAtlasRegion(material) overload.");
                    }
                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$4(s);
                    region.page = page;
                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$1:static start.*/
                /**
                 * Creates a Spine.AtlasRegion from a UnityEngine.Sprite. This creates a new AtlasPage object for every AtlasRegion you create. You can centralize Material control by creating a shared atlas page using Material.ToSpineAtlasPage and using the sprite.ToAtlasRegion(AtlasPage) overload.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Sprite}      s           
                 * @param   {UnityEngine.Material}    material
                 * @return  {Spine.AtlasRegion}
                 */
                ToAtlasRegion$1: function (s, material) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$1", this ); }

                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$4(s);
                    region.page = Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(material);
                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$4:static start.*/
                ToAtlasRegion$4: function (s, isolatedTexture) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$4", this ); }

                    if (isolatedTexture === void 0) { isolatedTexture = false; }
                    var region = new Spine.AtlasRegion();
                    region.name = s.name;
                    region.index = -1;
                    region.degrees = s.packed && s.packingRotation !== UnityEngine.SpritePackingRotation.None ? 90 : 0;

                    // World space units
                    var bounds = s.bounds;
                    var boundsMin = UnityEngine.Vector2.FromVector3(bounds.min.$clone()), boundsMax = UnityEngine.Vector2.FromVector3(bounds.max.$clone());

                    // Texture space/pixel units
                    var spineRect = Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect(s.textureRect, s.texture.height);
                    var originalRect = s.rect.$clone();
                    region.width = Bridge.Int.clip32(spineRect.width);
                    region.originalWidth = Bridge.Int.clip32(originalRect.width);
                    region.height = Bridge.Int.clip32(spineRect.height);
                    region.originalHeight = Bridge.Int.clip32(originalRect.height);
                    region.offsetX = s.textureRectOffset.x + spineRect.width * (0.5 - Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp(boundsMin.x, boundsMax.x, 0));
                    region.offsetY = s.textureRectOffset.y + spineRect.height * (0.5 - Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp(boundsMin.y, boundsMax.y, 0));

                    if (isolatedTexture) {
                        region.u = 0;
                        region.v = 1;
                        region.u2 = 1;
                        region.v2 = 0;
                        region.x = 0;
                        region.y = 0;
                    } else {
                        var tex = s.texture;
                        var uvRect = Spine.Unity.AttachmentTools.AtlasUtilities.TextureRectToUVRect(s.textureRect.$clone(), tex.width, tex.height);
                        region.u = uvRect.xMin;
                        region.v = uvRect.yMax;
                        region.u2 = uvRect.xMax;
                        region.v2 = uvRect.yMin;
                        region.x = Bridge.Int.clip32(spineRect.x);
                        region.y = Bridge.Int.clip32(spineRect.y);
                    }

                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$4:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$2:static start.*/
                /**
                 * Creates a Spine.AtlasRegion that uses a premultiplied alpha duplicate of the Sprite's texture data.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Texture2D}        t                         
                 * @param   {UnityEngine.Material}         materialPropertySource    
                 * @param   {UnityEngine.TextureFormat}    textureFormat             
                 * @param   {boolean}                      mipmaps
                 * @return  {Spine.AtlasRegion}
                 */
                ToAtlasRegionPMAClone$2: function (t, materialPropertySource, textureFormat, mipmaps) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone$2", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    return Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$3(t, materialPropertySource.shader, textureFormat, mipmaps, materialPropertySource);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$2:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$3:static start.*/
                /**
                 * Creates a Spine.AtlasRegion that uses a premultiplied alpha duplicate of the Sprite's texture data.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Texture2D}        t                         
                 * @param   {UnityEngine.Shader}           shader                    
                 * @param   {UnityEngine.TextureFormat}    textureFormat             
                 * @param   {boolean}                      mipmaps                   
                 * @param   {UnityEngine.Material}         materialPropertySource
                 * @return  {Spine.AtlasRegion}
                 */
                ToAtlasRegionPMAClone$3: function (t, shader, textureFormat, mipmaps, materialPropertySource) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone$3", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    var material = new UnityEngine.Material.$ctor2(shader);
                    if (materialPropertySource != null) {
                        material.CopyPropertiesFromMaterial(materialPropertySource);
                        material.shaderKeywords = materialPropertySource.shaderKeywords;
                    }
                    var newTexture = Spine.Unity.AttachmentTools.AtlasUtilities.GetClone(t, textureFormat, mipmaps, false, true);

                    newTexture.name = (t.name || "") + "-pma-";
                    material.name = (t.name || "") + (shader.name || "");

                    material.mainTexture = newTexture;
                    var page = Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(material);

                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$3(newTexture, shader);
                    region.page = page;

                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$3:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone:static start.*/
                ToAtlasRegionPMAClone: function (s, materialPropertySource, textureFormat, mipmaps) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    return Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$1(s, materialPropertySource.shader, textureFormat, mipmaps, materialPropertySource);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$1:static start.*/
                /**
                 * Creates a Spine.AtlasRegion that uses a premultiplied alpha duplicate of the Sprite's texture data.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Sprite}           s                         
                 * @param   {UnityEngine.Shader}           shader                    
                 * @param   {UnityEngine.TextureFormat}    textureFormat             
                 * @param   {boolean}                      mipmaps                   
                 * @param   {UnityEngine.Material}         materialPropertySource
                 * @return  {Spine.AtlasRegion}
                 */
                ToAtlasRegionPMAClone$1: function (s, shader, textureFormat, mipmaps, materialPropertySource) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone$1", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    var material = new UnityEngine.Material.$ctor2(shader);
                    if (materialPropertySource != null) {
                        material.CopyPropertiesFromMaterial(materialPropertySource);
                        material.shaderKeywords = materialPropertySource.shaderKeywords;
                    }

                    var tex = Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture$1(s, textureFormat, mipmaps, false, true);
                    tex.name = (s.name || "") + "-pma-";
                    material.name = (tex.name || "") + (shader.name || "");

                    material.mainTexture = tex;
                    var page = Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(material);

                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$4(s, true);
                    region.page = page;

                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage:static start.*/
                /**
                 * Creates a new Spine.AtlasPage from a UnityEngine.Material. If the material has a preassigned texture, the page width and height will be set.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Material}    m
                 * @return  {Spine.AtlasPage}
                 */
                ToSpineAtlasPage: function (m) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToSpineAtlasPage", this ); }

                    var $t;
                    var newPage = ($t = new Spine.AtlasPage(), $t.rendererObject = m, $t.name = m.name, $t);

                    var t = m.mainTexture;
                    if (t != null) {
                        newPage.width = t.width;
                        newPage.height = t.height;
                    }

                    return newPage;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedAttachments:static start.*/
                /**
                 * Fills the outputAttachments list with new attachment objects based on the attachments in sourceAttachments,
                 but mapped to a new single texture using the same material.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {System.Collections.Generic.List$1}    sourceAttachments                     The list of attachments to be repacked.
                 * @param   {System.Collections.Generic.List$1}    outputAttachments                     The List(Attachment) to populate with the newly created Attachment objects.
                 May be equal to <pre><code>sourceAttachments</code></pre> for in-place operation.
                 * @param   {UnityEngine.Material}                 materialPropertySource                May be null. If no Material property source is provided, a material with
                 default parameters using the provided <pre><code>shader</code></pre> will be created.
                 * @param   {UnityEngine.Material}                 outputMaterial                        
                 * @param   {UnityEngine.Texture2D}                outputTexture                         
                 * @param   {number}                               maxAtlasSize                          
                 * @param   {number}                               padding                               
                 * @param   {UnityEngine.TextureFormat}            textureFormat                         
                 * @param   {boolean}                              mipmaps                               
                 * @param   {string}                               newAssetName                          
                 * @param   {boolean}                              clearCache                            When set to <pre><code>true</code></pre>, {@link } is called after
                 repacking to clear the texture cache. See remarks for additional info.
                 * @param   {boolean}                              useOriginalNonrenderables             
                 * @param   {Array.<number>}                       additionalTexturePropertyIDsToCopy    Optional additional textures (such as normal maps) to copy while repacking.
                 To copy e.g. the main texture and normal maps, pass 'new int[] { Shader.PropertyToID("_BumpMap") }' at this parameter.
                 * @param   {Array.<UnityEngine.Texture2D>}        additionalOutputTextures              When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be filled with the resulting repacked texture for every property,
                 just as the main repacked texture is assigned to <pre><code>outputTexture</code></pre>.
                 * @param   {Array.<UnityEngine.TextureFormat>}    additionalTextureFormats              When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be used as <pre><code>TextureFormat</code></pre> at the Texture at the respective property.
                 When <pre><code>additionalTextureFormats</code></pre> is <pre><code>null</code></pre> or when its array size is smaller,
                 <pre><code>textureFormat</code></pre> is used where there exists no corresponding array item.
                 * @param   {Array.<boolean>}                      additionalTextureIsLinear             When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be used to determine whether <pre><code>linear</code></pre> or <pre><code>sRGB</code></pre> color space is used at the
                 Texture at the respective property. When <pre><code>additionalTextureIsLinear</code></pre> is <pre><code>null</code></pre>, <pre><code>linear</code></pre> color space
                 is assumed at every additional Texture element.
                 When e.g. packing the main texture and normal maps, pass 'new bool[] { true }' at this parameter, because normal maps use
                 linear color space.
                 * @return  {void}
                 */
                GetRepackedAttachments: function (sourceAttachments, outputAttachments, materialPropertySource, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, newAssetName, clearCache, useOriginalNonrenderables, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedAttachments", this ); }

                    if (maxAtlasSize === void 0) { maxAtlasSize = 1024; }
                    if (padding === void 0) { padding = 2; }
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (newAssetName === void 0) { newAssetName = "Repacked Attachments"; }
                    if (clearCache === void 0) { clearCache = false; }
                    if (useOriginalNonrenderables === void 0) { useOriginalNonrenderables = true; }
                    if (additionalTexturePropertyIDsToCopy === void 0) { additionalTexturePropertyIDsToCopy = null; }
                    if (additionalOutputTextures === void 0) { additionalOutputTextures = null; }
                    if (additionalTextureFormats === void 0) { additionalTextureFormats = null; }
                    if (additionalTextureIsLinear === void 0) { additionalTextureIsLinear = null; }

                    var shader = materialPropertySource == null ? UnityEngine.Shader.Find("Spine/Skeleton") : materialPropertySource.shader;
                    Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedAttachments$1(sourceAttachments, outputAttachments, shader, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, newAssetName, materialPropertySource, clearCache, useOriginalNonrenderables, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedAttachments:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedAttachments$1:static start.*/
                /**
                 * Fills the outputAttachments list with new attachment objects based on the attachments in sourceAttachments,
                 but mapped to a new single texture using the same material.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {System.Collections.Generic.List$1}    sourceAttachments                     The list of attachments to be repacked.
                 * @param   {System.Collections.Generic.List$1}    outputAttachments                     The List(Attachment) to populate with the newly created Attachment objects.
                 May be equal to <pre><code>sourceAttachments</code></pre> for in-place operation.
                 * @param   {UnityEngine.Shader}                   shader                                
                 * @param   {UnityEngine.Material}                 outputMaterial                        
                 * @param   {UnityEngine.Texture2D}                outputTexture                         
                 * @param   {number}                               maxAtlasSize                          
                 * @param   {number}                               padding                               
                 * @param   {UnityEngine.TextureFormat}            textureFormat                         
                 * @param   {boolean}                              mipmaps                               
                 * @param   {string}                               newAssetName                          
                 * @param   {UnityEngine.Material}                 materialPropertySource                May be null. If no Material property source is provided, a material with
                 default parameters using the provided <pre><code>shader</code></pre> will be created.
                 * @param   {boolean}                              clearCache                            
                 * @param   {boolean}                              useOriginalNonrenderables             
                 * @param   {Array.<number>}                       additionalTexturePropertyIDsToCopy    Optional additional textures (such as normal maps) to copy while repacking.
                 To copy e.g. the main texture and normal maps, pass 'new int[] { Shader.PropertyToID("_BumpMap") }' at this parameter.
                 * @param   {Array.<UnityEngine.Texture2D>}        additionalOutputTextures              When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be filled with the resulting repacked texture for every property,
                 just as the main repacked texture is assigned to <pre><code>outputTexture</code></pre>.
                 * @param   {Array.<UnityEngine.TextureFormat>}    additionalTextureFormats              When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be used as <pre><code>TextureFormat</code></pre> at the Texture at the respective property.
                 When <pre><code>additionalTextureFormats</code></pre> is <pre><code>null</code></pre> or when its array size is smaller,
                 <pre><code>textureFormat</code></pre> is used where there exists no corresponding array item.
                 * @param   {Array.<boolean>}                      additionalTextureIsLinear             When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be used to determine whether <pre><code>linear</code></pre> or <pre><code>sRGB</code></pre> color space is used at the
                 Texture at the respective property. When <pre><code>additionalTextureIsLinear</code></pre> is <pre><code>null</code></pre>, <pre><code>linear</code></pre> color space
                 is assumed at every additional Texture element.
                 When e.g. packing the main texture and normal maps, pass 'new bool[] { true }' at this parameter, because normal maps use
                 linear color space.
                 * @return  {void}
                 */
                GetRepackedAttachments$1: function (sourceAttachments, outputAttachments, shader, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, newAssetName, materialPropertySource, clearCache, useOriginalNonrenderables, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedAttachments$1", this ); }

                    if (maxAtlasSize === void 0) { maxAtlasSize = 1024; }
                    if (padding === void 0) { padding = 2; }
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (newAssetName === void 0) { newAssetName = "Repacked Attachments"; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    if (clearCache === void 0) { clearCache = false; }
                    if (useOriginalNonrenderables === void 0) { useOriginalNonrenderables = true; }
                    if (additionalTexturePropertyIDsToCopy === void 0) { additionalTexturePropertyIDsToCopy = null; }
                    if (additionalOutputTextures === void 0) { additionalOutputTextures = null; }
                    if (additionalTextureFormats === void 0) { additionalTextureFormats = null; }
                    if (additionalTextureIsLinear === void 0) { additionalTextureIsLinear = null; }

                    if (sourceAttachments == null) {
                        throw new System.ArgumentNullException.$ctor1("sourceAttachments");
                    }
                    if (outputAttachments == null) {
                        throw new System.ArgumentNullException.$ctor1("outputAttachments");
                    }
                    outputTexture.v = null;
                    if (additionalTexturePropertyIDsToCopy != null && additionalTextureIsLinear == null) {
                        additionalTextureIsLinear = System.Array.init(additionalTexturePropertyIDsToCopy.length, false, System.Boolean);
                        for (var i = 0; i < additionalTextureIsLinear.length; i = (i + 1) | 0) {
                            additionalTextureIsLinear[i] = true;
                        }
                    }

                    // Use these to detect and use shared regions.
                    Spine.Unity.AttachmentTools.AtlasUtilities.existingRegions.clear();
                    Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.clear();

                    // Collect all textures from original attachments.
                    var numTextureParamsToRepack = (1 + (additionalTexturePropertyIDsToCopy == null ? 0 : additionalTexturePropertyIDsToCopy.length)) | 0;
                    additionalOutputTextures = (additionalTexturePropertyIDsToCopy == null ? null : System.Array.init(additionalTexturePropertyIDsToCopy.length, null, UnityEngine.Texture2D));
                    if (Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam.length < numTextureParamsToRepack) {
                        System.Array.resize(Bridge.ref(Spine.Unity.AttachmentTools.AtlasUtilities, "texturesToPackAtParam"), numTextureParamsToRepack, null, System.Collections.Generic.List$1(UnityEngine.Texture2D));
                    }
                    for (var i1 = 0; i1 < numTextureParamsToRepack; i1 = (i1 + 1) | 0) {
                        if (Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam[i1] != null) {
                            Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam[i1].clear();
                        } else {
                            Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam[i1] = new (System.Collections.Generic.List$1(UnityEngine.Texture2D)).ctor();
                        }
                    }
                    Spine.Unity.AttachmentTools.AtlasUtilities.originalRegions.clear();

                    if (!Bridge.referenceEquals(sourceAttachments, outputAttachments)) {
                        outputAttachments.clear();
                        outputAttachments.AddRange(sourceAttachments);
                    }

                    var newRegionIndex = 0;
                    for (var attachmentIndex = 0, n = sourceAttachments.Count; attachmentIndex < n; attachmentIndex = (attachmentIndex + 1) | 0) {
                        var originalAttachment = sourceAttachments.getItem(attachmentIndex);

                        if (Bridge.is(originalAttachment, Spine.IHasTextureRegion)) {
                            var originalMeshAttachment = Bridge.as(originalAttachment, Spine.MeshAttachment);
                            var newAttachment = (originalMeshAttachment != null) ? originalMeshAttachment.newLinkedMesh() : originalAttachment.copy();
                            var region = Bridge.as(Bridge.cast(newAttachment, Spine.IHasTextureRegion).Spine$IHasTextureRegion$Region, Spine.AtlasRegion);
                            var existingIndex = { };
                            if (Spine.Unity.AttachmentTools.AtlasUtilities.existingRegions.tryGetValue(region, existingIndex)) {
                                Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.add(existingIndex.v);
                            } else {
                                Spine.Unity.AttachmentTools.AtlasUtilities.originalRegions.add(region);
                                for (var i2 = 0; i2 < numTextureParamsToRepack; i2 = (i2 + 1) | 0) {
                                    var regionTexture = (i2 === 0 ? Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture(region, textureFormat, mipmaps) : Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture(region, (additionalTextureFormats != null && ((i2 - 1) | 0) < additionalTextureFormats.length) ? additionalTextureFormats[((i2 - 1) | 0)] : textureFormat, mipmaps, additionalTexturePropertyIDsToCopy[((i2 - 1) | 0)], additionalTextureIsLinear[((i2 - 1) | 0)]));
                                    Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam[i2].add(regionTexture);
                                }

                                Spine.Unity.AttachmentTools.AtlasUtilities.existingRegions.add(region, newRegionIndex);
                                Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.add(newRegionIndex);
                                newRegionIndex = (newRegionIndex + 1) | 0;
                            }

                            outputAttachments.setItem(attachmentIndex, newAttachment);
                        } else {
                            outputAttachments.setItem(attachmentIndex, useOriginalNonrenderables ? originalAttachment : originalAttachment.copy());
                            Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.add(Spine.Unity.AttachmentTools.AtlasUtilities.NonrenderingRegion); // Output attachments pairs with regionIndices list 1:1. Pad with a sentinel if the attachment doesn't have a region.
                        }
                    }

                    // Rehydrate the repacked textures as a Material, Spine atlas and Spine.AtlasAttachments
                    var newMaterial = new UnityEngine.Material.$ctor2(shader);
                    if (materialPropertySource != null) {
                        newMaterial.CopyPropertiesFromMaterial(materialPropertySource);
                        newMaterial.shaderKeywords = materialPropertySource.shaderKeywords;
                    }
                    newMaterial.name = newAssetName;

                    var rects = null;
                    for (var i3 = 0; i3 < numTextureParamsToRepack; i3 = (i3 + 1) | 0) {
                        // Fill a new texture with the collected attachment textures.
                        var newTexture = new UnityEngine.Texture2D.$ctor12(maxAtlasSize, maxAtlasSize, (i3 > 0 && additionalTextureFormats != null && ((i3 - 1) | 0) < additionalTextureFormats.length) ? additionalTextureFormats[((i3 - 1) | 0)] : textureFormat, mipmaps, (i3 > 0) ? additionalTextureIsLinear[((i3 - 1) | 0)] : false);
                        newTexture.mipMapBias = Spine.Unity.AttachmentTools.AtlasUtilities.DefaultMipmapBias;

                        var texturesToPack = Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam[i3];
                        if (texturesToPack.Count > 0) {
                            var sourceTexture = texturesToPack.getItem(0);
                            Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom(newTexture, sourceTexture);
                        }
                        newTexture.name = newAssetName;
                        var rectsForTexParam = newTexture.PackTextures(texturesToPack.ToArray(), padding, maxAtlasSize);
                        if (i3 === 0) {
                            rects = rectsForTexParam;
                            newMaterial.mainTexture = newTexture;
                            outputTexture.v = newTexture;
                        } else {
                            newMaterial.SetTexture(additionalTexturePropertyIDsToCopy[((i3 - 1) | 0)], newTexture);
                            additionalOutputTextures[((i3 - 1) | 0)] = newTexture;
                        }
                    }

                    var page = Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(newMaterial);
                    page.name = newAssetName;

                    Spine.Unity.AttachmentTools.AtlasUtilities.repackedRegions.clear();
                    for (var i4 = 0, n1 = Spine.Unity.AttachmentTools.AtlasUtilities.originalRegions.Count; i4 < n1; i4 = (i4 + 1) | 0) {
                        var oldRegion = Spine.Unity.AttachmentTools.AtlasUtilities.originalRegions.getItem(i4);
                        var newRegion = Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToAtlasRegion(rects[i4], oldRegion, page);
                        Spine.Unity.AttachmentTools.AtlasUtilities.repackedRegions.add(newRegion);
                    }

                    // Map the cloned attachments to the repacked atlas.
                    for (var i5 = 0, n2 = outputAttachments.Count; i5 < n2; i5 = (i5 + 1) | 0) {
                        var attachment = outputAttachments.getItem(i5);
                        var iHasRegion = Bridge.as(attachment, Spine.IHasTextureRegion);
                        if (iHasRegion != null) {
                            iHasRegion.Spine$IHasTextureRegion$Region = Spine.Unity.AttachmentTools.AtlasUtilities.repackedRegions.getItem(Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.getItem(i5));
                            iHasRegion.Spine$IHasTextureRegion$UpdateRegion();
                        }
                    }

                    // Clean up.
                    if (clearCache) {
                        Spine.Unity.AttachmentTools.AtlasUtilities.ClearCache();
                    }

                    outputMaterial.v = newMaterial;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedAttachments$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedSkin:static start.*/
                /**
                 * Creates and populates a duplicate skin with cloned attachments that are backed by a new packed texture atlas
                 comprised of all the regions from the original skin.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.Skin}                           o                                     
                 * @param   {string}                               newName                               
                 * @param   {UnityEngine.Material}                 materialPropertySource                
                 * @param   {UnityEngine.Material}                 outputMaterial                        
                 * @param   {UnityEngine.Texture2D}                outputTexture                         
                 * @param   {number}                               maxAtlasSize                          
                 * @param   {number}                               padding                               
                 * @param   {UnityEngine.TextureFormat}            textureFormat                         
                 * @param   {boolean}                              mipmaps                               
                 * @param   {boolean}                              useOriginalNonrenderables             
                 * @param   {boolean}                              clearCache                            When set to <pre><code>true</code></pre>, {@link } is called after
                 repacking to clear the texture cache. See remarks for additional info.
                 * @param   {Array.<number>}                       additionalTexturePropertyIDsToCopy    Optional additional textures (such as normal maps) to copy while repacking.
                 To copy e.g. the main texture and normal maps, pass 'new int[] { Shader.PropertyToID("_BumpMap") }' at this parameter.
                 * @param   {Array.<UnityEngine.Texture2D>}        additionalOutputTextures              When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be filled with the resulting repacked texture for every property,
                 just as the main repacked texture is assigned to <pre><code>outputTexture</code></pre>.
                 * @param   {Array.<UnityEngine.TextureFormat>}    additionalTextureFormats              When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be used as <pre><code>TextureFormat</code></pre> at the Texture at the respective property.
                 When <pre><code>additionalTextureFormats</code></pre> is <pre><code>null</code></pre> or when its array size is smaller,
                 <pre><code>textureFormat</code></pre> is used where there exists no corresponding array item.
                 * @param   {Array.<boolean>}                      additionalTextureIsLinear             When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be used to determine whether <pre><code>linear</code></pre> or <pre><code>sRGB</code></pre> color space is used at the
                 Texture at the respective property. When <pre><code>additionalTextureIsLinear</code></pre> is <pre><code>null</code></pre>, <pre><code>linear</code></pre> color space
                 is assumed at every additional Texture element.
                 When e.g. packing the main texture and normal maps, pass 'new bool[] { true }' at this parameter, because normal maps use
                 linear color space.
                 * @return  {Spine.Skin}
                 */
                GetRepackedSkin: function (o, newName, materialPropertySource, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, useOriginalNonrenderables, clearCache, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedSkin", this ); }

                    if (maxAtlasSize === void 0) { maxAtlasSize = 1024; }
                    if (padding === void 0) { padding = 2; }
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (useOriginalNonrenderables === void 0) { useOriginalNonrenderables = true; }
                    if (clearCache === void 0) { clearCache = false; }
                    if (additionalTexturePropertyIDsToCopy === void 0) { additionalTexturePropertyIDsToCopy = null; }
                    if (additionalOutputTextures === void 0) { additionalOutputTextures = null; }
                    if (additionalTextureFormats === void 0) { additionalTextureFormats = null; }
                    if (additionalTextureIsLinear === void 0) { additionalTextureIsLinear = null; }

                    return Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedSkin$1(o, newName, materialPropertySource.shader, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, materialPropertySource, clearCache, useOriginalNonrenderables, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedSkin:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedSkin$1:static start.*/
                /**
                 * Creates and populates a duplicate skin with cloned attachments that are backed by a new packed texture atlas
                 comprised of all the regions from the original skin.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.Skin}                           o                                     
                 * @param   {string}                               newName                               
                 * @param   {UnityEngine.Shader}                   shader                                
                 * @param   {UnityEngine.Material}                 outputMaterial                        
                 * @param   {UnityEngine.Texture2D}                outputTexture                         
                 * @param   {number}                               maxAtlasSize                          
                 * @param   {number}                               padding                               
                 * @param   {UnityEngine.TextureFormat}            textureFormat                         
                 * @param   {boolean}                              mipmaps                               
                 * @param   {UnityEngine.Material}                 materialPropertySource                
                 * @param   {boolean}                              clearCache                            
                 * @param   {boolean}                              useOriginalNonrenderables             
                 * @param   {Array.<number>}                       additionalTexturePropertyIDsToCopy    
                 * @param   {Array.<UnityEngine.Texture2D>}        additionalOutputTextures              
                 * @param   {Array.<UnityEngine.TextureFormat>}    additionalTextureFormats              
                 * @param   {Array.<boolean>}                      additionalTextureIsLinear
                 * @return  {Spine.Skin}
                 */
                GetRepackedSkin$1: function (o, newName, shader, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, materialPropertySource, clearCache, useOriginalNonrenderables, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedSkin$1", this ); }

                    var $t, $t1;
                    if (maxAtlasSize === void 0) { maxAtlasSize = 1024; }
                    if (padding === void 0) { padding = 2; }
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    if (clearCache === void 0) { clearCache = false; }
                    if (useOriginalNonrenderables === void 0) { useOriginalNonrenderables = true; }
                    if (additionalTexturePropertyIDsToCopy === void 0) { additionalTexturePropertyIDsToCopy = null; }
                    if (additionalOutputTextures === void 0) { additionalOutputTextures = null; }
                    if (additionalTextureFormats === void 0) { additionalTextureFormats = null; }
                    if (additionalTextureIsLinear === void 0) { additionalTextureIsLinear = null; }

                    outputTexture.v = null;

                    if (o == null) {
                        throw new System.NullReferenceException.$ctor1("Skin was null");
                    }
                    var skinAttachments = o.Attachments;
                    var newSkin = new Spine.Skin(newName);

                    newSkin.Bones.AddRange(o.Bones);
                    newSkin.Constraints.AddRange(o.Constraints);

                    Spine.Unity.AttachmentTools.AtlasUtilities.inoutAttachments.clear();
                    $t = Bridge.getEnumerator(skinAttachments, spine.SkinEntry);
                    try {
                        while ($t.moveNext()) {
                            var entry = $t.Current;
                            Spine.Unity.AttachmentTools.AtlasUtilities.inoutAttachments.add(entry.attachment);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedAttachments(Spine.Unity.AttachmentTools.AtlasUtilities.inoutAttachments, Spine.Unity.AttachmentTools.AtlasUtilities.inoutAttachments, materialPropertySource, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, newName, clearCache, useOriginalNonrenderables, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear);
                    var i = 0;
                    $t1 = Bridge.getEnumerator(skinAttachments, spine.SkinEntry);
                    try {
                        while ($t1.moveNext()) {
                            var originalSkinEntry = $t1.Current;
                            var newAttachment = Spine.Unity.AttachmentTools.AtlasUtilities.inoutAttachments.getItem(Bridge.identity(i, ((i = (i + 1) | 0))));
                            newSkin.setAttachment(originalSkinEntry.slotIndex, originalSkinEntry.name, newAttachment);
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                    return newSkin;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedSkin$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToSprite:static start.*/
                ToSprite: function (ar, pixelsPerUnit) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToSprite", this ); }

                    if (pixelsPerUnit === void 0) { pixelsPerUnit = 100.0; }
                    return UnityEngine.Sprite.Create$1(Spine.Unity.AttachmentTools.AtlasUtilities.GetMainTexture(ar), Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect(ar), new pc.Vec2( 0.5, 0.5 ), pixelsPerUnit);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToSprite:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ClearCache:static start.*/
                /**
                 * Frees up textures cached by repacking and remapping operations.
                 Calling {@link } with parameter <pre><code>premultiplyAlpha=true</code></pre>,
                 {@link } or {@link } will cache textures for later re-use,
                	which might steadily increase the texture memory footprint when used excessively.
                	You can clear this Texture cache by calling {@link }.
                 You may also want to call <pre><code>Resources.UnloadUnusedAssets()</code></pre> after that. Be aware that while this cleanup
                 frees up memory, it is also a costly operation and will likely cause a spike in the framerate.
                 Thus it is recommended to perform costly repacking and cleanup operations after e.g. a character customization
                 screen has been exited, and if required additionally after a certain number of <pre><code>GetRemappedClone()</code></pre> calls.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @return  {void}
                 */
                ClearCache: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ClearCache", this ); }

                    var $t;
                    $t = Bridge.getEnumerator(Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTexturesList);
                    try {
                        while ($t.moveNext()) {
                            var t = $t.Current;
                            UnityEngine.Object.Destroy(t);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTextures.clear();
                    Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTexturesList.clear();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ClearCache:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture:static start.*/
                /**
                 * Creates a new Texture2D object based on an AtlasRegion.
                 If applyImmediately is true, Texture2D.Apply is called immediately after the Texture2D is filled with data.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}            ar                   
                 * @param   {UnityEngine.TextureFormat}    textureFormat        
                 * @param   {boolean}                      mipmaps              
                 * @param   {number}                       texturePropertyId    
                 * @param   {boolean}                      linear               
                 * @param   {boolean}                      applyPMA
                 * @return  {UnityEngine.Texture2D}
                 */
                ToTexture: function (ar, textureFormat, mipmaps, texturePropertyId, linear, applyPMA) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToTexture", this ); }

                    var $t;
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (texturePropertyId === void 0) { texturePropertyId = 0; }
                    if (linear === void 0) { linear = false; }
                    if (applyPMA === void 0) { applyPMA = false; }

                    var output = { };

                    var cacheKey = new Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey.$ctor1(texturePropertyId, ar);
                    Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTextures.tryGetValue(cacheKey.$clone(), output);
                    if (output.v == null) {
                        var sourceTexture = texturePropertyId === 0 ? Spine.Unity.AttachmentTools.AtlasUtilities.GetMainTexture(ar) : Spine.Unity.AttachmentTools.AtlasUtilities.GetTexture(ar, texturePropertyId);
                        var r = Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect(ar);
                        var width = Bridge.Int.clip32(r.width);
                        var height = Bridge.Int.clip32(r.height);
                        output.v = ($t = new UnityEngine.Texture2D.$ctor12(width, height, textureFormat, mipmaps, linear), $t.name = ar.name, $t);
                        Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom(output.v, sourceTexture);
                        if (applyPMA) {
                            Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureApplyPMA(sourceTexture, r, output.v);
                        } else {
                            Spine.Unity.AttachmentTools.AtlasUtilities.CopyTexture(sourceTexture, r, output.v);
                        }
                        Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTextures.add(cacheKey.$clone(), output.v);
                        Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTexturesList.add(output.v);
                    }

                    return output.v;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture$1:static start.*/
                ToTexture$1: function (s, textureFormat, mipmaps, linear, applyPMA) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToTexture$1", this ); }

                    var $t, $t1, $t2, $t3, $t4, $t5, $t6, $t7;
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (linear === void 0) { linear = false; }
                    if (applyPMA === void 0) { applyPMA = false; }

                    var spriteTexture = s.texture;
                    var r = new UnityEngine.Rect();
                    if (!s.packed || s.packingMode === UnityEngine.SpritePackingMode.Rectangle) {
                        r = s.textureRect.$clone();
                    } else {
                        r = new UnityEngine.Rect.ctor();
                        r.xMin = Math.min(($t = s.uv)[0].x, ($t1 = s.uv)[1].x) * spriteTexture.width;
                        r.xMax = Math.max(($t2 = s.uv)[0].x, ($t3 = s.uv)[1].x) * spriteTexture.width;
                        r.yMin = Math.min(($t4 = s.uv)[0].y, ($t5 = s.uv)[2].y) * spriteTexture.height;
                        r.yMax = Math.max(($t6 = s.uv)[0].y, ($t7 = s.uv)[2].y) * spriteTexture.height;
                    }
                    var newTexture = new UnityEngine.Texture2D.$ctor12(Bridge.Int.clip32(r.width), Bridge.Int.clip32(r.height), textureFormat, mipmaps, linear);
                    Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom(newTexture, spriteTexture);
                    if (applyPMA) {
                        Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureApplyPMA(spriteTexture, r, newTexture);
                    } else {
                        Spine.Unity.AttachmentTools.AtlasUtilities.CopyTexture(spriteTexture, r, newTexture);
                    }
                    return newTexture;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetClone:static start.*/
                GetClone: function (t, textureFormat, mipmaps, linear, applyPMA) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetClone", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (linear === void 0) { linear = false; }
                    if (applyPMA === void 0) { applyPMA = false; }

                    var newTexture = new UnityEngine.Texture2D.$ctor12(t.width, t.height, textureFormat, mipmaps, linear);
                    Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom(newTexture, t);
                    if (applyPMA) {
                        Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureApplyPMA(t, new UnityEngine.Rect.$ctor1(0, 0, t.width, t.height), newTexture);
                    } else {
                        Spine.Unity.AttachmentTools.AtlasUtilities.CopyTexture(t, new UnityEngine.Rect.$ctor1(0, 0, t.width, t.height), newTexture);
                    }
                    return newTexture;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetClone:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTexture:static start.*/
                CopyTexture: function (source, sourceRect, destination) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#CopyTexture", this ); }

                    if (UnityEngine.SystemInfo.copyTextureSupport === UnityEngine.Rendering.CopyTextureSupport.None) {
                        // GetPixels fallback for old devices.
                        var pixelBuffer = source.GetPixels$2(Bridge.Int.clip32(sourceRect.x), Bridge.Int.clip32(sourceRect.y), Bridge.Int.clip32(sourceRect.width), Bridge.Int.clip32(sourceRect.height));
                        destination.SetPixels$1(pixelBuffer);
                        destination.Apply();
                    } else {
                        UnityEngine.Graphics.CopyTexture(source, 0, 0, Bridge.Int.clip32(sourceRect.x), Bridge.Int.clip32(sourceRect.y), Bridge.Int.clip32(sourceRect.width), Bridge.Int.clip32(sourceRect.height), destination, 0, 0, 0, 0);
                    }
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTexture:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureApplyPMA:static start.*/
                CopyTextureApplyPMA: function (source, sourceRect, destination) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#CopyTextureApplyPMA", this ); }

                    var pixelBuffer = source.GetPixels$2(Bridge.Int.clip32(sourceRect.x), Bridge.Int.clip32(sourceRect.y), Bridge.Int.clip32(sourceRect.width), Bridge.Int.clip32(sourceRect.height));
                    for (var i = 0, n = pixelBuffer.length; i < n; i = (i + 1) | 0) {
                        var p = pixelBuffer[i].$clone();
                        var a = p.a;
                        p.r = p.r * a;
                        p.g = p.g * a;
                        p.b = p.b * a;
                        pixelBuffer[i] = p.$clone();
                    }
                    destination.SetPixels$1(pixelBuffer);
                    destination.Apply();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureApplyPMA:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.IsRenderable:static start.*/
                IsRenderable: function (a) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#IsRenderable", this ); }

                    return Bridge.is(a, Spine.IHasTextureRegion);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.IsRenderable:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect:static start.*/
                /**
                 * Get a rect with flipped Y so that a Spine atlas rect gets converted to a Unity Sprite rect and vice versa.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Rect}    rect             
                 * @param   {number}              textureHeight
                 * @return  {UnityEngine.Rect}
                 */
                SpineUnityFlipRect: function (rect, textureHeight) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#SpineUnityFlipRect", this ); }

                    rect.y = textureHeight - rect.y - rect.height;
                    return rect.$clone();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect:static start.*/
                /**
                 * Gets the Rect of an AtlasRegion according to Unity texture coordinates (x-right, y-up).
                 This overload relies on region.page.height being correctly set.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}    region
                 * @return  {UnityEngine.Rect}
                 */
                GetUnityRect: function (region) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetUnityRect", this ); }

                    return Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect(Spine.Unity.AttachmentTools.AtlasUtilities.GetSpineAtlasRect(region), region.page.height);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect$1:static start.*/
                /**
                 * Gets the Rect of an AtlasRegion according to Unity texture coordinates (x-right, y-up).
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}    region           
                 * @param   {number}               textureHeight
                 * @return  {UnityEngine.Rect}
                 */
                GetUnityRect$1: function (region, textureHeight) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetUnityRect$1", this ); }

                    return Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect(Spine.Unity.AttachmentTools.AtlasUtilities.GetSpineAtlasRect(region), textureHeight);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetSpineAtlasRect:static start.*/
                /**
                 * Returns a Rect of the AtlasRegion according to Spine texture coordinates. (x-right, y-down)
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}    region           
                 * @param   {boolean}              includeRotate
                 * @return  {UnityEngine.Rect}
                 */
                GetSpineAtlasRect: function (region, includeRotate) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetSpineAtlasRect", this ); }

                    if (includeRotate === void 0) { includeRotate = true; }
                    var width = region.width;
                    var height = region.height;
                    if (includeRotate && region.degrees === 270) {
                        width = region.height;
                        height = region.width;
                    }
                    return new UnityEngine.Rect.$ctor1(region.x, region.y, width, height);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetSpineAtlasRect:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToTextureRect:static start.*/
                /**
                 * Denormalize a uvRect into a texture-space Rect.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Rect}    uvRect       
                 * @param   {number}              texWidth     
                 * @param   {number}              texHeight
                 * @return  {UnityEngine.Rect}
                 */
                UVRectToTextureRect: function (uvRect, texWidth, texHeight) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#UVRectToTextureRect", this ); }

                    uvRect.x *= texWidth;
                    uvRect.width *= texWidth;
                    uvRect.y *= texHeight;
                    uvRect.height *= texHeight;
                    return uvRect.$clone();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToTextureRect:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.TextureRectToUVRect:static start.*/
                /**
                 * Normalize a texture Rect into UV coordinates.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Rect}    textureRect    
                 * @param   {number}              texWidth       
                 * @param   {number}              texHeight
                 * @return  {UnityEngine.Rect}
                 */
                TextureRectToUVRect: function (textureRect, texWidth, texHeight) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#TextureRectToUVRect", this ); }

                    textureRect.x = pc.math.inverseLerp(0, texWidth, textureRect.x);
                    textureRect.y = pc.math.inverseLerp(0, texHeight, textureRect.y);
                    textureRect.width = pc.math.inverseLerp(0, texWidth, textureRect.width);
                    textureRect.height = pc.math.inverseLerp(0, texHeight, textureRect.height);
                    return textureRect.$clone();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.TextureRectToUVRect:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToAtlasRegion:static start.*/
                /**
                 * Creates a new Spine AtlasRegion according to a Unity UV Rect (x-right, y-up, uv-normalized).
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Rect}     uvRect             
                 * @param   {Spine.AtlasRegion}    referenceRegion    
                 * @param   {Spine.AtlasPage}      page
                 * @return  {Spine.AtlasRegion}
                 */
                UVRectToAtlasRegion: function (uvRect, referenceRegion, page) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#UVRectToAtlasRegion", this ); }

                    var $t;
                    var tr = Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToTextureRect(uvRect.$clone(), page.width, page.height);
                    var rr = Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect(tr, page.height);

                    var x = Bridge.Int.clip32(rr.x);
                    var y = Bridge.Int.clip32(rr.y);
                    var w = Bridge.Int.clip32(rr.width);
                    var h = Bridge.Int.clip32(rr.height);

                    if (referenceRegion.degrees === 270) {
                        var tempW = w;
                        w = h;
                        h = tempW;
                    }

                    // Note: originalW and originalH need to be scaled according to the
                    // repacked width and height, repacking can mess with aspect ratio, etc.
                    var originalW = Math.round(w * (referenceRegion.originalWidth / referenceRegion.width));
                    var originalH = Math.round(h * (referenceRegion.originalHeight / referenceRegion.height));

                    var offsetX = Math.round(referenceRegion.offsetX * (w / referenceRegion.width));
                    var offsetY = Math.round(referenceRegion.offsetY * (h / referenceRegion.height));

                    var u = uvRect.xMin;
                    var u2 = uvRect.xMax;
                    var v = uvRect.yMax;
                    var v2 = uvRect.yMin;

                    if (referenceRegion.degrees === 270) {
                        // at a 270 degree region, u2/v2 deltas and atlas width/height are swapped, and delta-v is negative.
                        var du = uvRect.width; // u2 - u;
                        var dv = uvRect.height; // v - v2;
                        var atlasAspectRatio = page.width / page.height;
                        u2 = u + (dv / atlasAspectRatio);
                        v2 = v - (du * atlasAspectRatio);
                    }

                    return ($t = new Spine.AtlasRegion(), $t.page = page, $t.name = referenceRegion.name, $t.u = u, $t.u2 = u2, $t.v = v, $t.v2 = v2, $t.index = -1, $t.width = w, $t.originalWidth = originalW, $t.height = h, $t.originalHeight = originalH, $t.offsetX = offsetX, $t.offsetY = offsetY, $t.x = x, $t.y = y, $t.rotate = referenceRegion.rotate, $t.degrees = referenceRegion.degrees, $t);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToAtlasRegion:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetMainTexture:static start.*/
                /**
                 * Convenience method for getting the main texture of the material of the page of the region.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}        region
                 * @return  {UnityEngine.Texture2D}
                 */
                GetMainTexture: function (region) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetMainTexture", this ); }

                    var material = (Bridge.as(region.page.rendererObject, UnityEngine.Material));
                    return Bridge.as(material.mainTexture, UnityEngine.Texture2D);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetMainTexture:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetTexture$1:static start.*/
                /**
                 * Convenience method for getting any texture of the material of the page of the region by texture property name.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}        region                 
                 * @param   {string}                   texturePropertyName
                 * @return  {UnityEngine.Texture2D}
                 */
                GetTexture$1: function (region, texturePropertyName) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetTexture$1", this ); }

                    var material = (Bridge.as(region.page.rendererObject, UnityEngine.Material));
                    return Bridge.as(material.GetTexture$1(texturePropertyName), UnityEngine.Texture2D);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetTexture$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetTexture:static start.*/
                /**
                 * Convenience method for getting any texture of the material of the page of the region by texture property id.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}        region               
                 * @param   {number}                   texturePropertyId
                 * @return  {UnityEngine.Texture2D}
                 */
                GetTexture: function (region, texturePropertyId) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetTexture", this ); }

                    var material = (Bridge.as(region.page.rendererObject, UnityEngine.Material));
                    return Bridge.as(material.GetTexture(texturePropertyId), UnityEngine.Texture2D);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetTexture:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom:static start.*/
                CopyTextureAttributesFrom: function (destination, source) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#CopyTextureAttributesFrom", this ); }

                    destination.filterMode = source.filterMode;
                    destination.anisoLevel = source.anisoLevel;
                    destination.wrapModeU = source.wrapModeU;
                    destination.wrapModeV = source.wrapModeV;
                    destination.wrapModeW = source.wrapModeW;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp:static start.*/
                InverseLerp: function (a, b, value) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#InverseLerp", this ); }

                    return (value - a) / (b - a);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp:static end.*/


            }
        }
    });
    /*Spine.Unity.AttachmentTools.AtlasUtilities end.*/

    /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey start.*/
    Bridge.define("Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#getDefaultValue", this ); }
 return new Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey(); }
            }
        },
        fields: {
            i: 0,
            region: null
        },
        ctors: {
            $ctor1: function (i, region) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#$ctor1", this ); }

                this.$initialize();
                this.i = i;
                this.region = region;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey.getHashCode start.*/
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#getHashCode", this ); }

                return Bridge.Int.mul(Bridge.getHashCode(this.i), 23) ^ Bridge.getHashCode(this.region);
            },
            /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey.getHashCode end.*/

            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey)) {
                    return false;
                }
                return Bridge.equals(this.i, o.i) && Bridge.equals(this.region, o.region);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#$clone", this ); }

                var s = to || new Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey();
                s.i = this.i;
                s.region = this.region;
                return s;
            }
        },
        overloads: {
            "GetHashCode()": "getHashCode"
        }
    });
    /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey end.*/

    /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions start.*/
    Bridge.define("Spine.Unity.AttachmentTools.AttachmentCloneExtensions", {
        statics: {
            methods: {
                /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone$1:static start.*/
                
                GetRemappedClone$1: function (o, sprite, sourceMaterial, premultiplyAlpha, cloneMeshAsLinked, useOriginalRegionSize, pivotShiftsMeshUVCoords, useOriginalRegionScale, pmaCloneTextureFormat, pmaCloneMipmaps) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentCloneExtensions#GetRemappedClone$1", this ); }

                    var $t;
                    if (premultiplyAlpha === void 0) { premultiplyAlpha = true; }
                    if (cloneMeshAsLinked === void 0) { cloneMeshAsLinked = true; }
                    if (useOriginalRegionSize === void 0) { useOriginalRegionSize = false; }
                    if (pivotShiftsMeshUVCoords === void 0) { pivotShiftsMeshUVCoords = true; }
                    if (useOriginalRegionScale === void 0) { useOriginalRegionScale = false; }
                    if (pmaCloneTextureFormat === void 0) { pmaCloneTextureFormat = 4; }
                    if (pmaCloneMipmaps === void 0) { pmaCloneMipmaps = false; }

                    var atlasRegion = premultiplyAlpha ? Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone(sprite, sourceMaterial, pmaCloneTextureFormat, pmaCloneMipmaps) : Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$1(sprite, ($t = new UnityEngine.Material.$ctor1(sourceMaterial), $t.mainTexture = sprite.texture, $t));
                    if (!pivotShiftsMeshUVCoords && Bridge.is(o, Spine.MeshAttachment)) {
                        // prevent non-central sprite pivot setting offsetX/Y and shifting uv coords out of mesh bounds
                        atlasRegion.offsetX = 0;
                        atlasRegion.offsetY = 0;
                    }
                    var scale = 1.0 / sprite.pixelsPerUnit;
                    if (useOriginalRegionScale) {
                        var regionAttachment = Bridge.as(o, Spine.RegionAttachment);
                        if (regionAttachment != null) {
                            scale = regionAttachment.width / regionAttachment.region.originalWidth;
                        }
                    }
                    return Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone(o, atlasRegion, cloneMeshAsLinked, useOriginalRegionSize, scale);
                },
                /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone$1:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone:static start.*/
                /**
                 * Gets a clone of the attachment remapped with an atlasRegion image.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentCloneExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentCloneExtensions
                 * @param   {spine.Attachment}     o                        The original attachment.
                 * @param   {Spine.AtlasRegion}    atlasRegion              Atlas region.
                 * @param   {boolean}              cloneMeshAsLinked        If <pre><code>true</code></pre> MeshAttachments will be cloned as linked meshes and will inherit animation from the original attachment.
                 * @param   {boolean}              useOriginalRegionSize    If <pre><code>true</code></pre> the size of the original attachment will be followed, instead of using the Sprite size.
                 * @param   {number}               scale                    Unity units per pixel scale used to scale the atlas region size when not using the original region size.
                 * @return  {spine.Attachment}                              The remapped clone.
                 */
                GetRemappedClone: function (o, atlasRegion, cloneMeshAsLinked, useOriginalRegionSize, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentCloneExtensions#GetRemappedClone", this ); }

                    if (cloneMeshAsLinked === void 0) { cloneMeshAsLinked = true; }
                    if (useOriginalRegionSize === void 0) { useOriginalRegionSize = false; }
                    if (scale === void 0) { scale = 0.01; }
                    var regionAttachment = Bridge.as(o, Spine.RegionAttachment);
                    if (regionAttachment != null) {
                        var newAttachment = Bridge.cast(regionAttachment.copy(), Spine.RegionAttachment);
                        newAttachment.region = atlasRegion;
                        if (!useOriginalRegionSize) {
                            newAttachment.width = atlasRegion.width * scale;
                            newAttachment.height = atlasRegion.height * scale;
                        }
                        newAttachment.updateRegion();
                        return newAttachment;
                    } else {
                        var meshAttachment = Bridge.as(o, Spine.MeshAttachment);
                        if (meshAttachment != null) {
                            var newAttachment1 = cloneMeshAsLinked ? meshAttachment.newLinkedMesh() : Bridge.cast(meshAttachment.copy(), Spine.MeshAttachment);
                            newAttachment1.region = atlasRegion;
                            newAttachment1.updateRegion();
                            return newAttachment1;
                        }
                    }
                    return o.copy();
                },
                /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone:static end.*/


            }
        }
    });
    /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions end.*/

    /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions start.*/
    Bridge.define("Spine.Unity.AttachmentTools.AttachmentRegionExtensions", {
        statics: {
            methods: {
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment$2:static start.*/
                /**
                 * Creates a RegionAttachment based on a sprite. This method creates a real, usable AtlasRegion. That AtlasRegion uses a new AtlasPage with the Material provided.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {UnityEngine.Sprite}        sprite      
                 * @param   {UnityEngine.Material}      material    
                 * @param   {number}                    rotation
                 * @return  {Spine.RegionAttachment}
                 */
                ToRegionAttachment$2: function (sprite, material, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachment$2", this ); }

                    if (rotation === void 0) { rotation = 0.0; }
                    return Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment$1(sprite, Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(material), rotation);
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment$2:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment$1:static start.*/
                /**
                 * Creates a RegionAttachment based on a sprite. This method creates a real, usable AtlasRegion. That AtlasRegion uses the AtlasPage provided.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {UnityEngine.Sprite}        sprite      
                 * @param   {Spine.AtlasPage}           page        
                 * @param   {number}                    rotation
                 * @return  {Spine.RegionAttachment}
                 */
                ToRegionAttachment$1: function (sprite, page, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachment$1", this ); }

                    if (rotation === void 0) { rotation = 0.0; }
                    if (sprite == null) {
                        throw new System.ArgumentNullException.$ctor1("sprite");
                    }
                    if (page == null) {
                        throw new System.ArgumentNullException.$ctor1("page");
                    }
                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion(sprite, page);
                    var unitsPerPixel = 1.0 / sprite.pixelsPerUnit;
                    return Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment(region, sprite.name, unitsPerPixel, rotation);
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment$1:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment:static start.*/
                /**
                 * Creates a new RegionAttachment from a given AtlasRegion.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.AtlasRegion}         region            
                 * @param   {string}                    attachmentName    
                 * @param   {number}                    scale             
                 * @param   {number}                    rotation
                 * @return  {Spine.RegionAttachment}
                 */
                ToRegionAttachment: function (region, attachmentName, scale, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachment", this ); }

                    if (scale === void 0) { scale = 0.01; }
                    if (rotation === void 0) { rotation = 0.0; }
                    if (System.String.isNullOrEmpty(attachmentName)) {
                        throw new System.ArgumentException.$ctor3("attachmentName can't be null or empty.", "attachmentName");
                    }
                    if (region == null) {
                        throw new System.ArgumentNullException.$ctor1("region");
                    }

                    // (AtlasAttachmentLoader.cs)
                    var attachment = new Spine.RegionAttachment(attachmentName);

                    attachment.region = region;
                    attachment.path = region.name;
                    attachment.scaleX = 1;
                    attachment.scaleY = 1;
                    attachment.rotation = rotation;

                    attachment.color.r = 1;
                    attachment.color.g = 1;
                    attachment.color.b = 1;
                    attachment.color.a = 1;

                    // pass OriginalWidth and OriginalHeight because UpdateOffset uses it in its calculation.
                    var textreRegion = attachment.region;
                    var atlasRegion = Bridge.as(textreRegion, Spine.AtlasRegion);
                    var originalWidth = atlasRegion != null ? atlasRegion.originalWidth : textreRegion.width;
                    var originalHeight = atlasRegion != null ? atlasRegion.originalHeight : textreRegion.height;
                    attachment.width = originalWidth * scale;
                    attachment.height = originalHeight * scale;

                    Spine.Unity.SkeletonExtensions.SetColor$2(attachment, new pc.Color( 1, 1, 1, 1 ));
                    attachment.updateRegion();
                    return attachment;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachmentPMAClone$1:static start.*/
                /**
                 * Creates a Spine.AtlasRegion that uses a premultiplied alpha duplicate texture of the Sprite's texture data.
                 Returns a RegionAttachment that uses it. Use this if you plan to use a premultiply alpha shader such as "Spine/Skeleton".
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {UnityEngine.Sprite}           sprite                    
                 * @param   {UnityEngine.Shader}           shader                    
                 * @param   {UnityEngine.TextureFormat}    textureFormat             
                 * @param   {boolean}                      mipmaps                   
                 * @param   {UnityEngine.Material}         materialPropertySource    
                 * @param   {number}                       rotation
                 * @return  {Spine.RegionAttachment}
                 */
                ToRegionAttachmentPMAClone$1: function (sprite, shader, textureFormat, mipmaps, materialPropertySource, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachmentPMAClone$1", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    if (rotation === void 0) { rotation = 0.0; }
                    if (sprite == null) {
                        throw new System.ArgumentNullException.$ctor1("sprite");
                    }
                    if (shader == null) {
                        throw new System.ArgumentNullException.$ctor1("shader");
                    }
                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$1(sprite, shader, textureFormat, mipmaps, materialPropertySource);
                    var unitsPerPixel = 1.0 / sprite.pixelsPerUnit;
                    return Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment(region, sprite.name, unitsPerPixel, rotation);
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachmentPMAClone$1:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachmentPMAClone:static start.*/
                ToRegionAttachmentPMAClone: function (sprite, materialPropertySource, textureFormat, mipmaps, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachmentPMAClone", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (rotation === void 0) { rotation = 0.0; }
                    return Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachmentPMAClone$1(sprite, materialPropertySource.shader, textureFormat, mipmaps, materialPropertySource, rotation);
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachmentPMAClone:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetScale$1:static start.*/
                /**
                 * Sets the scale. Call regionAttachment.UpdateOffset to apply the change.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.RegionAttachment}    regionAttachment    
                 * @param   {UnityEngine.Vector2}       scale
                 * @return  {void}
                 */
                SetScale$1: function (regionAttachment, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetScale$1", this ); }

                    regionAttachment.scaleX = scale.x;
                    regionAttachment.scaleY = scale.y;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetScale$1:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetScale:static start.*/
                /**
                 * Sets the scale. Call regionAttachment.UpdateOffset to apply the change.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.RegionAttachment}    regionAttachment    
                 * @param   {number}                    x                   
                 * @param   {number}                    y
                 * @return  {void}
                 */
                SetScale: function (regionAttachment, x, y) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetScale", this ); }

                    regionAttachment.scaleX = x;
                    regionAttachment.scaleY = y;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetScale:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetPositionOffset$1:static start.*/
                /**
                 * Sets the position offset. Call regionAttachment.UpdateOffset to apply the change.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.RegionAttachment}    regionAttachment    
                 * @param   {UnityEngine.Vector2}       offset
                 * @return  {void}
                 */
                SetPositionOffset$1: function (regionAttachment, offset) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetPositionOffset$1", this ); }

                    regionAttachment.x = offset.x;
                    regionAttachment.y = offset.y;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetPositionOffset$1:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetPositionOffset:static start.*/
                /**
                 * Sets the position offset. Call regionAttachment.UpdateOffset to apply the change.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.RegionAttachment}    regionAttachment    
                 * @param   {number}                    x                   
                 * @param   {number}                    y
                 * @return  {void}
                 */
                SetPositionOffset: function (regionAttachment, x, y) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetPositionOffset", this ); }

                    regionAttachment.x = x;
                    regionAttachment.y = y;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetPositionOffset:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetRotation:static start.*/
                /**
                 * Sets the rotation. Call regionAttachment.UpdateOffset to apply the change.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.RegionAttachment}    regionAttachment    
                 * @param   {number}                    rotation
                 * @return  {void}
                 */
                SetRotation: function (regionAttachment, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetRotation", this ); }

                    regionAttachment.rotation = rotation;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetRotation:static end.*/


            }
        }
    });
    /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions end.*/

    /*Spine.Unity.BlendModeMaterials start.*/
    Bridge.define("Spine.Unity.BlendModeMaterials", {
        fields: {
            requiresBlendModeMaterials: false,
            applyAdditiveMaterial: false,
            additiveMaterials: null,
            multiplyMaterials: null,
            screenMaterials: null
        },
        props: {
            RequiresBlendModeMaterials: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#RequiresBlendModeMaterials#get", this ); }

                    return this.requiresBlendModeMaterials;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#RequiresBlendModeMaterials#set", this ); }

                    this.requiresBlendModeMaterials = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#init", this ); }

                this.requiresBlendModeMaterials = false;
                this.applyAdditiveMaterial = false;
                this.additiveMaterials = new (System.Collections.Generic.List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial)).ctor();
                this.multiplyMaterials = new (System.Collections.Generic.List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial)).ctor();
                this.screenMaterials = new (System.Collections.Generic.List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.BlendModeMaterials.BlendModeForMaterial start.*/
            BlendModeForMaterial: function (material) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#BlendModeForMaterial", this ); }

                var $t, $t1, $t2;
                $t = Bridge.getEnumerator(this.multiplyMaterials);
                try {
                    while ($t.moveNext()) {
                        var pair = $t.Current;
                        if (Bridge.referenceEquals(pair.material, material)) {
                            return spine.BlendMode.Multiply;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                $t1 = Bridge.getEnumerator(this.additiveMaterials);
                try {
                    while ($t1.moveNext()) {
                        var pair1 = $t1.Current;
                        if (Bridge.referenceEquals(pair1.material, material)) {
                            return spine.BlendMode.Additive;
                        }
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }
                $t2 = Bridge.getEnumerator(this.screenMaterials);
                try {
                    while ($t2.moveNext()) {
                        var pair2 = $t2.Current;
                        if (Bridge.referenceEquals(pair2.material, material)) {
                            return spine.BlendMode.Screen;
                        }
                    }
                } finally {
                    if (Bridge.is($t2, System.IDisposable)) {
                        $t2.System$IDisposable$Dispose();
                    }
                }
                return spine.BlendMode.Normal;
            },
            /*Spine.Unity.BlendModeMaterials.BlendModeForMaterial end.*/

            /*Spine.Unity.BlendModeMaterials.ApplyMaterials start.*/
            ApplyMaterials: function (skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#ApplyMaterials", this ); }

                var $t, $t1;
                if (skeletonData == null) {
                    throw new System.ArgumentNullException.$ctor1("skeletonData");
                }
                if (!this.requiresBlendModeMaterials) {
                    return;
                }

                var skinEntries = new (System.Collections.Generic.List$1(spine.SkinEntry)).ctor();
                var slotsItems = skeletonData.Slots.Items;
                for (var slotIndex = 0, slotCount = skeletonData.Slots.Count; slotIndex < slotCount; slotIndex = (slotIndex + 1) | 0) {
                    var slot = slotsItems[slotIndex];
                    if (slot.blendMode === spine.BlendMode.Normal) {
                        continue;
                    }
                    if (!this.applyAdditiveMaterial && slot.blendMode === spine.BlendMode.Additive) {
                        continue;
                    }

                    var replacementMaterials = null;
                    switch (slot.blendMode) {
                        case spine.BlendMode.Multiply: 
                            replacementMaterials = this.multiplyMaterials;
                            break;
                        case spine.BlendMode.Screen: 
                            replacementMaterials = this.screenMaterials;
                            break;
                        case spine.BlendMode.Additive: 
                            replacementMaterials = this.additiveMaterials;
                            break;
                    }
                    if (replacementMaterials == null) {
                        continue;
                    }

                    skinEntries.clear();
                    $t = Bridge.getEnumerator(skeletonData.Skins);
                    try {
                        while ($t.moveNext()) {
                            var skin = $t.Current;
                            ( skinEntries._items.length = 0, skin.getAttachmentsForSlot( slotIndex, skinEntries._items ), skinEntries._size = skinEntries._items.length );
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    $t1 = Bridge.getEnumerator(skinEntries);
                    try {
                        while ($t1.moveNext()) {
                            var entry = $t1.Current;
                            var renderableAttachment = Bridge.as(entry.attachment, Spine.IHasTextureRegion);
                            if (renderableAttachment != null) {
                                if (renderableAttachment.Spine$IHasTextureRegion$Region != null) {
                                    renderableAttachment.Spine$IHasTextureRegion$Region = this.CloneAtlasRegionWithMaterial(Bridge.cast(renderableAttachment.Spine$IHasTextureRegion$Region, Spine.AtlasRegion), replacementMaterials);
                                } else {
                                    if (renderableAttachment.Spine$IHasTextureRegion$Sequence != null) {
                                        var regions = renderableAttachment.Spine$IHasTextureRegion$Sequence.regions;
                                        for (var i = 0; i < regions.length; i = (i + 1) | 0) {
                                            regions[i] = this.CloneAtlasRegionWithMaterial(Bridge.cast(regions[i], Spine.AtlasRegion), replacementMaterials);
                                        }
                                    }
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                }
            },
            /*Spine.Unity.BlendModeMaterials.ApplyMaterials end.*/

            /*Spine.Unity.BlendModeMaterials.CloneAtlasRegionWithMaterial start.*/
            CloneAtlasRegionWithMaterial: function (originalRegion, replacementMaterials) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#CloneAtlasRegionWithMaterial", this ); }

                var $t;
                var newRegion = originalRegion.Clone();
                var material = null;
                $t = Bridge.getEnumerator(replacementMaterials);
                try {
                    while ($t.moveNext()) {
                        var replacement = $t.Current;
                        if (Bridge.referenceEquals(replacement.pageName, originalRegion.page.name)) {
                            material = replacement.material;
                            break;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                var originalPage = originalRegion.page;
                var newPage = originalPage.Clone();
                newPage.rendererObject = material;
                newRegion.page = newPage;
                return newRegion;
            },
            /*Spine.Unity.BlendModeMaterials.CloneAtlasRegionWithMaterial end.*/


        }
    });
    /*Spine.Unity.BlendModeMaterials end.*/

    /*Spine.Unity.BlendModeMaterials+ReplacementMaterial start.*/
    Bridge.define("Spine.Unity.BlendModeMaterials.ReplacementMaterial", {
        $kind: 1002,
        fields: {
            pageName: null,
            material: null
        }
    });
    /*Spine.Unity.BlendModeMaterials+ReplacementMaterial end.*/

    /*Spine.Unity.SkeletonDataModifierAsset start.*/
    /**
     * Can be stored by SkeletonDataAsset to automatically apply modifications to loaded SkeletonData.
     *
     * @abstract
     * @public
     * @class Spine.Unity.SkeletonDataModifierAsset
     * @augments UnityEngine.ScriptableObject
     */
    Bridge.define("Spine.Unity.SkeletonDataModifierAsset", {
        inherits: [UnityEngine.ScriptableObject]
    });
    /*Spine.Unity.SkeletonDataModifierAsset end.*/

    /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache start.*/
    Bridge.define("Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache", {
        inherits: [System.IDisposable],
        $kind: 1002,
        fields: {
            cache: null
        },
        alias: ["Dispose", "System$IDisposable$Dispose"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#init", this ); }

                this.cache = new (System.Collections.Generic.Dictionary$2(System.Collections.Generic.KeyValuePair$2(Spine.AtlasPage,UnityEngine.Material),Spine.AtlasPage)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.CloneAtlasRegionWithMaterial start.*/
            /**
             * Creates a clone of an AtlasRegion that uses different Material settings, while retaining the original texture.
             *
             * @instance
             * @public
             * @this Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache
             * @memberof Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache
             * @param   {Spine.AtlasRegion}       originalRegion      
             * @param   {UnityEngine.Material}    materialTemplate
             * @return  {Spine.AtlasRegion}
             */
            CloneAtlasRegionWithMaterial: function (originalRegion, materialTemplate) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#CloneAtlasRegionWithMaterial", this ); }

                var newRegion = originalRegion.Clone();
                newRegion.page = this.GetAtlasPageWithMaterial(originalRegion.page, materialTemplate);
                return newRegion;
            },
            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.CloneAtlasRegionWithMaterial end.*/

            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.GetAtlasPageWithMaterial start.*/
            GetAtlasPageWithMaterial: function (originalPage, materialTemplate) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#GetAtlasPageWithMaterial", this ); }

                var $t;
                if (originalPage == null) {
                    throw new System.ArgumentNullException.$ctor1("originalPage");
                }

                var newPage = { v : null };
                var key = new (System.Collections.Generic.KeyValuePair$2(Spine.AtlasPage,UnityEngine.Material)).$ctor1(originalPage, materialTemplate);
                this.cache.tryGetValue(key, newPage);

                if (newPage.v == null) {
                    newPage.v = originalPage.Clone();
                    var originalMaterial = Bridge.as(originalPage.rendererObject, UnityEngine.Material);
                    newPage.v.rendererObject = ($t = new UnityEngine.Material.$ctor1(materialTemplate), $t.name = (originalMaterial.name || "") + " " + (materialTemplate.name || ""), $t.mainTexture = originalMaterial.mainTexture, $t);
                    this.cache.add(key, newPage.v);
                }

                return newPage.v;
            },
            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.GetAtlasPageWithMaterial end.*/

            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#Dispose", this ); }

                this.cache.clear();
            },
            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.Dispose end.*/


        }
    });
    /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache end.*/

    /*Spine.Unity.BoneFollower start.*/
    /**
     * Sets a GameObject's transform to match a bone on a Spine skeleton.
     *
     * @public
     * @class Spine.Unity.BoneFollower
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.BoneFollower", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonRenderer: null,
            /**
             * If a bone isn't set in code, boneName is used to find the bone at the beginning. For runtime switching by name, use SetBoneByName. You can also set the BoneFollower.bone field directly.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.BoneFollower
             * @type string
             */
            boneName: null,
            followXYPosition: false,
            followZPosition: false,
            followBoneRotation: false,
            followSkeletonFlip: false,
            followLocalScale: false,
            followParentWorldScale: false,
            maintainedAxisOrientation: 0,
            initializeOnAwake: false,
            valid: false,
            bone: null,
            skeletonTransform: null,
            skeletonTransformIsParent: false
        },
        props: {
            SkeletonRenderer: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#SkeletonRenderer#get", this ); }

                    return this.skeletonRenderer;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#SkeletonRenderer#set", this ); }

                    this.skeletonRenderer = value;
                    this.Initialize();
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#init", this ); }

                this.followXYPosition = true;
                this.followZPosition = true;
                this.followBoneRotation = true;
                this.followSkeletonFlip = true;
                this.followLocalScale = false;
                this.followParentWorldScale = false;
                this.maintainedAxisOrientation = Spine.Unity.BoneFollower.AxisOrientation.XAxis;
                this.initializeOnAwake = true;
            }
        },
        methods: {
            /*Spine.Unity.BoneFollower.SetBone start.*/
            /**
             * Sets the target bone by its bone name. Returns false if no bone was found. To set the bone by reference, use BoneFollower.bone directly.
             *
             * @instance
             * @public
             * @this Spine.Unity.BoneFollower
             * @memberof Spine.Unity.BoneFollower
             * @param   {string}     name
             * @return  {boolean}
             */
            SetBone: function (name) {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#SetBone", this ); }

                this.bone = this.skeletonRenderer.skeleton.findBone(name);
                if (this.bone == null) {
                    UnityEngine.Debug.LogError$2("Bone not found: " + (name || ""), this);
                    return false;
                }
                this.boneName = name;
                return true;
            },
            /*Spine.Unity.BoneFollower.SetBone end.*/

            /*Spine.Unity.BoneFollower.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#Awake", this ); }

                if (this.initializeOnAwake) {
                    this.Initialize();
                }
            },
            /*Spine.Unity.BoneFollower.Awake end.*/

            /*Spine.Unity.BoneFollower.HandleRebuildRenderer start.*/
            HandleRebuildRenderer: function (skeletonRenderer) {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#HandleRebuildRenderer", this ); }

                this.Initialize();
            },
            /*Spine.Unity.BoneFollower.HandleRebuildRenderer end.*/

            /*Spine.Unity.BoneFollower.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#Initialize", this ); }

                this.bone = null;
                this.valid = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) && this.skeletonRenderer.valid;
                if (!this.valid) {
                    return;
                }

                this.skeletonTransform = this.skeletonRenderer.transform;
                this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                this.skeletonRenderer.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                this.skeletonTransformIsParent = Bridge.referenceEquals(this.skeletonTransform, this.transform.parent);

                if (!System.String.isNullOrEmpty(this.boneName)) {
                    this.bone = this.skeletonRenderer.skeleton.findBone(this.boneName);
                }

            },
            /*Spine.Unity.BoneFollower.Initialize end.*/

            /*Spine.Unity.BoneFollower.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#OnDestroy", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                }
            },
            /*Spine.Unity.BoneFollower.OnDestroy end.*/

            /*Spine.Unity.BoneFollower.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#LateUpdate", this ); }

                var $t, $t1;
                if (!this.valid) {
                    this.Initialize();
                    return;
                }


                if (this.bone == null) {
                    if (System.String.isNullOrEmpty(this.boneName)) {
                        return;
                    }
                    this.bone = this.skeletonRenderer.skeleton.findBone(this.boneName);
                    if (!this.SetBone(this.boneName)) {
                        return;
                    }
                }

                var thisTransform = this.transform;
                var additionalFlipScale = 1;
                if (this.skeletonTransformIsParent) {
                    // Recommended setup: Use local transform properties if Spine GameObject is the immediate parent
                    thisTransform.localPosition = new pc.Vec3( this.followXYPosition ? this.bone.worldX : thisTransform.localPosition.x, this.followXYPosition ? this.bone.worldY : thisTransform.localPosition.y, this.followZPosition ? 0.0 : thisTransform.localPosition.z );
                    if (this.followBoneRotation) {
                        var halfRotation = Math.atan2(this.bone.c, this.bone.a) * 0.5;
                        if (this.followLocalScale && this.bone.scaleX < 0) {
                            halfRotation += 1.57079637;
                        }

                        var q = Bridge.getDefaultValue(UnityEngine.Quaternion);
                        q.z = Math.sin(halfRotation);
                        q.w = Math.cos(halfRotation);
                        thisTransform.localRotation = q.$clone();
                    }
                } else {
                    // For special cases: Use transform world properties if transform relationship is complicated
                    var targetWorldPosition = this.skeletonTransform.TransformPoint$1(new pc.Vec3( this.bone.worldX, this.bone.worldY, 0.0 ));
                    if (!this.followZPosition) {
                        targetWorldPosition.z = thisTransform.position.z;
                    }
                    if (!this.followXYPosition) {
                        targetWorldPosition.x = thisTransform.position.x;
                        targetWorldPosition.y = thisTransform.position.y;
                    }

                    var skeletonLossyScale = this.skeletonTransform.lossyScale.$clone();
                    var transformParent = thisTransform.parent;
                    var parentLossyScale = UnityEngine.Component.op_Inequality(transformParent, null) ? transformParent.lossyScale.$clone() : new pc.Vec3( 1, 1, 1 );
                    if (this.followBoneRotation) {
                        var boneWorldRotation = this.bone.getWorldRotationX();

                        if ((skeletonLossyScale.x * skeletonLossyScale.y) < 0) {
                            boneWorldRotation = -boneWorldRotation;
                        }

                        if (this.followSkeletonFlip || this.maintainedAxisOrientation === Spine.Unity.BoneFollower.AxisOrientation.XAxis) {
                            if ((skeletonLossyScale.x * parentLossyScale.x < 0)) {
                                boneWorldRotation += 180.0;
                            }
                        } else {
                            if ((skeletonLossyScale.y * parentLossyScale.y < 0)) {
                                boneWorldRotation += 180.0;
                            }
                        }

                        var worldRotation = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                        if (this.followLocalScale && this.bone.scaleX < 0) {
                            boneWorldRotation += 180.0;
                        }
                        thisTransform.SetPositionAndRotation(targetWorldPosition, new pc.Quat().setFromEulerAngles_Unity( worldRotation.x, worldRotation.y, worldRotation.z + boneWorldRotation ));
                    } else {
                        thisTransform.position = targetWorldPosition.$clone();
                    }

                    additionalFlipScale = ($t = skeletonLossyScale.x * parentLossyScale.x * skeletonLossyScale.y * parentLossyScale.y, ($t === 0 ? 1 : Math.sign($t)));
                }

                var parentBone = this.bone.parent;
                if (this.followParentWorldScale || this.followLocalScale || this.followSkeletonFlip) {
                    var localScale = new pc.Vec3( 1.0, 1.0, 1.0 );
                    if (this.followParentWorldScale && parentBone != null) {
                        localScale = new pc.Vec3( parentBone.getWorldScaleX(), parentBone.getWorldScaleY(), 1.0 );
                    }
                    if (this.followLocalScale) {
                        localScale.mul( new pc.Vec3( this.bone.scaleX, this.bone.scaleY, 1.0 ) );
                    }
                    if (this.followSkeletonFlip) {
                        localScale.y *= ($t1 = this.bone.skeleton.scaleX * this.bone.skeleton.scaleY, ($t1 === 0 ? 1 : Math.sign($t1))) * additionalFlipScale;
                    }
                    thisTransform.localScale = localScale.$clone();
                }
            },
            /*Spine.Unity.BoneFollower.LateUpdate end.*/


        }
    });
    /*Spine.Unity.BoneFollower end.*/

    /*Spine.Unity.BoneFollower+AxisOrientation start.*/
    Bridge.define("Spine.Unity.BoneFollower.AxisOrientation", {
        $kind: 1006,
        statics: {
            fields: {
                XAxis: 1,
                YAxis: 2
            }
        }
    });
    /*Spine.Unity.BoneFollower+AxisOrientation end.*/

    /*Spine.Unity.BoneFollowerGraphic start.*/
    Bridge.define("Spine.Unity.BoneFollowerGraphic", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonGraphic: null,
            initializeOnAwake: false,
            /**
             * If a bone isn't set in code, boneName is used to find the bone at the beginning. For runtime switching by name, use SetBoneByName. You can also set the BoneFollower.bone field directly.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.BoneFollowerGraphic
             * @type string
             */
            boneName: null,
            followBoneRotation: false,
            followSkeletonFlip: false,
            followLocalScale: false,
            followParentWorldScale: false,
            followXYPosition: false,
            followZPosition: false,
            maintainedAxisOrientation: 0,
            bone: null,
            skeletonTransform: null,
            skeletonTransformIsParent: false,
            valid: false
        },
        props: {
            SkeletonGraphic: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#SkeletonGraphic#get", this ); }

                    return this.skeletonGraphic;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#SkeletonGraphic#set", this ); }

                    this.skeletonGraphic = value;
                    this.Initialize();
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#init", this ); }

                this.initializeOnAwake = true;
                this.followBoneRotation = true;
                this.followSkeletonFlip = true;
                this.followLocalScale = false;
                this.followParentWorldScale = false;
                this.followXYPosition = true;
                this.followZPosition = true;
                this.maintainedAxisOrientation = Spine.Unity.BoneFollower.AxisOrientation.XAxis;
            }
        },
        methods: {
            /*Spine.Unity.BoneFollowerGraphic.SetBone start.*/
            /**
             * Sets the target bone by its bone name. Returns false if no bone was found.
             *
             * @instance
             * @public
             * @this Spine.Unity.BoneFollowerGraphic
             * @memberof Spine.Unity.BoneFollowerGraphic
             * @param   {string}     name
             * @return  {boolean}
             */
            SetBone: function (name) {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#SetBone", this ); }

                this.bone = this.skeletonGraphic.Skeleton.findBone(name);
                if (this.bone == null) {
                    UnityEngine.Debug.LogError$2("Bone not found: " + (name || ""), this);
                    return false;
                }
                this.boneName = name;
                return true;
            },
            /*Spine.Unity.BoneFollowerGraphic.SetBone end.*/

            /*Spine.Unity.BoneFollowerGraphic.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#Awake", this ); }

                if (this.initializeOnAwake) {
                    this.Initialize();
                }
            },
            /*Spine.Unity.BoneFollowerGraphic.Awake end.*/

            /*Spine.Unity.BoneFollowerGraphic.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#Initialize", this ); }

                this.bone = null;
                this.valid = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) && this.skeletonGraphic.IsValid;
                if (!this.valid) {
                    return;
                }

                this.skeletonTransform = this.skeletonGraphic.transform;
                //			skeletonGraphic.OnRebuild -= HandleRebuildRenderer;
                //			skeletonGraphic.OnRebuild += HandleRebuildRenderer;
                this.skeletonTransformIsParent = Bridge.referenceEquals(this.skeletonTransform, this.transform.parent);

                if (!System.String.isNullOrEmpty(this.boneName)) {
                    this.bone = this.skeletonGraphic.Skeleton.findBone(this.boneName);
                }

            },
            /*Spine.Unity.BoneFollowerGraphic.Initialize end.*/

            /*Spine.Unity.BoneFollowerGraphic.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#LateUpdate", this ); }

                var $t, $t1;
                if (!this.valid) {
                    this.Initialize();
                    return;
                }


                if (this.bone == null) {
                    if (System.String.isNullOrEmpty(this.boneName)) {
                        return;
                    }
                    this.bone = this.skeletonGraphic.Skeleton.findBone(this.boneName);
                    if (!this.SetBone(this.boneName)) {
                        return;
                    }
                }

                var thisTransform = Bridge.as(this.transform, UnityEngine.RectTransform);
                if (UnityEngine.Component.op_Equality(thisTransform, null)) {
                    return;
                }

                var scale = this.skeletonGraphic.MeshScale;

                var additionalFlipScale = 1;
                if (this.skeletonTransformIsParent) {
                    // Recommended setup: Use local transform properties if Spine GameObject is the immediate parent
                    thisTransform.localPosition = new pc.Vec3( this.followXYPosition ? this.bone.worldX * scale : thisTransform.localPosition.x, this.followXYPosition ? this.bone.worldY * scale : thisTransform.localPosition.y, this.followZPosition ? 0.0 : thisTransform.localPosition.z );
                    if (this.followBoneRotation) {
                        thisTransform.localRotation = Spine.Unity.SkeletonExtensions.GetQuaternion(this.bone);
                    }
                } else {
                    // For special cases: Use transform world properties if transform relationship is complicated
                    var targetWorldPosition = this.skeletonTransform.TransformPoint$1(new pc.Vec3( this.bone.worldX * scale, this.bone.worldY * scale, 0.0 ));
                    if (!this.followZPosition) {
                        targetWorldPosition.z = thisTransform.position.z;
                    }
                    if (!this.followXYPosition) {
                        targetWorldPosition.x = thisTransform.position.x;
                        targetWorldPosition.y = thisTransform.position.y;
                    }

                    var skeletonLossyScale = this.skeletonTransform.lossyScale.$clone();
                    var transformParent = thisTransform.parent;
                    var parentLossyScale = UnityEngine.Component.op_Inequality(transformParent, null) ? transformParent.lossyScale.$clone() : new pc.Vec3( 1, 1, 1 );
                    if (this.followBoneRotation) {
                        var boneWorldRotation = this.bone.getWorldRotationX();

                        if ((skeletonLossyScale.x * skeletonLossyScale.y) < 0) {
                            boneWorldRotation = -boneWorldRotation;
                        }

                        if (this.followSkeletonFlip || this.maintainedAxisOrientation === Spine.Unity.BoneFollower.AxisOrientation.XAxis) {
                            if ((skeletonLossyScale.x * parentLossyScale.x < 0)) {
                                boneWorldRotation += 180.0;
                            }
                        } else {
                            if ((skeletonLossyScale.y * parentLossyScale.y < 0)) {
                                boneWorldRotation += 180.0;
                            }
                        }

                        var worldRotation = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                        if (this.followLocalScale && this.bone.scaleX < 0) {
                            boneWorldRotation += 180.0;
                        }
                        thisTransform.SetPositionAndRotation(targetWorldPosition, new pc.Quat().setFromEulerAngles_Unity( worldRotation.x, worldRotation.y, worldRotation.z + boneWorldRotation ));
                    } else {
                        thisTransform.position = targetWorldPosition.$clone();
                    }

                    additionalFlipScale = ($t = skeletonLossyScale.x * parentLossyScale.x * skeletonLossyScale.y * parentLossyScale.y, ($t === 0 ? 1 : Math.sign($t)));
                }

                var parentBone = this.bone.parent;
                if (this.followParentWorldScale || this.followLocalScale || this.followSkeletonFlip) {
                    var localScale = new pc.Vec3( 1.0, 1.0, 1.0 );
                    if (this.followParentWorldScale && parentBone != null) {
                        localScale = new pc.Vec3( parentBone.getWorldScaleX(), parentBone.getWorldScaleY(), 1.0 );
                    }
                    if (this.followLocalScale) {
                        localScale.mul( new pc.Vec3( this.bone.scaleX, this.bone.scaleY, 1.0 ) );
                    }
                    if (this.followSkeletonFlip) {
                        localScale.y *= ($t1 = this.bone.skeleton.scaleX * this.bone.skeleton.scaleY, ($t1 === 0 ? 1 : Math.sign($t1))) * additionalFlipScale;
                    }
                    thisTransform.localScale = localScale.$clone();
                }
            },
            /*Spine.Unity.BoneFollowerGraphic.LateUpdate end.*/


        }
    });
    /*Spine.Unity.BoneFollowerGraphic end.*/

    /*Spine.Unity.BoundingBoxFollower start.*/
    Bridge.define("Spine.Unity.BoundingBoxFollower", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                DebugMessages: false
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#init", this ); }

                    this.DebugMessages = true;
                }
            }
        },
        fields: {
            skeletonRenderer: null,
            slotName: null,
            isTrigger: false,
            usedByEffector: false,
            usedByComposite: false,
            clearStateOnDisable: false,
            slot: null,
            currentAttachment: null,
            currentAttachmentName: null,
            currentCollider: null,
            colliderTable: null,
            nameTable: null
        },
        props: {
            Slot: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#Slot#get", this ); }

                    return this.slot;
                }
            },
            CurrentAttachment: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#CurrentAttachment#get", this ); }

                    return this.currentAttachment;
                }
            },
            CurrentAttachmentName: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#CurrentAttachmentName#get", this ); }

                    return this.currentAttachmentName;
                }
            },
            CurrentCollider: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#CurrentCollider#get", this ); }

                    return this.currentCollider;
                }
            },
            IsTrigger: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#IsTrigger#get", this ); }

                    return this.isTrigger;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#init", this ); }

                this.clearStateOnDisable = true;
                this.colliderTable = new (System.Collections.Generic.Dictionary$2(spine.BoundingBoxAttachment,UnityEngine.PolygonCollider2D)).ctor();
                this.nameTable = new (System.Collections.Generic.Dictionary$2(spine.BoundingBoxAttachment,System.String)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.BoundingBoxFollower.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#Start", this ); }

                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollower.Start end.*/

            /*Spine.Unity.BoundingBoxFollower.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                    this.skeletonRenderer.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                }

                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollower.OnEnable end.*/

            /*Spine.Unity.BoundingBoxFollower.HandleRebuild start.*/
            HandleRebuild: function (sr) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#HandleRebuild", this ); }

                //if (BoundingBoxFollower.DebugMessages) Debug.Log("Skeleton was rebuilt. Repopulating BoundingBoxFollower.");
                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollower.HandleRebuild end.*/

            /*Spine.Unity.BoundingBoxFollower.Initialize start.*/
            /**
             * Initialize and instantiate the BoundingBoxFollower colliders. This is method checks if the BoundingBoxFollower has already been initialized for the skeleton instance and slotName and prevents overwriting unless it detects a new setup.
             *
             * @instance
             * @public
             * @this Spine.Unity.BoundingBoxFollower
             * @memberof Spine.Unity.BoundingBoxFollower
             * @param   {boolean}    overwrite
             * @return  {void}
             */
            Initialize: function (overwrite) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#Initialize", this ); }

                var $t;
                if (overwrite === void 0) { overwrite = false; }
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    return;
                }

                this.skeletonRenderer.Initialize(false);

                if (System.String.isNullOrEmpty(this.slotName)) {
                    return;
                }

                // Don't reinitialize if the setup did not change.
                if (!overwrite && this.colliderTable.Count > 0 && this.slot != null && Bridge.referenceEquals(this.skeletonRenderer.skeleton, this.slot.getSkeleton()) && Bridge.referenceEquals(this.slotName, this.slot.data.name)) {
                    return;
                }

                this.slot = null;
                this.currentAttachment = null;
                this.currentAttachmentName = null;
                this.currentCollider = null;
                this.colliderTable.clear();
                this.nameTable.clear();

                var skeleton = this.skeletonRenderer.skeleton;
                if (skeleton == null) {
                    return;
                }
                this.slot = skeleton.findSlot(this.slotName);
                if (this.slot == null) {
                    if (Spine.Unity.BoundingBoxFollower.DebugMessages) {
                        UnityEngine.Debug.LogWarning$1(System.String.format("Slot '{0}' not found for BoundingBoxFollower on '{1}'. (Previous colliders were disposed.)", this.slotName, this.gameObject.name));
                    }
                    return;
                }
                var slotIndex = this.slot.data.index;

                var requiredCollidersCount = { v : 0 };
                var colliders = this.GetComponents(UnityEngine.PolygonCollider2D);
                if (this.gameObject.activeInHierarchy) {
                    $t = Bridge.getEnumerator(skeleton.data.Skins);
                    try {
                        while ($t.moveNext()) {
                            var skin = $t.Current;
                            this.AddCollidersForSkin(skin, slotIndex, colliders, requiredCollidersCount);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    if (skeleton.skin != null) {
                        this.AddCollidersForSkin(skeleton.skin, slotIndex, colliders, requiredCollidersCount);
                    }
                }
                this.DisposeExcessCollidersAfter(requiredCollidersCount.v);

                if (Spine.Unity.BoundingBoxFollower.DebugMessages) {
                    var valid = this.colliderTable.Count !== 0;
                    if (!valid) {
                        if (this.gameObject.activeInHierarchy) {
                            UnityEngine.Debug.LogWarning$1("Bounding Box Follower not valid! Slot [" + (this.slotName || "") + "] does not contain any Bounding Box Attachments!");
                        } else {
                            UnityEngine.Debug.LogWarning$1("Bounding Box Follower tried to rebuild as a prefab.");
                        }
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollower.Initialize end.*/

            /*Spine.Unity.BoundingBoxFollower.AddCollidersForSkin start.*/
            AddCollidersForSkin: function (skin, slotIndex, previousColliders, collidersCount) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#AddCollidersForSkin", this ); }

                var $t;
                if (skin == null) {
                    return;
                }
                var skinEntries = new (System.Collections.Generic.List$1(spine.SkinEntry)).ctor();
                ( skinEntries._items.length = 0, skin.getAttachmentsForSlot( slotIndex, skinEntries._items ), skinEntries._size = skinEntries._items.length );

                $t = Bridge.getEnumerator(skinEntries);
                try {
                    while ($t.moveNext()) {
                        var entry = $t.Current;
                        var attachment = skin.getAttachment(slotIndex, entry.name);
                        var boundingBoxAttachment = Bridge.as(attachment, spine.BoundingBoxAttachment);

                        if (Spine.Unity.BoundingBoxFollower.DebugMessages && attachment != null && boundingBoxAttachment == null) {
                            UnityEngine.Debug.Log$1("BoundingBoxFollower tried to follow a slot that contains non-boundingbox attachments: " + (this.slotName || ""));
                        }

                        if (boundingBoxAttachment != null) {
                            if (!this.colliderTable.containsKey(boundingBoxAttachment)) {
                                var bbCollider = collidersCount.v < previousColliders.length ? previousColliders[collidersCount.v] : this.gameObject.AddComponent(UnityEngine.PolygonCollider2D);
                                collidersCount.v = (collidersCount.v + 1) | 0;
                                Spine.Unity.SkeletonUtility.SetColliderPointsLocal(bbCollider, this.slot, boundingBoxAttachment);
                                bbCollider.isTrigger = this.isTrigger;
                                bbCollider.usedByEffector = this.usedByEffector;
                                bbCollider.usedByComposite = this.usedByComposite;
                                bbCollider.enabled = false;
                                bbCollider.hideFlags = UnityEngine.HideFlags.NotEditable;
                                this.colliderTable.add(boundingBoxAttachment, bbCollider);
                                this.nameTable.add(boundingBoxAttachment, entry.name);
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollower.AddCollidersForSkin end.*/

            /*Spine.Unity.BoundingBoxFollower.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#OnDisable", this ); }

                if (this.clearStateOnDisable) {
                    this.ClearState();
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                }
            },
            /*Spine.Unity.BoundingBoxFollower.OnDisable end.*/

            /*Spine.Unity.BoundingBoxFollower.ClearState start.*/
            ClearState: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#ClearState", this ); }

                var $t;
                if (this.colliderTable != null) {
                    $t = Bridge.getEnumerator(this.colliderTable.Values);
                    try {
                        while ($t.moveNext()) {
                            var col = $t.Current;
                            col.enabled = false;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }

                this.currentAttachment = null;
                this.currentAttachmentName = null;
                this.currentCollider = null;
            },
            /*Spine.Unity.BoundingBoxFollower.ClearState end.*/

            /*Spine.Unity.BoundingBoxFollower.DisposeExcessCollidersAfter start.*/
            DisposeExcessCollidersAfter: function (requiredCount) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#DisposeExcessCollidersAfter", this ); }

                var colliders = this.GetComponents(UnityEngine.PolygonCollider2D);
                if (colliders.length === 0) {
                    return;
                }

                for (var i = requiredCount; i < colliders.length; i = (i + 1) | 0) {
                    var collider = colliders[i];
                    if (UnityEngine.Component.op_Inequality(collider, null)) {
                        UnityEngine.Object.Destroy(collider);
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollower.DisposeExcessCollidersAfter end.*/

            /*Spine.Unity.BoundingBoxFollower.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#LateUpdate", this ); }

                if (this.slot != null && !Bridge.referenceEquals(this.slot.getAttachment(), this.currentAttachment)) {
                    this.MatchAttachment(this.slot.getAttachment());
                }
            },
            /*Spine.Unity.BoundingBoxFollower.LateUpdate end.*/

            /*Spine.Unity.BoundingBoxFollower.MatchAttachment start.*/
            /**
             * Sets the current collider to match attachment.
             *
             * @instance
             * @private
             * @this Spine.Unity.BoundingBoxFollower
             * @memberof Spine.Unity.BoundingBoxFollower
             * @param   {spine.Attachment}    attachment    If the attachment is not a bounding box, it will be treated as null.
             * @return  {void}
             */
            MatchAttachment: function (attachment) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#MatchAttachment", this ); }

                var bbAttachment = Bridge.as(attachment, spine.BoundingBoxAttachment);

                if (Spine.Unity.BoundingBoxFollower.DebugMessages && attachment != null && bbAttachment == null) {
                    UnityEngine.Debug.LogWarning$1("BoundingBoxFollower tried to match a non-boundingbox attachment. It will treat it as null.");
                }

                if (UnityEngine.Component.op_Inequality(this.currentCollider, null)) {
                    this.currentCollider.enabled = false;
                }

                if (bbAttachment == null) {
                    this.currentCollider = null;
                    this.currentAttachment = null;
                    this.currentAttachmentName = null;
                } else {
                    var foundCollider = { };
                    this.colliderTable.tryGetValue(bbAttachment, foundCollider);
                    if (UnityEngine.Component.op_Inequality(foundCollider.v, null)) {
                        this.currentCollider = foundCollider.v;
                        this.currentCollider.enabled = true;
                        this.currentAttachment = bbAttachment;
                        this.currentAttachmentName = this.nameTable.getItem(bbAttachment);
                    } else {
                        this.currentCollider = null;
                        this.currentAttachment = bbAttachment;
                        this.currentAttachmentName = null;
                        if (Spine.Unity.BoundingBoxFollower.DebugMessages) {
                            UnityEngine.Debug.LogFormat("Collider for BoundingBoxAttachment named '{0}' was not initialized. It is possibly from a new skin. currentAttachmentName will be null. You may need to call BoundingBoxFollower.Initialize(overwrite: true);", [bbAttachment.name]);
                        }
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollower.MatchAttachment end.*/


        }
    });
    /*Spine.Unity.BoundingBoxFollower end.*/

    /*Spine.Unity.BoundingBoxFollowerGraphic start.*/
    Bridge.define("Spine.Unity.BoundingBoxFollowerGraphic", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                DebugMessages: false
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#init", this ); }

                    this.DebugMessages = true;
                }
            }
        },
        fields: {
            skeletonGraphic: null,
            slotName: null,
            isTrigger: false,
            usedByEffector: false,
            usedByComposite: false,
            clearStateOnDisable: false,
            slot: null,
            currentAttachment: null,
            currentAttachmentName: null,
            currentCollider: null,
            colliderTable: null,
            nameTable: null
        },
        props: {
            Slot: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#Slot#get", this ); }

                    return this.slot;
                }
            },
            CurrentAttachment: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#CurrentAttachment#get", this ); }

                    return this.currentAttachment;
                }
            },
            CurrentAttachmentName: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#CurrentAttachmentName#get", this ); }

                    return this.currentAttachmentName;
                }
            },
            CurrentCollider: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#CurrentCollider#get", this ); }

                    return this.currentCollider;
                }
            },
            IsTrigger: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#IsTrigger#get", this ); }

                    return this.isTrigger;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#init", this ); }

                this.clearStateOnDisable = true;
                this.colliderTable = new (System.Collections.Generic.Dictionary$2(spine.BoundingBoxAttachment,UnityEngine.PolygonCollider2D)).ctor();
                this.nameTable = new (System.Collections.Generic.Dictionary$2(spine.BoundingBoxAttachment,System.String)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.BoundingBoxFollowerGraphic.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#Start", this ); }

                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.Start end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                    this.skeletonGraphic.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                }

                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.OnEnable end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.HandleRebuild start.*/
            HandleRebuild: function (sr) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#HandleRebuild", this ); }

                //if (BoundingBoxFollowerGraphic.DebugMessages) Debug.Log("Skeleton was rebuilt. Repopulating BoundingBoxFollowerGraphic.");
                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.HandleRebuild end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.Initialize start.*/
            /**
             * Initialize and instantiate the BoundingBoxFollowerGraphic colliders. This is method checks if the BoundingBoxFollowerGraphic has already been initialized for the skeleton instance and slotName and prevents overwriting unless it detects a new setup.
             *
             * @instance
             * @public
             * @this Spine.Unity.BoundingBoxFollowerGraphic
             * @memberof Spine.Unity.BoundingBoxFollowerGraphic
             * @param   {boolean}    overwrite
             * @return  {void}
             */
            Initialize: function (overwrite) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#Initialize", this ); }

                var $t;
                if (overwrite === void 0) { overwrite = false; }
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    return;
                }

                this.skeletonGraphic.Initialize(false);

                if (System.String.isNullOrEmpty(this.slotName)) {
                    return;
                }

                // Don't reinitialize if the setup did not change.
                if (!overwrite && this.colliderTable.Count > 0 && this.slot != null && Bridge.referenceEquals(this.skeletonGraphic.Skeleton, this.slot.getSkeleton()) && Bridge.referenceEquals(this.slotName, this.slot.data.name)) {
                    return;
                }

                this.slot = null;
                this.currentAttachment = null;
                this.currentAttachmentName = null;
                this.currentCollider = null;
                this.colliderTable.clear();
                this.nameTable.clear();

                var skeleton = this.skeletonGraphic.Skeleton;
                if (skeleton == null) {
                    return;
                }
                this.slot = skeleton.findSlot(this.slotName);
                if (this.slot == null) {
                    if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages) {
                        UnityEngine.Debug.LogWarning$1(System.String.format("Slot '{0}' not found for BoundingBoxFollowerGraphic on '{1}'. (Previous colliders were disposed.)", this.slotName, this.gameObject.name));
                    }
                    return;
                }
                var slotIndex = this.slot.data.index;

                var requiredCollidersCount = { v : 0 };
                var colliders = this.GetComponents(UnityEngine.PolygonCollider2D);
                if (this.gameObject.activeInHierarchy) {
                    var scale = this.skeletonGraphic.MeshScale;
                    $t = Bridge.getEnumerator(skeleton.data.Skins);
                    try {
                        while ($t.moveNext()) {
                            var skin = $t.Current;
                            this.AddCollidersForSkin(skin, slotIndex, colliders, scale, requiredCollidersCount);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    if (skeleton.skin != null) {
                        this.AddCollidersForSkin(skeleton.skin, slotIndex, colliders, scale, requiredCollidersCount);
                    }
                }
                this.DisposeExcessCollidersAfter(requiredCollidersCount.v);

                if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages) {
                    var valid = this.colliderTable.Count !== 0;
                    if (!valid) {
                        if (this.gameObject.activeInHierarchy) {
                            UnityEngine.Debug.LogWarning$1("Bounding Box Follower not valid! Slot [" + (this.slotName || "") + "] does not contain any Bounding Box Attachments!");
                        } else {
                            UnityEngine.Debug.LogWarning$1("Bounding Box Follower tried to rebuild as a prefab.");
                        }
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.Initialize end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.AddCollidersForSkin start.*/
            AddCollidersForSkin: function (skin, slotIndex, previousColliders, scale, collidersCount) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#AddCollidersForSkin", this ); }

                var $t;
                if (skin == null) {
                    return;
                }
                var skinEntries = new (System.Collections.Generic.List$1(spine.SkinEntry)).ctor();
                ( skinEntries._items.length = 0, skin.getAttachmentsForSlot( slotIndex, skinEntries._items ), skinEntries._size = skinEntries._items.length );

                $t = Bridge.getEnumerator(skinEntries);
                try {
                    while ($t.moveNext()) {
                        var entry = $t.Current;
                        var attachment = skin.getAttachment(slotIndex, entry.name);
                        var boundingBoxAttachment = Bridge.as(attachment, spine.BoundingBoxAttachment);

                        if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages && attachment != null && boundingBoxAttachment == null) {
                            UnityEngine.Debug.Log$1("BoundingBoxFollowerGraphic tried to follow a slot that contains non-boundingbox attachments: " + (this.slotName || ""));
                        }

                        if (boundingBoxAttachment != null) {
                            if (!this.colliderTable.containsKey(boundingBoxAttachment)) {
                                var bbCollider = collidersCount.v < previousColliders.length ? previousColliders[collidersCount.v] : this.gameObject.AddComponent(UnityEngine.PolygonCollider2D);
                                collidersCount.v = (collidersCount.v + 1) | 0;
                                Spine.Unity.SkeletonUtility.SetColliderPointsLocal(bbCollider, this.slot, boundingBoxAttachment, scale);
                                bbCollider.isTrigger = this.isTrigger;
                                bbCollider.usedByEffector = this.usedByEffector;
                                bbCollider.usedByComposite = this.usedByComposite;
                                bbCollider.enabled = false;
                                bbCollider.hideFlags = UnityEngine.HideFlags.NotEditable;
                                this.colliderTable.add(boundingBoxAttachment, bbCollider);
                                this.nameTable.add(boundingBoxAttachment, entry.name);
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.AddCollidersForSkin end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#OnDisable", this ); }

                if (this.clearStateOnDisable) {
                    this.ClearState();
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.OnDisable end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.ClearState start.*/
            ClearState: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#ClearState", this ); }

                var $t;
                if (this.colliderTable != null) {
                    $t = Bridge.getEnumerator(this.colliderTable.Values);
                    try {
                        while ($t.moveNext()) {
                            var col = $t.Current;
                            col.enabled = false;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }

                this.currentAttachment = null;
                this.currentAttachmentName = null;
                this.currentCollider = null;
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.ClearState end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.DisposeExcessCollidersAfter start.*/
            DisposeExcessCollidersAfter: function (requiredCount) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#DisposeExcessCollidersAfter", this ); }

                var colliders = this.GetComponents(UnityEngine.PolygonCollider2D);
                if (colliders.length === 0) {
                    return;
                }

                for (var i = requiredCount; i < colliders.length; i = (i + 1) | 0) {
                    var collider = colliders[i];
                    if (UnityEngine.Component.op_Inequality(collider, null)) {
                        UnityEngine.Object.Destroy(collider);
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.DisposeExcessCollidersAfter end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#LateUpdate", this ); }

                if (this.slot != null && !Bridge.referenceEquals(this.slot.getAttachment(), this.currentAttachment)) {
                    this.MatchAttachment(this.slot.getAttachment());
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.LateUpdate end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.MatchAttachment start.*/
            /**
             * Sets the current collider to match attachment.
             *
             * @instance
             * @private
             * @this Spine.Unity.BoundingBoxFollowerGraphic
             * @memberof Spine.Unity.BoundingBoxFollowerGraphic
             * @param   {spine.Attachment}    attachment    If the attachment is not a bounding box, it will be treated as null.
             * @return  {void}
             */
            MatchAttachment: function (attachment) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#MatchAttachment", this ); }

                var bbAttachment = Bridge.as(attachment, spine.BoundingBoxAttachment);

                if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages && attachment != null && bbAttachment == null) {
                    UnityEngine.Debug.LogWarning$1("BoundingBoxFollowerGraphic tried to match a non-boundingbox attachment. It will treat it as null.");
                }

                if (UnityEngine.Component.op_Inequality(this.currentCollider, null)) {
                    this.currentCollider.enabled = false;
                }

                if (bbAttachment == null) {
                    this.currentCollider = null;
                    this.currentAttachment = null;
                    this.currentAttachmentName = null;
                } else {
                    var foundCollider = { };
                    this.colliderTable.tryGetValue(bbAttachment, foundCollider);
                    if (UnityEngine.Component.op_Inequality(foundCollider.v, null)) {
                        this.currentCollider = foundCollider.v;
                        this.currentCollider.enabled = true;
                        this.currentAttachment = bbAttachment;
                        this.currentAttachmentName = this.nameTable.getItem(bbAttachment);
                    } else {
                        this.currentCollider = null;
                        this.currentAttachment = bbAttachment;
                        this.currentAttachmentName = null;
                        if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages) {
                            UnityEngine.Debug.LogFormat("Collider for BoundingBoxAttachment named '{0}' was not initialized. It is possibly from a new skin. currentAttachmentName will be null. You may need to call BoundingBoxFollowerGraphic.Initialize(overwrite: true);", [bbAttachment.name]);
                        }
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.MatchAttachment end.*/


        }
    });
    /*Spine.Unity.BoundingBoxFollowerGraphic end.*/

    /*Spine.Unity.DoubleBuffered$1 start.*/
    Bridge.define("Spine.Unity.DoubleBuffered$1", function (T) { return {
        fields: {
            a: null,
            b: null,
            usingA: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.DoubleBuffered$1#init", this ); }

                this.a = Bridge.createInstance(T);
                this.b = Bridge.createInstance(T);
            }
        },
        methods: {
            /*Spine.Unity.DoubleBuffered$1.GetCurrent start.*/
            GetCurrent: function () {
if ( TRACE ) { TRACE( "Spine.Unity.DoubleBuffered$1#GetCurrent", this ); }

                return this.usingA ? Bridge.rValue(this.a) : Bridge.rValue(this.b);
            },
            /*Spine.Unity.DoubleBuffered$1.GetCurrent end.*/

            /*Spine.Unity.DoubleBuffered$1.GetNext start.*/
            GetNext: function () {
if ( TRACE ) { TRACE( "Spine.Unity.DoubleBuffered$1#GetNext", this ); }

                this.usingA = !this.usingA;
                return this.usingA ? Bridge.rValue(this.a) : Bridge.rValue(this.b);
            },
            /*Spine.Unity.DoubleBuffered$1.GetNext end.*/


        }
    }; });
    /*Spine.Unity.DoubleBuffered$1 end.*/

    /*Spine.Unity.EventDataReferenceAsset start.*/
    Bridge.define("Spine.Unity.EventDataReferenceAsset", {
        inherits: [UnityEngine.ScriptableObject],
        statics: {
            fields: {
                QuietSkeletonData: false
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.EventDataReferenceAsset#init", this ); }

                    this.QuietSkeletonData = true;
                }
            },
            methods: {
                op_Implicit: function (asset) {
if ( TRACE ) { TRACE( "Spine.Unity.EventDataReferenceAsset#op_Implicit", this ); }

                    return asset.EventData;
                }
            }
        },
        fields: {
            skeletonDataAsset: null,
            eventName: null,
            eventData: null
        },
        props: {
            EventData: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.EventDataReferenceAsset#EventData#get", this ); }

                    if (this.eventData == null) {
                        this.Initialize();
                    }
                    return this.eventData;
                }
            }
        },
        methods: {
            /*Spine.Unity.EventDataReferenceAsset.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.EventDataReferenceAsset#Initialize", this ); }

                if (this.skeletonDataAsset == null) {
                    return;
                }
                this.eventData = this.skeletonDataAsset.GetSkeletonData(Spine.Unity.EventDataReferenceAsset.QuietSkeletonData).findEvent(this.eventName);
                if (this.eventData == null) {
                    UnityEngine.Debug.LogWarningFormat("Event Data '{0}' not found in SkeletonData : {1}.", [this.eventName, this.skeletonDataAsset.name]);
                }
            },
            /*Spine.Unity.EventDataReferenceAsset.Initialize end.*/


        }
    });
    /*Spine.Unity.EventDataReferenceAsset end.*/

    /*Spine.Unity.Examples.AnimationMatchModifierAsset+AnimationTools start.*/
    Bridge.define("Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools", {
        $kind: 1002,
        statics: {
            methods: {
                /*Spine.Unity.Examples.AnimationMatchModifierAsset+AnimationTools.MatchAnimationTimelines:static start.*/
                /**
                 * Matches the animation timelines across the given set of animations.
                 This allows unkeyed properties to assume setup pose when animations are naively mixed using Animation.Apply.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools
                 * @memberof Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools
                 * @param   {System.Collections.Generic.IEnumerable$1}    animations      An enumerable collection animations whose timelines will be matched.
                 * @param   {Spine.SkeletonData}                          skeletonData    The SkeletonData where the animations belong.
                 * @return  {void}
                 */
                MatchAnimationTimelines: function (animations, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools#MatchAnimationTimelines", this ); }

                    var $t, $t1, $t2, $t3, $t4, $t5, $t6;
                    if (animations == null) {
                        return;
                    }
                    if (skeletonData == null) {
                        throw new System.ArgumentNullException.$ctor3("skeletonData", "Timelines can't be matched without a SkeletonData source.");
                    }

                    // Build a reference collection of timelines to match
                    // and a collection of dummy timelines that can be used to fill-in missing items.
                    var timelineDictionary = new (System.Collections.Generic.Dictionary$2(System.String,spine.Timeline)).ctor();
                    $t = Bridge.getEnumerator(animations, Spine.Animation);
                    try {
                        while ($t.moveNext()) {
                            var animation = $t.Current;
                            $t1 = Bridge.getEnumerator(animation.Timelines);
                            try {
                                while ($t1.moveNext()) {
                                    var timeline = $t1.Current;
                                    if (Bridge.is(timeline, spine.EventTimeline)) {
                                        continue;
                                    }

                                    $t2 = Bridge.getEnumerator(timeline.getPropertyIds());
                                    try {
                                        while ($t2.moveNext()) {
                                            var propertyId = $t2.Current;
                                            if (!timelineDictionary.containsKey(propertyId)) {
                                                timelineDictionary.add(propertyId, Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools.GetFillerTimeline$12(timeline, skeletonData));
                                            }
                                        }
                                    } finally {
                                        if (Bridge.is($t2, System.IDisposable)) {
                                            $t2.System$IDisposable$Dispose();
                                        }
                                    }
                                }
                            } finally {
                                if (Bridge.is($t1, System.IDisposable)) {
                                    $t1.System$IDisposable$Dispose();
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    var idsToMatch = new (System.Collections.Generic.List$1(System.String)).$ctor1(timelineDictionary.Keys);

                    // For each animation in the list, check for and add missing timelines.
                    var currentAnimationIDs = new (System.Collections.Generic.HashSet$1(System.String)).ctor();
                    $t3 = Bridge.getEnumerator(animations, Spine.Animation);
                    try {
                        while ($t3.moveNext()) {
                            var animation1 = $t3.Current;
                            currentAnimationIDs.clear();
                            $t4 = Bridge.getEnumerator(animation1.Timelines);
                            try {
                                while ($t4.moveNext()) {
                                    var timeline1 = $t4.Current;
                                    if (Bridge.is(timeline1, spine.EventTimeline)) {
                                        continue;
                                    }
                                    $t5 = Bridge.getEnumerator(timeline1.getPropertyIds());
                                    try {
                                        while ($t5.moveNext()) {
                                            var propertyId1 = $t5.Current;
                                            currentAnimationIDs.add(propertyId1);
                                        }
                                    } finally {
                                        if (Bridge.is($t5, System.IDisposable)) {
                                            $t5.System$IDisposable$Dispose();
                                        }
                                    }
                                }
                            } finally {
                                if (Bridge.is($t4, System.IDisposable)) {
                                    $t4.System$IDisposable$Dispose();
                                }
                            }

                            var animationTimelines = animation1.Timelines;
                            $t6 = Bridge.getEnumerator(idsToMatch);
                            try {
                                while ($t6.moveNext()) {
                                    var propertyId2 = $t6.Current;
                                    if (!currentAnimationIDs.contains(propertyId2)) {
                                        animationTimelines.Add(timelineDictionary.getItem(propertyId2));
                                    }
                                }
                            } finally {
                                if (Bridge.is($t6, System.IDisposable)) {
                                    $t6.System$IDisposable$Dispose();
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t3, System.IDisposable)) {
                            $t3.System$IDisposable$Dispose();
                        }
                    }

                    // These are locals, but sometimes Unity's GC does weird stuff. So let's clean up.
                    timelineDictionary.clear();
                    timelineDictionary = null;
                    idsToMatch.clear();
                    idsToMatch = null;
                    currentAnimationIDs.clear();
                    currentAnimationIDs = null;
                },
                /*Spine.Unity.Examples.AnimationMatchModifierAsset+AnimationTools.MatchAnimationTimelines:static end.*/

                /*Spine.Unity.Examples.AnimationMatchModifierAsset+AnimationTools.GetFillerTimeline$12:static start.*/
                GetFillerTimeline$12: function (timeline, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools#GetFillerTimeline$12", this ); }

                    if (Bridge.is(timeline, spine.RotateTimeline)) {
                        return Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools.GetFillerTimeline$9(Bridge.cast(timeline, spine.RotateTimeline), skeletonData);
                    }
                    if (Bridge.is(timeline, spine.TranslateTimeline)) {
                        return Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools.GetFillerTimeline$14(Bridge.cast(timeline, spine.TranslateTimeline), skeletonData);
                    }
                    if (Bridge.is(timeline, spine.ScaleTimeline)) {
                        return Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools.GetFillerTimeline$10(Bridge.cast(timeline, spine.ScaleTimeline), skeletonData);
                    }
                    if (Bridge.is(timeline, spine.ShearTimeline)) {
                        return Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools.GetFillerTimeline$11(Bridge.cast(timeline, spine.ShearTimeline), skeletonData);
                    }
                    if (Bridge.is(timeline, spine.AttachmentTimeline)) {
                        return Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools.GetFillerTimeline(Bridge.cast(timeline, spine.AttachmentTimeline), skeletonData);
                    }
                    if (Bridge.is(timeline, spine.RGBATimeline)) {
                        return Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools.GetFillerTimeline$8(Bridge.cast(timeline, spine.RGBATimeline), skeletonData);
                    }
                    if (Bridge.is(timeline, spine.RGBA2Timeline)) {
                        return Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools.GetFillerTimeline$7(Bridge.cast(timeline, spine.RGBA2Timeline), skeletonData);
                    }
                    if (Bridge.is(timeline, spine.DeformTimeline)) {
                        return Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools.GetFillerTimeline$1(Bridge.cast(timeline, spine.DeformTimeline), skeletonData);
                    }
                    if (Bridge.is(timeline, spine.DrawOrderTimeline)) {
                        return Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools.GetFillerTimeline$2(Bridge.cast(timeline, spine.DrawOrderTimeline), skeletonData);
                    }
                    if (Bridge.is(timeline, spine.IkConstraintTimeline)) {
                        return Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools.GetFillerTimeline$3(Bridge.cast(timeline, spine.IkConstraintTimeline), skeletonData);
                    }
                    if (Bridge.is(timeline, spine.TransformConstraintTimeline)) {
                        return Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools.GetFillerTimeline$13(Bridge.cast(timeline, spine.TransformConstraintTimeline), skeletonData);
                    }
                    if (Bridge.is(timeline, spine.PathConstraintPositionTimeline)) {
                        return Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools.GetFillerTimeline$5(Bridge.cast(timeline, spine.PathConstraintPositionTimeline), skeletonData);
                    }
                    if (Bridge.is(timeline, spine.PathConstraintSpacingTimeline)) {
                        return Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools.GetFillerTimeline$6(Bridge.cast(timeline, spine.PathConstraintSpacingTimeline), skeletonData);
                    }
                    if (Bridge.is(timeline, spine.PathConstraintMixTimeline)) {
                        return Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools.GetFillerTimeline$4(Bridge.cast(timeline, spine.PathConstraintMixTimeline), skeletonData);
                    }
                    return null;
                },
                /*Spine.Unity.Examples.AnimationMatchModifierAsset+AnimationTools.GetFillerTimeline$12:static end.*/

                /*Spine.Unity.Examples.AnimationMatchModifierAsset+AnimationTools.GetFillerTimeline$9:static start.*/
                GetFillerTimeline$9: function (timeline, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools#GetFillerTimeline$9", this ); }

                    var t = new spine.RotateTimeline( 1, 0, timeline.boneIndex );
                    t.setFrame(0, 0, 0);
                    return t;
                },
                /*Spine.Unity.Examples.AnimationMatchModifierAsset+AnimationTools.GetFillerTimeline$9:static end.*/

                /*Spine.Unity.Examples.AnimationMatchModifierAsset+AnimationTools.GetFillerTimeline$14:static start.*/
                GetFillerTimeline$14: function (timeline, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools#GetFillerTimeline$14", this ); }

                    var t = new spine.TranslateTimeline( 1, 0, timeline.boneIndex );
                    t.setFrame(0, 0, 0, 0);
                    return t;
                },
                /*Spine.Unity.Examples.AnimationMatchModifierAsset+AnimationTools.GetFillerTimeline$14:static end.*/

                /*Spine.Unity.Examples.AnimationMatchModifierAsset+AnimationTools.GetFillerTimeline$10:static start.*/
                GetFillerTimeline$10: function (timeline, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools#GetFillerTimeline$10", this ); }

                    var t = new spine.ScaleTimeline( 1, 0, timeline.boneIndex );
                    t.setFrame(0, 0, 0, 0);
                    return t;
                },
                /*Spine.Unity.Examples.AnimationMatchModifierAsset+AnimationTools.GetFillerTimeline$10:static end.*/

                /*Spine.Unity.Examples.AnimationMatchModifierAsset+AnimationTools.GetFillerTimeline$11:static start.*/
                GetFillerTimeline$11: function (timeline, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools#GetFillerTimeline$11", this ); }

                    var t = new spine.ShearTimeline( 1, 0, timeline.boneIndex );
                    t.setFrame(0, 0, 0, 0);
                    return t;
                },
                /*Spine.Unity.Examples.AnimationMatchModifierAsset+AnimationTools.GetFillerTimeline$11:static end.*/

                /*Spine.Unity.Examples.AnimationMatchModifierAsset+AnimationTools.GetFillerTimeline:static start.*/
                GetFillerTimeline: function (timeline, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools#GetFillerTimeline", this ); }

                    var $t;
                    var t = new spine.AttachmentTimeline( 1, timeline.slotIndex );
                    var slotData = ($t = skeletonData.Slots.Items)[t.slotIndex];
                    t.setFrame(0, 0, slotData.attachmentName);
                    return t;
                },
                /*Spine.Unity.Examples.AnimationMatchModifierAsset+AnimationTools.GetFillerTimeline:static end.*/

                /*Spine.Unity.Examples.AnimationMatchModifierAsset+AnimationTools.GetFillerTimeline$8:static start.*/
                GetFillerTimeline$8: function (timeline, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools#GetFillerTimeline$8", this ); }

                    var $t;
                    var t = new spine.RGBATimeline( 1, 0, timeline.slotIndex );
                    var slotData = ($t = skeletonData.Slots.Items)[t.slotIndex];
                    t.setFrame(0, 0, slotData.color.r, slotData.color.g, slotData.color.b, slotData.color.a);
                    return t;
                },
                /*Spine.Unity.Examples.AnimationMatchModifierAsset+AnimationTools.GetFillerTimeline$8:static end.*/

                /*Spine.Unity.Examples.AnimationMatchModifierAsset+AnimationTools.GetFillerTimeline$7:static start.*/
                GetFillerTimeline$7: function (timeline, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools#GetFillerTimeline$7", this ); }

                    var $t;
                    var t = new spine.RGBA2Timeline( 1, 0, timeline.slotIndex );
                    var slotData = ($t = skeletonData.Slots.Items)[t.slotIndex];
                    t.setFrame(0, 0, slotData.color.r, slotData.color.g, slotData.color.b, slotData.color.a, slotData.darkColor.r, slotData.darkColor.g, slotData.darkColor.b);
                    return t;
                },
                /*Spine.Unity.Examples.AnimationMatchModifierAsset+AnimationTools.GetFillerTimeline$7:static end.*/

                /*Spine.Unity.Examples.AnimationMatchModifierAsset+AnimationTools.GetFillerTimeline$1:static start.*/
                GetFillerTimeline$1: function (timeline, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools#GetFillerTimeline$1", this ); }

                    var t = new spine.DeformTimeline( 1, 0, timeline.slotIndex, timeline.attachment );
                    if (Spine.SpineSkeletonExtensions.IsWeighted(t.attachment)) {
                        t.setFrame(0, 0, System.Array.init(t.attachment.vertices.length, 0, System.Single));
                    } else {
                        t.setFrame(0, 0, Bridge.as(System.Array.clone(t.attachment.vertices), System.Array.type(System.Single)));
                    }

                    return t;
                },
                /*Spine.Unity.Examples.AnimationMatchModifierAsset+AnimationTools.GetFillerTimeline$1:static end.*/

                /*Spine.Unity.Examples.AnimationMatchModifierAsset+AnimationTools.GetFillerTimeline$2:static start.*/
                GetFillerTimeline$2: function (timeline, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools#GetFillerTimeline$2", this ); }

                    var t = new spine.DrawOrderTimeline( 1 );
                    t.setFrame(0, 0, null); // null means use setup pose in DrawOrderTimeline.Apply.
                    return t;
                },
                /*Spine.Unity.Examples.AnimationMatchModifierAsset+AnimationTools.GetFillerTimeline$2:static end.*/

                /*Spine.Unity.Examples.AnimationMatchModifierAsset+AnimationTools.GetFillerTimeline$3:static start.*/
                GetFillerTimeline$3: function (timeline, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools#GetFillerTimeline$3", this ); }

                    var $t;
                    var t = new spine.IkConstraintTimeline( 1, 0, timeline.ikConstraintIndex );
                    var ikConstraintData = ($t = skeletonData.IkConstraints.Items)[timeline.ikConstraintIndex];
                    t.setFrame(0, 0, ikConstraintData.mix, ikConstraintData.softness, ikConstraintData.bendDirection, ikConstraintData.compress, ikConstraintData.stretch);
                    return t;
                },
                /*Spine.Unity.Examples.AnimationMatchModifierAsset+AnimationTools.GetFillerTimeline$3:static end.*/

                /*Spine.Unity.Examples.AnimationMatchModifierAsset+AnimationTools.GetFillerTimeline$13:static start.*/
                GetFillerTimeline$13: function (timeline, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools#GetFillerTimeline$13", this ); }

                    var $t;
                    var t = new spine.TransformConstraintTimeline( 1, 0, timeline.transformConstraintIndex );
                    var data = ($t = skeletonData.TransformConstraints.Items)[timeline.transformConstraintIndex];
                    t.setFrame(0, 0, data.mixRotate, data.mixX, data.mixY, data.mixScaleX, data.mixScaleY, data.mixShearY);
                    return t;
                },
                /*Spine.Unity.Examples.AnimationMatchModifierAsset+AnimationTools.GetFillerTimeline$13:static end.*/

                /*Spine.Unity.Examples.AnimationMatchModifierAsset+AnimationTools.GetFillerTimeline$5:static start.*/
                GetFillerTimeline$5: function (timeline, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools#GetFillerTimeline$5", this ); }

                    var $t;
                    var t = new spine.PathConstraintPositionTimeline( 1, 0, timeline.pathConstraintIndex );
                    var data = ($t = skeletonData.PathConstraints.Items)[timeline.pathConstraintIndex];
                    t.setFrame(0, 0, data.position);
                    return t;
                },
                /*Spine.Unity.Examples.AnimationMatchModifierAsset+AnimationTools.GetFillerTimeline$5:static end.*/

                /*Spine.Unity.Examples.AnimationMatchModifierAsset+AnimationTools.GetFillerTimeline$6:static start.*/
                GetFillerTimeline$6: function (timeline, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools#GetFillerTimeline$6", this ); }

                    var $t;
                    var t = new spine.PathConstraintSpacingTimeline( 1, 0, timeline.pathConstraintIndex );
                    var data = ($t = skeletonData.PathConstraints.Items)[timeline.pathConstraintIndex];
                    t.setFrame(0, 0, data.spacing);
                    return t;
                },
                /*Spine.Unity.Examples.AnimationMatchModifierAsset+AnimationTools.GetFillerTimeline$6:static end.*/

                /*Spine.Unity.Examples.AnimationMatchModifierAsset+AnimationTools.GetFillerTimeline$4:static start.*/
                GetFillerTimeline$4: function (timeline, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools#GetFillerTimeline$4", this ); }

                    var $t;
                    var t = new spine.PathConstraintMixTimeline( 1, 0, timeline.pathConstraintIndex );
                    var data = ($t = skeletonData.PathConstraints.Items)[timeline.pathConstraintIndex];
                    t.setFrame(0, 0, data.mixRotate, data.mixX, data.mixY);
                    return t;
                },
                /*Spine.Unity.Examples.AnimationMatchModifierAsset+AnimationTools.GetFillerTimeline$4:static end.*/


            }
        }
    });
    /*Spine.Unity.Examples.AnimationMatchModifierAsset+AnimationTools end.*/

    /*Spine.Unity.Examples.AtlasRegionAttacher start.*/
    /** @namespace Spine.Unity.Examples */

    /**
     * Example code for a component that replaces the default attachment of a slot with an image from a Spine atlas.
     *
     * @public
     * @class Spine.Unity.Examples.AtlasRegionAttacher
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.Examples.AtlasRegionAttacher", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            atlasAsset: null,
            inheritProperties: false,
            attachments: null,
            atlas: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.AtlasRegionAttacher#init", this ); }

                this.inheritProperties = true;
                this.attachments = new (System.Collections.Generic.List$1(Spine.Unity.Examples.AtlasRegionAttacher.SlotRegionPair)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.Examples.AtlasRegionAttacher.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.AtlasRegionAttacher#Awake", this ); }

                var skeletonRenderer = this.GetComponent(Spine.Unity.SkeletonRenderer);
                skeletonRenderer.addOnRebuild(Bridge.fn.cacheBind(this, this.Apply));
                if (skeletonRenderer.valid) {
                    this.Apply(skeletonRenderer);
                }
            },
            /*Spine.Unity.Examples.AtlasRegionAttacher.Awake end.*/

            /*Spine.Unity.Examples.AtlasRegionAttacher.Apply start.*/
            Apply: function (skeletonRenderer) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.AtlasRegionAttacher#Apply", this ); }

                var $t;
                if (!this.enabled) {
                    return;
                }

                this.atlas = this.atlasAsset.GetAtlas();
                if (this.atlas == null) {
                    return;
                }
                var scale = skeletonRenderer.skeletonDataAsset.scale;

                $t = Bridge.getEnumerator(this.attachments);
                try {
                    while ($t.moveNext()) {
                        var entry = $t.Current;
                        var slot = skeletonRenderer.Skeleton.findSlot(entry.slot);
                        var originalAttachment = slot.getAttachment();
                        var region = this.atlas.findRegion(entry.region);

                        if (region == null) {
                            slot.setAttachment( null );
                        } else if (this.inheritProperties && originalAttachment != null) {
                            slot.setAttachment( Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone(originalAttachment, region, true, true, scale) );
                        } else {
                            var newRegionAttachment = Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment(region, region.name, scale);
                            slot.setAttachment( newRegionAttachment );
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.Examples.AtlasRegionAttacher.Apply end.*/


        }
    });
    /*Spine.Unity.Examples.AtlasRegionAttacher end.*/

    /*Spine.Unity.Examples.AtlasRegionAttacher+SlotRegionPair start.*/
    Bridge.define("Spine.Unity.Examples.AtlasRegionAttacher.SlotRegionPair", {
        $kind: 1002,
        fields: {
            slot: null,
            region: null
        }
    });
    /*Spine.Unity.Examples.AtlasRegionAttacher+SlotRegionPair end.*/

    /*Spine.Unity.Examples.AttackSpineboy start.*/
    Bridge.define("Spine.Unity.Examples.AttackSpineboy", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                maxHealth: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.AttackSpineboy#init", this ); }

                    this.maxHealth = 100;
                }
            }
        },
        fields: {
            spineboy: null,
            attackerSpineboy: null,
            gauge: null,
            healthText: null,
            currentHealth: 0,
            shoot: null,
            hit: null,
            idle: null,
            death: null,
            onAttack: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.AttackSpineboy#init", this ); }

                this.currentHealth = 100;
            }
        },
        methods: {
            /*Spine.Unity.Examples.AttackSpineboy.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.AttackSpineboy#Update", this ); }

                if (UnityEngine.Input.GetKeyDown(UnityEngine.KeyCode.Space)) {
                    this.currentHealth = (this.currentHealth - 10) | 0;
                    this.healthText.text = this.currentHealth + "/" + Spine.Unity.Examples.AttackSpineboy.maxHealth;

                    this.attackerSpineboy.AnimationState.setAnimationWith( 1, Spine.Unity.AnimationReferenceAsset.op_Implicit(this.shoot), false );
                    this.attackerSpineboy.AnimationState.addEmptyAnimation(1, 0.5, 2.0);

                    if (this.currentHealth > 0) {
                        this.spineboy.AnimationState.setAnimationWith( 0, Spine.Unity.AnimationReferenceAsset.op_Implicit(this.hit), false );
                        this.spineboy.AnimationState.addAnimationWith( 0, Spine.Unity.AnimationReferenceAsset.op_Implicit(this.idle), true, 0 );
                        this.gauge.fillPercent = this.currentHealth / 100.0;
                        this.onAttack.Invoke();
                    } else {
                        if (this.currentHealth >= 0) {
                            this.gauge.fillPercent = 0;
                            this.spineboy.AnimationState.setAnimationWith( 0, Spine.Unity.AnimationReferenceAsset.op_Implicit(this.death), false ).trackEnd = Number.POSITIVE_INFINITY;
                        }
                    }
                }
            },
            /*Spine.Unity.Examples.AttackSpineboy.Update end.*/


        }
    });
    /*Spine.Unity.Examples.AttackSpineboy end.*/

    /*Spine.Unity.Examples.BasicPlatformerController start.*/
    Bridge.define("Spine.Unity.Examples.BasicPlatformerController", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            controller: null,
            XAxis: null,
            YAxis: null,
            JumpButton: null,
            walkSpeed: 0,
            runSpeed: 0,
            gravityScale: 0,
            jumpSpeed: 0,
            minimumJumpDuration: 0,
            jumpInterruptFactor: 0,
            forceCrouchVelocity: 0,
            forceCrouchDuration: 0,
            animationHandle: null,
            input: null,
            velocity: null,
            minimumJumpEndTime: 0,
            forceCrouchEndTime: 0,
            wasGrounded: false,
            previousState: 0,
            currentState: 0
        },
        events: {
            OnJump: null,
            OnLand: null,
            OnHardLand: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.BasicPlatformerController#init", this ); }

                this.input = new UnityEngine.Vector2();
                this.velocity = new UnityEngine.Vector3();
                this.XAxis = "Horizontal";
                this.YAxis = "Vertical";
                this.JumpButton = "Jump";
                this.walkSpeed = 1.5;
                this.runSpeed = 7.0;
                this.gravityScale = 6.6;
                this.jumpSpeed = 25;
                this.minimumJumpDuration = 0.5;
                this.jumpInterruptFactor = 0.5;
                this.forceCrouchVelocity = 25;
                this.forceCrouchDuration = 0.5;
                this.input = Bridge.getDefaultValue(UnityEngine.Vector2);
                this.velocity = Bridge.getDefaultValue(UnityEngine.Vector3);
                this.minimumJumpEndTime = 0;
                this.wasGrounded = false;
            }
        },
        methods: {
            /*Spine.Unity.Examples.BasicPlatformerController.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.BasicPlatformerController#Update", this ); }

                var $t;
                var dt = UnityEngine.Time.deltaTime;
                var isGrounded = this.controller.isGrounded;
                var landed = !this.wasGrounded && isGrounded;

                // Dummy input.
                this.input.x = UnityEngine.Input.GetAxis(this.XAxis);
                this.input.y = UnityEngine.Input.GetAxis(this.YAxis);
                var inputJumpStop = UnityEngine.Input.GetButtonUp(this.JumpButton);
                var inputJumpStart = UnityEngine.Input.GetButtonDown(this.JumpButton);
                var doCrouch = (isGrounded && this.input.y < -0.5) || (this.forceCrouchEndTime > UnityEngine.Time.time);
                var doJumpInterrupt = false;
                var doJump = false;
                var hardLand = false;

                if (landed) {
                    if (-this.velocity.y > this.forceCrouchVelocity) {
                        hardLand = true;
                        doCrouch = true;
                        this.forceCrouchEndTime = UnityEngine.Time.time + this.forceCrouchDuration;
                    }
                }

                if (!doCrouch) {
                    if (isGrounded) {
                        if (inputJumpStart) {
                            doJump = true;
                        }
                    } else {
                        doJumpInterrupt = inputJumpStop && UnityEngine.Time.time < this.minimumJumpEndTime;
                    }
                }

                // Dummy physics and controller using UnityEngine.CharacterController.
                var gravityDeltaVelocity = UnityEngine.Physics.gravity.$clone().clone().scale( this.gravityScale ).clone().scale( dt );

                if (doJump) {
                    this.velocity.y = this.jumpSpeed;
                    this.minimumJumpEndTime = UnityEngine.Time.time + this.minimumJumpDuration;
                } else if (doJumpInterrupt) {
                    if (this.velocity.y > 0) {
                        this.velocity.y *= this.jumpInterruptFactor;
                    }
                }

                this.velocity.x = 0;
                if (!doCrouch) {
                    if (this.input.x !== 0) {
                        this.velocity.x = Math.abs(this.input.x) > 0.6 ? this.runSpeed : this.walkSpeed;
                        this.velocity.x *= ($t = this.input.x, ($t === 0 ? 1 : Math.sign($t)));
                    }
                }


                if (!isGrounded) {
                    if (this.wasGrounded) {
                        if (this.velocity.y < 0) {
                            this.velocity.y = 0;
                        }
                    } else {
                        this.velocity = this.velocity.$clone().add( gravityDeltaVelocity.$clone() );
                    }
                }
                this.controller.Move(this.velocity.$clone().clone().scale( dt ));
                this.wasGrounded = isGrounded;

                // Determine and store character state
                if (isGrounded) {
                    if (doCrouch) {
                        this.currentState = Spine.Unity.Examples.BasicPlatformerController.CharacterState.Crouch;
                    } else {
                        if (this.input.x === 0) {
                            this.currentState = Spine.Unity.Examples.BasicPlatformerController.CharacterState.Idle;
                        } else {
                            this.currentState = Math.abs(this.input.x) > 0.6 ? Spine.Unity.Examples.BasicPlatformerController.CharacterState.Run : Spine.Unity.Examples.BasicPlatformerController.CharacterState.Walk;
                        }
                    }
                } else {
                    this.currentState = this.velocity.y > 0 ? Spine.Unity.Examples.BasicPlatformerController.CharacterState.Rise : Spine.Unity.Examples.BasicPlatformerController.CharacterState.Fall;
                }

                var stateChanged = this.previousState !== this.currentState;
                this.previousState = this.currentState;

                // Animation
                // Do not modify character parameters or state in this phase. Just read them.
                // Detect changes in state, and communicate with animation handle if it changes.
                if (stateChanged) {
                    this.HandleStateChanged();
                }

                if (this.input.x !== 0) {
                    this.animationHandle.SetFlip(this.input.x);
                }

                // Fire events.
                if (doJump) {
                    this.OnJump();
                }
                if (landed) {
                    if (hardLand) {
                        this.OnHardLand();
                    } else {
                        this.OnLand();
                    }
                }
            },
            /*Spine.Unity.Examples.BasicPlatformerController.Update end.*/

            /*Spine.Unity.Examples.BasicPlatformerController.HandleStateChanged start.*/
            HandleStateChanged: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.BasicPlatformerController#HandleStateChanged", this ); }

                // When the state changes, notify the animation handle of the new state.
                var stateName = null;
                switch (this.currentState) {
                    case Spine.Unity.Examples.BasicPlatformerController.CharacterState.Idle: 
                        stateName = "idle";
                        break;
                    case Spine.Unity.Examples.BasicPlatformerController.CharacterState.Walk: 
                        stateName = "walk";
                        break;
                    case Spine.Unity.Examples.BasicPlatformerController.CharacterState.Run: 
                        stateName = "run";
                        break;
                    case Spine.Unity.Examples.BasicPlatformerController.CharacterState.Crouch: 
                        stateName = "crouch";
                        break;
                    case Spine.Unity.Examples.BasicPlatformerController.CharacterState.Rise: 
                        stateName = "rise";
                        break;
                    case Spine.Unity.Examples.BasicPlatformerController.CharacterState.Fall: 
                        stateName = "fall";
                        break;
                    case Spine.Unity.Examples.BasicPlatformerController.CharacterState.Attack: 
                        stateName = "attack";
                        break;
                    default: 
                        break;
                }

                this.animationHandle.PlayAnimationForState$1(stateName, 0);
            },
            /*Spine.Unity.Examples.BasicPlatformerController.HandleStateChanged end.*/


        }
    });
    /*Spine.Unity.Examples.BasicPlatformerController end.*/

    /*Spine.Unity.Examples.BasicPlatformerController+CharacterState start.*/
    Bridge.define("Spine.Unity.Examples.BasicPlatformerController.CharacterState", {
        $kind: 1006,
        statics: {
            fields: {
                None: 0,
                Idle: 1,
                Walk: 2,
                Run: 3,
                Crouch: 4,
                Rise: 5,
                Fall: 6,
                Attack: 7
            }
        }
    });
    /*Spine.Unity.Examples.BasicPlatformerController+CharacterState end.*/

    /*Spine.Unity.Examples.BoneLocalOverride start.*/
    Bridge.define("Spine.Unity.Examples.BoneLocalOverride", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            boneName: null,
            alpha: 0,
            overridePosition: false,
            localPosition: null,
            overrideRotation: false,
            rotation: 0,
            spineComponent: null,
            bone: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.BoneLocalOverride#init", this ); }

                this.localPosition = new UnityEngine.Vector2();
                this.alpha = 1;
                this.overridePosition = true;
                this.overrideRotation = true;
                this.rotation = 0;
            }
        },
        methods: {
            /*Spine.Unity.Examples.BoneLocalOverride.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.BoneLocalOverride#Awake", this ); }

                this.spineComponent = this.GetComponent(Spine.Unity.ISkeletonAnimation);
                if (this.spineComponent == null) {
                    this.enabled = false;
                    return;
                }
                this.spineComponent.Spine$Unity$ISkeletonAnimation$addUpdateLocal(Bridge.fn.cacheBind(this, this.OverrideLocal));

                if (this.bone == null) {
                    this.enabled = false;
                    return;
                }
            },
            /*Spine.Unity.Examples.BoneLocalOverride.Awake end.*/

            /*Spine.Unity.Examples.BoneLocalOverride.OverrideLocal start.*/
            OverrideLocal: function (animated) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.BoneLocalOverride#OverrideLocal", this ); }

                if (this.bone == null || !Bridge.referenceEquals(this.bone.data.name, this.boneName)) {
                    if (System.String.isNullOrEmpty(this.boneName)) {
                        return;
                    }
                    this.bone = this.spineComponent.Spine$Unity$ISkeletonAnimation$Skeleton.findBone(this.boneName);
                    if (this.bone == null) {
                        UnityEngine.Debug.LogFormat("Cannot find bone: '{0}'", [this.boneName]);
                        return;
                    }
                }

                if (this.overridePosition) {
                    this.bone.x = pc.math.lerp(this.bone.x, this.localPosition.x, this.alpha);
                    this.bone.y = pc.math.lerp(this.bone.y, this.localPosition.y, this.alpha);
                }

                if (this.overrideRotation) {
                    this.bone.rotation = pc.math.lerp(this.bone.rotation, this.rotation, this.alpha);
                }
            },
            /*Spine.Unity.Examples.BoneLocalOverride.OverrideLocal end.*/


        }
    });
    /*Spine.Unity.Examples.BoneLocalOverride end.*/

    /*Spine.Unity.Examples.CombinedSkin start.*/
    Bridge.define("Spine.Unity.Examples.CombinedSkin", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skinsToCombine: null,
            combinedSkin: null
        },
        methods: {
            /*Spine.Unity.Examples.CombinedSkin.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.CombinedSkin#Start", this ); }

                var $t;
                var skeletonComponent = this.GetComponent(Spine.Unity.ISkeletonComponent);
                if (skeletonComponent == null) {
                    return;
                }
                var skeleton = skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                if (skeleton == null) {
                    return;
                }

                this.combinedSkin = this.combinedSkin || new Spine.Skin("combined");
                this.combinedSkin.clear();
                $t = Bridge.getEnumerator(this.skinsToCombine);
                try {
                    while ($t.moveNext()) {
                        var skinName = $t.Current;
                        var skin = skeleton.data.findSkin(skinName);
                        if (skin != null) {
                            this.combinedSkin.addSkin(skin);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                skeleton.setSkin(this.combinedSkin);
                skeleton.setToSetupPose();
                var animationStateComponent = Bridge.as(skeletonComponent, Spine.Unity.IAnimationStateComponent);
                if (animationStateComponent != null) {
                    animationStateComponent.Spine$Unity$IAnimationStateComponent$AnimationState.apply(skeleton);
                }
            },
            /*Spine.Unity.Examples.CombinedSkin.Start end.*/


        }
    });
    /*Spine.Unity.Examples.CombinedSkin end.*/

    /*Spine.Unity.Examples.DummyMecanimControllerExample start.*/
    Bridge.define("Spine.Unity.Examples.DummyMecanimControllerExample", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            logicAnimator: null,
            animationHandle: null,
            walkButton: 0,
            jumpButton: 0,
            horizontalSpeedProperty: null,
            verticalSpeedProperty: null,
            groundedProperty: null,
            jumpDuration: 0,
            speed: null,
            isGrounded: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.DummyMecanimControllerExample#init", this ); }

                this.speed = new UnityEngine.Vector2();
                this.walkButton = UnityEngine.KeyCode.LeftShift;
                this.jumpButton = UnityEngine.KeyCode.Space;
                this.horizontalSpeedProperty = "Speed";
                this.verticalSpeedProperty = "VerticalSpeed";
                this.groundedProperty = "Grounded";
                this.jumpDuration = 1.5;
            }
        },
        methods: {
            /*Spine.Unity.Examples.DummyMecanimControllerExample.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.DummyMecanimControllerExample#Awake", this ); }

                this.isGrounded = true;
            },
            /*Spine.Unity.Examples.DummyMecanimControllerExample.Awake end.*/

            /*Spine.Unity.Examples.DummyMecanimControllerExample.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.DummyMecanimControllerExample#Update", this ); }

                var x = UnityEngine.Input.GetAxisRaw("Horizontal");
                if (UnityEngine.Input.GetKey(this.walkButton)) {
                    x *= 0.4;
                }

                this.speed.x = x;

                // Flip skeleton.
                if (x !== 0) {
                    this.animationHandle.SetFlip(x);
                }

                if (UnityEngine.Input.GetKeyDown(this.jumpButton)) {
                    if (this.isGrounded) {
                        this.StartCoroutine$1(this.FakeJump());
                    }
                }

                this.logicAnimator.SetFloat$1(this.horizontalSpeedProperty, Math.abs(this.speed.x));
                this.logicAnimator.SetFloat$1(this.verticalSpeedProperty, this.speed.y);
                this.logicAnimator.SetBool$1(this.groundedProperty, this.isGrounded);
            },
            /*Spine.Unity.Examples.DummyMecanimControllerExample.Update end.*/

            /*Spine.Unity.Examples.DummyMecanimControllerExample.FakeJump start.*/
            FakeJump: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.DummyMecanimControllerExample#FakeJump", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    durationLeft,
                    fallDuration,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    // Rise
                                        this.isGrounded = false;
                                        this.speed.y = 10.0;
                                        durationLeft = this.jumpDuration * 0.5;
                                    $step = 1;
                                    continue;
                                }
                                case 1: {
                                    if ( durationLeft > 0 ) {
                                            $step = 2;
                                            continue;
                                        } 
                                        $step = 4;
                                        continue;
                                }
                                case 2: {
                                    durationLeft -= UnityEngine.Time.deltaTime;
                                        if (!UnityEngine.Input.GetKey(this.jumpButton)) {
                                            $step = 4;
                                            continue;
                                        }
                                        $enumerator.current = null;
                                        $step = 3;
                                        return true;
                                }
                                case 3: {
                                    
                                        $step = 1;
                                        continue;
                                }
                                case 4: {
                                    // Fall
                                        this.speed.y = -10.0;
                                        fallDuration = (this.jumpDuration * 0.5) - durationLeft;
                                        $enumerator.current = new UnityEngine.WaitForSeconds(fallDuration);
                                        $step = 5;
                                        return true;
                                }
                                case 5: {
                                    // Land
                                        this.speed.y = 0.0;
                                        this.isGrounded = true;
                                        $enumerator.current = null;
                                        $step = 6;
                                        return true;
                                }
                                case 6: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Spine.Unity.Examples.DummyMecanimControllerExample.FakeJump end.*/


        }
    });
    /*Spine.Unity.Examples.DummyMecanimControllerExample end.*/

    /*Spine.Unity.Examples.EquipAssetExample start.*/
    Bridge.define("Spine.Unity.Examples.EquipAssetExample", {
        inherits: [UnityEngine.ScriptableObject],
        fields: {
            equipType: 0,
            sprite: null,
            description: null,
            yourStats: 0
        }
    });
    /*Spine.Unity.Examples.EquipAssetExample end.*/

    /*Spine.Unity.Examples.EquipButtonExample start.*/
    Bridge.define("Spine.Unity.Examples.EquipButtonExample", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            asset: null,
            equipSystem: null,
            inventoryImage: null
        },
        methods: {
            /*Spine.Unity.Examples.EquipButtonExample.OnValidate start.*/
            OnValidate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.EquipButtonExample#OnValidate", this ); }

                this.MatchImage();
            },
            /*Spine.Unity.Examples.EquipButtonExample.OnValidate end.*/

            /*Spine.Unity.Examples.EquipButtonExample.MatchImage start.*/
            MatchImage: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.EquipButtonExample#MatchImage", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.inventoryImage, null)) {
                    this.inventoryImage.sprite = this.asset.sprite;
                }
            },
            /*Spine.Unity.Examples.EquipButtonExample.MatchImage end.*/

            /*Spine.Unity.Examples.EquipButtonExample.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.EquipButtonExample#Start", this ); }

                this.MatchImage();

                var button = this.GetComponent(UnityEngine.UI.Button);
                button.onClick.AddListener(Bridge.fn.bind(this, function () {
                    this.equipSystem.Equip(this.asset);
                }));
            },
            /*Spine.Unity.Examples.EquipButtonExample.Start end.*/


        }
    });
    /*Spine.Unity.Examples.EquipButtonExample end.*/

    /*Spine.Unity.Examples.EquipsVisualsComponentExample start.*/
    Bridge.define("Spine.Unity.Examples.EquipsVisualsComponentExample", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonAnimation: null,
            templateSkinName: null,
            equipsSkin: null,
            collectedSkin: null,
            runtimeMaterial: null,
            runtimeAtlas: null
        },
        methods: {
            /*Spine.Unity.Examples.EquipsVisualsComponentExample.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.EquipsVisualsComponentExample#Start", this ); }

                this.equipsSkin = new Spine.Skin("Equips");

                // OPTIONAL: Add all the attachments from the template skin.
                var templateSkin = this.skeletonAnimation.Skeleton.data.findSkin(this.templateSkinName);
                if (templateSkin != null) {
                    this.equipsSkin.addSkin(templateSkin);
                }

                this.skeletonAnimation.Skeleton.skin = this.equipsSkin;
                this.RefreshSkeletonAttachments();
            },
            /*Spine.Unity.Examples.EquipsVisualsComponentExample.Start end.*/

            /*Spine.Unity.Examples.EquipsVisualsComponentExample.Equip start.*/
            Equip: function (slotIndex, attachmentName, attachment) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.EquipsVisualsComponentExample#Equip", this ); }

                this.equipsSkin.setAttachment(slotIndex, attachmentName, attachment);
                this.skeletonAnimation.Skeleton.setSkin(this.equipsSkin);
                this.RefreshSkeletonAttachments();
            },
            /*Spine.Unity.Examples.EquipsVisualsComponentExample.Equip end.*/

            /*Spine.Unity.Examples.EquipsVisualsComponentExample.OptimizeSkin start.*/
            OptimizeSkin: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.EquipsVisualsComponentExample#OptimizeSkin", this ); }

                var $t;
                // 1. Collect all the attachments of all active skins.
                this.collectedSkin = this.collectedSkin || new Spine.Skin("Collected skin");
                this.collectedSkin.clear();
                this.collectedSkin.addSkin(this.skeletonAnimation.Skeleton.data.defaultSkin);
                this.collectedSkin.addSkin(this.equipsSkin);

                // 2. Create a repacked skin.
                // Note: materials and textures returned by GetRepackedSkin() behave like 'new Texture2D()' and need to be destroyed
                if (UnityEngine.Object.op_Implicit(this.runtimeMaterial)) {
                    UnityEngine.Object.Destroy(this.runtimeMaterial);
                }
                if (UnityEngine.Object.op_Implicit(this.runtimeAtlas)) {
                    UnityEngine.Object.Destroy(this.runtimeAtlas);
                }
                var repackedSkin = Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedSkin(this.collectedSkin, "Repacked skin", ($t = this.skeletonAnimation.SkeletonDataAsset.atlasAssets)[0].PrimaryMaterial, Bridge.ref(this, "runtimeMaterial"), Bridge.ref(this, "runtimeAtlas"), 1024, 2, 4, false, true, false, void 0, void 0, void 0, void 0);
                this.collectedSkin.clear();

                // You can optionally clear the textures cache after each ore multiple repack operations are done.
                //AtlasUtilities.ClearCache();
                //Resources.UnloadUnusedAssets();

                // 3. Use the repacked skin.
                this.skeletonAnimation.Skeleton.skin = repackedSkin;
                this.RefreshSkeletonAttachments();
            },
            /*Spine.Unity.Examples.EquipsVisualsComponentExample.OptimizeSkin end.*/

            /*Spine.Unity.Examples.EquipsVisualsComponentExample.RefreshSkeletonAttachments start.*/
            RefreshSkeletonAttachments: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.EquipsVisualsComponentExample#RefreshSkeletonAttachments", this ); }

                this.skeletonAnimation.Skeleton.setSlotsToSetupPose();
                this.skeletonAnimation.AnimationState.apply(this.skeletonAnimation.Skeleton); //skeletonAnimation.Update(0);
            },
            /*Spine.Unity.Examples.EquipsVisualsComponentExample.RefreshSkeletonAttachments end.*/


        }
    });
    /*Spine.Unity.Examples.EquipsVisualsComponentExample end.*/

    /*Spine.Unity.Examples.EquipSystemExample+EquipHook start.*/
    Bridge.define("Spine.Unity.Examples.EquipSystemExample.EquipHook", {
        $kind: 1002,
        fields: {
            type: 0,
            slot: null,
            templateSkin: null,
            templateAttachment: null
        }
    });
    /*Spine.Unity.Examples.EquipSystemExample+EquipHook end.*/

    /*Spine.Unity.Examples.EquipSystemExample+EquipType start.*/
    Bridge.define("Spine.Unity.Examples.EquipSystemExample.EquipType", {
        $kind: 1006,
        statics: {
            fields: {
                Gun: 0,
                Goggles: 1
            }
        }
    });
    /*Spine.Unity.Examples.EquipSystemExample+EquipType end.*/

    /*Spine.Unity.Examples.FootSoldierExample start.*/
    Bridge.define("Spine.Unity.Examples.FootSoldierExample", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            idleAnimation: null,
            attackAnimation: null,
            moveAnimation: null,
            eyesSlot: null,
            eyesOpenAttachment: null,
            blinkAttachment: null,
            blinkDuration: 0,
            attackKey: 0,
            rightKey: 0,
            leftKey: 0,
            moveSpeed: 0,
            skeletonAnimation: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.FootSoldierExample#init", this ); }

                this.blinkDuration = 0.05;
                this.attackKey = UnityEngine.KeyCode.Mouse0;
                this.rightKey = UnityEngine.KeyCode.D;
                this.leftKey = UnityEngine.KeyCode.A;
                this.moveSpeed = 3;
            }
        },
        methods: {
            /*Spine.Unity.Examples.FootSoldierExample.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.FootSoldierExample#Awake", this ); }

                this.skeletonAnimation = this.GetComponent(Spine.Unity.SkeletonAnimation);
                this.skeletonAnimation.addOnRebuild(Bridge.fn.cacheBind(this, this.Apply));
            },
            /*Spine.Unity.Examples.FootSoldierExample.Awake end.*/

            /*Spine.Unity.Examples.FootSoldierExample.Apply start.*/
            Apply: function (skeletonRenderer) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.FootSoldierExample#Apply", this ); }

                this.StartCoroutine$1(this.Blink());
            },
            /*Spine.Unity.Examples.FootSoldierExample.Apply end.*/

            /*Spine.Unity.Examples.FootSoldierExample.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.FootSoldierExample#Update", this ); }

                if (UnityEngine.Input.GetKey(this.attackKey)) {
                    this.skeletonAnimation.AnimationName = this.attackAnimation;
                } else {
                    if (UnityEngine.Input.GetKey(this.rightKey)) {
                        this.skeletonAnimation.AnimationName = this.moveAnimation;
                        this.skeletonAnimation.Skeleton.scaleX = 1;
                        this.transform.Translate(this.moveSpeed * UnityEngine.Time.deltaTime, 0, 0);
                    } else if (UnityEngine.Input.GetKey(this.leftKey)) {
                        this.skeletonAnimation.AnimationName = this.moveAnimation;
                        this.skeletonAnimation.Skeleton.scaleX = -1;
                        this.transform.Translate(-this.moveSpeed * UnityEngine.Time.deltaTime, 0, 0);
                    } else {
                        this.skeletonAnimation.AnimationName = this.idleAnimation;
                    }
                }
            },
            /*Spine.Unity.Examples.FootSoldierExample.Update end.*/

            /*Spine.Unity.Examples.FootSoldierExample.Blink start.*/
            Blink: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.FootSoldierExample#Blink", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if ( true ) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 4;
                                        continue;
                                }
                                case 1: {
                                    $enumerator.current = new UnityEngine.WaitForSeconds(UnityEngine.Random.Range$1(0.25, 3.0));
                                        $step = 2;
                                        return true;
                                }
                                case 2: {
                                    this.skeletonAnimation.Skeleton.setAttachment(this.eyesSlot, this.blinkAttachment);
                                        $enumerator.current = new UnityEngine.WaitForSeconds(this.blinkDuration);
                                        $step = 3;
                                        return true;
                                }
                                case 3: {
                                    this.skeletonAnimation.Skeleton.setAttachment(this.eyesSlot, this.eyesOpenAttachment);

                                        $step = 0;
                                        continue;
                                }
                                case 4: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Spine.Unity.Examples.FootSoldierExample.Blink end.*/


        }
    });
    /*Spine.Unity.Examples.FootSoldierExample end.*/

    /*Spine.Unity.Examples.Goblins start.*/
    Bridge.define("Spine.Unity.Examples.Goblins", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonAnimation: null,
            headBone: null,
            girlSkin: false,
            extraRotation: 0
        },
        methods: {
            /*Spine.Unity.Examples.Goblins.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.Goblins#Start", this ); }

                this.skeletonAnimation = this.GetComponent(Spine.Unity.SkeletonAnimation);
                this.headBone = this.skeletonAnimation.Skeleton.findBone("head");
                this.skeletonAnimation.addUpdateLocal(Bridge.fn.cacheBind(this, this.UpdateLocal));
            },
            /*Spine.Unity.Examples.Goblins.Start end.*/

            /*Spine.Unity.Examples.Goblins.UpdateLocal start.*/
            UpdateLocal: function (skeletonRenderer) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.Goblins#UpdateLocal", this ); }

                this.headBone.rotation = +this.extraRotation;
            },
            /*Spine.Unity.Examples.Goblins.UpdateLocal end.*/

            /*Spine.Unity.Examples.Goblins.OnMouseDown start.*/
            OnMouseDown: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.Goblins#OnMouseDown", this ); }

                this.skeletonAnimation.Skeleton.setSkinByName(this.girlSkin ? "goblin" : "goblingirl");
                this.skeletonAnimation.Skeleton.setSlotsToSetupPose();

                this.girlSkin = !this.girlSkin;

                if (this.girlSkin) {
                    this.skeletonAnimation.Skeleton.setAttachment("right-hand-item", null);
                    this.skeletonAnimation.Skeleton.setAttachment("left-hand-item", "spear");
                } else {
                    this.skeletonAnimation.Skeleton.setAttachment("left-hand-item", "dagger");
                }
            },
            /*Spine.Unity.Examples.Goblins.OnMouseDown end.*/


        }
    });
    /*Spine.Unity.Examples.Goblins end.*/

    /*Spine.Unity.Examples.HandleEventWithAudioExample start.*/
    Bridge.define("Spine.Unity.Examples.HandleEventWithAudioExample", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonAnimation: null,
            eventName: null,
            audioSource: null,
            audioClip: null,
            basePitch: 0,
            randomPitchOffset: 0,
            logDebugMessage: false,
            eventData: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.HandleEventWithAudioExample#init", this ); }

                this.basePitch = 1.0;
                this.randomPitchOffset = 0.1;
                this.logDebugMessage = false;
            }
        },
        methods: {
            /*Spine.Unity.Examples.HandleEventWithAudioExample.OnValidate start.*/
            OnValidate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.HandleEventWithAudioExample#OnValidate", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonAnimation, null)) {
                    this.GetComponent(Spine.Unity.SkeletonAnimation);
                }
                if (UnityEngine.Component.op_Equality(this.audioSource, null)) {
                    this.GetComponent(UnityEngine.AudioSource);
                }
            },
            /*Spine.Unity.Examples.HandleEventWithAudioExample.OnValidate end.*/

            /*Spine.Unity.Examples.HandleEventWithAudioExample.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.HandleEventWithAudioExample#Start", this ); }

                if (UnityEngine.Component.op_Equality(this.audioSource, null)) {
                    return;
                }
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonAnimation, null)) {
                    return;
                }
                this.skeletonAnimation.Initialize(false);
                if (!this.skeletonAnimation.valid) {
                    return;
                }

                this.eventData = this.skeletonAnimation.Skeleton.data.findEvent(this.eventName);
                this.skeletonAnimation.AnimationState.addEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEvent));
            },
            /*Spine.Unity.Examples.HandleEventWithAudioExample.Start end.*/

            /*Spine.Unity.Examples.HandleEventWithAudioExample.HandleAnimationStateEvent start.*/
            HandleAnimationStateEvent: function (trackEntry, e) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.HandleEventWithAudioExample#HandleAnimationStateEvent", this ); }

                if (this.logDebugMessage) {
                    UnityEngine.Debug.Log$1("Event fired! " + (e.data.name || ""));
                }
                //bool eventMatch = string.Equals(e.Data.Name, eventName, System.StringComparison.Ordinal); // Testing recommendation: String compare.
                var eventMatch = (Bridge.referenceEquals(this.eventData, e.data)); // Performance recommendation: Match cached reference instead of string.
                if (eventMatch) {
                    this.Play();
                }
            },
            /*Spine.Unity.Examples.HandleEventWithAudioExample.HandleAnimationStateEvent end.*/

            /*Spine.Unity.Examples.HandleEventWithAudioExample.Play start.*/
            Play: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.HandleEventWithAudioExample#Play", this ); }

                this.audioSource.pitch = this.basePitch + UnityEngine.Random.Range$1(-this.randomPitchOffset, this.randomPitchOffset);
                this.audioSource.clip = this.audioClip;
                this.audioSource.Play();
            },
            /*Spine.Unity.Examples.HandleEventWithAudioExample.Play end.*/


        }
    });
    /*Spine.Unity.Examples.HandleEventWithAudioExample end.*/

    /*Spine.Unity.Examples.HeroEffectsHandlerExample start.*/
    Bridge.define("Spine.Unity.Examples.HeroEffectsHandlerExample", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            eventSource: null,
            OnJump: null,
            OnLand: null,
            OnHardLand: null
        },
        methods: {
            /*Spine.Unity.Examples.HeroEffectsHandlerExample.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.HeroEffectsHandlerExample#Awake", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.eventSource, null)) {
                    return;
                }

                this.eventSource.addOnLand(Bridge.fn.cacheBind(this.OnLand, this.OnLand.Invoke));
                this.eventSource.addOnJump(Bridge.fn.cacheBind(this.OnJump, this.OnJump.Invoke));
                this.eventSource.addOnHardLand(Bridge.fn.cacheBind(this.OnHardLand, this.OnHardLand.Invoke));
            },
            /*Spine.Unity.Examples.HeroEffectsHandlerExample.Awake end.*/


        }
    });
    /*Spine.Unity.Examples.HeroEffectsHandlerExample end.*/

    /*Spine.Unity.Examples.JitterEffectExample start.*/
    Bridge.define("Spine.Unity.Examples.JitterEffectExample", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            jitterMagnitude: 0,
            skeletonRenderer: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.JitterEffectExample#init", this ); }

                this.jitterMagnitude = 0.2;
            }
        },
        methods: {
            /*Spine.Unity.Examples.JitterEffectExample.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.JitterEffectExample#OnEnable", this ); }

                this.skeletonRenderer = this.GetComponent(Spine.Unity.SkeletonRenderer);
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    return;
                }

                // Use the OnPostProcessVertices callback to modify the vertices at the correct time.
                this.skeletonRenderer.removeOnPostProcessVertices(Bridge.fn.cacheBind(this, this.ProcessVertices));
                this.skeletonRenderer.addOnPostProcessVertices(Bridge.fn.cacheBind(this, this.ProcessVertices));

                UnityEngine.Debug.Log$1("Jitter Effect Enabled.");
            },
            /*Spine.Unity.Examples.JitterEffectExample.OnEnable end.*/

            /*Spine.Unity.Examples.JitterEffectExample.ProcessVertices start.*/
            ProcessVertices: function (buffers) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.JitterEffectExample#ProcessVertices", this ); }

                if (!this.enabled) {
                    return;
                }

                // For efficiency, limit your effect to the actual mesh vertex count using vertexCount
                var vertexCount = buffers.vertexCount;

                // Modify vertex positions by accessing Vector3[] vertexBuffer
                var vertices = buffers.vertexBuffer;
                for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                    vertices[i] = vertices[i].$clone().add( UnityEngine.Vector3.FromVector2((UnityEngine.Random.insideUnitCircle.$clone().scale( this.jitterMagnitude ))) );
                }

                // You can also modify uvs and colors.
                //Vector2[] uvs = buffers.uvBuffer;
                //Color32[] colors = buffers.colorBuffer;

                //
            },
            /*Spine.Unity.Examples.JitterEffectExample.ProcessVertices end.*/

            /*Spine.Unity.Examples.JitterEffectExample.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.JitterEffectExample#OnDisable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    return;
                }
                this.skeletonRenderer.removeOnPostProcessVertices(Bridge.fn.cacheBind(this, this.ProcessVertices));

                UnityEngine.Debug.Log$1("Jitter Effect Disabled.");
            },
            /*Spine.Unity.Examples.JitterEffectExample.OnDisable end.*/


        }
    });
    /*Spine.Unity.Examples.JitterEffectExample end.*/

    /*Spine.Unity.Examples.MaterialReplacementExample start.*/
    Bridge.define("Spine.Unity.Examples.MaterialReplacementExample", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            originalMaterial: null,
            replacementMaterial: null,
            replacementEnabled: false,
            skeletonAnimation: null,
            phasePropertyName: null,
            phase: 0,
            previousEnabled: false,
            mpb: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.MaterialReplacementExample#init", this ); }

                this.replacementEnabled = true;
                this.phasePropertyName = "_FillPhase";
                this.phase = 1.0;
            }
        },
        methods: {
            /*Spine.Unity.Examples.MaterialReplacementExample.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.MaterialReplacementExample#Start", this ); }

                var $t;
                // Use the code below to programmatically query the original material.
                // Note: using MeshRenderer.material will fail since it creates an instance copy of the Material,
                // MeshRenderer.sharedMaterial might also fail when called too early or when no Attachments
                // are visible in the initial first frame.
                if (this.originalMaterial == null) {
                    this.originalMaterial = ($t = this.skeletonAnimation.SkeletonDataAsset.atlasAssets)[0].PrimaryMaterial;
                }

                this.previousEnabled = this.replacementEnabled;
                this.SetReplacementEnabled(this.replacementEnabled);
                this.mpb = new UnityEngine.MaterialPropertyBlock();
            },
            /*Spine.Unity.Examples.MaterialReplacementExample.Start end.*/

            /*Spine.Unity.Examples.MaterialReplacementExample.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.MaterialReplacementExample#Update", this ); }

                this.mpb.SetFloat$1(this.phasePropertyName, this.phase);
                this.GetComponent(UnityEngine.MeshRenderer).SetPropertyBlock(this.mpb);

                if (this.previousEnabled !== this.replacementEnabled) {
                    this.SetReplacementEnabled(this.replacementEnabled);
                }

                this.previousEnabled = this.replacementEnabled;

            },
            /*Spine.Unity.Examples.MaterialReplacementExample.Update end.*/

            /*Spine.Unity.Examples.MaterialReplacementExample.SetReplacementEnabled start.*/
            SetReplacementEnabled: function (active) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.MaterialReplacementExample#SetReplacementEnabled", this ); }

                if (this.replacementEnabled) {
                    this.skeletonAnimation.CustomMaterialOverride.setItem(this.originalMaterial, this.replacementMaterial);
                } else {
                    this.skeletonAnimation.CustomMaterialOverride.remove(this.originalMaterial);
                }
            },
            /*Spine.Unity.Examples.MaterialReplacementExample.SetReplacementEnabled end.*/


        }
    });
    /*Spine.Unity.Examples.MaterialReplacementExample end.*/

    /*Spine.Unity.Examples.MecanimToAnimationHandleExample start.*/
    Bridge.define("Spine.Unity.Examples.MecanimToAnimationHandleExample", {
        inherits: [UnityEngine.StateMachineBehaviour],
        fields: {
            animationHandle: null,
            initialized: false
        },
        methods: {
            /*Spine.Unity.Examples.MecanimToAnimationHandleExample.OnStateEnter start.*/
            OnStateEnter: function (animator, stateInfo, layerIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.MecanimToAnimationHandleExample#OnStateEnter", this ); }

                if (!this.initialized) {
                    this.animationHandle = animator.GetComponent(Spine.Unity.Examples.SkeletonAnimationHandleExample);
                    this.initialized = true;
                }

                this.animationHandle.PlayAnimationForState(stateInfo.shortNameHash, layerIndex);
            },
            /*Spine.Unity.Examples.MecanimToAnimationHandleExample.OnStateEnter end.*/


        }
    });
    /*Spine.Unity.Examples.MecanimToAnimationHandleExample end.*/

    /*Spine.Unity.Examples.MixAndMatch start.*/
    Bridge.define("Spine.Unity.Examples.MixAndMatch", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            templateAttachmentsSkin: null,
            sourceMaterial: null,
            visorSprite: null,
            visorSlot: null,
            visorKey: null,
            gunSprite: null,
            gunSlot: null,
            gunKey: null,
            repack: false,
            bbFollower: null,
            runtimeAtlas: null,
            runtimeMaterial: null,
            customSkin: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.MixAndMatch#init", this ); }

                this.templateAttachmentsSkin = "base";
                this.visorKey = "goggles";
                this.gunKey = "gun";
                this.repack = true;
            }
        },
        methods: {
            /*Spine.Unity.Examples.MixAndMatch.OnValidate start.*/
            OnValidate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.MixAndMatch#OnValidate", this ); }

                var $t;
                if (this.sourceMaterial == null) {
                    var skeletonAnimation = this.GetComponent(Spine.Unity.SkeletonAnimation);
                    if (UnityEngine.MonoBehaviour.op_Inequality(skeletonAnimation, null)) {
                        this.sourceMaterial = ($t = skeletonAnimation.SkeletonDataAsset.atlasAssets)[0].PrimaryMaterial;
                    }
                }
            },
            /*Spine.Unity.Examples.MixAndMatch.OnValidate end.*/

            /*Spine.Unity.Examples.MixAndMatch.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.MixAndMatch#Start", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    $enumerator.current = new UnityEngine.WaitForSeconds(1.0);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    // Delay for one second before applying. For testing.
                                        this.Apply();

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Spine.Unity.Examples.MixAndMatch.Start end.*/

            /*Spine.Unity.Examples.MixAndMatch.Apply start.*/
            Apply: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.MixAndMatch#Apply", this ); }

                var skeletonAnimation = this.GetComponent(Spine.Unity.SkeletonAnimation);
                var skeleton = skeletonAnimation.Skeleton;

                // STEP 0: PREPARE SKINS
                // Let's prepare a new skin to be our custom skin with equips/customizations. We get a clone so our original skins are unaffected.
                this.customSkin = this.customSkin || new Spine.Skin("custom skin"); // This requires that all customizations are done with skin placeholders defined in Spine.
                var templateSkin = skeleton.data.findSkin(this.templateAttachmentsSkin);

                // STEP 1: "EQUIP" ITEMS USING SPRITES
                // STEP 1.1 Find the original/template attachment.
                // Step 1.2 Get a clone of the original/template attachment.
                // Step 1.3 Apply the Sprite image to the clone.
                // Step 1.4 Add the remapped clone to the new custom skin.

                // Let's do this for the visor.
                var visorSlotIndex = skeleton.data.findSlot(this.visorSlot).index; // You can access GetAttachment and SetAttachment via string, but caching the slotIndex is faster.
                var templateAttachment = templateSkin.getAttachment(visorSlotIndex, this.visorKey); // STEP 1.1

                // Note: Each call to `GetRemappedClone()` with parameter `premultiplyAlpha` set to `true` creates
                // a cached Texture copy which can be cleared by calling AtlasUtilities.ClearCache() as done in the method below.
                var newAttachment = Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone$1(templateAttachment, this.visorSprite, this.sourceMaterial, true, true, false, false, false, 4, false); // STEP 1.2 - 1.3
                this.customSkin.setAttachment(visorSlotIndex, this.visorKey, newAttachment); // STEP 1.4

                // And now for the gun.
                var gunSlotIndex = skeleton.data.findSlot(this.gunSlot).index;
                var templateGun = templateSkin.getAttachment(gunSlotIndex, this.gunKey); // STEP 1.1
                var newGun = Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone$1(templateGun, this.gunSprite, this.sourceMaterial, true, true, false, false, false, 4, false); // STEP 1.2 - 1.3
                if (newGun != null) {
                    this.customSkin.setAttachment(gunSlotIndex, this.gunKey, newGun);
                } // STEP 1.4

                // customSkin.RemoveAttachment(gunSlotIndex, gunKey); // To remove an item.
                // customSkin.Clear()
                // Use skin.Clear() To remove all customizations.
                // Customizations will fall back to the value in the default skin if it was defined there.
                // To prevent fallback from happening, make sure the key is not defined in the default skin.

                // STEP 3: APPLY AND CLEAN UP.
                // Recommended, preferably at level-load-time: REPACK THE CUSTOM SKIN TO MINIMIZE DRAW CALLS
                // 				IMPORTANT NOTE: the GetRepackedSkin() operation is expensive - if multiple characters
                // 				need to call it every few seconds the overhead will outweigh the draw call benefits.
                //
                // 				Repacking requires that you set all source textures/sprites/atlases to be Read/Write enabled in the inspector.
                // 				Combine all the attachment sources into one skin. Usually this means the default skin and the custom skin.
                // 				call Skin.GetRepackedSkin to get a cloned skin with cloned attachments that all use one texture.
                if (this.repack) {
                    var repackedSkin = new Spine.Skin("repacked skin");
                    repackedSkin.addSkin(skeleton.data.defaultSkin); // Include the "default" skin. (everything outside of skin placeholders)
                    repackedSkin.addSkin(this.customSkin); // Include your new custom skin.

                    // Note: materials and textures returned by GetRepackedSkin() behave like 'new Texture2D()' and need to be destroyed
                    if (UnityEngine.Object.op_Implicit(this.runtimeMaterial)) {
                        UnityEngine.Object.Destroy(this.runtimeMaterial);
                    }
                    if (UnityEngine.Object.op_Implicit(this.runtimeAtlas)) {
                        UnityEngine.Object.Destroy(this.runtimeAtlas);
                    }
                    repackedSkin = Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedSkin(repackedSkin, "repacked skin", this.sourceMaterial, Bridge.ref(this, "runtimeMaterial"), Bridge.ref(this, "runtimeAtlas")); // Pack all the items in the skin.
                    skeleton.setSkin(repackedSkin); // Assign the repacked skin to your Skeleton.
                    if (UnityEngine.MonoBehaviour.op_Inequality(this.bbFollower, null)) {
                        this.bbFollower.Initialize(true);
                    }
                } else {
                    skeleton.setSkin(this.customSkin); // Just use the custom skin directly.
                }

                skeleton.setSlotsToSetupPose(); // Use the pose from setup pose.
                skeletonAnimation.Update(0); // Use the pose in the currently active animation.

                // `GetRepackedSkin()` and each call to `GetRemappedClone()` with parameter `premultiplyAlpha` set to `true`
                // cache necessarily created Texture copies which can be cleared by calling AtlasUtilities.ClearCache().
                // You can optionally clear the textures cache after multiple repack operations.
                // Just be aware that while this cleanup frees up memory, it is also a costly operation
                // and will likely cause a spike in the framerate.
                Spine.Unity.AttachmentTools.AtlasUtilities.ClearCache();
                UnityEngine.Resources.UnloadUnusedAssets();
            },
            /*Spine.Unity.Examples.MixAndMatch.Apply end.*/


        }
    });
    /*Spine.Unity.Examples.MixAndMatch end.*/

    /*Spine.Unity.Examples.MixAndMatchGraphic start.*/
    Bridge.define("Spine.Unity.Examples.MixAndMatchGraphic", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            baseSkinName: null,
            sourceMaterial: null,
            visorSprite: null,
            visorSlot: null,
            visorKey: null,
            gunSprite: null,
            gunSlot: null,
            gunKey: null,
            repack: false,
            runtimeAtlas: null,
            runtimeMaterial: null,
            customSkin: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.MixAndMatchGraphic#init", this ); }

                this.baseSkinName = "base";
                this.visorKey = "goggles";
                this.gunKey = "gun";
                this.repack = true;
            }
        },
        methods: {
            /*Spine.Unity.Examples.MixAndMatchGraphic.OnValidate start.*/
            OnValidate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.MixAndMatchGraphic#OnValidate", this ); }

                var $t;
                if (this.sourceMaterial == null) {
                    var skeletonGraphic = this.GetComponent(Spine.Unity.SkeletonGraphic);
                    if (UnityEngine.MonoBehaviour.op_Inequality(skeletonGraphic, null)) {
                        this.sourceMaterial = ($t = skeletonGraphic.SkeletonDataAsset.atlasAssets)[0].PrimaryMaterial;
                    }
                }
            },
            /*Spine.Unity.Examples.MixAndMatchGraphic.OnValidate end.*/

            /*Spine.Unity.Examples.MixAndMatchGraphic.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.MixAndMatchGraphic#Start", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    $enumerator.current = new UnityEngine.WaitForSeconds(1.0);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    // Delay for 1 second. For testing.
                                        this.Apply();

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Spine.Unity.Examples.MixAndMatchGraphic.Start end.*/

            /*Spine.Unity.Examples.MixAndMatchGraphic.Apply start.*/
            Apply: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.MixAndMatchGraphic#Apply", this ); }

                var skeletonGraphic = this.GetComponent(Spine.Unity.SkeletonGraphic);
                var skeleton = skeletonGraphic.Skeleton;

                // STEP 0: PREPARE SKINS
                // Let's prepare a new skin to be our custom skin with equips/customizations. We get a clone so our original skins are unaffected.
                this.customSkin = this.customSkin || new Spine.Skin("custom skin"); // This requires that all customizations are done with skin placeholders defined in Spine.

                // Next let's get the skin that contains our source attachments. These are the attachments that
                var baseSkin = skeleton.data.findSkin(this.baseSkinName);

                // STEP 1: "EQUIP" ITEMS USING SPRITES
                // STEP 1.1 Find the original attachment.
                // Step 1.2 Get a clone of the original attachment.
                // Step 1.3 Apply the Sprite image to it.
                // Step 1.4 Add the remapped clone to the new custom skin.

                // Let's do this for the visor.
                var visorSlotIndex = skeleton.data.findSlot(this.visorSlot).index; // You can access GetAttachment and SetAttachment via string, but caching the slotIndex is faster.
                var baseAttachment = baseSkin.getAttachment(visorSlotIndex, this.visorKey); // STEP 1.1

                // Note: Each call to `GetRemappedClone()` with parameter `premultiplyAlpha` set to `true` creates
                // a cached Texture copy which can be cleared by calling AtlasUtilities.ClearCache() as done below.
                var newAttachment = Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone$1(baseAttachment, this.visorSprite, this.sourceMaterial); // STEP 1.2 - 1.3
                this.customSkin.setAttachment(visorSlotIndex, this.visorKey, newAttachment); // STEP 1.4

                // And now for the gun.
                var gunSlotIndex = skeleton.data.findSlot(this.gunSlot).index;
                var baseGun = baseSkin.getAttachment(gunSlotIndex, this.gunKey); // STEP 1.1
                var newGun = Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone$1(baseGun, this.gunSprite, this.sourceMaterial); // STEP 1.2 - 1.3
                if (newGun != null) {
                    this.customSkin.setAttachment(gunSlotIndex, this.gunKey, newGun);
                } // STEP 1.4

                // customSkin.RemoveAttachment(gunSlotIndex, gunKey); // To remove an item.
                // customSkin.Clear()
                // Use skin.Clear() To remove all customizations.
                // Customizations will fall back to the value in the default skin if it was defined there.
                // To prevent fallback from happening, make sure the key is not defined in the default skin.

                // STEP 3: APPLY AND CLEAN UP.
                // Recommended: REPACK THE CUSTOM SKIN TO MINIMIZE DRAW CALLS
                // 				Repacking requires that you set all source textures/sprites/atlases to be Read/Write enabled in the inspector.
                // 				Combine all the attachment sources into one skin. Usually this means the default skin and the custom skin.
                // 				call Skin.GetRepackedSkin to get a cloned skin with cloned attachments that all use one texture.
                if (this.repack) {
                    var repackedSkin = new Spine.Skin("repacked skin");
                    repackedSkin.addSkin(skeleton.data.defaultSkin);
                    repackedSkin.addSkin(this.customSkin);
                    // Note: materials and textures returned by GetRepackedSkin() behave like 'new Texture2D()' and need to be destroyed
                    if (UnityEngine.Object.op_Implicit(this.runtimeMaterial)) {
                        UnityEngine.Object.Destroy(this.runtimeMaterial);
                    }
                    if (UnityEngine.Object.op_Implicit(this.runtimeAtlas)) {
                        UnityEngine.Object.Destroy(this.runtimeAtlas);
                    }
                    repackedSkin = Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedSkin(repackedSkin, "repacked skin", this.sourceMaterial, Bridge.ref(this, "runtimeMaterial"), Bridge.ref(this, "runtimeAtlas"));
                    skeleton.setSkin(repackedSkin);
                } else {
                    skeleton.setSkin(this.customSkin);
                }

                //skeleton.SetSlotsToSetupPose();
                skeleton.setToSetupPose();
                skeletonGraphic.Update$1(0);
                skeletonGraphic.OverrideTexture = this.runtimeAtlas;

                // `GetRepackedSkin()` and each call to `GetRemappedClone()` with parameter `premultiplyAlpha` set to `true`
                // cache necessarily created Texture copies which can be cleared by calling AtlasUtilities.ClearCache().
                // You can optionally clear the textures cache after multiple repack operations.
                // Just be aware that while this cleanup frees up memory, it is also a costly operation
                // and will likely cause a spike in the framerate.
                Spine.Unity.AttachmentTools.AtlasUtilities.ClearCache();
                UnityEngine.Resources.UnloadUnusedAssets();
            },
            /*Spine.Unity.Examples.MixAndMatchGraphic.Apply end.*/


        }
    });
    /*Spine.Unity.Examples.MixAndMatchGraphic end.*/

    /*Spine.Unity.Examples.MixAndMatchSkinsButtonExample start.*/
    Bridge.define("Spine.Unity.Examples.MixAndMatchSkinsButtonExample", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonDataAsset: null,
            skinsSystem: null,
            itemSkin: null,
            itemType: 0
        },
        methods: {
            /*Spine.Unity.Examples.MixAndMatchSkinsButtonExample.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.MixAndMatchSkinsButtonExample#Start", this ); }

                var button = this.GetComponent(UnityEngine.UI.Button);
                button.onClick.AddListener(Bridge.fn.bind(this, function () {
                    this.skinsSystem.Equip(this.itemSkin, this.itemType);
                }));
            },
            /*Spine.Unity.Examples.MixAndMatchSkinsButtonExample.Start end.*/


        }
    });
    /*Spine.Unity.Examples.MixAndMatchSkinsButtonExample end.*/

    /*Spine.Unity.Examples.MixAndMatchSkinsExample start.*/
    Bridge.define("Spine.Unity.Examples.MixAndMatchSkinsExample", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            baseSkin: null,
            eyelidsSkin: null,
            hairSkins: null,
            activeHairIndex: 0,
            eyesSkins: null,
            activeEyesIndex: 0,
            noseSkins: null,
            activeNoseIndex: 0,
            clothesSkin: null,
            pantsSkin: null,
            bagSkin: null,
            hatSkin: null,
            skeletonAnimation: null,
            characterSkin: null,
            runtimeMaterial: null,
            runtimeAtlas: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.MixAndMatchSkinsExample#init", this ); }

                this.baseSkin = "skin-base";
                this.eyelidsSkin = "eyelids/girly";
                this.hairSkins = System.Array.init([
                    "hair/brown", 
                    "hair/blue", 
                    "hair/pink", 
                    "hair/short-red", 
                    "hair/long-blue-with-scarf"
                ], System.String);
                this.activeHairIndex = 0;
                this.eyesSkins = System.Array.init([
                    "eyes/violet", 
                    "eyes/green", 
                    "eyes/yellow"
                ], System.String);
                this.activeEyesIndex = 0;
                this.noseSkins = System.Array.init(["nose/short", "nose/long"], System.String);
                this.activeNoseIndex = 0;
                this.clothesSkin = "clothes/hoodie-orange";
                this.pantsSkin = "legs/pants-jeans";
                this.bagSkin = "";
                this.hatSkin = "accessories/hat-red-yellow";
            }
        },
        methods: {
            /*Spine.Unity.Examples.MixAndMatchSkinsExample.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.MixAndMatchSkinsExample#Awake", this ); }

                this.skeletonAnimation = this.GetComponent(Spine.Unity.SkeletonAnimation);
            },
            /*Spine.Unity.Examples.MixAndMatchSkinsExample.Awake end.*/

            /*Spine.Unity.Examples.MixAndMatchSkinsExample.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.MixAndMatchSkinsExample#Start", this ); }

                this.UpdateCharacterSkin();
                this.UpdateCombinedSkin();
            },
            /*Spine.Unity.Examples.MixAndMatchSkinsExample.Start end.*/

            /*Spine.Unity.Examples.MixAndMatchSkinsExample.NextHairSkin start.*/
            NextHairSkin: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.MixAndMatchSkinsExample#NextHairSkin", this ); }

                this.activeHairIndex = (((this.activeHairIndex + 1) | 0)) % this.hairSkins.length;
                this.UpdateCharacterSkin();
                this.UpdateCombinedSkin();
            },
            /*Spine.Unity.Examples.MixAndMatchSkinsExample.NextHairSkin end.*/

            /*Spine.Unity.Examples.MixAndMatchSkinsExample.PrevHairSkin start.*/
            PrevHairSkin: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.MixAndMatchSkinsExample#PrevHairSkin", this ); }

                this.activeHairIndex = (((((this.activeHairIndex + this.hairSkins.length) | 0) - 1) | 0)) % this.hairSkins.length;
                this.UpdateCharacterSkin();
                this.UpdateCombinedSkin();
            },
            /*Spine.Unity.Examples.MixAndMatchSkinsExample.PrevHairSkin end.*/

            /*Spine.Unity.Examples.MixAndMatchSkinsExample.NextEyesSkin start.*/
            NextEyesSkin: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.MixAndMatchSkinsExample#NextEyesSkin", this ); }

                this.activeEyesIndex = (((this.activeEyesIndex + 1) | 0)) % this.eyesSkins.length;
                this.UpdateCharacterSkin();
                this.UpdateCombinedSkin();
            },
            /*Spine.Unity.Examples.MixAndMatchSkinsExample.NextEyesSkin end.*/

            /*Spine.Unity.Examples.MixAndMatchSkinsExample.PrevEyesSkin start.*/
            PrevEyesSkin: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.MixAndMatchSkinsExample#PrevEyesSkin", this ); }

                this.activeEyesIndex = (((((this.activeEyesIndex + this.eyesSkins.length) | 0) - 1) | 0)) % this.eyesSkins.length;
                this.UpdateCharacterSkin();
                this.UpdateCombinedSkin();
            },
            /*Spine.Unity.Examples.MixAndMatchSkinsExample.PrevEyesSkin end.*/

            /*Spine.Unity.Examples.MixAndMatchSkinsExample.NextNoseSkin start.*/
            NextNoseSkin: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.MixAndMatchSkinsExample#NextNoseSkin", this ); }

                this.activeNoseIndex = (((this.activeNoseIndex + 1) | 0)) % this.noseSkins.length;
                this.UpdateCharacterSkin();
                this.UpdateCombinedSkin();
            },
            /*Spine.Unity.Examples.MixAndMatchSkinsExample.NextNoseSkin end.*/

            /*Spine.Unity.Examples.MixAndMatchSkinsExample.PrevNoseSkin start.*/
            PrevNoseSkin: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.MixAndMatchSkinsExample#PrevNoseSkin", this ); }

                this.activeNoseIndex = (((((this.activeNoseIndex + this.noseSkins.length) | 0) - 1) | 0)) % this.noseSkins.length;
                this.UpdateCharacterSkin();
                this.UpdateCombinedSkin();
            },
            /*Spine.Unity.Examples.MixAndMatchSkinsExample.PrevNoseSkin end.*/

            /*Spine.Unity.Examples.MixAndMatchSkinsExample.Equip start.*/
            Equip: function (itemSkin, itemType) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.MixAndMatchSkinsExample#Equip", this ); }

                switch (itemType) {
                    case Spine.Unity.Examples.MixAndMatchSkinsExample.ItemType.Cloth: 
                        this.clothesSkin = itemSkin;
                        break;
                    case Spine.Unity.Examples.MixAndMatchSkinsExample.ItemType.Pants: 
                        this.pantsSkin = itemSkin;
                        break;
                    case Spine.Unity.Examples.MixAndMatchSkinsExample.ItemType.Bag: 
                        this.bagSkin = itemSkin;
                        break;
                    case Spine.Unity.Examples.MixAndMatchSkinsExample.ItemType.Hat: 
                        this.hatSkin = itemSkin;
                        break;
                    default: 
                        break;
                }
                this.UpdateCombinedSkin();
            },
            /*Spine.Unity.Examples.MixAndMatchSkinsExample.Equip end.*/

            /*Spine.Unity.Examples.MixAndMatchSkinsExample.OptimizeSkin start.*/
            OptimizeSkin: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.MixAndMatchSkinsExample#OptimizeSkin", this ); }

                var $t;
                // Create a repacked skin.
                var previousSkin = this.skeletonAnimation.Skeleton.skin;
                // Note: materials and textures returned by GetRepackedSkin() behave like 'new Texture2D()' and need to be destroyed
                if (UnityEngine.Object.op_Implicit(this.runtimeMaterial)) {
                    UnityEngine.Object.Destroy(this.runtimeMaterial);
                }
                if (UnityEngine.Object.op_Implicit(this.runtimeAtlas)) {
                    UnityEngine.Object.Destroy(this.runtimeAtlas);
                }
                var repackedSkin = Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedSkin(previousSkin, "Repacked skin", ($t = this.skeletonAnimation.SkeletonDataAsset.atlasAssets)[0].PrimaryMaterial, Bridge.ref(this, "runtimeMaterial"), Bridge.ref(this, "runtimeAtlas"));
                previousSkin.clear();

                // Use the repacked skin.
                this.skeletonAnimation.Skeleton.skin = repackedSkin;
                this.skeletonAnimation.Skeleton.setSlotsToSetupPose();
                this.skeletonAnimation.AnimationState.apply(this.skeletonAnimation.Skeleton);

                // `GetRepackedSkin()` and each call to `GetRemappedClone()` with parameter `premultiplyAlpha` set to `true`
                // cache necessarily created Texture copies which can be cleared by calling AtlasUtilities.ClearCache().
                // You can optionally clear the textures cache after multiple repack operations.
                // Just be aware that while this cleanup frees up memory, it is also a costly operation
                // and will likely cause a spike in the framerate.
                Spine.Unity.AttachmentTools.AtlasUtilities.ClearCache();
                UnityEngine.Resources.UnloadUnusedAssets();
            },
            /*Spine.Unity.Examples.MixAndMatchSkinsExample.OptimizeSkin end.*/

            /*Spine.Unity.Examples.MixAndMatchSkinsExample.UpdateCharacterSkin start.*/
            UpdateCharacterSkin: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.MixAndMatchSkinsExample#UpdateCharacterSkin", this ); }

                var skeleton = this.skeletonAnimation.Skeleton;
                var skeletonData = skeleton.data;
                this.characterSkin = new Spine.Skin("character-base");
                // Note that the result Skin returned by calls to skeletonData.FindSkin()
                // could be cached once in Start() instead of searching for the same skin
                // every time. For demonstration purposes we keep it simple here.
                this.characterSkin.addSkin(skeletonData.findSkin(this.baseSkin));
                this.characterSkin.addSkin(skeletonData.findSkin(this.noseSkins[this.activeNoseIndex]));
                this.characterSkin.addSkin(skeletonData.findSkin(this.eyelidsSkin));
                this.characterSkin.addSkin(skeletonData.findSkin(this.eyesSkins[this.activeEyesIndex]));
                this.characterSkin.addSkin(skeletonData.findSkin(this.hairSkins[this.activeHairIndex]));
            },
            /*Spine.Unity.Examples.MixAndMatchSkinsExample.UpdateCharacterSkin end.*/

            /*Spine.Unity.Examples.MixAndMatchSkinsExample.AddEquipmentSkinsTo start.*/
            AddEquipmentSkinsTo: function (combinedSkin) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.MixAndMatchSkinsExample#AddEquipmentSkinsTo", this ); }

                var skeleton = this.skeletonAnimation.Skeleton;
                var skeletonData = skeleton.data;
                combinedSkin.addSkin(skeletonData.findSkin(this.clothesSkin));
                combinedSkin.addSkin(skeletonData.findSkin(this.pantsSkin));
                if (!System.String.isNullOrEmpty(this.bagSkin)) {
                    combinedSkin.addSkin(skeletonData.findSkin(this.bagSkin));
                }
                if (!System.String.isNullOrEmpty(this.hatSkin)) {
                    combinedSkin.addSkin(skeletonData.findSkin(this.hatSkin));
                }
            },
            /*Spine.Unity.Examples.MixAndMatchSkinsExample.AddEquipmentSkinsTo end.*/

            /*Spine.Unity.Examples.MixAndMatchSkinsExample.UpdateCombinedSkin start.*/
            UpdateCombinedSkin: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.MixAndMatchSkinsExample#UpdateCombinedSkin", this ); }

                var skeleton = this.skeletonAnimation.Skeleton;
                var resultCombinedSkin = new Spine.Skin("character-combined");

                resultCombinedSkin.addSkin(this.characterSkin);
                this.AddEquipmentSkinsTo(resultCombinedSkin);

                skeleton.setSkin(resultCombinedSkin);
                skeleton.setSlotsToSetupPose();
            },
            /*Spine.Unity.Examples.MixAndMatchSkinsExample.UpdateCombinedSkin end.*/


        }
    });
    /*Spine.Unity.Examples.MixAndMatchSkinsExample end.*/

    /*Spine.Unity.Examples.MixAndMatchSkinsExample+ItemType start.*/
    Bridge.define("Spine.Unity.Examples.MixAndMatchSkinsExample.ItemType", {
        $kind: 1006,
        statics: {
            fields: {
                Cloth: 0,
                Pants: 1,
                Bag: 2,
                Hat: 3
            }
        }
    });
    /*Spine.Unity.Examples.MixAndMatchSkinsExample+ItemType end.*/

    /*Spine.Unity.Examples.OutlineSkeletonGraphic start.*/
    Bridge.define("Spine.Unity.Examples.OutlineSkeletonGraphic", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonGraphic: null,
            materialWithoutOutline: null,
            materialWithOutline: null
        },
        methods: {
            /*Spine.Unity.Examples.OutlineSkeletonGraphic.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.OutlineSkeletonGraphic#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic = this.GetComponent(Spine.Unity.SkeletonGraphic);
                }
            },
            /*Spine.Unity.Examples.OutlineSkeletonGraphic.OnEnable end.*/

            /*Spine.Unity.Examples.OutlineSkeletonGraphic.EnableOutlineRendering start.*/
            EnableOutlineRendering: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.OutlineSkeletonGraphic#EnableOutlineRendering", this ); }

                this.skeletonGraphic.material = this.materialWithOutline;
            },
            /*Spine.Unity.Examples.OutlineSkeletonGraphic.EnableOutlineRendering end.*/

            /*Spine.Unity.Examples.OutlineSkeletonGraphic.DisableOutlineRendering start.*/
            DisableOutlineRendering: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.OutlineSkeletonGraphic#DisableOutlineRendering", this ); }

                this.skeletonGraphic.material = this.materialWithoutOutline;
            },
            /*Spine.Unity.Examples.OutlineSkeletonGraphic.DisableOutlineRendering end.*/


        }
    });
    /*Spine.Unity.Examples.OutlineSkeletonGraphic end.*/

    /*Spine.Unity.Examples.RaggedySpineboy start.*/
    Bridge.define("Spine.Unity.Examples.RaggedySpineboy", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            groundMask: null,
            restoreDuration: 0,
            launchVelocity: null,
            ragdoll: null,
            naturalCollider: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.RaggedySpineboy#init", this ); }

                this.groundMask = new UnityEngine.LayerMask();
                this.launchVelocity = new UnityEngine.Vector2();
                this.restoreDuration = 0.5;
                this.launchVelocity = new pc.Vec2( 50, 100 );
            }
        },
        methods: {
            /*Spine.Unity.Examples.RaggedySpineboy.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.RaggedySpineboy#Start", this ); }

                this.ragdoll = this.GetComponent(Spine.Unity.Examples.SkeletonRagdoll2D);
                this.naturalCollider = this.GetComponent(UnityEngine.Collider2D);
            },
            /*Spine.Unity.Examples.RaggedySpineboy.Start end.*/

            /*Spine.Unity.Examples.RaggedySpineboy.AddRigidbody start.*/
            AddRigidbody: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.RaggedySpineboy#AddRigidbody", this ); }

                var rb = this.gameObject.AddComponent(UnityEngine.Rigidbody2D);
                rb.freezeRotation = true;
                this.naturalCollider.enabled = true;
            },
            /*Spine.Unity.Examples.RaggedySpineboy.AddRigidbody end.*/

            /*Spine.Unity.Examples.RaggedySpineboy.RemoveRigidbody start.*/
            RemoveRigidbody: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.RaggedySpineboy#RemoveRigidbody", this ); }

                UnityEngine.Object.Destroy(this.GetComponent(UnityEngine.Rigidbody2D));
                this.naturalCollider.enabled = false;
            },
            /*Spine.Unity.Examples.RaggedySpineboy.RemoveRigidbody end.*/

            /*Spine.Unity.Examples.RaggedySpineboy.OnMouseUp start.*/
            OnMouseUp: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.RaggedySpineboy#OnMouseUp", this ); }

                if (this.naturalCollider.enabled) {
                    this.Launch();
                }
            },
            /*Spine.Unity.Examples.RaggedySpineboy.OnMouseUp end.*/

            /*Spine.Unity.Examples.RaggedySpineboy.Launch start.*/
            Launch: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.RaggedySpineboy#Launch", this ); }

                this.RemoveRigidbody();
                this.ragdoll.Apply();
                this.ragdoll.RootRigidbody.velocity = new pc.Vec2( UnityEngine.Random.Range$1(-this.launchVelocity.x, this.launchVelocity.x), this.launchVelocity.y );
                this.StartCoroutine$1(this.WaitUntilStopped());
            },
            /*Spine.Unity.Examples.RaggedySpineboy.Launch end.*/

            /*Spine.Unity.Examples.RaggedySpineboy.Restore start.*/
            Restore: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.RaggedySpineboy#Restore", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    estimatedPos,
                    rbPosition,
                    skeletonPoint,
                    hit,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    estimatedPos = this.ragdoll.EstimatedSkeletonPosition.$clone();
                                        rbPosition = UnityEngine.Vector3.FromVector2(this.ragdoll.RootRigidbody.position.$clone());

                                        skeletonPoint = estimatedPos.$clone();
                                        hit = UnityEngine.Physics2D.Raycast$2(UnityEngine.Vector2.FromVector3(rbPosition), UnityEngine.Vector2.FromVector3((estimatedPos.$clone().sub( rbPosition ))), pc.Vec3.distance( estimatedPos, rbPosition ), UnityEngine.LayerMask.op_Implicit(this.groundMask.$clone()));
                                        if (UnityEngine.Component.op_Inequality(hit.collider, null)) {
                                            skeletonPoint = UnityEngine.Vector3.FromVector2(hit.point.$clone());
                                        }

                                        this.ragdoll.RootRigidbody.isKinematic = true;
                                        this.ragdoll.SetSkeletonPosition(skeletonPoint);

                                        $enumerator.current = this.ragdoll.SmoothMix(0, this.restoreDuration);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    this.ragdoll.Remove();

                                        this.AddRigidbody();

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Spine.Unity.Examples.RaggedySpineboy.Restore end.*/

            /*Spine.Unity.Examples.RaggedySpineboy.WaitUntilStopped start.*/
            WaitUntilStopped: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.RaggedySpineboy#WaitUntilStopped", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    t,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    $enumerator.current = new UnityEngine.WaitForSeconds(0.5);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    t = 0;
                                    $step = 2;
                                    continue;
                                }
                                case 2: {
                                    if ( t < 0.5 ) {
                                            $step = 3;
                                            continue;
                                        } 
                                        $step = 5;
                                        continue;
                                }
                                case 3: {
                                    t = (this.ragdoll.RootRigidbody.velocity.length() > 0.09) ? 0 : t + UnityEngine.Time.deltaTime;
                                        $enumerator.current = null;
                                        $step = 4;
                                        return true;
                                }
                                case 4: {
                                    
                                        $step = 2;
                                        continue;
                                }
                                case 5: {
                                    this.StartCoroutine$1(this.Restore());

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Spine.Unity.Examples.RaggedySpineboy.WaitUntilStopped end.*/


        }
    });
    /*Spine.Unity.Examples.RaggedySpineboy end.*/

    /*Spine.Unity.Examples.Raptor start.*/
    Bridge.define("Spine.Unity.Examples.Raptor", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            walk: null,
            gungrab: null,
            gunkeep: null,
            skeletonAnimation: null
        },
        methods: {
            /*Spine.Unity.Examples.Raptor.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.Raptor#Start", this ); }

                this.skeletonAnimation = this.GetComponent(Spine.Unity.SkeletonAnimation);
                this.StartCoroutine$1(this.GunGrabRoutine());
            },
            /*Spine.Unity.Examples.Raptor.Start end.*/

            /*Spine.Unity.Examples.Raptor.GunGrabRoutine start.*/
            GunGrabRoutine: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.Raptor#GunGrabRoutine", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    // Play the walk animation on track 0.
                                        this.skeletonAnimation.AnimationState.setAnimationWith( 0, Spine.Unity.AnimationReferenceAsset.op_Implicit(this.walk), true );

                                        // Repeatedly play the gungrab and gunkeep animation on track 1.
                                    $step = 1;
                                    continue;
                                }
                                case 1: {
                                    if ( true ) {
                                            $step = 2;
                                            continue;
                                        } 
                                        $step = 5;
                                        continue;
                                }
                                case 2: {
                                    $enumerator.current = new UnityEngine.WaitForSeconds(UnityEngine.Random.Range$1(0.5, 3.0));
                                        $step = 3;
                                        return true;
                                }
                                case 3: {
                                    this.skeletonAnimation.AnimationState.setAnimationWith( 1, Spine.Unity.AnimationReferenceAsset.op_Implicit(this.gungrab), false );

                                        $enumerator.current = new UnityEngine.WaitForSeconds(UnityEngine.Random.Range$1(0.5, 3.0));
                                        $step = 4;
                                        return true;
                                }
                                case 4: {
                                    this.skeletonAnimation.AnimationState.setAnimationWith( 1, Spine.Unity.AnimationReferenceAsset.op_Implicit(this.gunkeep), false );

                                        $step = 1;
                                        continue;
                                }
                                case 5: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Spine.Unity.Examples.Raptor.GunGrabRoutine end.*/


        }
    });
    /*Spine.Unity.Examples.Raptor end.*/

    /*Spine.Unity.Examples.RenderExistingMesh start.*/
    Bridge.define("Spine.Unity.Examples.RenderExistingMesh", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            referenceRenderer: null,
            updateViaSkeletonCallback: false,
            referenceMeshFilter: null,
            ownRenderer: null,
            ownMeshFilter: null,
            replacementMaterials: null,
            replacementMaterialDict: null,
            sharedMaterials: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.RenderExistingMesh#init", this ); }

                this.updateViaSkeletonCallback = false;
                this.replacementMaterials = System.Array.init(0, function (){
                    return new Spine.Unity.Examples.RenderExistingMesh.MaterialReplacement();
                }, Spine.Unity.Examples.RenderExistingMesh.MaterialReplacement);
                this.replacementMaterialDict = new (System.Collections.Generic.Dictionary$2(UnityEngine.Material,UnityEngine.Material)).ctor();
                this.sharedMaterials = System.Array.init(0, null, UnityEngine.Material);
            }
        },
        methods: {
            /*Spine.Unity.Examples.RenderExistingMesh.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.RenderExistingMesh#Awake", this ); }

                if (UnityEngine.Component.op_Equality(this.referenceRenderer, null)) {
                    this.referenceRenderer = this.transform.parent.GetComponentInParent(UnityEngine.MeshRenderer);
                }

                // subscribe to OnMeshAndMaterialsUpdated
                var skeletonRenderer = this.referenceRenderer.GetComponent(Spine.Unity.SkeletonAnimation);
                if (UnityEngine.Object.op_Implicit(skeletonRenderer)) {
                    skeletonRenderer.removeOnMeshAndMaterialsUpdated(Bridge.fn.cacheBind(this, this.UpdateOnCallback));
                    skeletonRenderer.addOnMeshAndMaterialsUpdated(Bridge.fn.cacheBind(this, this.UpdateOnCallback));
                    this.updateViaSkeletonCallback = true;
                }
                this.referenceMeshFilter = this.referenceRenderer.GetComponent(UnityEngine.MeshFilter);
                this.ownRenderer = this.GetComponent(UnityEngine.MeshRenderer);
                this.ownMeshFilter = this.GetComponent(UnityEngine.MeshFilter);

                this.InitializeDict();
            },
            /*Spine.Unity.Examples.RenderExistingMesh.Awake end.*/

            /*Spine.Unity.Examples.RenderExistingMesh.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.RenderExistingMesh#LateUpdate", this ); }


                if (this.updateViaSkeletonCallback) {
                    return;
                }
                this.UpdateMaterials();
            },
            /*Spine.Unity.Examples.RenderExistingMesh.LateUpdate end.*/

            /*Spine.Unity.Examples.RenderExistingMesh.UpdateOnCallback start.*/
            UpdateOnCallback: function (r) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.RenderExistingMesh#UpdateOnCallback", this ); }

                this.UpdateMaterials();
            },
            /*Spine.Unity.Examples.RenderExistingMesh.UpdateOnCallback end.*/

            /*Spine.Unity.Examples.RenderExistingMesh.UpdateMaterials start.*/
            UpdateMaterials: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.RenderExistingMesh#UpdateMaterials", this ); }

                this.ownMeshFilter.sharedMesh = this.referenceMeshFilter.sharedMesh;

                var parentMaterials = this.referenceRenderer.sharedMaterials;
                if (this.sharedMaterials.length !== parentMaterials.length) {
                    this.sharedMaterials = System.Array.init(parentMaterials.length, null, UnityEngine.Material);
                }
                for (var i = 0; i < parentMaterials.length; i = (i + 1) | 0) {
                    var parentMaterial = parentMaterials[i];
                    if (this.replacementMaterialDict.containsKey(parentMaterial)) {
                        this.sharedMaterials[i] = this.replacementMaterialDict.getItem(parentMaterial);
                    }
                }
                this.ownRenderer.sharedMaterials = this.sharedMaterials;
            },
            /*Spine.Unity.Examples.RenderExistingMesh.UpdateMaterials end.*/

            /*Spine.Unity.Examples.RenderExistingMesh.InitializeDict start.*/
            InitializeDict: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.RenderExistingMesh#InitializeDict", this ); }

                this.replacementMaterialDict.clear();
                for (var i = 0; i < this.replacementMaterials.length; i = (i + 1) | 0) {
                    var entry = this.replacementMaterials[i].$clone();
                    this.replacementMaterialDict.setItem(entry.originalMaterial, entry.replacementMaterial);
                }
            },
            /*Spine.Unity.Examples.RenderExistingMesh.InitializeDict end.*/


        }
    });
    /*Spine.Unity.Examples.RenderExistingMesh end.*/

    /*Spine.Unity.Examples.RenderExistingMesh+MaterialReplacement start.*/
    Bridge.define("Spine.Unity.Examples.RenderExistingMesh.MaterialReplacement", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.RenderExistingMesh.MaterialReplacement#getDefaultValue", this ); }
 return new Spine.Unity.Examples.RenderExistingMesh.MaterialReplacement(); }
            }
        },
        fields: {
            originalMaterial: null,
            replacementMaterial: null
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.RenderExistingMesh.MaterialReplacement#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.RenderExistingMesh.MaterialReplacement#getHashCode", this ); }

                var h = Bridge.addHash([7182746071, this.originalMaterial, this.replacementMaterial]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.RenderExistingMesh.MaterialReplacement#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.Examples.RenderExistingMesh.MaterialReplacement)) {
                    return false;
                }
                return Bridge.equals(this.originalMaterial, o.originalMaterial) && Bridge.equals(this.replacementMaterial, o.replacementMaterial);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.RenderExistingMesh.MaterialReplacement#$clone", this ); }

                var s = to || new Spine.Unity.Examples.RenderExistingMesh.MaterialReplacement();
                s.originalMaterial = this.originalMaterial;
                s.replacementMaterial = this.replacementMaterial;
                return s;
            }
        }
    });
    /*Spine.Unity.Examples.RenderExistingMesh+MaterialReplacement end.*/

    /*Spine.Unity.Examples.RenderTextureFadeoutExample start.*/
    Bridge.define("Spine.Unity.Examples.RenderTextureFadeoutExample", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            renderTextureFadeout: null,
            renderTextureFadeoutCanvas: null,
            normalSkeletonRenderer: null,
            fadeoutSeconds: 0,
            fadeoutSecondsRemaining: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.RenderTextureFadeoutExample#init", this ); }

                this.fadeoutSeconds = 2.0;
            }
        },
        methods: {
            /*Spine.Unity.Examples.RenderTextureFadeoutExample.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.RenderTextureFadeoutExample#Start", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if ( true ) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 3;
                                        continue;
                                }
                                case 1: {
                                    this.StartFadeoutBad();
                                        this.StartFadeoutGood(this.renderTextureFadeout);
                                        this.StartFadeoutGood(this.renderTextureFadeoutCanvas);
                                        $enumerator.current = new UnityEngine.WaitForSeconds(this.fadeoutSeconds + 1.0);
                                        $step = 2;
                                        return true;
                                }
                                case 2: {
                                    
                                        $step = 0;
                                        continue;
                                }
                                case 3: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Spine.Unity.Examples.RenderTextureFadeoutExample.Start end.*/

            /*Spine.Unity.Examples.RenderTextureFadeoutExample.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.RenderTextureFadeoutExample#Update", this ); }

                this.UpdateBadFadeOutAlpha();
            },
            /*Spine.Unity.Examples.RenderTextureFadeoutExample.Update end.*/

            /*Spine.Unity.Examples.RenderTextureFadeoutExample.UpdateBadFadeOutAlpha start.*/
            UpdateBadFadeOutAlpha: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.RenderTextureFadeoutExample#UpdateBadFadeOutAlpha", this ); }

                if (this.fadeoutSecondsRemaining === 0) {
                    return;
                }

                this.fadeoutSecondsRemaining -= UnityEngine.Time.deltaTime;
                if (this.fadeoutSecondsRemaining <= 0) {
                    this.fadeoutSecondsRemaining = 0;
                    return;
                }
                var fadeoutAlpha = this.fadeoutSecondsRemaining / this.fadeoutSeconds;

                // changing transparency at a MeshRenderer does not yield the desired effect
                // due to overlapping attachment meshes.
                Spine.Unity.SkeletonExtensions.SetColor$4(this.normalSkeletonRenderer.Skeleton, new pc.Color( 1, 1, 1, fadeoutAlpha ));
            },
            /*Spine.Unity.Examples.RenderTextureFadeoutExample.UpdateBadFadeOutAlpha end.*/

            /*Spine.Unity.Examples.RenderTextureFadeoutExample.StartFadeoutBad start.*/
            StartFadeoutBad: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.RenderTextureFadeoutExample#StartFadeoutBad", this ); }

                this.fadeoutSecondsRemaining = this.fadeoutSeconds;
            },
            /*Spine.Unity.Examples.RenderTextureFadeoutExample.StartFadeoutBad end.*/

            /*Spine.Unity.Examples.RenderTextureFadeoutExample.StartFadeoutGood start.*/
            StartFadeoutGood: function (fadeoutComponent) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.RenderTextureFadeoutExample#StartFadeoutGood", this ); }

                fadeoutComponent.gameObject.SetActive(true);
                // enabling the SkeletonRenderTextureFadeout component starts the fadeout.
                fadeoutComponent.enabled = true;
                fadeoutComponent.removeOnFadeoutComplete(Bridge.fn.cacheBind(this, this.DisableGameObject));
                fadeoutComponent.addOnFadeoutComplete(Bridge.fn.cacheBind(this, this.DisableGameObject));
            },
            /*Spine.Unity.Examples.RenderTextureFadeoutExample.StartFadeoutGood end.*/

            /*Spine.Unity.Examples.RenderTextureFadeoutExample.DisableGameObject start.*/
            DisableGameObject: function (target) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.RenderTextureFadeoutExample#DisableGameObject", this ); }

                target.gameObject.SetActive(false);
            },
            /*Spine.Unity.Examples.RenderTextureFadeoutExample.DisableGameObject end.*/


        }
    });
    /*Spine.Unity.Examples.RenderTextureFadeoutExample end.*/

    /*Spine.Unity.Examples.RootMotionDeltaCompensation start.*/
    Bridge.define("Spine.Unity.Examples.RootMotionDeltaCompensation", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            rootMotion: null,
            targetPosition: null,
            trackIndex: 0,
            adjustX: false,
            adjustY: false,
            minScaleX: 0,
            minScaleY: 0,
            maxScaleX: 0,
            maxScaleY: 0,
            allowXTranslation: false,
            allowYTranslation: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.RootMotionDeltaCompensation#init", this ); }

                this.trackIndex = 0;
                this.adjustX = true;
                this.adjustY = true;
                this.minScaleX = -999;
                this.minScaleY = -999;
                this.maxScaleX = 999;
                this.maxScaleY = 999;
                this.allowXTranslation = false;
                this.allowYTranslation = true;
            }
        },
        methods: {
            /*Spine.Unity.Examples.RootMotionDeltaCompensation.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.RootMotionDeltaCompensation#Start", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.rootMotion, null)) {
                    this.rootMotion = this.GetComponent(Spine.Unity.SkeletonRootMotionBase);
                }
            },
            /*Spine.Unity.Examples.RootMotionDeltaCompensation.Start end.*/

            /*Spine.Unity.Examples.RootMotionDeltaCompensation.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.RootMotionDeltaCompensation#Update", this ); }

                this.AdjustDelta();
            },
            /*Spine.Unity.Examples.RootMotionDeltaCompensation.Update end.*/

            /*Spine.Unity.Examples.RootMotionDeltaCompensation.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.RootMotionDeltaCompensation#OnDisable", this ); }

                if (this.adjustX) {
                    this.rootMotion.rootMotionScaleX = 1;
                }
                if (this.adjustY) {
                    this.rootMotion.rootMotionScaleY = 1;
                }
                if (this.allowXTranslation) {
                    this.rootMotion.rootMotionTranslateXPerY = 0;
                }
                if (this.allowYTranslation) {
                    this.rootMotion.rootMotionTranslateYPerX = 0;
                }
            },
            /*Spine.Unity.Examples.RootMotionDeltaCompensation.OnDisable end.*/

            /*Spine.Unity.Examples.RootMotionDeltaCompensation.AdjustDelta start.*/
            AdjustDelta: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.RootMotionDeltaCompensation#AdjustDelta", this ); }

                var toTarget = this.targetPosition.position.$clone().sub( this.transform.position );
                this.rootMotion.AdjustRootMotionToDistance(UnityEngine.Vector2.FromVector3(toTarget.$clone()), this.trackIndex, this.adjustX, this.adjustY, this.minScaleX, this.maxScaleX, this.minScaleY, this.maxScaleY, this.allowXTranslation, this.allowYTranslation);
            },
            /*Spine.Unity.Examples.RootMotionDeltaCompensation.AdjustDelta end.*/


        }
    });
    /*Spine.Unity.Examples.RootMotionDeltaCompensation end.*/

    /*Spine.Unity.Examples.RuntimeLoadFromExportsExample start.*/
    Bridge.define("Spine.Unity.Examples.RuntimeLoadFromExportsExample", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonJson: null,
            atlasText: null,
            textures: null,
            materialPropertySource: null,
            delay: 0,
            skinName: null,
            animationName: null,
            runtimeAtlasAsset: null,
            runtimeSkeletonDataAsset: null,
            runtimeSkeletonAnimation: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.RuntimeLoadFromExportsExample#init", this ); }

                this.delay = 0;
            }
        },
        methods: {
            /*Spine.Unity.Examples.RuntimeLoadFromExportsExample.CreateRuntimeAssetsAndGameObject start.*/
            CreateRuntimeAssetsAndGameObject: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.RuntimeLoadFromExportsExample#CreateRuntimeAssetsAndGameObject", this ); }

                // 1. Create the AtlasAsset (needs atlas text asset and textures, and materials/shader);
                // 2. Create SkeletonDataAsset (needs json or binary asset file, and an AtlasAsset)
                // 3. Create SkeletonAnimation (needs a valid SkeletonDataAsset)

                this.runtimeAtlasAsset = Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$1(this.atlasText, this.textures, this.materialPropertySource, true);
                this.runtimeSkeletonDataAsset = Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance(this.skeletonJson, this.runtimeAtlasAsset, true);
            },
            /*Spine.Unity.Examples.RuntimeLoadFromExportsExample.CreateRuntimeAssetsAndGameObject end.*/

            /*Spine.Unity.Examples.RuntimeLoadFromExportsExample.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.RuntimeLoadFromExportsExample#Start", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    this.CreateRuntimeAssetsAndGameObject();
                                        if (this.delay > 0) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 3;
                                        continue;
                                }
                                case 1: {
                                    this.runtimeSkeletonDataAsset.GetSkeletonData(false); // preload
                                        $enumerator.current = new UnityEngine.WaitForSeconds(this.delay);
                                        $step = 2;
                                        return true;
                                }
                                case 2: {
                                    $step = 3;
                                    continue;
                                }
                                case 3: {
                                    this.runtimeSkeletonAnimation = Spine.Unity.SkeletonAnimation.NewSkeletonAnimationGameObject(this.runtimeSkeletonDataAsset);

                                        // additional initialization
                                        this.runtimeSkeletonAnimation.Initialize(false);
                                        if (!Bridge.referenceEquals(this.skinName, "")) {
                                            this.runtimeSkeletonAnimation.Skeleton.setSkinByName(this.skinName);
                                        }
                                        this.runtimeSkeletonAnimation.Skeleton.setSlotsToSetupPose();
                                        if (!Bridge.referenceEquals(this.animationName, "")) {
                                            this.runtimeSkeletonAnimation.AnimationState.setAnimation(0, this.animationName, true);
                                        }

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Spine.Unity.Examples.RuntimeLoadFromExportsExample.Start end.*/


        }
    });
    /*Spine.Unity.Examples.RuntimeLoadFromExportsExample end.*/

    /*Spine.Unity.Examples.SkeletonAnimationHandleExample start.*/
    Bridge.define("Spine.Unity.Examples.SkeletonAnimationHandleExample", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonAnimation: null,
            statesAndAnimations: null,
            transitions: null,
            TargetAnimation: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonAnimationHandleExample#init", this ); }

                this.statesAndAnimations = new (System.Collections.Generic.List$1(Spine.Unity.Examples.SkeletonAnimationHandleExample.StateNameToAnimationReference)).ctor();
                this.transitions = new (System.Collections.Generic.List$1(Spine.Unity.Examples.SkeletonAnimationHandleExample.AnimationTransition)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.Examples.SkeletonAnimationHandleExample.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonAnimationHandleExample#Awake", this ); }

                var $t, $t1;
                // Initialize AnimationReferenceAssets
                $t = Bridge.getEnumerator(this.statesAndAnimations);
                try {
                    while ($t.moveNext()) {
                        var entry = $t.Current;
                        entry.animation.Initialize();
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                $t1 = Bridge.getEnumerator(this.transitions);
                try {
                    while ($t1.moveNext()) {
                        var entry1 = $t1.Current;
                        entry1.from.Initialize();
                        entry1.to.Initialize();
                        entry1.transition.Initialize();
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }

                // Build Dictionary
                //foreach (AnimationTransition entry in transitions) {
                //	transitionDictionary.Add(new AnimationStateData.AnimationPair(entry.from.Animation, entry.to.Animation), entry.transition.Animation);
                //}
            },
            /*Spine.Unity.Examples.SkeletonAnimationHandleExample.Awake end.*/

            /*Spine.Unity.Examples.SkeletonAnimationHandleExample.SetFlip start.*/
            /**
             * Sets the horizontal flip state of the skeleton based on a nonzero float. If negative, the skeleton is flipped. If positive, the skeleton is not flipped.
             *
             * @instance
             * @public
             * @this Spine.Unity.Examples.SkeletonAnimationHandleExample
             * @memberof Spine.Unity.Examples.SkeletonAnimationHandleExample
             * @param   {number}    horizontal
             * @return  {void}
             */
            SetFlip: function (horizontal) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonAnimationHandleExample#SetFlip", this ); }

                if (horizontal !== 0) {
                    this.skeletonAnimation.Skeleton.scaleX = horizontal > 0 ? 1.0 : -1.0;
                }
            },
            /*Spine.Unity.Examples.SkeletonAnimationHandleExample.SetFlip end.*/

            /*Spine.Unity.Examples.SkeletonAnimationHandleExample.PlayAnimationForState$1 start.*/
            /**
             * Plays an animation based on the state name.
             *
             * @instance
             * @public
             * @this Spine.Unity.Examples.SkeletonAnimationHandleExample
             * @memberof Spine.Unity.Examples.SkeletonAnimationHandleExample
             * @param   {string}    stateShortName    
             * @param   {number}    layerIndex
             * @return  {void}
             */
            PlayAnimationForState$1: function (stateShortName, layerIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonAnimationHandleExample#PlayAnimationForState$1", this ); }

                this.PlayAnimationForState(this.StringToHash(stateShortName), layerIndex);
            },
            /*Spine.Unity.Examples.SkeletonAnimationHandleExample.PlayAnimationForState$1 end.*/

            /*Spine.Unity.Examples.SkeletonAnimationHandleExample.PlayAnimationForState start.*/
            /**
             * Plays an animation based on the hash of the state name.
             *
             * @instance
             * @public
             * @this Spine.Unity.Examples.SkeletonAnimationHandleExample
             * @memberof Spine.Unity.Examples.SkeletonAnimationHandleExample
             * @param   {number}    shortNameHash    
             * @param   {number}    layerIndex
             * @return  {void}
             */
            PlayAnimationForState: function (shortNameHash, layerIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonAnimationHandleExample#PlayAnimationForState", this ); }

                var foundAnimation = this.GetAnimationForState(shortNameHash);
                if (foundAnimation == null) {
                    return;
                }

                this.PlayNewAnimation(foundAnimation, layerIndex);
            },
            /*Spine.Unity.Examples.SkeletonAnimationHandleExample.PlayAnimationForState end.*/

            /*Spine.Unity.Examples.SkeletonAnimationHandleExample.GetAnimationForState$1 start.*/
            /**
             * Gets a Spine Animation based on the state name.
             *
             * @instance
             * @public
             * @this Spine.Unity.Examples.SkeletonAnimationHandleExample
             * @memberof Spine.Unity.Examples.SkeletonAnimationHandleExample
             * @param   {string}             stateShortName
             * @return  {Spine.Animation}
             */
            GetAnimationForState$1: function (stateShortName) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonAnimationHandleExample#GetAnimationForState$1", this ); }

                return this.GetAnimationForState(this.StringToHash(stateShortName));
            },
            /*Spine.Unity.Examples.SkeletonAnimationHandleExample.GetAnimationForState$1 end.*/

            /*Spine.Unity.Examples.SkeletonAnimationHandleExample.GetAnimationForState start.*/
            /**
             * Gets a Spine Animation based on the hash of the state name.
             *
             * @instance
             * @public
             * @this Spine.Unity.Examples.SkeletonAnimationHandleExample
             * @memberof Spine.Unity.Examples.SkeletonAnimationHandleExample
             * @param   {number}             shortNameHash
             * @return  {Spine.Animation}
             */
            GetAnimationForState: function (shortNameHash) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonAnimationHandleExample#GetAnimationForState", this ); }

                var foundState = this.statesAndAnimations.Find(Bridge.fn.bind(this, function (entry) {
                    return this.StringToHash(entry.stateName) === shortNameHash;
                }));
                return Spine.Unity.AnimationReferenceAsset.op_Implicit((foundState == null) ? null : foundState.animation);
            },
            /*Spine.Unity.Examples.SkeletonAnimationHandleExample.GetAnimationForState end.*/

            /*Spine.Unity.Examples.SkeletonAnimationHandleExample.PlayNewAnimation start.*/
            /**
             * Play an animation. If a transition animation is defined, the transition is played before the target animation being passed.
             *
             * @instance
             * @public
             * @this Spine.Unity.Examples.SkeletonAnimationHandleExample
             * @memberof Spine.Unity.Examples.SkeletonAnimationHandleExample
             * @param   {Spine.Animation}    target        
             * @param   {number}             layerIndex
             * @return  {void}
             */
            PlayNewAnimation: function (target, layerIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonAnimationHandleExample#PlayNewAnimation", this ); }

                var transition = null;
                var current = null;

                current = this.GetCurrentAnimation(layerIndex);
                if (current != null) {
                    transition = this.TryGetTransition(current, target);
                }

                if (transition != null) {
                    this.skeletonAnimation.AnimationState.setAnimationWith( layerIndex, transition, false );
                    this.skeletonAnimation.AnimationState.addAnimationWith( layerIndex, target, true, 0.0 );
                } else {
                    this.skeletonAnimation.AnimationState.setAnimationWith( layerIndex, target, true );
                }

                this.TargetAnimation = target;
            },
            /*Spine.Unity.Examples.SkeletonAnimationHandleExample.PlayNewAnimation end.*/

            /*Spine.Unity.Examples.SkeletonAnimationHandleExample.PlayOneShot start.*/
            /**
             * Play a non-looping animation once then continue playing the state animation.
             *
             * @instance
             * @public
             * @this Spine.Unity.Examples.SkeletonAnimationHandleExample
             * @memberof Spine.Unity.Examples.SkeletonAnimationHandleExample
             * @param   {Spine.Animation}    oneShot       
             * @param   {number}             layerIndex
             * @return  {void}
             */
            PlayOneShot: function (oneShot, layerIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonAnimationHandleExample#PlayOneShot", this ); }

                var state = this.skeletonAnimation.AnimationState;
                state.setAnimationWith( 0, oneShot, false );

                var transition = this.TryGetTransition(oneShot, this.TargetAnimation);
                if (transition != null) {
                    state.addAnimationWith( 0, transition, false, 0.0 );
                }

                state.addAnimationWith( 0, this.TargetAnimation, true, 0.0 );
            },
            /*Spine.Unity.Examples.SkeletonAnimationHandleExample.PlayOneShot end.*/

            /*Spine.Unity.Examples.SkeletonAnimationHandleExample.TryGetTransition start.*/
            TryGetTransition: function (from, to) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonAnimationHandleExample#TryGetTransition", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.transitions);
                try {
                    while ($t.moveNext()) {
                        var transition = $t.Current;
                        if (Bridge.referenceEquals(transition.from.Animation, from) && Bridge.referenceEquals(transition.to.Animation, to)) {
                            return transition.transition.Animation;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return null;

                //Spine.Animation foundTransition = null;
                //transitionDictionary.TryGetValue(new AnimationStateData.AnimationPair(from, to), out foundTransition);
                //return foundTransition;
            },
            /*Spine.Unity.Examples.SkeletonAnimationHandleExample.TryGetTransition end.*/

            /*Spine.Unity.Examples.SkeletonAnimationHandleExample.GetCurrentAnimation start.*/
            GetCurrentAnimation: function (layerIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonAnimationHandleExample#GetCurrentAnimation", this ); }

                var currentTrackEntry = this.skeletonAnimation.AnimationState.getCurrent(layerIndex);
                return (currentTrackEntry != null) ? currentTrackEntry.animation : null;
            },
            /*Spine.Unity.Examples.SkeletonAnimationHandleExample.GetCurrentAnimation end.*/

            /*Spine.Unity.Examples.SkeletonAnimationHandleExample.StringToHash start.*/
            StringToHash: function (s) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonAnimationHandleExample#StringToHash", this ); }

                return UnityEngine.Animator.StringToHash(s);
            },
            /*Spine.Unity.Examples.SkeletonAnimationHandleExample.StringToHash end.*/


        },
        overloads: {
            "PlayAnimationForState(string, int)": "PlayAnimationForState$1",
            "GetAnimationForState(string)": "GetAnimationForState$1"
        }
    });
    /*Spine.Unity.Examples.SkeletonAnimationHandleExample end.*/

    /*Spine.Unity.Examples.SkeletonAnimationHandleExample+AnimationTransition start.*/
    Bridge.define("Spine.Unity.Examples.SkeletonAnimationHandleExample.AnimationTransition", {
        $kind: 1002,
        fields: {
            from: null,
            to: null,
            transition: null
        }
    });
    /*Spine.Unity.Examples.SkeletonAnimationHandleExample+AnimationTransition end.*/

    /*Spine.Unity.Examples.SkeletonAnimationHandleExample+StateNameToAnimationReference start.*/
    Bridge.define("Spine.Unity.Examples.SkeletonAnimationHandleExample.StateNameToAnimationReference", {
        $kind: 1002,
        fields: {
            stateName: null,
            animation: null
        }
    });
    /*Spine.Unity.Examples.SkeletonAnimationHandleExample+StateNameToAnimationReference end.*/

    /*Spine.Unity.Examples.SkeletonGhost start.*/
    Bridge.define("Spine.Unity.Examples.SkeletonGhost", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                GhostHideFlags: 0,
                GhostingShaderName: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGhost#init", this ); }

                    this.GhostHideFlags = UnityEngine.HideFlags.HideInHierarchy;
                    this.GhostingShaderName = "Spine/Special/SkeletonGhost";
                }
            },
            methods: {
                /*Spine.Unity.Examples.SkeletonGhost.HexToColor:static start.*/
                HexToColor: function (hex) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGhost#HexToColor", this ); }

                    var HexNumber = 515;

                    if (hex.length < 6) {
                        return UnityEngine.Color32.op_Implicit$1(new pc.Color( 1, 0, 1, 1 ));
                    }

                    hex = System.String.replaceAll(hex, "#", "");
                    var r = System.Byte.parseStyles(hex.substr(0, 2), HexNumber);
                    var g = System.Byte.parseStyles(hex.substr(2, 2), HexNumber);
                    var b = System.Byte.parseStyles(hex.substr(4, 2), HexNumber);
                    var a = 255;
                    if (hex.length === 8) {
                        a = System.Byte.parseStyles(hex.substr(6, 2), HexNumber);
                    }

                    return new UnityEngine.Color32.$ctor1(r, g, b, a);
                },
                /*Spine.Unity.Examples.SkeletonGhost.HexToColor:static end.*/


            }
        },
        fields: {
            ghostingEnabled: false,
            spawnInterval: 0,
            maximumGhosts: 0,
            fadeSpeed: 0,
            ghostShader: null,
            color: null,
            additive: false,
            textureFade: 0,
            sortWithDistanceOnly: false,
            zOffset: 0,
            nextSpawnTime: 0,
            pool: null,
            poolIndex: 0,
            skeletonRenderer: null,
            meshRenderer: null,
            meshFilter: null,
            materialTable: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGhost#init", this ); }

                this.color = new UnityEngine.Color32();
                this.ghostingEnabled = true;
                this.spawnInterval = 0.0333333351;
                this.maximumGhosts = 10;
                this.fadeSpeed = 10;
                this.color = new UnityEngine.Color32.$ctor1(255, 255, 255, 0);
                this.additive = true;
                this.textureFade = 1;
                this.zOffset = 0.0;
                this.poolIndex = 0;
                this.materialTable = new (System.Collections.Generic.Dictionary$2(UnityEngine.Material,UnityEngine.Material)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.Examples.SkeletonGhost.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGhost#Start", this ); }

                this.Initialize(false);
            },
            /*Spine.Unity.Examples.SkeletonGhost.Start end.*/

            /*Spine.Unity.Examples.SkeletonGhost.Initialize start.*/
            Initialize: function (overwrite) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGhost#Initialize", this ); }

                if (this.pool == null || overwrite) {
                    if (this.ghostShader == null) {
                        this.ghostShader = UnityEngine.Shader.Find(Spine.Unity.Examples.SkeletonGhost.GhostingShaderName);
                    }

                    this.skeletonRenderer = this.GetComponent(Spine.Unity.SkeletonRenderer);
                    this.meshFilter = this.GetComponent(UnityEngine.MeshFilter);
                    this.meshRenderer = this.GetComponent(UnityEngine.MeshRenderer);
                    this.nextSpawnTime = UnityEngine.Time.time + this.spawnInterval;
                    this.pool = System.Array.init(this.maximumGhosts, null, Spine.Unity.Examples.SkeletonGhostRenderer);
                    for (var i = 0; i < this.maximumGhosts; i = (i + 1) | 0) {
                        var go = new UnityEngine.GameObject.$ctor3((this.gameObject.name || "") + " Ghost", Spine.Unity.Examples.SkeletonGhostRenderer);
                        this.pool[i] = go.GetComponent(Spine.Unity.Examples.SkeletonGhostRenderer);
                        go.SetActive(false);
                        go.hideFlags = Spine.Unity.Examples.SkeletonGhost.GhostHideFlags;
                    }

                    var skeletonAnimation = Bridge.as(this.skeletonRenderer, Spine.Unity.IAnimationStateComponent);
                    if (skeletonAnimation != null) {
                        skeletonAnimation.Spine$Unity$IAnimationStateComponent$AnimationState.addEvent(Bridge.fn.cacheBind(this, this.OnEvent));
                    }
                }
            },
            /*Spine.Unity.Examples.SkeletonGhost.Initialize end.*/

            /*Spine.Unity.Examples.SkeletonGhost.OnEvent start.*/
            OnEvent: function (trackEntry, e) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGhost#OnEvent", this ); }

                if (System.String.equals(e.data.name, "Ghosting", 4)) {
                    this.ghostingEnabled = e.intValue > 0;
                    if (e.floatValue > 0) {
                        this.spawnInterval = e.floatValue;
                    }

                    if (!System.String.isNullOrEmpty(e.stringValue)) {
                        this.color = Spine.Unity.Examples.SkeletonGhost.HexToColor(e.stringValue);
                    }
                }
            },
            /*Spine.Unity.Examples.SkeletonGhost.OnEvent end.*/

            /*Spine.Unity.Examples.SkeletonGhost.Ghosting start.*/
            Ghosting: function (val) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGhost#Ghosting", this ); }

                this.ghostingEnabled = val > 0;
            },
            /*Spine.Unity.Examples.SkeletonGhost.Ghosting end.*/

            /*Spine.Unity.Examples.SkeletonGhost.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGhost#Update", this ); }

                var $t;
                if (!this.ghostingEnabled || this.poolIndex >= this.pool.length) {
                    return;
                }

                if (UnityEngine.Time.time >= this.nextSpawnTime) {
                    var go = this.pool[this.poolIndex].gameObject;

                    var materials = this.meshRenderer.sharedMaterials;
                    for (var i = 0; i < materials.length; i = (i + 1) | 0) {
                        var originalMat = materials[i];
                        var ghostMat;
                        if (!this.materialTable.containsKey(originalMat)) {
                            ghostMat = ($t = new UnityEngine.Material.$ctor1(originalMat), $t.shader = this.ghostShader, $t.color = new pc.Color( 1, 1, 1, 1 ), $t);

                            if (ghostMat.HasProperty$1("_TextureFade")) {
                                ghostMat.SetFloat$1("_TextureFade", this.textureFade);
                            }

                            this.materialTable.add(originalMat, ghostMat);
                        } else {
                            ghostMat = this.materialTable.getItem(originalMat);
                        }

                        materials[i] = ghostMat;
                    }

                    var goTransform = go.transform;
                    goTransform.parent = this.transform;

                    this.pool[this.poolIndex].Initialize(this.meshFilter.sharedMesh, materials, this.color, this.additive, this.fadeSpeed, this.meshRenderer.sortingLayerID, (this.sortWithDistanceOnly) ? this.meshRenderer.sortingOrder : ((this.meshRenderer.sortingOrder - 1) | 0));

                    goTransform.localPosition = new pc.Vec3( 0.0, 0.0, this.zOffset );
                    goTransform.localRotation = pc.Quat.IDENTITY.clone();
                    goTransform.localScale = new pc.Vec3( 1, 1, 1 );

                    goTransform.parent = null;

                    this.poolIndex = (this.poolIndex + 1) | 0;

                    if (this.poolIndex === this.pool.length) {
                        this.poolIndex = 0;
                    }

                    this.nextSpawnTime = UnityEngine.Time.time + this.spawnInterval;
                }
            },
            /*Spine.Unity.Examples.SkeletonGhost.Update end.*/

            /*Spine.Unity.Examples.SkeletonGhost.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGhost#OnDestroy", this ); }

                var $t;
                if (this.pool != null) {
                    for (var i = 0; i < this.maximumGhosts; i = (i + 1) | 0) {
                        if (UnityEngine.MonoBehaviour.op_Inequality(this.pool[i], null)) {
                            this.pool[i].Cleanup();
                        }
                    }
                }

                $t = Bridge.getEnumerator(this.materialTable.Values);
                try {
                    while ($t.moveNext()) {
                        var mat = $t.Current;
                        UnityEngine.Object.Destroy(mat);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.Examples.SkeletonGhost.OnDestroy end.*/


        }
    });
    /*Spine.Unity.Examples.SkeletonGhost end.*/

    /*Spine.Unity.Examples.SkeletonGhostRenderer start.*/
    Bridge.define("Spine.Unity.Examples.SkeletonGhostRenderer", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                colorPropertyName: null,
                TransparentBlack: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGhostRenderer#init", this ); }

                    this.TransparentBlack = new UnityEngine.Color32();
                    this.colorPropertyName = "_Color";
                    this.TransparentBlack = new UnityEngine.Color32.$ctor1(0, 0, 0, 0);
                }
            }
        },
        fields: {
            fadeSpeed: 0,
            startColor: null,
            meshFilter: null,
            meshRenderer: null,
            mpb: null,
            colorId: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGhostRenderer#init", this ); }

                this.startColor = new UnityEngine.Color32();
                this.fadeSpeed = 10;
            }
        },
        methods: {
            /*Spine.Unity.Examples.SkeletonGhostRenderer.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGhostRenderer#Awake", this ); }

                this.meshRenderer = this.gameObject.AddComponent(UnityEngine.MeshRenderer);
                this.meshFilter = this.gameObject.AddComponent(UnityEngine.MeshFilter);

                this.colorId = UnityEngine.Shader.PropertyToID(Spine.Unity.Examples.SkeletonGhostRenderer.colorPropertyName);
                this.mpb = new UnityEngine.MaterialPropertyBlock();
            },
            /*Spine.Unity.Examples.SkeletonGhostRenderer.Awake end.*/

            /*Spine.Unity.Examples.SkeletonGhostRenderer.Initialize start.*/
            Initialize: function (mesh, materials, color, additive, speed, sortingLayerID, sortingOrder) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGhostRenderer#Initialize", this ); }

                this.StopAllCoroutines();

                this.gameObject.SetActive(true);
                this.meshRenderer.sharedMaterials = materials;
                this.meshRenderer.sortingLayerID = sortingLayerID;
                this.meshRenderer.sortingOrder = sortingOrder;
                this.meshFilter.sharedMesh = UnityEngine.Object.Instantiate(UnityEngine.Mesh, mesh);
                this.startColor = color.$clone();
                this.mpb.SetColor(this.colorId, UnityEngine.Color32.op_Implicit(color));
                this.meshRenderer.SetPropertyBlock(this.mpb);

                this.fadeSpeed = speed;

                if (additive) {
                    this.StartCoroutine$1(this.FadeAdditive());
                } else {
                    this.StartCoroutine$1(this.Fade());
                }
            },
            /*Spine.Unity.Examples.SkeletonGhostRenderer.Initialize end.*/

            /*Spine.Unity.Examples.SkeletonGhostRenderer.Fade start.*/
            Fade: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGhostRenderer#Fade", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    c,
                    black,
                    t,
                    hardTimeLimit,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    c = this.startColor.$clone();
                                        black = Spine.Unity.Examples.SkeletonGhostRenderer.TransparentBlack.$clone();

                                        t = 1.0;
                                        hardTimeLimit = 5.0;
                                        $step = 1;
                                        continue;
                                }
                                case 1: {
                                    if ( hardTimeLimit > 0 ) {
                                            $step = 2;
                                            continue;
                                        }
                                    $step = 5;
                                    continue;
                                }
                                case 2: {
                                    c = UnityEngine.Color32.Lerp(black, this.startColor, t);
                                        this.mpb.SetColor(this.colorId, UnityEngine.Color32.op_Implicit(c));
                                        this.meshRenderer.SetPropertyBlock(this.mpb);

                                        t = pc.math.lerp(t, 0, UnityEngine.Time.deltaTime * this.fadeSpeed);
                                        if (t <= 0) {
                                            $step = 5;
                                            continue;
                                        }

                                        $enumerator.current = null;
                                        $step = 3;
                                        return true;
                                }
                                case 3: {
                                    $step = 4;
                                    continue;
                                }
                                case 4: {
                                    hardTimeLimit -= UnityEngine.Time.deltaTime;
                                    $step = 1;
                                    continue;
                                }
                                case 5: {
                                    UnityEngine.Object.Destroy(this.meshFilter.sharedMesh);
                                        this.gameObject.SetActive(false);

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Spine.Unity.Examples.SkeletonGhostRenderer.Fade end.*/

            /*Spine.Unity.Examples.SkeletonGhostRenderer.FadeAdditive start.*/
            FadeAdditive: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGhostRenderer#FadeAdditive", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    c,
                    black,
                    t,
                    hardTimeLimit,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    c = this.startColor.$clone();
                                        black = Spine.Unity.Examples.SkeletonGhostRenderer.TransparentBlack.$clone();

                                        t = 1.0;

                                        hardTimeLimit = 5.0;
                                        $step = 1;
                                        continue;
                                }
                                case 1: {
                                    if ( hardTimeLimit > 0 ) {
                                            $step = 2;
                                            continue;
                                        }
                                    $step = 5;
                                    continue;
                                }
                                case 2: {
                                    c = UnityEngine.Color32.Lerp(black, this.startColor, t);
                                        this.mpb.SetColor(this.colorId, UnityEngine.Color32.op_Implicit(c));
                                        this.meshRenderer.SetPropertyBlock(this.mpb);

                                        t = pc.math.lerp(t, 0, UnityEngine.Time.deltaTime * this.fadeSpeed);
                                        if (t <= 0) {
                                            $step = 5;
                                            continue;
                                        }

                                        $enumerator.current = null;
                                        $step = 3;
                                        return true;
                                }
                                case 3: {
                                    $step = 4;
                                    continue;
                                }
                                case 4: {
                                    hardTimeLimit -= UnityEngine.Time.deltaTime;
                                    $step = 1;
                                    continue;
                                }
                                case 5: {
                                    UnityEngine.Object.Destroy(this.meshFilter.sharedMesh);

                                        this.gameObject.SetActive(false);

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Spine.Unity.Examples.SkeletonGhostRenderer.FadeAdditive end.*/

            /*Spine.Unity.Examples.SkeletonGhostRenderer.Cleanup start.*/
            Cleanup: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGhostRenderer#Cleanup", this ); }

                if (UnityEngine.Component.op_Inequality(this.meshFilter, null) && this.meshFilter.sharedMesh != null) {
                    UnityEngine.Object.Destroy(this.meshFilter.sharedMesh);
                }

                UnityEngine.MonoBehaviour.Destroy(this.gameObject);
            },
            /*Spine.Unity.Examples.SkeletonGhostRenderer.Cleanup end.*/


        }
    });
    /*Spine.Unity.Examples.SkeletonGhostRenderer end.*/

    /*Spine.Unity.Examples.SkeletonGraphicMirror start.*/
    Bridge.define("Spine.Unity.Examples.SkeletonGraphicMirror", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            source: null,
            mirrorOnStart: false,
            restoreOnDisable: false,
            skeletonGraphic: null,
            originalSkeleton: null,
            originalFreeze: false,
            overrideTexture: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGraphicMirror#init", this ); }

                this.mirrorOnStart = true;
                this.restoreOnDisable = true;
            }
        },
        methods: {
            /*Spine.Unity.Examples.SkeletonGraphicMirror.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGraphicMirror#Awake", this ); }

                this.skeletonGraphic = this.GetComponent(Spine.Unity.SkeletonGraphic);
            },
            /*Spine.Unity.Examples.SkeletonGraphicMirror.Awake end.*/

            /*Spine.Unity.Examples.SkeletonGraphicMirror.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGraphicMirror#Start", this ); }

                if (this.mirrorOnStart) {
                    this.StartMirroring();
                }
            },
            /*Spine.Unity.Examples.SkeletonGraphicMirror.Start end.*/

            /*Spine.Unity.Examples.SkeletonGraphicMirror.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGraphicMirror#LateUpdate", this ); }

                this.skeletonGraphic.UpdateMesh();
            },
            /*Spine.Unity.Examples.SkeletonGraphicMirror.LateUpdate end.*/

            /*Spine.Unity.Examples.SkeletonGraphicMirror.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGraphicMirror#OnDisable", this ); }

                if (this.restoreOnDisable) {
                    this.RestoreIndependentSkeleton();
                }
            },
            /*Spine.Unity.Examples.SkeletonGraphicMirror.OnDisable end.*/

            /*Spine.Unity.Examples.SkeletonGraphicMirror.StartMirroring start.*/
            /**
             * Freeze the SkeletonGraphic on this GameObject, and use the source as the Skeleton to be rendered by the SkeletonGraphic.
             *
             * @instance
             * @public
             * @this Spine.Unity.Examples.SkeletonGraphicMirror
             * @memberof Spine.Unity.Examples.SkeletonGraphicMirror
             * @return  {void}
             */
            StartMirroring: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGraphicMirror#StartMirroring", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.source, null)) {
                    return;
                }
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    return;
                }

                this.skeletonGraphic.startingAnimation = "";

                if (this.originalSkeleton == null) {
                    this.originalSkeleton = this.skeletonGraphic.Skeleton;
                    this.originalFreeze = this.skeletonGraphic.freeze;
                }

                this.skeletonGraphic.Skeleton = this.source.skeleton;
                this.skeletonGraphic.freeze = true;
                if (this.overrideTexture != null) {
                    this.skeletonGraphic.OverrideTexture = this.overrideTexture;
                }
            },
            /*Spine.Unity.Examples.SkeletonGraphicMirror.StartMirroring end.*/

            /*Spine.Unity.Examples.SkeletonGraphicMirror.UpdateTexture start.*/
            /**
             * Use a new texture for the SkeletonGraphic. Use this if your source skeleton uses a repacked atlas.
             *
             * @instance
             * @public
             * @this Spine.Unity.Examples.SkeletonGraphicMirror
             * @memberof Spine.Unity.Examples.SkeletonGraphicMirror
             * @param   {UnityEngine.Texture2D}    newOverrideTexture
             * @return  {void}
             */
            UpdateTexture: function (newOverrideTexture) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGraphicMirror#UpdateTexture", this ); }

                this.overrideTexture = newOverrideTexture;
                if (newOverrideTexture != null) {
                    this.skeletonGraphic.OverrideTexture = this.overrideTexture;
                }
            },
            /*Spine.Unity.Examples.SkeletonGraphicMirror.UpdateTexture end.*/

            /*Spine.Unity.Examples.SkeletonGraphicMirror.RestoreIndependentSkeleton start.*/
            /**
             * Stops mirroring the source SkeletonRenderer and allows the SkeletonGraphic to become an independent Skeleton component again.
             *
             * @instance
             * @public
             * @this Spine.Unity.Examples.SkeletonGraphicMirror
             * @memberof Spine.Unity.Examples.SkeletonGraphicMirror
             * @return  {void}
             */
            RestoreIndependentSkeleton: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGraphicMirror#RestoreIndependentSkeleton", this ); }

                if (this.originalSkeleton == null) {
                    return;
                }

                this.skeletonGraphic.Skeleton = this.originalSkeleton;
                this.skeletonGraphic.freeze = this.originalFreeze;
                this.skeletonGraphic.OverrideTexture = null;

                this.originalSkeleton = null;
            },
            /*Spine.Unity.Examples.SkeletonGraphicMirror.RestoreIndependentSkeleton end.*/


        }
    });
    /*Spine.Unity.Examples.SkeletonGraphicMirror end.*/

    /*Spine.Unity.Examples.SkeletonRenderTextureBase start.*/
    Bridge.define("Spine.Unity.Examples.SkeletonRenderTextureBase", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            color: null,
            maxRenderTextureSize: 0,
            quad: null,
            quadMesh: null,
            renderTexture: null,
            targetCamera: null,
            commandBuffer: null,
            screenSize: null,
            usedRenderTextureSize: null,
            allocatedRenderTextureSize: null,
            downScaleFactor: null,
            worldCornerNoDistortion0: null,
            worldCornerNoDistortion1: null,
            worldCornerNoDistortion2: null,
            worldCornerNoDistortion3: null,
            uvCorner0: null,
            uvCorner1: null,
            uvCorner2: null,
            uvCorner3: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRenderTextureBase#init", this ); }

                this.color = new UnityEngine.Color();
                this.screenSize = new UnityEngine.Vector2Int();
                this.usedRenderTextureSize = new UnityEngine.Vector2Int();
                this.allocatedRenderTextureSize = new UnityEngine.Vector2Int();
                this.downScaleFactor = new UnityEngine.Vector2();
                this.worldCornerNoDistortion0 = new UnityEngine.Vector3();
                this.worldCornerNoDistortion1 = new UnityEngine.Vector3();
                this.worldCornerNoDistortion2 = new UnityEngine.Vector3();
                this.worldCornerNoDistortion3 = new UnityEngine.Vector3();
                this.uvCorner0 = new UnityEngine.Vector2();
                this.uvCorner1 = new UnityEngine.Vector2();
                this.uvCorner2 = new UnityEngine.Vector2();
                this.uvCorner3 = new UnityEngine.Vector2();
                this.color = new pc.Color( 1, 1, 1, 1 );
                this.maxRenderTextureSize = 1024;
                this.downScaleFactor = pc.Vec2.ONE.clone();
            }
        },
        methods: {
            /*Spine.Unity.Examples.SkeletonRenderTextureBase.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRenderTextureBase#Awake", this ); }

                this.commandBuffer = new UnityEngine.Rendering.CommandBuffer();
            },
            /*Spine.Unity.Examples.SkeletonRenderTextureBase.Awake end.*/

            /*Spine.Unity.Examples.SkeletonRenderTextureBase.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRenderTextureBase#OnDestroy", this ); }

                if (UnityEngine.Object.op_Implicit(this.renderTexture)) {
                    UnityEngine.RenderTexture.ReleaseTemporary(this.renderTexture);
                }
            },
            /*Spine.Unity.Examples.SkeletonRenderTextureBase.OnDestroy end.*/

            /*Spine.Unity.Examples.SkeletonRenderTextureBase.PrepareTextureMapping start.*/
            PrepareTextureMapping: function (screenSpaceMin, screenSpaceMax, screenCorner0, screenCorner1, screenCorner2, screenCorner3) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRenderTextureBase#PrepareTextureMapping", this ); }

                var $t, $t1, $t2, $t3;

                screenSpaceMin.v = ($t1 = ($t = new pc.Vec3( Math.min( screenCorner2.x, screenCorner3.x ), Math.min( screenCorner2.y, screenCorner3.y ), Math.min( screenCorner2.z, screenCorner3.z) ), new pc.Vec3( Math.min( screenCorner1.x, $t.x ), Math.min( screenCorner1.y, $t.y ), Math.min( screenCorner1.z, $t.z) )), new pc.Vec3( Math.min( screenCorner0.x, $t1.x ), Math.min( screenCorner0.y, $t1.y ), Math.min( screenCorner0.z, $t1.z) ));
                screenSpaceMax.v = ($t3 = ($t2 = new pc.Vec3( Math.max( screenCorner2.x, screenCorner3.x ), Math.max( screenCorner2.y, screenCorner3.y ), Math.max( screenCorner2.z, screenCorner3.z ) ), new pc.Vec3( Math.max( screenCorner1.x, $t2.x ), Math.max( screenCorner1.y, $t2.y ), Math.max( screenCorner1.z, $t2.z ) )), new pc.Vec3( Math.max( screenCorner0.x, $t3.x ), Math.max( screenCorner0.y, $t3.y ), Math.max( screenCorner0.z, $t3.z ) ));
                // ensure we are on whole pixel borders
                screenSpaceMin.v.x = Math.floor(screenSpaceMin.v.x);
                screenSpaceMin.v.y = Math.floor(screenSpaceMin.v.y);
                screenSpaceMax.v.x = Math.ceil(screenSpaceMax.v.x);
                screenSpaceMax.v.y = Math.ceil(screenSpaceMax.v.y);

                // inverse-map screenCornerN to screenSpaceMin/screenSpaceMax area to get UV coordinates
                this.uvCorner0 = UnityEngine.Vector2.FromVector3(Spine.Unity.MathUtilities.InverseLerp$2(screenSpaceMin.v, screenSpaceMax.v, screenCorner0));
                this.uvCorner1 = UnityEngine.Vector2.FromVector3(Spine.Unity.MathUtilities.InverseLerp$2(screenSpaceMin.v, screenSpaceMax.v, screenCorner1));
                this.uvCorner2 = UnityEngine.Vector2.FromVector3(Spine.Unity.MathUtilities.InverseLerp$2(screenSpaceMin.v, screenSpaceMax.v, screenCorner2));
                this.uvCorner3 = UnityEngine.Vector2.FromVector3(Spine.Unity.MathUtilities.InverseLerp$2(screenSpaceMin.v, screenSpaceMax.v, screenCorner3));

                this.screenSize = new UnityEngine.Vector2Int.$ctor1(Math.abs(((Bridge.Int.clip32(screenSpaceMax.v.x) - Bridge.Int.clip32(screenSpaceMin.v.x)) | 0)), Math.abs(((Bridge.Int.clip32(screenSpaceMax.v.y) - Bridge.Int.clip32(screenSpaceMin.v.y)) | 0)));
                this.usedRenderTextureSize = new UnityEngine.Vector2Int.$ctor1(Math.min(this.maxRenderTextureSize, this.screenSize.x), Math.min(this.maxRenderTextureSize, this.screenSize.y));
                this.downScaleFactor = new pc.Vec2( this.usedRenderTextureSize.x / this.screenSize.x, this.usedRenderTextureSize.y / this.screenSize.y );

                this.PrepareRenderTexture();
            },
            /*Spine.Unity.Examples.SkeletonRenderTextureBase.PrepareTextureMapping end.*/

            /*Spine.Unity.Examples.SkeletonRenderTextureBase.PrepareRenderTexture start.*/
            PrepareRenderTexture: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRenderTextureBase#PrepareRenderTexture", this ); }

                var textureSize = new UnityEngine.Vector2Int.$ctor1(UnityEngine.Mathf.NextPowerOfTwo(this.usedRenderTextureSize.x), UnityEngine.Mathf.NextPowerOfTwo(this.usedRenderTextureSize.y));

                if (UnityEngine.Vector2Int.op_Inequality(textureSize.$clone(), this.allocatedRenderTextureSize.$clone())) {
                    if (UnityEngine.Object.op_Implicit(this.renderTexture)) {
                        UnityEngine.RenderTexture.ReleaseTemporary(this.renderTexture);
                    }
                    this.renderTexture = UnityEngine.RenderTexture.GetTemporary(textureSize.x, textureSize.y);
                    this.renderTexture.filterMode = UnityEngine.FilterMode.Point;
                    this.allocatedRenderTextureSize = textureSize.$clone();
                }
            },
            /*Spine.Unity.Examples.SkeletonRenderTextureBase.PrepareRenderTexture end.*/

            /*Spine.Unity.Examples.SkeletonRenderTextureBase.AssignAtQuad start.*/
            AssignAtQuad: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRenderTextureBase#AssignAtQuad", this ); }

                var quadTransform = this.quad.transform;
                quadTransform.position = this.transform.position.$clone();
                quadTransform.rotation = this.transform.rotation.$clone();
                quadTransform.localScale = this.transform.localScale.$clone();

                var v0 = quadTransform.InverseTransformPoint(this.worldCornerNoDistortion0);
                var v1 = quadTransform.InverseTransformPoint(this.worldCornerNoDistortion1);
                var v2 = quadTransform.InverseTransformPoint(this.worldCornerNoDistortion2);
                var v3 = quadTransform.InverseTransformPoint(this.worldCornerNoDistortion3);
                var vertices = System.Array.init([v0.$clone(), v1.$clone(), v2.$clone(), v3.$clone()], UnityEngine.Vector3);

                this.quadMesh.vertices = vertices;

                var indices = System.Array.init([0, 1, 2, 2, 1, 3], System.Int32);
                this.quadMesh.triangles = indices;

                var normals = System.Array.init([new pc.Vec3( 0, 0, 1 ).scale( -1 ), new pc.Vec3( 0, 0, 1 ).scale( -1 ), new pc.Vec3( 0, 0, 1 ).scale( -1 ), new pc.Vec3( 0, 0, 1 ).scale( -1 )], UnityEngine.Vector3);
                this.quadMesh.normals = normals;

                var maxU = this.usedRenderTextureSize.x / this.allocatedRenderTextureSize.x;
                var maxV = this.usedRenderTextureSize.y / this.allocatedRenderTextureSize.y;
                if (this.downScaleFactor.x < 1 || this.downScaleFactor.y < 1) {
                    maxU = this.downScaleFactor.x * this.screenSize.x / this.allocatedRenderTextureSize.x;
                    maxV = this.downScaleFactor.y * this.screenSize.y / this.allocatedRenderTextureSize.y;
                }
                var uv = System.Array.init([new pc.Vec2( this.uvCorner0.x * maxU, this.uvCorner0.y * maxV ), new pc.Vec2( this.uvCorner1.x * maxU, this.uvCorner1.y * maxV ), new pc.Vec2( this.uvCorner2.x * maxU, this.uvCorner2.y * maxV ), new pc.Vec2( this.uvCorner3.x * maxU, this.uvCorner3.y * maxV )], UnityEngine.Vector2);
                this.quadMesh.uv = uv;
                this.AssignMeshAtRenderer();
            },
            /*Spine.Unity.Examples.SkeletonRenderTextureBase.AssignAtQuad end.*/


        }
    });
    /*Spine.Unity.Examples.SkeletonRenderTextureBase end.*/

    /*Spine.Unity.Examples.SkeletonGraphicRenderTexture+TextureMaterialPair start.*/
    Bridge.define("Spine.Unity.Examples.SkeletonGraphicRenderTexture.TextureMaterialPair", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGraphicRenderTexture.TextureMaterialPair#getDefaultValue", this ); }
 return new Spine.Unity.Examples.SkeletonGraphicRenderTexture.TextureMaterialPair(); }
            }
        },
        fields: {
            texture: null,
            material: null
        },
        ctors: {
            $ctor1: function (texture, material) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGraphicRenderTexture.TextureMaterialPair#$ctor1", this ); }

                this.$initialize();
                this.texture = texture;
                this.material = material;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGraphicRenderTexture.TextureMaterialPair#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGraphicRenderTexture.TextureMaterialPair#getHashCode", this ); }

                var h = Bridge.addHash([6528571124, this.texture, this.material]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGraphicRenderTexture.TextureMaterialPair#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.Examples.SkeletonGraphicRenderTexture.TextureMaterialPair)) {
                    return false;
                }
                return Bridge.equals(this.texture, o.texture) && Bridge.equals(this.material, o.material);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGraphicRenderTexture.TextureMaterialPair#$clone", this ); }

                var s = to || new Spine.Unity.Examples.SkeletonGraphicRenderTexture.TextureMaterialPair();
                s.texture = this.texture;
                s.material = this.material;
                return s;
            }
        }
    });
    /*Spine.Unity.Examples.SkeletonGraphicRenderTexture+TextureMaterialPair end.*/

    /*Spine.Unity.Examples.SkeletonRagdoll start.*/
    Bridge.define("Spine.Unity.Examples.SkeletonRagdoll", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                parentSpaceHelper: null
            }
        },
        fields: {
            startingBoneName: null,
            stopBoneNames: null,
            applyOnStart: false,
            disableIK: false,
            disableOtherConstraints: false,
            pinStartBone: false,
            enableJointCollision: false,
            useGravity: false,
            thickness: 0,
            rotationLimit: 0,
            rootMass: 0,
            massFalloffFactor: 0,
            colliderLayer: 0,
            mix: 0,
            oldRagdollBehaviour: false,
            targetSkeletonComponent: null,
            skeleton: null,
            boneTable: null,
            boneFlipTable: null,
            ragdollRoot: null,
            RootRigidbody: null,
            StartingBone: null,
            rootOffset: null,
            isActive: false
        },
        props: {
            RootOffset: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll#RootOffset#get", this ); }

                    return this.rootOffset.$clone();
                }
            },
            IsActive: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll#IsActive#get", this ); }

                    return this.isActive;
                }
            },
            RigidbodyArray: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll#RigidbodyArray#get", this ); }

                    var $t;
                    if (!this.isActive) {
                        return System.Array.init(0, null, UnityEngine.Rigidbody);
                    }

                    var rigidBodies = System.Array.init(this.boneTable.Count, null, UnityEngine.Rigidbody);
                    var i = 0;
                    $t = Bridge.getEnumerator(this.boneTable.Values);
                    try {
                        while ($t.moveNext()) {
                            var t = $t.Current;
                            rigidBodies[i] = t.GetComponent(UnityEngine.Rigidbody);
                            i = (i + 1) | 0;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    return rigidBodies;
                }
            },
            EstimatedSkeletonPosition: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll#EstimatedSkeletonPosition#get", this ); }

                    return this.RootRigidbody.position.$clone().sub( this.rootOffset );
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll#init", this ); }

                this.rootOffset = new UnityEngine.Vector3();
                this.startingBoneName = "";
                this.stopBoneNames = new (System.Collections.Generic.List$1(System.String)).ctor();
                this.disableIK = true;
                this.disableOtherConstraints = false;
                this.useGravity = true;
                this.thickness = 0.125;
                this.rotationLimit = 20;
                this.rootMass = 20;
                this.massFalloffFactor = 0.4;
                this.colliderLayer = 0;
                this.mix = 1;
                this.oldRagdollBehaviour = false;
                this.boneTable = new (System.Collections.Generic.Dictionary$2(Spine.Bone,UnityEngine.Transform)).ctor();
                this.boneFlipTable = new (System.Collections.Generic.Dictionary$2(Spine.Bone,Spine.Unity.Examples.SkeletonRagdoll.BoneFlipEntry)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.Examples.SkeletonRagdoll.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll#Start", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if (UnityEngine.Component.op_Equality(Spine.Unity.Examples.SkeletonRagdoll.parentSpaceHelper, null)) {
                                            Spine.Unity.Examples.SkeletonRagdoll.parentSpaceHelper = (new UnityEngine.GameObject.$ctor2("Parent Space Helper")).transform;
                                            Spine.Unity.Examples.SkeletonRagdoll.parentSpaceHelper.hideFlags = UnityEngine.HideFlags.HideInHierarchy;
                                        }

                                        this.targetSkeletonComponent = Bridge.as(this.GetComponent(Spine.Unity.SkeletonRenderer), Spine.Unity.ISkeletonAnimation);
                                        if (this.targetSkeletonComponent == null) {
                                            UnityEngine.Debug.LogError$2("Attached Spine component does not implement ISkeletonAnimation. This script is not compatible.");
                                        }
                                        this.skeleton = this.targetSkeletonComponent.Spine$Unity$ISkeletonAnimation$Skeleton;

                                        if (this.applyOnStart) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 3;
                                        continue;
                                }
                                case 1: {
                                    $enumerator.current = null;
                                        $step = 2;
                                        return true;
                                }
                                case 2: {
                                    this.Apply();
                                    $step = 3;
                                    continue;
                                }
                                case 3: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Spine.Unity.Examples.SkeletonRagdoll.Start end.*/

            /*Spine.Unity.Examples.SkeletonRagdoll.Apply start.*/
            /**
             * Instantiates the ragdoll simulation and applies its transforms to the skeleton.
             *
             * @instance
             * @public
             * @this Spine.Unity.Examples.SkeletonRagdoll
             * @memberof Spine.Unity.Examples.SkeletonRagdoll
             * @return  {void}
             */
            Apply: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll#Apply", this ); }

                var $t, $t1;
                this.isActive = true;
                this.mix = 1;

                this.StartingBone = this.skeleton.findBone(this.startingBoneName);
                this.RecursivelyCreateBoneProxies(this.StartingBone);

                this.RootRigidbody = this.boneTable.getItem(this.StartingBone).GetComponent(UnityEngine.Rigidbody);
                this.RootRigidbody.isKinematic = this.pinStartBone;
                this.RootRigidbody.mass = this.rootMass;
                var boneColliders = new (System.Collections.Generic.List$1(UnityEngine.Collider)).ctor();
                $t = Bridge.getEnumerator(this.boneTable);
                try {
                    while ($t.moveNext()) {
                        var pair = $t.Current;
                        var b = pair.key;
                        var t = pair.value;
                        var parentTransform;
                        boneColliders.add(t.GetComponent(UnityEngine.Collider));
                        if (Bridge.referenceEquals(b, this.StartingBone)) {
                            this.ragdollRoot = new UnityEngine.GameObject.$ctor2("RagdollRoot").transform;
                            this.ragdollRoot.SetParent(this.transform, false);
                            if (Bridge.referenceEquals(b, this.skeleton.getRootBone())) { // RagdollRoot is skeleton root's parent, thus the skeleton's scale and position.
                                this.ragdollRoot.localPosition = new pc.Vec3( this.skeleton.x, this.skeleton.y, 0 );
                                this.ragdollRoot.localRotation = (this.skeleton.scaleX < 0) ? new pc.Quat().setFromEulerAngles_Unity( 0, 0, 180.0 ) : pc.Quat.IDENTITY.clone();
                            } else {
                                this.ragdollRoot.localPosition = new pc.Vec3( b.parent.worldX, b.parent.worldY, 0 );
                                this.ragdollRoot.localRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, b.parent.getWorldRotationX() - b.parent.shearX );
                            }
                            parentTransform = this.ragdollRoot;
                            this.rootOffset = t.position.$clone().sub( this.transform.position );
                        } else {
                            parentTransform = this.boneTable.getItem(b.parent);
                        }

                        // Add joint and attach to parent.
                        var rbParent = parentTransform.GetComponent(UnityEngine.Rigidbody);
                        if (UnityEngine.Component.op_Inequality(rbParent, null)) {
                            var joint = t.gameObject.AddComponent(UnityEngine.HingeJoint);
                            joint.connectedBody = rbParent;
                            var localPos = parentTransform.InverseTransformPoint(t.position);
                            localPos.x *= 1;
                            joint.connectedAnchor = localPos.$clone();
                            joint.axis = new pc.Vec3( 0, 0, 1 );

                            joint.GetComponent(UnityEngine.Rigidbody).mass = joint.connectedBody.mass * this.massFalloffFactor;
                            joint.limits = ($t1 = new UnityEngine.JointLimits(), $t1.min = -this.rotationLimit, $t1.max = this.rotationLimit, $t1);
                            joint.useLimits = true;
                            joint.enableCollision = this.enableJointCollision;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                // Ignore collisions among bones.
                for (var x = 0; x < boneColliders.Count; x = (x + 1) | 0) {
                    for (var y = 0; y < boneColliders.Count; y = (y + 1) | 0) {
                        if (x === y) {
                            continue;
                        }
                        UnityEngine.Physics.IgnoreCollision(boneColliders.getItem(x), boneColliders.getItem(y));
                    }
                }

                // Destroy existing override-mode SkeletonUtilityBones.
                var utilityBones = this.GetComponentsInChildren(Spine.Unity.SkeletonUtilityBone);
                if (utilityBones.length > 0) {
                    var destroyedUtilityBoneNames = new (System.Collections.Generic.List$1(System.String)).ctor();
                    $t1 = Bridge.getEnumerator(utilityBones);
                    try {
                        while ($t1.moveNext()) {
                            var ub = $t1.Current;
                            if (ub.mode === Spine.Unity.SkeletonUtilityBone.Mode.Override) {
                                destroyedUtilityBoneNames.add(ub.gameObject.name);
                                UnityEngine.MonoBehaviour.Destroy(ub.gameObject);
                            }
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                    if (destroyedUtilityBoneNames.Count > 0) {
                        var msg = "Destroyed Utility Bones: ";
                        for (var i = 0; i < destroyedUtilityBoneNames.Count; i = (i + 1) | 0) {
                            msg = (msg || "") + (destroyedUtilityBoneNames.getItem(i) || "");
                            if (i !== ((destroyedUtilityBoneNames.Count - 1) | 0)) {
                                msg = (msg || "") + ",";
                            }
                        }
                        UnityEngine.Debug.LogWarning$1(msg);
                    }
                }

                // Disable skeleton constraints.
                if (this.disableIK) {
                    var ikConstraints = this.skeleton.IkConstraints;
                    for (var i1 = 0, n = ikConstraints.Count; i1 < n; i1 = (i1 + 1) | 0) {
                        ikConstraints.Items[i1].mix = 0;
                    }
                }

                if (this.disableOtherConstraints) {
                    var transformConstraints = this.skeleton.TransformConstraints;
                    for (var i2 = 0, n1 = transformConstraints.Count; i2 < n1; i2 = (i2 + 1) | 0) {
                        transformConstraints.Items[i2].mixRotate = 0;
                        transformConstraints.Items[i2].mixScaleX = 0;
                        transformConstraints.Items[i2].mixScaleY = 0;
                        transformConstraints.Items[i2].mixShearY = 0;
                        transformConstraints.Items[i2].mixX = 0;
                        transformConstraints.Items[i2].mixY = 0;
                    }

                    var pathConstraints = this.skeleton.PathConstraints;
                    for (var i3 = 0, n2 = pathConstraints.Count; i3 < n2; i3 = (i3 + 1) | 0) {
                        pathConstraints.Items[i3].mixRotate = 0;
                        pathConstraints.Items[i3].mixX = 0;
                        pathConstraints.Items[i3].mixY = 0;
                    }
                }

                this.targetSkeletonComponent.Spine$Unity$ISkeletonAnimation$addUpdateWorld(Bridge.fn.cacheBind(this, this.UpdateSpineSkeleton));
            },
            /*Spine.Unity.Examples.SkeletonRagdoll.Apply end.*/

            /*Spine.Unity.Examples.SkeletonRagdoll.SmoothMix start.*/
            /**
             * Transitions the mix value from the current value to a target value.
             *
             * @instance
             * @public
             * @this Spine.Unity.Examples.SkeletonRagdoll
             * @memberof Spine.Unity.Examples.SkeletonRagdoll
             * @param   {number}                   target      
             * @param   {number}                   duration
             * @return  {UnityEngine.Coroutine}
             */
            SmoothMix: function (target, duration) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll#SmoothMix", this ); }

                return this.StartCoroutine$1(this.SmoothMixCoroutine(target, duration));
            },
            /*Spine.Unity.Examples.SkeletonRagdoll.SmoothMix end.*/

            /*Spine.Unity.Examples.SkeletonRagdoll.SmoothMixCoroutine start.*/
            SmoothMixCoroutine: function (target, duration) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll#SmoothMixCoroutine", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    startTime,
                    startMix,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    startTime = UnityEngine.Time.time;
                                        startMix = this.mix;
                                    $step = 1;
                                    continue;
                                }
                                case 1: {
                                    if ( this.mix > 0 ) {
                                            $step = 2;
                                            continue;
                                        } 
                                        $step = 4;
                                        continue;
                                }
                                case 2: {
                                    this.skeleton.setBonesToSetupPose();
                                        this.mix = pc.math.smoothstep(startMix, target, (UnityEngine.Time.time - startTime) / duration);
                                        $enumerator.current = null;
                                        $step = 3;
                                        return true;
                                }
                                case 3: {
                                    
                                        $step = 1;
                                        continue;
                                }
                                case 4: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Spine.Unity.Examples.SkeletonRagdoll.SmoothMixCoroutine end.*/

            /*Spine.Unity.Examples.SkeletonRagdoll.SetSkeletonPosition start.*/
            /**
             * Set the transform world position while preserving the ragdoll parts world position.
             *
             * @instance
             * @public
             * @this Spine.Unity.Examples.SkeletonRagdoll
             * @memberof Spine.Unity.Examples.SkeletonRagdoll
             * @param   {UnityEngine.Vector3}    worldPosition
             * @return  {void}
             */
            SetSkeletonPosition: function (worldPosition) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll#SetSkeletonPosition", this ); }

                var $t;
                if (!this.isActive) {
                    UnityEngine.Debug.LogWarning$1("Can't call SetSkeletonPosition while Ragdoll is not active!");
                    return;
                }

                var offset = worldPosition.$clone().sub( this.transform.position );
                this.transform.position = worldPosition.$clone();
                $t = Bridge.getEnumerator(this.boneTable.Values);
                try {
                    while ($t.moveNext()) {
                        var t = $t.Current;
                        t.position = t.position.$clone().sub( offset.$clone() );
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                this.UpdateSpineSkeleton(null);
                this.skeleton.updateWorldTransform();
            },
            /*Spine.Unity.Examples.SkeletonRagdoll.SetSkeletonPosition end.*/

            /*Spine.Unity.Examples.SkeletonRagdoll.Remove start.*/
            /**
             * Removes the ragdoll instance and effect from the animated skeleton.
             *
             * @instance
             * @public
             * @this Spine.Unity.Examples.SkeletonRagdoll
             * @memberof Spine.Unity.Examples.SkeletonRagdoll
             * @return  {void}
             */
            Remove: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll#Remove", this ); }

                var $t;
                this.isActive = false;
                $t = Bridge.getEnumerator(this.boneTable.Values);
                try {
                    while ($t.moveNext()) {
                        var t = $t.Current;
                        UnityEngine.MonoBehaviour.Destroy(t.gameObject);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                UnityEngine.MonoBehaviour.Destroy(this.ragdollRoot.gameObject);

                this.boneTable.clear();
                this.targetSkeletonComponent.Spine$Unity$ISkeletonAnimation$removeUpdateWorld(Bridge.fn.cacheBind(this, this.UpdateSpineSkeleton));
            },
            /*Spine.Unity.Examples.SkeletonRagdoll.Remove end.*/

            /*Spine.Unity.Examples.SkeletonRagdoll.GetRigidbody start.*/
            GetRigidbody: function (boneName) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll#GetRigidbody", this ); }

                var bone = this.skeleton.findBone(boneName);
                return (bone != null && this.boneTable.containsKey(bone)) ? this.boneTable.getItem(bone).GetComponent(UnityEngine.Rigidbody) : null;
            },
            /*Spine.Unity.Examples.SkeletonRagdoll.GetRigidbody end.*/

            /*Spine.Unity.Examples.SkeletonRagdoll.RecursivelyCreateBoneProxies start.*/
            RecursivelyCreateBoneProxies: function (b) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll#RecursivelyCreateBoneProxies", this ); }

                var $t;
                var boneName = b.data.name;
                if (this.stopBoneNames.contains(boneName)) {
                    return;
                }

                var boneGameObject = new UnityEngine.GameObject.$ctor2(boneName);
                boneGameObject.layer = this.colliderLayer;
                var t = boneGameObject.transform;
                this.boneTable.add(b, t);

                t.parent = this.transform;
                t.localPosition = new pc.Vec3( b.worldX, b.worldY, 0 );
                t.localRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, b.getWorldRotationX() - b.shearX );
                t.localScale = new pc.Vec3( b.getWorldScaleX(), b.getWorldScaleY(), 1 );

                var colliders = this.AttachBoundingBoxRagdollColliders(b);
                if (colliders.Count === 0) {
                    var length = b.data.length;
                    if (length === 0) {
                        var ball = boneGameObject.AddComponent(UnityEngine.SphereCollider);
                        ball.radius = this.thickness * 0.5;
                    } else {
                        var box = boneGameObject.AddComponent(UnityEngine.BoxCollider);
                        box.size = new pc.Vec3( length, this.thickness, this.thickness );
                        box.center = new pc.Vec3( length * 0.5, 0, 0 );
                    }
                }
                var rb = boneGameObject.AddComponent(UnityEngine.Rigidbody);
                rb.constraints = UnityEngine.RigidbodyConstraints.FreezePositionZ;

                $t = Bridge.getEnumerator(b.Children);
                try {
                    while ($t.moveNext()) {
                        var child = $t.Current;
                        this.RecursivelyCreateBoneProxies(child);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.Examples.SkeletonRagdoll.RecursivelyCreateBoneProxies end.*/

            /*Spine.Unity.Examples.SkeletonRagdoll.UpdateSpineSkeleton start.*/
            UpdateSpineSkeleton: function (skeletonRenderer) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll#UpdateSpineSkeleton", this ); }

                var $t;
                var parentFlipX = { };
                var parentFlipY = { };
                this.GetStartBoneParentFlipState(parentFlipX, parentFlipY);

                $t = Bridge.getEnumerator(this.boneTable);
                try {
                    while ($t.moveNext()) {
                        var pair = $t.Current;
                        var b = pair.key;
                        var t = pair.value;
                        var isStartingBone = Bridge.referenceEquals(b, this.StartingBone);
                        var parentBone = b.parent;
                        var parentTransform = isStartingBone ? this.ragdollRoot : this.boneTable.getItem(parentBone);
                        if (!isStartingBone) {
                            var parentBoneFlip = this.boneFlipTable.getItem(parentBone).$clone();
                            parentFlipX.v = parentBoneFlip.flipX;
                            parentFlipY.v = parentBoneFlip.flipY;
                        }
                        var flipX = parentFlipX.v != (b.scaleX < 0);
                        var flipY = parentFlipY.v != (b.scaleY < 0);

                        var boneFlip = { v : new Spine.Unity.Examples.SkeletonRagdoll.BoneFlipEntry() };
                        this.boneFlipTable.tryGetValue(b, boneFlip);
                        boneFlip.v.flipX = flipX;
                        boneFlip.v.flipY = flipY;
                        this.boneFlipTable.setItem(b, boneFlip.v.$clone());

                        var flipXOR = flipX != flipY;
                        var parentFlipXOR = parentFlipX.v != parentFlipY.v;

                        if (!this.oldRagdollBehaviour && isStartingBone) {
                            if (!Bridge.referenceEquals(b, this.skeleton.getRootBone())) { // RagdollRoot is not skeleton root.
                                this.ragdollRoot.localPosition = new pc.Vec3( parentBone.worldX, parentBone.worldY, 0 );
                                this.ragdollRoot.localRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, parentBone.getWorldRotationX() - parentBone.shearX );
                                this.ragdollRoot.localScale = new pc.Vec3( parentBone.getWorldScaleX(), parentBone.getWorldScaleY(), 1 );
                            }
                        }
                        var parentTransformWorldPosition = parentTransform.position.$clone();
                        var parentTransformWorldRotation = parentTransform.rotation.$clone();

                        Spine.Unity.Examples.SkeletonRagdoll.parentSpaceHelper.position = parentTransformWorldPosition.$clone();
                        Spine.Unity.Examples.SkeletonRagdoll.parentSpaceHelper.rotation = parentTransformWorldRotation.$clone();
                        Spine.Unity.Examples.SkeletonRagdoll.parentSpaceHelper.localScale = parentTransform.lossyScale.$clone();

                        if (this.oldRagdollBehaviour) {
                            if (isStartingBone && !Bridge.referenceEquals(b, this.skeleton.getRootBone())) {
                                var localPosition = new pc.Vec3( b.parent.worldX, b.parent.worldY, 0 );
                                Spine.Unity.Examples.SkeletonRagdoll.parentSpaceHelper.position = this.ragdollRoot.TransformPoint$1(localPosition);
                                Spine.Unity.Examples.SkeletonRagdoll.parentSpaceHelper.localRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, parentBone.getWorldRotationX() - parentBone.shearX );
                                Spine.Unity.Examples.SkeletonRagdoll.parentSpaceHelper.localScale = new pc.Vec3( parentBone.getWorldScaleX(), parentBone.getWorldScaleY(), 1 );
                            }
                        }

                        var boneWorldPosition = t.position.$clone();
                        var right = Spine.Unity.Examples.SkeletonRagdoll.parentSpaceHelper.InverseTransformDirection(t.right);

                        var boneLocalPosition = Spine.Unity.Examples.SkeletonRagdoll.parentSpaceHelper.InverseTransformPoint(boneWorldPosition);
                        var boneLocalRotation = Math.atan2(right.y, right.x) * UnityEngine.Mathf.Rad2Deg;

                        if (flipXOR) {
                            boneLocalPosition.y *= -1.0;
                        }
                        if (parentFlipXOR !== flipXOR) {
                            boneLocalPosition.y *= -1.0;
                        }

                        if (parentFlipXOR) {
                            boneLocalRotation *= -1.0;
                        }
                        if (parentFlipX.v !== flipX) {
                            boneLocalRotation += 180;
                        }

                        b.x = pc.math.lerp(b.x, boneLocalPosition.x, this.mix);
                        b.y = pc.math.lerp(b.y, boneLocalPosition.y, this.mix);
                        b.rotation = pc.math.lerp(b.rotation, boneLocalRotation, this.mix);
                        //b.AppliedRotation = Mathf.Lerp(b.AppliedRotation, boneLocalRotation, mix);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.Examples.SkeletonRagdoll.UpdateSpineSkeleton end.*/

            /*Spine.Unity.Examples.SkeletonRagdoll.GetStartBoneParentFlipState start.*/
            GetStartBoneParentFlipState: function (parentFlipX, parentFlipY) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll#GetStartBoneParentFlipState", this ); }

                parentFlipX.v = this.skeleton.scaleX < 0;
                parentFlipY.v = this.skeleton.scaleY < 0;
                var parent = this.StartingBone == null ? null : this.StartingBone.parent;
                while (parent != null) {
                    parentFlipX.v = parentFlipX.v != parent.scaleX < 0;
                    parentFlipY.v = parentFlipY.v != parent.scaleY < 0;
                    parent = parent.parent;
                }
            },
            /*Spine.Unity.Examples.SkeletonRagdoll.GetStartBoneParentFlipState end.*/

            /*Spine.Unity.Examples.SkeletonRagdoll.AttachBoundingBoxRagdollColliders start.*/
            AttachBoundingBoxRagdollColliders: function (b) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll#AttachBoundingBoxRagdollColliders", this ); }

                var $t, $t1;
                var AttachmentNameMarker = "ragdoll";
                var colliders = new (System.Collections.Generic.List$1(UnityEngine.Collider)).ctor();

                var t = this.boneTable.getItem(b);
                var go = t.gameObject;
                var skin = this.skeleton.skin || this.skeleton.data.defaultSkin;

                var skinEntries = new (System.Collections.Generic.List$1(spine.SkinEntry)).ctor();
                $t = Bridge.getEnumerator(this.skeleton.Slots);
                try {
                    while ($t.moveNext()) {
                        var s = $t.Current;
                        if (Bridge.referenceEquals(s.bone, b)) {
                            ( skinEntries._items.length = 0, skin.getAttachmentsForSlot( this.skeleton.Slots.IndexOf(s), skinEntries._items ), skinEntries._size = skinEntries._items.length );

                            $t1 = Bridge.getEnumerator(skinEntries);
                            try {
                                while ($t1.moveNext()) {
                                    var entry = $t1.Current;
                                    var bbAttachment = Bridge.as(entry.attachment, spine.BoundingBoxAttachment);
                                    if (bbAttachment != null) {
                                        if (!System.String.contains(entry.name.toLowerCase(),AttachmentNameMarker)) {
                                            continue;
                                        }

                                        var bbCollider = go.AddComponent(UnityEngine.BoxCollider);
                                        var bounds = Spine.Unity.SkeletonUtility.GetBoundingBoxBounds(bbAttachment, this.thickness);
                                        bbCollider.center = bounds.center.$clone();
                                        bbCollider.size = bounds.halfExtents.$clone().scale( 2 ).$clone();
                                        colliders.add(bbCollider);
                                    }
                                }
                            } finally {
                                if (Bridge.is($t1, System.IDisposable)) {
                                    $t1.System$IDisposable$Dispose();
                                }
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                return colliders;
            },
            /*Spine.Unity.Examples.SkeletonRagdoll.AttachBoundingBoxRagdollColliders end.*/


        }
    });
    /*Spine.Unity.Examples.SkeletonRagdoll end.*/

    /*Spine.Unity.Examples.SkeletonRagdoll+BoneFlipEntry start.*/
    Bridge.define("Spine.Unity.Examples.SkeletonRagdoll.BoneFlipEntry", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll.BoneFlipEntry#getDefaultValue", this ); }
 return new Spine.Unity.Examples.SkeletonRagdoll.BoneFlipEntry(); }
            }
        },
        fields: {
            flipX: false,
            flipY: false
        },
        ctors: {
            $ctor1: function (flipX, flipY) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll.BoneFlipEntry#$ctor1", this ); }

                this.$initialize();
                this.flipX = flipX;
                this.flipY = flipY;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll.BoneFlipEntry#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll.BoneFlipEntry#getHashCode", this ); }

                var h = Bridge.addHash([5507926598, this.flipX, this.flipY]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll.BoneFlipEntry#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.Examples.SkeletonRagdoll.BoneFlipEntry)) {
                    return false;
                }
                return Bridge.equals(this.flipX, o.flipX) && Bridge.equals(this.flipY, o.flipY);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll.BoneFlipEntry#$clone", this ); }

                var s = to || new Spine.Unity.Examples.SkeletonRagdoll.BoneFlipEntry();
                s.flipX = this.flipX;
                s.flipY = this.flipY;
                return s;
            }
        }
    });
    /*Spine.Unity.Examples.SkeletonRagdoll+BoneFlipEntry end.*/

    /*Spine.Unity.Examples.SkeletonRagdoll+LayerFieldAttribute start.*/
    Bridge.define("Spine.Unity.Examples.SkeletonRagdoll.LayerFieldAttribute", {
        inherits: [UnityEngine.PropertyAttribute],
        $kind: 1002
    });
    /*Spine.Unity.Examples.SkeletonRagdoll+LayerFieldAttribute end.*/

    /*Spine.Unity.Examples.SkeletonRagdoll2D start.*/
    Bridge.define("Spine.Unity.Examples.SkeletonRagdoll2D", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                parentSpaceHelper: null
            },
            methods: {
                /*Spine.Unity.Examples.SkeletonRagdoll2D.AttachBoundingBoxRagdollColliders:static start.*/
                AttachBoundingBoxRagdollColliders: function (b, go, skeleton, gravityScale) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll2D#AttachBoundingBoxRagdollColliders", this ); }

                    var $t, $t1;
                    var AttachmentNameMarker = "ragdoll";
                    var colliders = new (System.Collections.Generic.List$1(UnityEngine.Collider2D)).ctor();
                    var skin = skeleton.skin || skeleton.data.defaultSkin;

                    var skinEntries = new (System.Collections.Generic.List$1(spine.SkinEntry)).ctor();
                    $t = Bridge.getEnumerator(skeleton.Slots);
                    try {
                        while ($t.moveNext()) {
                            var slot = $t.Current;
                            if (Bridge.referenceEquals(slot.bone, b)) {
                                ( skinEntries._items.length = 0, skin.getAttachmentsForSlot( skeleton.Slots.IndexOf(slot), skinEntries._items ), skinEntries._size = skinEntries._items.length );

                                var bbAttachmentAdded = false;
                                $t1 = Bridge.getEnumerator(skinEntries);
                                try {
                                    while ($t1.moveNext()) {
                                        var entry = $t1.Current;
                                        var bbAttachment = Bridge.as(entry.attachment, spine.BoundingBoxAttachment);
                                        if (bbAttachment != null) {
                                            if (!System.String.contains(entry.name.toLowerCase(),AttachmentNameMarker)) {
                                                continue;
                                            }

                                            bbAttachmentAdded = true;
                                            var bbCollider = Spine.Unity.SkeletonUtility.AddBoundingBoxAsComponent(bbAttachment, slot, go, false);
                                            colliders.add(bbCollider);
                                        }
                                    }
                                } finally {
                                    if (Bridge.is($t1, System.IDisposable)) {
                                        $t1.System$IDisposable$Dispose();
                                    }
                                }

                                if (bbAttachmentAdded) {
                                    Spine.Unity.SkeletonUtility.AddBoneRigidbody2D(go, false, gravityScale);
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    return colliders;
                },
                /*Spine.Unity.Examples.SkeletonRagdoll2D.AttachBoundingBoxRagdollColliders:static end.*/

                /*Spine.Unity.Examples.SkeletonRagdoll2D.FlipScale:static start.*/
                FlipScale: function (flipX, flipY) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll2D#FlipScale", this ); }

                    return new pc.Vec3( flipX ? -1.0 : 1.0, flipY ? -1.0 : 1.0, 1.0 );
                },
                /*Spine.Unity.Examples.SkeletonRagdoll2D.FlipScale:static end.*/


            }
        },
        fields: {
            startingBoneName: null,
            stopBoneNames: null,
            applyOnStart: false,
            disableIK: false,
            disableOtherConstraints: false,
            pinStartBone: false,
            gravityScale: 0,
            thickness: 0,
            rotationLimit: 0,
            rootMass: 0,
            massFalloffFactor: 0,
            colliderLayer: 0,
            mix: 0,
            oldRagdollBehaviour: false,
            targetSkeletonComponent: null,
            skeleton: null,
            boneTable: null,
            boneFlipTable: null,
            ragdollRoot: null,
            RootRigidbody: null,
            StartingBone: null,
            rootOffset: null,
            isActive: false
        },
        props: {
            RootOffset: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll2D#RootOffset#get", this ); }

                    return UnityEngine.Vector3.FromVector2(this.rootOffset.$clone());
                }
            },
            IsActive: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll2D#IsActive#get", this ); }

                    return this.isActive;
                }
            },
            RigidbodyArray: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll2D#RigidbodyArray#get", this ); }

                    var $t;
                    if (!this.isActive) {
                        return System.Array.init(0, null, UnityEngine.Rigidbody2D);
                    }

                    var rigidBodies = System.Array.init(this.boneTable.Count, null, UnityEngine.Rigidbody2D);
                    var i = 0;
                    $t = Bridge.getEnumerator(this.boneTable.Values);
                    try {
                        while ($t.moveNext()) {
                            var t = $t.Current;
                            rigidBodies[i] = t.GetComponent(UnityEngine.Rigidbody2D);
                            i = (i + 1) | 0;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    return rigidBodies;
                }
            },
            EstimatedSkeletonPosition: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll2D#EstimatedSkeletonPosition#get", this ); }

                    return UnityEngine.Vector3.FromVector2(this.RootRigidbody.position.$clone().sub( this.rootOffset ));
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll2D#init", this ); }

                this.rootOffset = new UnityEngine.Vector2();
                this.startingBoneName = "";
                this.stopBoneNames = new (System.Collections.Generic.List$1(System.String)).ctor();
                this.disableIK = true;
                this.disableOtherConstraints = false;
                this.gravityScale = 1;
                this.thickness = 0.125;
                this.rotationLimit = 20;
                this.rootMass = 20;
                this.massFalloffFactor = 0.4;
                this.colliderLayer = 0;
                this.mix = 1;
                this.oldRagdollBehaviour = false;
                this.boneTable = new (System.Collections.Generic.Dictionary$2(Spine.Bone,UnityEngine.Transform)).ctor();
                this.boneFlipTable = new (System.Collections.Generic.Dictionary$2(Spine.Bone,Spine.Unity.Examples.SkeletonRagdoll2D.BoneFlipEntry)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.Examples.SkeletonRagdoll2D.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll2D#Start", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if (UnityEngine.Component.op_Equality(Spine.Unity.Examples.SkeletonRagdoll2D.parentSpaceHelper, null)) {
                                            Spine.Unity.Examples.SkeletonRagdoll2D.parentSpaceHelper = (new UnityEngine.GameObject.$ctor2("Parent Space Helper")).transform;
                                        }

                                        this.targetSkeletonComponent = Bridge.as(this.GetComponent(Spine.Unity.SkeletonRenderer), Spine.Unity.ISkeletonAnimation);
                                        if (this.targetSkeletonComponent == null) {
                                            UnityEngine.Debug.LogError$2("Attached Spine component does not implement ISkeletonAnimation. This script is not compatible.");
                                        }
                                        this.skeleton = this.targetSkeletonComponent.Spine$Unity$ISkeletonAnimation$Skeleton;

                                        if (this.applyOnStart) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 3;
                                        continue;
                                }
                                case 1: {
                                    $enumerator.current = null;
                                        $step = 2;
                                        return true;
                                }
                                case 2: {
                                    this.Apply();
                                    $step = 3;
                                    continue;
                                }
                                case 3: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Spine.Unity.Examples.SkeletonRagdoll2D.Start end.*/

            /*Spine.Unity.Examples.SkeletonRagdoll2D.Apply start.*/
            /**
             * Instantiates the ragdoll simulation and applies its transforms to the skeleton.
             *
             * @instance
             * @public
             * @this Spine.Unity.Examples.SkeletonRagdoll2D
             * @memberof Spine.Unity.Examples.SkeletonRagdoll2D
             * @return  {void}
             */
            Apply: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll2D#Apply", this ); }

                var $t, $t1, $t2;
                this.isActive = true;
                this.mix = 1;

                var startingBone = ($t = this.skeleton.findBone(this.startingBoneName), this.StartingBone = $t, $t);
                this.RecursivelyCreateBoneProxies(startingBone);

                this.RootRigidbody = this.boneTable.getItem(startingBone).GetComponent(UnityEngine.Rigidbody2D);
                this.RootRigidbody.isKinematic = this.pinStartBone;
                this.RootRigidbody.mass = this.rootMass;
                var boneColliders = new (System.Collections.Generic.List$1(UnityEngine.Collider2D)).ctor();
                $t1 = Bridge.getEnumerator(this.boneTable);
                try {
                    while ($t1.moveNext()) {
                        var pair = $t1.Current;
                        var b = pair.key;
                        var t = pair.value;
                        var parentTransform;
                        boneColliders.add(t.GetComponent(UnityEngine.Collider2D));
                        if (Bridge.referenceEquals(b, startingBone)) {
                            this.ragdollRoot = new UnityEngine.GameObject.$ctor2("RagdollRoot").transform;
                            this.ragdollRoot.SetParent(this.transform, false);
                            if (Bridge.referenceEquals(b, this.skeleton.getRootBone())) { // RagdollRoot is skeleton root's parent, thus the skeleton's scale and position.
                                this.ragdollRoot.localPosition = new pc.Vec3( this.skeleton.x, this.skeleton.y, 0 );
                                this.ragdollRoot.localRotation = (this.skeleton.scaleX < 0) ? new pc.Quat().setFromEulerAngles_Unity( 0, 0, 180.0 ) : pc.Quat.IDENTITY.clone();
                            } else {
                                this.ragdollRoot.localPosition = new pc.Vec3( b.parent.worldX, b.parent.worldY, 0 );
                                this.ragdollRoot.localRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, b.parent.getWorldRotationX() - b.parent.shearX );
                            }
                            parentTransform = this.ragdollRoot;
                            this.rootOffset = UnityEngine.Vector2.FromVector3(t.position.$clone().sub( this.transform.position ));
                        } else {
                            parentTransform = this.boneTable.getItem(b.parent);
                        }

                        // Add joint and attach to parent.
                        var rbParent = parentTransform.GetComponent(UnityEngine.Rigidbody2D);
                        if (UnityEngine.Component.op_Inequality(rbParent, null)) {
                            var joint = t.gameObject.AddComponent(UnityEngine.HingeJoint2D);
                            joint.connectedBody = rbParent;
                            var localPos = parentTransform.InverseTransformPoint(t.position);
                            joint.connectedAnchor = UnityEngine.Vector2.FromVector3(localPos.$clone());

                            joint.GetComponent(UnityEngine.Rigidbody2D).mass = joint.connectedBody.mass * this.massFalloffFactor;

                            var minAngle = -this.rotationLimit;
                            var maxAngle = this.rotationLimit;
                            joint.limits = ($t2 = new UnityEngine.JointAngleLimits2D(), $t2.min = minAngle, $t2.max = maxAngle, $t2);
                            joint.useLimits = true;
                        }
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }

                // Ignore collisions among bones.
                for (var x = 0; x < boneColliders.Count; x = (x + 1) | 0) {
                    for (var y = 0; y < boneColliders.Count; y = (y + 1) | 0) {
                        if (x === y) {
                            continue;
                        }
                        UnityEngine.Physics2D.IgnoreCollision(boneColliders.getItem(x), boneColliders.getItem(y));
                    }
                }

                // Destroy existing override-mode SkeletonUtility bones.
                var utilityBones = this.GetComponentsInChildren(Spine.Unity.SkeletonUtilityBone);
                if (utilityBones.length > 0) {
                    var destroyedUtilityBoneNames = new (System.Collections.Generic.List$1(System.String)).ctor();
                    $t2 = Bridge.getEnumerator(utilityBones);
                    try {
                        while ($t2.moveNext()) {
                            var ub = $t2.Current;
                            if (ub.mode === Spine.Unity.SkeletonUtilityBone.Mode.Override) {
                                destroyedUtilityBoneNames.add(ub.gameObject.name);
                                UnityEngine.MonoBehaviour.Destroy(ub.gameObject);
                            }
                        }
                    } finally {
                        if (Bridge.is($t2, System.IDisposable)) {
                            $t2.System$IDisposable$Dispose();
                        }
                    }
                    if (destroyedUtilityBoneNames.Count > 0) {
                        var msg = "Destroyed Utility Bones: ";
                        for (var i = 0; i < destroyedUtilityBoneNames.Count; i = (i + 1) | 0) {
                            msg = (msg || "") + (destroyedUtilityBoneNames.getItem(i) || "");
                            if (i !== ((destroyedUtilityBoneNames.Count - 1) | 0)) {
                                msg = (msg || "") + ",";
                            }
                        }
                        UnityEngine.Debug.LogWarning$1(msg);
                    }
                }

                // Disable skeleton constraints.
                if (this.disableIK) {
                    var ikConstraints = this.skeleton.IkConstraints;
                    for (var i1 = 0, n = ikConstraints.Count; i1 < n; i1 = (i1 + 1) | 0) {
                        ikConstraints.Items[i1].mix = 0;
                    }
                }

                if (this.disableOtherConstraints) {
                    var transformConstraints = this.skeleton.TransformConstraints;
                    for (var i2 = 0, n1 = transformConstraints.Count; i2 < n1; i2 = (i2 + 1) | 0) {
                        transformConstraints.Items[i2].mixRotate = 0;
                        transformConstraints.Items[i2].mixScaleX = 0;
                        transformConstraints.Items[i2].mixScaleY = 0;
                        transformConstraints.Items[i2].mixShearY = 0;
                        transformConstraints.Items[i2].mixX = 0;
                        transformConstraints.Items[i2].mixY = 0;
                    }

                    var pathConstraints = this.skeleton.PathConstraints;
                    for (var i3 = 0, n2 = pathConstraints.Count; i3 < n2; i3 = (i3 + 1) | 0) {
                        pathConstraints.Items[i3].mixRotate = 0;
                        pathConstraints.Items[i3].mixX = 0;
                        pathConstraints.Items[i3].mixY = 0;
                    }
                }

                this.targetSkeletonComponent.Spine$Unity$ISkeletonAnimation$addUpdateWorld(Bridge.fn.cacheBind(this, this.UpdateSpineSkeleton));
            },
            /*Spine.Unity.Examples.SkeletonRagdoll2D.Apply end.*/

            /*Spine.Unity.Examples.SkeletonRagdoll2D.SmoothMix start.*/
            /**
             * Transitions the mix value from the current value to a target value.
             *
             * @instance
             * @public
             * @this Spine.Unity.Examples.SkeletonRagdoll2D
             * @memberof Spine.Unity.Examples.SkeletonRagdoll2D
             * @param   {number}                   target      
             * @param   {number}                   duration
             * @return  {UnityEngine.Coroutine}
             */
            SmoothMix: function (target, duration) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll2D#SmoothMix", this ); }

                return this.StartCoroutine$1(this.SmoothMixCoroutine(target, duration));
            },
            /*Spine.Unity.Examples.SkeletonRagdoll2D.SmoothMix end.*/

            /*Spine.Unity.Examples.SkeletonRagdoll2D.SmoothMixCoroutine start.*/
            SmoothMixCoroutine: function (target, duration) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll2D#SmoothMixCoroutine", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    startTime,
                    startMix,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    startTime = UnityEngine.Time.time;
                                        startMix = this.mix;
                                    $step = 1;
                                    continue;
                                }
                                case 1: {
                                    if ( this.mix > 0 ) {
                                            $step = 2;
                                            continue;
                                        } 
                                        $step = 4;
                                        continue;
                                }
                                case 2: {
                                    this.skeleton.setBonesToSetupPose();
                                        this.mix = pc.math.smoothstep(startMix, target, (UnityEngine.Time.time - startTime) / duration);
                                        $enumerator.current = null;
                                        $step = 3;
                                        return true;
                                }
                                case 3: {
                                    
                                        $step = 1;
                                        continue;
                                }
                                case 4: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Spine.Unity.Examples.SkeletonRagdoll2D.SmoothMixCoroutine end.*/

            /*Spine.Unity.Examples.SkeletonRagdoll2D.SetSkeletonPosition start.*/
            /**
             * Set the transform world position while preserving the ragdoll parts world position.
             *
             * @instance
             * @public
             * @this Spine.Unity.Examples.SkeletonRagdoll2D
             * @memberof Spine.Unity.Examples.SkeletonRagdoll2D
             * @param   {UnityEngine.Vector3}    worldPosition
             * @return  {void}
             */
            SetSkeletonPosition: function (worldPosition) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll2D#SetSkeletonPosition", this ); }

                var $t;
                if (!this.isActive) {
                    UnityEngine.Debug.LogWarning$1("Can't call SetSkeletonPosition while Ragdoll is not active!");
                    return;
                }

                var offset = worldPosition.$clone().sub( this.transform.position );
                this.transform.position = worldPosition.$clone();
                $t = Bridge.getEnumerator(this.boneTable.Values);
                try {
                    while ($t.moveNext()) {
                        var t = $t.Current;
                        t.position = t.position.$clone().sub( offset.$clone() );
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                this.UpdateSpineSkeleton(null);
                this.skeleton.updateWorldTransform();
            },
            /*Spine.Unity.Examples.SkeletonRagdoll2D.SetSkeletonPosition end.*/

            /*Spine.Unity.Examples.SkeletonRagdoll2D.Remove start.*/
            /**
             * Removes the ragdoll instance and effect from the animated skeleton.
             *
             * @instance
             * @public
             * @this Spine.Unity.Examples.SkeletonRagdoll2D
             * @memberof Spine.Unity.Examples.SkeletonRagdoll2D
             * @return  {void}
             */
            Remove: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll2D#Remove", this ); }

                var $t;
                this.isActive = false;
                $t = Bridge.getEnumerator(this.boneTable.Values);
                try {
                    while ($t.moveNext()) {
                        var t = $t.Current;
                        UnityEngine.MonoBehaviour.Destroy(t.gameObject);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                UnityEngine.MonoBehaviour.Destroy(this.ragdollRoot.gameObject);
                this.boneTable.clear();
                this.targetSkeletonComponent.Spine$Unity$ISkeletonAnimation$removeUpdateWorld(Bridge.fn.cacheBind(this, this.UpdateSpineSkeleton));
            },
            /*Spine.Unity.Examples.SkeletonRagdoll2D.Remove end.*/

            /*Spine.Unity.Examples.SkeletonRagdoll2D.GetRigidbody start.*/
            GetRigidbody: function (boneName) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll2D#GetRigidbody", this ); }

                var bone = this.skeleton.findBone(boneName);
                return (bone != null && this.boneTable.containsKey(bone)) ? this.boneTable.getItem(bone).GetComponent(UnityEngine.Rigidbody2D) : null;
            },
            /*Spine.Unity.Examples.SkeletonRagdoll2D.GetRigidbody end.*/

            /*Spine.Unity.Examples.SkeletonRagdoll2D.RecursivelyCreateBoneProxies start.*/
            /**
             * Generates the ragdoll simulation's Transform and joint setup.
             *
             * @instance
             * @private
             * @this Spine.Unity.Examples.SkeletonRagdoll2D
             * @memberof Spine.Unity.Examples.SkeletonRagdoll2D
             * @param   {Spine.Bone}    b
             * @return  {void}
             */
            RecursivelyCreateBoneProxies: function (b) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll2D#RecursivelyCreateBoneProxies", this ); }

                var $t;
                var boneName = b.data.name;
                if (this.stopBoneNames.contains(boneName)) {
                    return;
                }

                var boneGameObject = new UnityEngine.GameObject.$ctor2(boneName);
                boneGameObject.layer = this.colliderLayer;
                var t = boneGameObject.transform;
                this.boneTable.add(b, t);

                t.parent = this.transform;
                t.localPosition = new pc.Vec3( b.worldX, b.worldY, 0 );
                t.localRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, b.getWorldRotationX() - b.shearX );
                t.localScale = new pc.Vec3( b.getWorldScaleX(), b.getWorldScaleY(), 1 );

                var colliders = Spine.Unity.Examples.SkeletonRagdoll2D.AttachBoundingBoxRagdollColliders(b, boneGameObject, this.skeleton, this.gravityScale);
                if (colliders.Count === 0) {
                    var length = b.data.length;
                    if (length === 0) {
                        var circle = boneGameObject.AddComponent(UnityEngine.CircleCollider2D);
                        circle.radius = this.thickness * 0.5;
                    } else {
                        var box = boneGameObject.AddComponent(UnityEngine.BoxCollider2D);
                        box.size = new pc.Vec2( length, this.thickness );
                        box.offset = new pc.Vec2( length * 0.5, 0 ); // box.center in UNITY_4
                    }
                }

                var rb = boneGameObject.GetComponent(UnityEngine.Rigidbody2D);
                if (UnityEngine.Component.op_Equality(rb, null)) {
                    rb = boneGameObject.AddComponent(UnityEngine.Rigidbody2D);
                }
                rb.gravityScale = this.gravityScale;

                $t = Bridge.getEnumerator(b.Children);
                try {
                    while ($t.moveNext()) {
                        var child = $t.Current;
                        this.RecursivelyCreateBoneProxies(child);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.Examples.SkeletonRagdoll2D.RecursivelyCreateBoneProxies end.*/

            /*Spine.Unity.Examples.SkeletonRagdoll2D.UpdateSpineSkeleton start.*/
            /**
             * Performed every skeleton animation update to translate Unity Transforms positions into Spine bone transforms.
             *
             * @instance
             * @private
             * @this Spine.Unity.Examples.SkeletonRagdoll2D
             * @memberof Spine.Unity.Examples.SkeletonRagdoll2D
             * @param   {Spine.Unity.ISkeletonAnimation}    animatedSkeleton
             * @return  {void}
             */
            UpdateSpineSkeleton: function (animatedSkeleton) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll2D#UpdateSpineSkeleton", this ); }

                var $t;
                var parentFlipX = { };
                var parentFlipY = { };
                var startingBone = this.StartingBone;
                this.GetStartBoneParentFlipState(parentFlipX, parentFlipY);

                $t = Bridge.getEnumerator(this.boneTable);
                try {
                    while ($t.moveNext()) {
                        var pair = $t.Current;
                        var b = pair.key;
                        var t = pair.value;
                        var isStartingBone = (Bridge.referenceEquals(b, startingBone));
                        var parentBone = b.parent;
                        var parentTransform = isStartingBone ? this.ragdollRoot : this.boneTable.getItem(parentBone);
                        if (!isStartingBone) {
                            var parentBoneFlip = this.boneFlipTable.getItem(parentBone).$clone();
                            parentFlipX.v = parentBoneFlip.flipX;
                            parentFlipY.v = parentBoneFlip.flipY;
                        }
                        var flipX = parentFlipX.v != (b.scaleX < 0);
                        var flipY = parentFlipY.v != (b.scaleY < 0);

                        var boneFlip = { v : new Spine.Unity.Examples.SkeletonRagdoll2D.BoneFlipEntry() };
                        this.boneFlipTable.tryGetValue(b, boneFlip);
                        boneFlip.v.flipX = flipX;
                        boneFlip.v.flipY = flipY;
                        this.boneFlipTable.setItem(b, boneFlip.v.$clone());

                        var flipXOR = flipX != flipY;
                        var parentFlipXOR = parentFlipX.v != parentFlipY.v;

                        if (!this.oldRagdollBehaviour && isStartingBone) {
                            if (!Bridge.referenceEquals(b, this.skeleton.getRootBone())) { // RagdollRoot is not skeleton root.
                                this.ragdollRoot.localPosition = new pc.Vec3( parentBone.worldX, parentBone.worldY, 0 );
                                this.ragdollRoot.localRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, parentBone.getWorldRotationX() - parentBone.shearX );
                                this.ragdollRoot.localScale = new pc.Vec3( parentBone.getWorldScaleX(), parentBone.getWorldScaleY(), 1 );
                            }
                        }

                        var parentTransformWorldPosition = parentTransform.position.$clone();
                        var parentTransformWorldRotation = parentTransform.rotation.$clone();

                        Spine.Unity.Examples.SkeletonRagdoll2D.parentSpaceHelper.position = parentTransformWorldPosition.$clone();
                        Spine.Unity.Examples.SkeletonRagdoll2D.parentSpaceHelper.rotation = parentTransformWorldRotation.$clone();
                        Spine.Unity.Examples.SkeletonRagdoll2D.parentSpaceHelper.localScale = parentTransform.lossyScale.$clone();

                        if (this.oldRagdollBehaviour) {
                            if (isStartingBone && !Bridge.referenceEquals(b, this.skeleton.getRootBone())) {
                                var localPosition = new pc.Vec3( b.parent.worldX, b.parent.worldY, 0 );
                                Spine.Unity.Examples.SkeletonRagdoll2D.parentSpaceHelper.position = this.ragdollRoot.TransformPoint$1(localPosition);
                                Spine.Unity.Examples.SkeletonRagdoll2D.parentSpaceHelper.localRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, parentBone.getWorldRotationX() - parentBone.shearX );
                                Spine.Unity.Examples.SkeletonRagdoll2D.parentSpaceHelper.localScale = new pc.Vec3( parentBone.getWorldScaleX(), parentBone.getWorldScaleY(), 1 );
                            }
                        }

                        var boneWorldPosition = t.position.$clone();
                        var right = Spine.Unity.Examples.SkeletonRagdoll2D.parentSpaceHelper.InverseTransformDirection(t.right);

                        var boneLocalPosition = Spine.Unity.Examples.SkeletonRagdoll2D.parentSpaceHelper.InverseTransformPoint(boneWorldPosition);
                        var boneLocalRotation = Math.atan2(right.y, right.x) * UnityEngine.Mathf.Rad2Deg;

                        if (flipXOR) {
                            boneLocalPosition.y *= -1.0;
                        }
                        if (parentFlipXOR !== flipXOR) {
                            boneLocalPosition.y *= -1.0;
                        }

                        if (parentFlipXOR) {
                            boneLocalRotation *= -1.0;
                        }
                        if (parentFlipX.v !== flipX) {
                            boneLocalRotation += 180;
                        }

                        b.x = pc.math.lerp(b.x, boneLocalPosition.x, this.mix);
                        b.y = pc.math.lerp(b.y, boneLocalPosition.y, this.mix);
                        b.rotation = pc.math.lerp(b.rotation, boneLocalRotation, this.mix);
                        //b.AppliedRotation = Mathf.Lerp(b.AppliedRotation, boneLocalRotation, mix);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.Examples.SkeletonRagdoll2D.UpdateSpineSkeleton end.*/

            /*Spine.Unity.Examples.SkeletonRagdoll2D.GetStartBoneParentFlipState start.*/
            GetStartBoneParentFlipState: function (parentFlipX, parentFlipY) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll2D#GetStartBoneParentFlipState", this ); }

                parentFlipX.v = this.skeleton.scaleX < 0;
                parentFlipY.v = this.skeleton.scaleY < 0;
                var parent = this.StartingBone == null ? null : this.StartingBone.parent;
                while (parent != null) {
                    parentFlipX.v = parentFlipX.v != parent.scaleX < 0;
                    parentFlipY.v = parentFlipY.v != parent.scaleY < 0;
                    parent = parent.parent;
                }
            },
            /*Spine.Unity.Examples.SkeletonRagdoll2D.GetStartBoneParentFlipState end.*/


        }
    });
    /*Spine.Unity.Examples.SkeletonRagdoll2D end.*/

    /*Spine.Unity.Examples.SkeletonRagdoll2D+BoneFlipEntry start.*/
    Bridge.define("Spine.Unity.Examples.SkeletonRagdoll2D.BoneFlipEntry", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll2D.BoneFlipEntry#getDefaultValue", this ); }
 return new Spine.Unity.Examples.SkeletonRagdoll2D.BoneFlipEntry(); }
            }
        },
        fields: {
            flipX: false,
            flipY: false
        },
        ctors: {
            $ctor1: function (flipX, flipY) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll2D.BoneFlipEntry#$ctor1", this ); }

                this.$initialize();
                this.flipX = flipX;
                this.flipY = flipY;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll2D.BoneFlipEntry#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll2D.BoneFlipEntry#getHashCode", this ); }

                var h = Bridge.addHash([5507926598, this.flipX, this.flipY]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll2D.BoneFlipEntry#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.Examples.SkeletonRagdoll2D.BoneFlipEntry)) {
                    return false;
                }
                return Bridge.equals(this.flipX, o.flipX) && Bridge.equals(this.flipY, o.flipY);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRagdoll2D.BoneFlipEntry#$clone", this ); }

                var s = to || new Spine.Unity.Examples.SkeletonRagdoll2D.BoneFlipEntry();
                s.flipX = this.flipX;
                s.flipY = this.flipY;
                return s;
            }
        }
    });
    /*Spine.Unity.Examples.SkeletonRagdoll2D+BoneFlipEntry end.*/

    /*Spine.Unity.Examples.SkeletonRenderTextureFadeout start.*/
    /**
     * A simple fadeout component that uses a {@link } for transparency fadeout.
     Attach a {@link } and this component to a skeleton GameObject and disable both
     components initially and keep them disabled during normal gameplay. When you need to start fadeout,
     enable this component.
     At the end of the fadeout, the event delegate <pre><code>OnFadeoutComplete</code></pre> is called, to which you can bind e.g.
     a method that disables or destroys the entire GameObject.
     *
     * @public
     * @class Spine.Unity.Examples.SkeletonRenderTextureFadeout
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.Examples.SkeletonRenderTextureFadeout", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonRenderTexture: null,
            fadeoutSeconds: 0,
            fadeoutSecondsRemaining: 0
        },
        events: {
            OnFadeoutComplete: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRenderTextureFadeout#init", this ); }

                this.fadeoutSeconds = 2.0;
            }
        },
        methods: {
            /*Spine.Unity.Examples.SkeletonRenderTextureFadeout.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRenderTextureFadeout#Awake", this ); }

                this.skeletonRenderTexture = this.GetComponent(Spine.Unity.Examples.SkeletonRenderTextureBase);
            },
            /*Spine.Unity.Examples.SkeletonRenderTextureFadeout.Awake end.*/

            /*Spine.Unity.Examples.SkeletonRenderTextureFadeout.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRenderTextureFadeout#OnEnable", this ); }

                this.fadeoutSecondsRemaining = this.fadeoutSeconds;
                this.skeletonRenderTexture.enabled = true;
            },
            /*Spine.Unity.Examples.SkeletonRenderTextureFadeout.OnEnable end.*/

            /*Spine.Unity.Examples.SkeletonRenderTextureFadeout.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRenderTextureFadeout#Update", this ); }

                if (this.fadeoutSecondsRemaining === 0) {
                    return;
                }

                this.fadeoutSecondsRemaining -= UnityEngine.Time.deltaTime;
                if (this.fadeoutSecondsRemaining <= 0) {
                    this.fadeoutSecondsRemaining = 0;
                    if (!Bridge.staticEquals(this.OnFadeoutComplete, null)) {
                        this.OnFadeoutComplete(this);
                    }
                    return;
                }
                var fadeoutAlpha = this.fadeoutSecondsRemaining / this.fadeoutSeconds;
                this.skeletonRenderTexture.color.a = fadeoutAlpha;
            },
            /*Spine.Unity.Examples.SkeletonRenderTextureFadeout.Update end.*/


        }
    });
    /*Spine.Unity.Examples.SkeletonRenderTextureFadeout end.*/

    /*Spine.Unity.SkeletonUtilityConstraint start.*/
    Bridge.define("Spine.Unity.SkeletonUtilityConstraint", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            bone: null,
            hierarchy: null
        },
        methods: {
            /*Spine.Unity.SkeletonUtilityConstraint.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityConstraint#OnEnable", this ); }

                this.bone = this.GetComponent(Spine.Unity.SkeletonUtilityBone);
                this.hierarchy = this.transform.GetComponentInParent(Spine.Unity.SkeletonUtility);
                this.hierarchy.RegisterConstraint(this);
            },
            /*Spine.Unity.SkeletonUtilityConstraint.OnEnable end.*/

            /*Spine.Unity.SkeletonUtilityConstraint.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityConstraint#OnDisable", this ); }

                this.hierarchy.UnregisterConstraint(this);
            },
            /*Spine.Unity.SkeletonUtilityConstraint.OnDisable end.*/


        }
    });
    /*Spine.Unity.SkeletonUtilityConstraint end.*/

    /*Spine.Unity.Examples.SkeletonUtilityKinematicShadow start.*/
    Bridge.define("Spine.Unity.Examples.SkeletonUtilityKinematicShadow", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            methods: {
                /*Spine.Unity.Examples.SkeletonUtilityKinematicShadow.DestroyComponents:static start.*/
                DestroyComponents: function (components) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonUtilityKinematicShadow#DestroyComponents", this ); }

                    for (var i = 0, n = components.length; i < n; i = (i + 1) | 0) {
                        UnityEngine.Object.Destroy(components[i]);
                    }
                },
                /*Spine.Unity.Examples.SkeletonUtilityKinematicShadow.DestroyComponents:static end.*/


            }
        },
        fields: {
            detachedShadow: false,
            parent: null,
            hideShadow: false,
            physicsSystem: 0,
            shadowRoot: null,
            shadowTable: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonUtilityKinematicShadow#init", this ); }

                this.detachedShadow = false;
                this.hideShadow = true;
                this.physicsSystem = Spine.Unity.Examples.SkeletonUtilityKinematicShadow.PhysicsSystem.Physics3D;
                this.shadowTable = new (System.Collections.Generic.List$1(Spine.Unity.Examples.SkeletonUtilityKinematicShadow.TransformPair)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.Examples.SkeletonUtilityKinematicShadow.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonUtilityKinematicShadow#Start", this ); }

                var $t, $t1, $t2, $t3;
                // Duplicate this gameObject as the "shadow" with a different parent.
                this.shadowRoot = UnityEngine.Object.Instantiate(UnityEngine.GameObject, this.gameObject);
                UnityEngine.Object.Destroy(this.shadowRoot.GetComponent(Spine.Unity.Examples.SkeletonUtilityKinematicShadow));

                // Prepare shadow gameObject's properties.
                var shadowRootTransform = this.shadowRoot.transform;
                shadowRootTransform.position = this.transform.position.$clone();
                shadowRootTransform.rotation = this.transform.rotation.$clone();

                var scaleRef = this.transform.TransformPoint$1(pc.Vec3.RIGHT.clone());
                var scale = pc.Vec3.distance( this.transform.position, scaleRef );
                shadowRootTransform.localScale = new pc.Vec3( 1, 1, 1 );

                if (!this.detachedShadow) {
                    // Do not change to null coalescing operator (??). Unity overloads null checks for UnityEngine.Objects but not the ?? operator.
                    if (UnityEngine.Component.op_Equality(this.parent, null)) {
                        shadowRootTransform.parent = this.transform.root;
                    } else {
                        shadowRootTransform.parent = this.parent;
                    }
                }

                if (this.hideShadow) {
                    this.shadowRoot.hideFlags = UnityEngine.HideFlags.HideInHierarchy;
                }

                var shadowJoints = this.shadowRoot.GetComponentsInChildren(UnityEngine.Joint);
                $t = Bridge.getEnumerator(shadowJoints);
                try {
                    while ($t.moveNext()) {
                        var j = $t.Current;
                        j.connectedAnchor = j.connectedAnchor.$clone().clone().scale( scale );
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                // Build list of bone pairs (matches shadow transforms with bone transforms)
                var bones = this.GetComponentsInChildren(Spine.Unity.SkeletonUtilityBone);
                var shadowBones = this.shadowRoot.GetComponentsInChildren(Spine.Unity.SkeletonUtilityBone);
                $t1 = Bridge.getEnumerator(bones);
                try {
                    while ($t1.moveNext()) {
                        var b = $t1.Current;
                        if (UnityEngine.GameObject.op_Equality(b.gameObject, this.gameObject)) {
                            continue;
                        }

                        var checkType = (this.physicsSystem === Spine.Unity.Examples.SkeletonUtilityKinematicShadow.PhysicsSystem.Physics2D) ? UnityEngine.Rigidbody2D : UnityEngine.Rigidbody;
                        $t2 = Bridge.getEnumerator(shadowBones);
                        try {
                            while ($t2.moveNext()) {
                                var sb = $t2.Current;
                                if (UnityEngine.Component.op_Inequality(sb.GetComponent$1(checkType), null) && Bridge.referenceEquals(sb.boneName, b.boneName)) {
                                    this.shadowTable.add(($t3 = new Spine.Unity.Examples.SkeletonUtilityKinematicShadow.TransformPair(), $t3.dest = b.transform, $t3.src = sb.transform, $t3));
                                    break;
                                }
                            }
                        } finally {
                            if (Bridge.is($t2, System.IDisposable)) {
                                $t2.System$IDisposable$Dispose();
                            }
                        }

                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }

                // Destroy conflicting and unneeded components
                Spine.Unity.Examples.SkeletonUtilityKinematicShadow.DestroyComponents(shadowBones);

                Spine.Unity.Examples.SkeletonUtilityKinematicShadow.DestroyComponents(this.GetComponentsInChildren(UnityEngine.Joint));
                Spine.Unity.Examples.SkeletonUtilityKinematicShadow.DestroyComponents(this.GetComponentsInChildren(UnityEngine.Rigidbody));
                Spine.Unity.Examples.SkeletonUtilityKinematicShadow.DestroyComponents(this.GetComponentsInChildren(UnityEngine.Collider));
            },
            /*Spine.Unity.Examples.SkeletonUtilityKinematicShadow.Start end.*/

            /*Spine.Unity.Examples.SkeletonUtilityKinematicShadow.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonUtilityKinematicShadow#FixedUpdate", this ); }

                if (this.physicsSystem === Spine.Unity.Examples.SkeletonUtilityKinematicShadow.PhysicsSystem.Physics2D) {
                    var shadowRootRigidbody = this.shadowRoot.GetComponent(UnityEngine.Rigidbody2D);
                    shadowRootRigidbody.MovePosition$1(this.transform.position);
                    shadowRootRigidbody.MoveRotation(this.transform.rotation.getPositiveEulerAngles().z);
                } else {
                    var shadowRootRigidbody1 = this.shadowRoot.GetComponent(UnityEngine.Rigidbody);
                    shadowRootRigidbody1.MovePosition(this.transform.position);
                    shadowRootRigidbody1.MoveRotation(this.transform.rotation);
                }

                for (var i = 0, n = this.shadowTable.Count; i < n; i = (i + 1) | 0) {
                    var pair = this.shadowTable.getItem(i).$clone();
                    pair.dest.localPosition = pair.src.localPosition.$clone();
                    pair.dest.localRotation = pair.src.localRotation.$clone();
                }
            },
            /*Spine.Unity.Examples.SkeletonUtilityKinematicShadow.FixedUpdate end.*/


        }
    });
    /*Spine.Unity.Examples.SkeletonUtilityKinematicShadow end.*/

    /*Spine.Unity.Examples.SkeletonUtilityKinematicShadow+PhysicsSystem start.*/
    Bridge.define("Spine.Unity.Examples.SkeletonUtilityKinematicShadow.PhysicsSystem", {
        $kind: 1006,
        statics: {
            fields: {
                Physics2D: 0,
                Physics3D: 1
            }
        }
    });
    /*Spine.Unity.Examples.SkeletonUtilityKinematicShadow+PhysicsSystem end.*/

    /*Spine.Unity.Examples.SkeletonUtilityKinematicShadow+TransformPair start.*/
    Bridge.define("Spine.Unity.Examples.SkeletonUtilityKinematicShadow.TransformPair", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonUtilityKinematicShadow.TransformPair#getDefaultValue", this ); }
 return new Spine.Unity.Examples.SkeletonUtilityKinematicShadow.TransformPair(); }
            }
        },
        fields: {
            dest: null,
            src: null
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonUtilityKinematicShadow.TransformPair#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonUtilityKinematicShadow.TransformPair#getHashCode", this ); }

                var h = Bridge.addHash([5539768742, this.dest, this.src]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonUtilityKinematicShadow.TransformPair#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.Examples.SkeletonUtilityKinematicShadow.TransformPair)) {
                    return false;
                }
                return Bridge.equals(this.dest, o.dest) && Bridge.equals(this.src, o.src);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonUtilityKinematicShadow.TransformPair#$clone", this ); }

                var s = to || new Spine.Unity.Examples.SkeletonUtilityKinematicShadow.TransformPair();
                s.dest = this.dest;
                s.src = this.src;
                return s;
            }
        }
    });
    /*Spine.Unity.Examples.SkeletonUtilityKinematicShadow+TransformPair end.*/

    /*Spine.Unity.Examples.SlotTintBlackFollower start.*/
    /**
     * Add this component to a Spine GameObject to apply a specific slot's Colors as MaterialProperties.
     This allows you to apply the two color tint to the whole skeleton and not require the overhead of an extra vertex stream on the mesh.
     *
     * @public
     * @class Spine.Unity.Examples.SlotTintBlackFollower
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.Examples.SlotTintBlackFollower", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            /**
             * Serialized name of the slot loaded at runtime. Change the slot field instead of this if you want to change the followed slot at runtime.
             *
             * @instance
             * @protected
             * @memberof Spine.Unity.Examples.SlotTintBlackFollower
             * @type string
             */
            slotName: null,
            colorPropertyName: null,
            blackPropertyName: null,
            slot: null,
            mr: null,
            mb: null,
            colorPropertyId: 0,
            blackPropertyId: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SlotTintBlackFollower#init", this ); }

                this.colorPropertyName = "_Color";
                this.blackPropertyName = "_Black";
            }
        },
        methods: {
            /*Spine.Unity.Examples.SlotTintBlackFollower.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SlotTintBlackFollower#Start", this ); }

                this.Initialize(false);
            },
            /*Spine.Unity.Examples.SlotTintBlackFollower.Start end.*/

            /*Spine.Unity.Examples.SlotTintBlackFollower.Initialize start.*/
            Initialize: function (overwrite) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SlotTintBlackFollower#Initialize", this ); }

                if (overwrite || this.mb == null) {
                    this.mb = new UnityEngine.MaterialPropertyBlock();
                    this.mr = this.GetComponent(UnityEngine.MeshRenderer);
                    this.slot = this.GetComponent(Spine.Unity.ISkeletonComponent).Spine$Unity$ISkeletonComponent$Skeleton.findSlot(this.slotName);

                    this.colorPropertyId = UnityEngine.Shader.PropertyToID(this.colorPropertyName);
                    this.blackPropertyId = UnityEngine.Shader.PropertyToID(this.blackPropertyName);
                }
            },
            /*Spine.Unity.Examples.SlotTintBlackFollower.Initialize end.*/

            /*Spine.Unity.Examples.SlotTintBlackFollower.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SlotTintBlackFollower#Update", this ); }

                var s = this.slot;
                if (s == null) {
                    return;
                }

                this.mb.SetColor(this.colorPropertyId, Spine.Unity.SkeletonExtensions.GetColor$3(s));
                this.mb.SetColor(this.blackPropertyId, Spine.Unity.SkeletonExtensions.GetColorTintBlack(s));

                this.mr.SetPropertyBlock(this.mb);
            },
            /*Spine.Unity.Examples.SlotTintBlackFollower.Update end.*/

            /*Spine.Unity.Examples.SlotTintBlackFollower.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SlotTintBlackFollower#OnDisable", this ); }

                this.mb.Clear();
                this.mr.SetPropertyBlock(this.mb);
            },
            /*Spine.Unity.Examples.SlotTintBlackFollower.OnDisable end.*/


        }
    });
    /*Spine.Unity.Examples.SlotTintBlackFollower end.*/

    /*Spine.Unity.Examples.SpawnFromSkeletonDataExample start.*/
    Bridge.define("Spine.Unity.Examples.SpawnFromSkeletonDataExample", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonDataAsset: null,
            count: 0,
            startingAnimation: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpawnFromSkeletonDataExample#init", this ); }

                this.count = 20;
            }
        },
        methods: {
            /*Spine.Unity.Examples.SpawnFromSkeletonDataExample.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpawnFromSkeletonDataExample#Start", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    spineAnimation,
                    i,
                    sa,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if (this.skeletonDataAsset == null) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 2;
                                        continue;
                                }
                                case 1: {
                                    return false;
                                }
                                case 2: {
                                    this.skeletonDataAsset.GetSkeletonData(false); // Preload SkeletonDataAsset.
                                        $enumerator.current = new UnityEngine.WaitForSeconds(1.0);
                                        $step = 3;
                                        return true;
                                }
                                case 3: {
                                    // Pretend stuff is happening.

                                        spineAnimation = this.skeletonDataAsset.GetSkeletonData(false).findAnimation(this.startingAnimation);
                                        i = 0;
                                        $step = 4;
                                        continue;
                                }
                                case 4: {
                                    if ( i < this.count ) {
                                            $step = 5;
                                            continue;
                                        }
                                    $step = 8;
                                    continue;
                                }
                                case 5: {
                                    sa = Spine.Unity.SkeletonAnimation.NewSkeletonAnimationGameObject(this.skeletonDataAsset); // Spawn a new SkeletonAnimation GameObject.
                                        this.DoExtraStuff(sa, spineAnimation); // optional stuff for fun.
                                        sa.gameObject.name = Bridge.toString(i);
                                        $enumerator.current = new UnityEngine.WaitForSeconds(0.125);
                                        $step = 6;
                                        return true;
                                }
                                case 6: {
                                    $step = 7;
                                    continue;
                                }
                                case 7: {
                                    i = (i + 1) | 0;
                                    $step = 4;
                                    continue;
                                }
                                case 8: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Spine.Unity.Examples.SpawnFromSkeletonDataExample.Start end.*/

            /*Spine.Unity.Examples.SpawnFromSkeletonDataExample.DoExtraStuff start.*/
            DoExtraStuff: function (sa, spineAnimation) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpawnFromSkeletonDataExample#DoExtraStuff", this ); }

                sa.transform.localPosition = UnityEngine.Vector3.FromVector2(UnityEngine.Random.insideUnitCircle.$clone().scale( 6.0 ));
                sa.transform.SetParent(this.transform, false);

                if (spineAnimation != null) {
                    sa.Initialize(false);
                    sa.AnimationState.setAnimationWith( 0, spineAnimation, true );
                }
            },
            /*Spine.Unity.Examples.SpawnFromSkeletonDataExample.DoExtraStuff end.*/


        }
    });
    /*Spine.Unity.Examples.SpawnFromSkeletonDataExample end.*/

    /*Spine.Unity.Examples.SpawnSkeletonGraphicExample start.*/
    Bridge.define("Spine.Unity.Examples.SpawnSkeletonGraphicExample", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonDataAsset: null,
            startingAnimation: null,
            startingSkin: null,
            skeletonGraphicMaterial: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpawnSkeletonGraphicExample#init", this ); }

                this.startingSkin = "base";
            }
        },
        methods: {
            /*Spine.Unity.Examples.SpawnSkeletonGraphicExample.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpawnSkeletonGraphicExample#Start", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    sg,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if (this.skeletonDataAsset == null) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 2;
                                        continue;
                                }
                                case 1: {
                                    return false;
                                }
                                case 2: {
                                    this.skeletonDataAsset.GetSkeletonData(false); // Preload SkeletonDataAsset.
                                        $enumerator.current = new UnityEngine.WaitForSeconds(1.0);
                                        $step = 3;
                                        return true;
                                }
                                case 3: {
                                    // Pretend stuff is happening.

                                        sg = Spine.Unity.SkeletonGraphic.NewSkeletonGraphicGameObject(this.skeletonDataAsset, this.transform, this.skeletonGraphicMaterial); // Spawn a new SkeletonGraphic GameObject.
                                        sg.gameObject.name = "SkeletonGraphic Instance";

                                        // Extra Stuff
                                        sg.Initialize(false);
                                        sg.Skeleton.setSkinByName(this.startingSkin);
                                        sg.Skeleton.setSlotsToSetupPose();
                                        sg.AnimationState.setAnimation(0, this.startingAnimation, true);

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Spine.Unity.Examples.SpawnSkeletonGraphicExample.Start end.*/


        }
    });
    /*Spine.Unity.Examples.SpawnSkeletonGraphicExample end.*/

    /*Spine.Unity.Examples.SpineAnimationTesterTool+AnimationControl start.*/
    Bridge.define("Spine.Unity.Examples.SpineAnimationTesterTool.AnimationControl", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineAnimationTesterTool.AnimationControl#getDefaultValue", this ); }
 return new Spine.Unity.Examples.SpineAnimationTesterTool.AnimationControl(); }
            }
        },
        fields: {
            animationName: null,
            loop: false,
            key: 0,
            useCustomMixDuration: false,
            mixDuration: 0
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineAnimationTesterTool.AnimationControl#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineAnimationTesterTool.AnimationControl#getHashCode", this ); }

                var h = Bridge.addHash([7376836740, this.animationName, this.loop, this.key, this.useCustomMixDuration, this.mixDuration]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineAnimationTesterTool.AnimationControl#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.Examples.SpineAnimationTesterTool.AnimationControl)) {
                    return false;
                }
                return Bridge.equals(this.animationName, o.animationName) && Bridge.equals(this.loop, o.loop) && Bridge.equals(this.key, o.key) && Bridge.equals(this.useCustomMixDuration, o.useCustomMixDuration) && Bridge.equals(this.mixDuration, o.mixDuration);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineAnimationTesterTool.AnimationControl#$clone", this ); }

                var s = to || new Spine.Unity.Examples.SpineAnimationTesterTool.AnimationControl();
                s.animationName = this.animationName;
                s.loop = this.loop;
                s.key = this.key;
                s.useCustomMixDuration = this.useCustomMixDuration;
                s.mixDuration = this.mixDuration;
                return s;
            }
        }
    });
    /*Spine.Unity.Examples.SpineAnimationTesterTool+AnimationControl end.*/

    /*Spine.Unity.Examples.SpineAnimationTesterTool+ControlledTrack start.*/
    Bridge.define("Spine.Unity.Examples.SpineAnimationTesterTool.ControlledTrack", {
        $kind: 1002,
        fields: {
            controls: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineAnimationTesterTool.ControlledTrack#init", this ); }

                this.controls = new (System.Collections.Generic.List$1(Spine.Unity.Examples.SpineAnimationTesterTool.AnimationControl)).ctor();
            }
        }
    });
    /*Spine.Unity.Examples.SpineAnimationTesterTool+ControlledTrack end.*/

    /*Spine.Unity.Examples.SpineBeginnerBodyState start.*/
    Bridge.define("Spine.Unity.Examples.SpineBeginnerBodyState", {
        $kind: 6,
        statics: {
            fields: {
                Idle: 0,
                Running: 1,
                Jumping: 2
            }
        }
    });
    /*Spine.Unity.Examples.SpineBeginnerBodyState end.*/

    /*Spine.Unity.Examples.SpineBeginnerTwo start.*/
    Bridge.define("Spine.Unity.Examples.SpineBeginnerTwo", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            runAnimationName: null,
            idleAnimationName: null,
            walkAnimationName: null,
            shootAnimationName: null,
            idleTurnAnimationName: null,
            runToIdleAnimationName: null,
            runWalkDuration: 0,
            skeletonAnimation: null,
            spineAnimationState: null,
            skeleton: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineBeginnerTwo#init", this ); }

                this.runWalkDuration = 1.5;
            }
        },
        methods: {
            /*Spine.Unity.Examples.SpineBeginnerTwo.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineBeginnerTwo#Start", this ); }

                // Make sure you get these AnimationState and Skeleton references in Start or Later.
                // Getting and using them in Awake is not guaranteed by default execution order.
                this.skeletonAnimation = this.GetComponent(Spine.Unity.SkeletonAnimation);
                this.spineAnimationState = this.skeletonAnimation.AnimationState;
                this.skeleton = this.skeletonAnimation.Skeleton;

                this.StartCoroutine$1(this.DoDemoRoutine());
            },
            /*Spine.Unity.Examples.SpineBeginnerTwo.Start end.*/

            /*Spine.Unity.Examples.SpineBeginnerTwo.DoDemoRoutine start.*/
            /**
             * @instance
             * @private
             * @this Spine.Unity.Examples.SpineBeginnerTwo
             * @memberof Spine.Unity.Examples.SpineBeginnerTwo
             * @return  {System.Collections.IEnumerator}
             */
            DoDemoRoutine: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineBeginnerTwo#DoDemoRoutine", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if ( true ) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 7;
                                        continue;
                                }
                                case 1: {
                                    // SetAnimation is the basic way to set an animation.
                                        // SetAnimation sets the animation and starts playing it from the beginning.
                                        // Common Mistake: If you keep calling it in Update, it will keep showing the first pose of the animation, do don't do that.

                                        this.spineAnimationState.setAnimation(0, this.walkAnimationName, true);
                                        $enumerator.current = new UnityEngine.WaitForSeconds(this.runWalkDuration);
                                        $step = 2;
                                        return true;
                                }
                                case 2: {
                                    this.spineAnimationState.setAnimation(0, this.runAnimationName, true);
                                        $enumerator.current = new UnityEngine.WaitForSeconds(this.runWalkDuration);
                                        $step = 3;
                                        return true;
                                }
                                case 3: {
                                    // AddAnimation queues up an animation to play after the previous one ends.
                                        this.spineAnimationState.setAnimation(0, this.runToIdleAnimationName, false);
                                        this.spineAnimationState.addAnimation(0, this.idleAnimationName, true, 0);
                                        $enumerator.current = new UnityEngine.WaitForSeconds(1.0);
                                        $step = 4;
                                        return true;
                                }
                                case 4: {
                                    this.skeleton.scaleX = -1; // skeleton allows you to flip the skeleton.
                                        this.spineAnimationState.setAnimation(0, this.idleTurnAnimationName, false);
                                        this.spineAnimationState.addAnimation(0, this.idleAnimationName, true, 0);
                                        $enumerator.current = new UnityEngine.WaitForSeconds(0.5);
                                        $step = 5;
                                        return true;
                                }
                                case 5: {
                                    this.skeleton.scaleX = 1;
                                        this.spineAnimationState.setAnimation(0, this.idleTurnAnimationName, false);
                                        this.spineAnimationState.addAnimation(0, this.idleAnimationName, true, 0);
                                        $enumerator.current = new UnityEngine.WaitForSeconds(0.5);
                                        $step = 6;
                                        return true;
                                }
                                case 6: {
                                    
                                        $step = 0;
                                        continue;
                                }
                                case 7: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Spine.Unity.Examples.SpineBeginnerTwo.DoDemoRoutine end.*/


        }
    });
    /*Spine.Unity.Examples.SpineBeginnerTwo end.*/

    /*Spine.Unity.Examples.SpineBlinkPlayer start.*/
    Bridge.define("Spine.Unity.Examples.SpineBlinkPlayer", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                BlinkTrack: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineBlinkPlayer#init", this ); }

                    this.BlinkTrack = 1;
                }
            }
        },
        fields: {
            blinkAnimation: null,
            minimumDelay: 0,
            maximumDelay: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineBlinkPlayer#init", this ); }

                this.minimumDelay = 0.15;
                this.maximumDelay = 3.0;
            }
        },
        methods: {
            /*Spine.Unity.Examples.SpineBlinkPlayer.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineBlinkPlayer#Start", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    skeletonAnimation,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    skeletonAnimation = this.GetComponent(Spine.Unity.SkeletonAnimation);
                                        if (UnityEngine.MonoBehaviour.op_Equality(skeletonAnimation, null)) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 2;
                                        continue;
                                }
                                case 1: {
                                    return false;
                                }
                                case 2: {
                                    if ( true ) {
                                            $step = 3;
                                            continue;
                                        } 
                                        $step = 5;
                                        continue;
                                }
                                case 3: {
                                    skeletonAnimation.AnimationState.setAnimationWith( Spine.Unity.Examples.SpineBlinkPlayer.BlinkTrack, Spine.Unity.AnimationReferenceAsset.op_Implicit(this.blinkAnimation), false );
                                        $enumerator.current = new UnityEngine.WaitForSeconds(UnityEngine.Random.Range$1(this.minimumDelay, this.maximumDelay));
                                        $step = 4;
                                        return true;
                                }
                                case 4: {
                                    
                                        $step = 2;
                                        continue;
                                }
                                case 5: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Spine.Unity.Examples.SpineBlinkPlayer.Start end.*/


        }
    });
    /*Spine.Unity.Examples.SpineBlinkPlayer end.*/

    /*Spine.Unity.Examples.Spineboy start.*/
    Bridge.define("Spine.Unity.Examples.Spineboy", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonAnimation: null
        },
        methods: {
            /*Spine.Unity.Examples.Spineboy.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.Spineboy#Start", this ); }

                this.skeletonAnimation = this.GetComponent(Spine.Unity.SkeletonAnimation); // Get the SkeletonAnimation component for the GameObject this script is attached to.
                var animationState = this.skeletonAnimation.AnimationState;

                animationState.addEvent(Bridge.fn.cacheBind(this, this.HandleEvent));
                ; // Call our method any time an animation fires an event.
                animationState.addEnd(function (entry) {
                    UnityEngine.Debug.Log$1("start: " + entry.trackIndex);
                }); // A lambda can be used for the callback instead of a method.

                animationState.addAnimation(0, "jump", false, 2); // Queue jump to be played on track 0 two seconds after the starting animation.
                animationState.addAnimation(0, "run", true, 0); // Queue walk to be looped on track 0 after the jump animation.
            },
            /*Spine.Unity.Examples.Spineboy.Start end.*/

            /*Spine.Unity.Examples.Spineboy.HandleEvent start.*/
            HandleEvent: function (trackEntry, e) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.Spineboy#HandleEvent", this ); }

                UnityEngine.Debug.Log$1(System.String.concat(trackEntry.trackIndex + " " + (trackEntry.animation.name || "") + ": event ", data.name) + ", " + e.intValue);
            },
            /*Spine.Unity.Examples.Spineboy.HandleEvent end.*/

            /*Spine.Unity.Examples.Spineboy.OnMouseDown start.*/
            OnMouseDown: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.Spineboy#OnMouseDown", this ); }

                this.skeletonAnimation.AnimationState.setAnimation(0, "jump", false); // Set jump to be played on track 0 immediately.
                this.skeletonAnimation.AnimationState.addAnimation(0, "run", true, 0); // Queue walk to be looped on track 0 after the jump animation.
            },
            /*Spine.Unity.Examples.Spineboy.OnMouseDown end.*/


        }
    });
    /*Spine.Unity.Examples.Spineboy end.*/

    /*Spine.Unity.Examples.SpineboyBeginnerInput start.*/
    Bridge.define("Spine.Unity.Examples.SpineboyBeginnerInput", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            horizontalAxis: null,
            attackButton: null,
            aimButton: null,
            jumpButton: null,
            model: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyBeginnerInput#init", this ); }

                this.horizontalAxis = "Horizontal";
                this.attackButton = "Fire1";
                this.aimButton = "Fire2";
                this.jumpButton = "Jump";
            }
        },
        methods: {
            /*Spine.Unity.Examples.SpineboyBeginnerInput.OnValidate start.*/
            OnValidate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyBeginnerInput#OnValidate", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.model, null)) {
                    this.model = this.GetComponent(Spine.Unity.Examples.SpineboyBeginnerModel);
                }
            },
            /*Spine.Unity.Examples.SpineboyBeginnerInput.OnValidate end.*/

            /*Spine.Unity.Examples.SpineboyBeginnerInput.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyBeginnerInput#Update", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.model, null)) {
                    return;
                }

                var currentHorizontal = UnityEngine.Input.GetAxisRaw(this.horizontalAxis);
                this.model.TryMove(currentHorizontal);

                if (UnityEngine.Input.GetButton(this.attackButton)) {
                    this.model.TryShoot();
                }

                if (UnityEngine.Input.GetButtonDown(this.aimButton)) {
                    this.model.StartAim();
                }
                if (UnityEngine.Input.GetButtonUp(this.aimButton)) {
                    this.model.StopAim();
                }

                if (UnityEngine.Input.GetButtonDown(this.jumpButton)) {
                    this.model.TryJump();
                }
            },
            /*Spine.Unity.Examples.SpineboyBeginnerInput.Update end.*/


        }
    });
    /*Spine.Unity.Examples.SpineboyBeginnerInput end.*/

    /*Spine.Unity.Examples.SpineboyBeginnerModel start.*/
    Bridge.define("Spine.Unity.Examples.SpineboyBeginnerModel", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            state: 0,
            facingLeft: false,
            currentSpeed: 0,
            shootInterval: 0,
            lastShootTime: 0
        },
        events: {
            ShootEvent: null,
            StartAimEvent: null,
            StopAimEvent: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyBeginnerModel#init", this ); }

                this.shootInterval = 0.12;
            }
        },
        methods: {
            /*Spine.Unity.Examples.SpineboyBeginnerModel.TryJump start.*/
            TryJump: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyBeginnerModel#TryJump", this ); }

                this.StartCoroutine$1(this.JumpRoutine());
            },
            /*Spine.Unity.Examples.SpineboyBeginnerModel.TryJump end.*/

            /*Spine.Unity.Examples.SpineboyBeginnerModel.TryShoot start.*/
            TryShoot: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyBeginnerModel#TryShoot", this ); }

                var currentTime = UnityEngine.Time.time;

                if (currentTime - this.lastShootTime > this.shootInterval) {
                    this.lastShootTime = currentTime;
                    if (!Bridge.staticEquals(this.ShootEvent, null)) {
                        this.ShootEvent();
                    } // Fire the "ShootEvent" event.
                }
            },
            /*Spine.Unity.Examples.SpineboyBeginnerModel.TryShoot end.*/

            /*Spine.Unity.Examples.SpineboyBeginnerModel.StartAim start.*/
            StartAim: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyBeginnerModel#StartAim", this ); }

                if (!Bridge.staticEquals(this.StartAimEvent, null)) {
                    this.StartAimEvent();
                } // Fire the "StartAimEvent" event.
            },
            /*Spine.Unity.Examples.SpineboyBeginnerModel.StartAim end.*/

            /*Spine.Unity.Examples.SpineboyBeginnerModel.StopAim start.*/
            StopAim: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyBeginnerModel#StopAim", this ); }

                if (!Bridge.staticEquals(this.StopAimEvent, null)) {
                    this.StopAimEvent();
                } // Fire the "StopAimEvent" event.
            },
            /*Spine.Unity.Examples.SpineboyBeginnerModel.StopAim end.*/

            /*Spine.Unity.Examples.SpineboyBeginnerModel.TryMove start.*/
            TryMove: function (speed) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyBeginnerModel#TryMove", this ); }

                this.currentSpeed = speed; // show the "speed" in the Inspector.

                if (speed !== 0) {
                    var speedIsNegative = (speed < 0.0);
                    this.facingLeft = speedIsNegative; // Change facing direction whenever speed is not 0.
                }

                if (this.state !== Spine.Unity.Examples.SpineBeginnerBodyState.Jumping) {
                    this.state = (speed === 0) ? Spine.Unity.Examples.SpineBeginnerBodyState.Idle : Spine.Unity.Examples.SpineBeginnerBodyState.Running;
                }

            },
            /*Spine.Unity.Examples.SpineboyBeginnerModel.TryMove end.*/

            /*Spine.Unity.Examples.SpineboyBeginnerModel.JumpRoutine start.*/
            JumpRoutine: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyBeginnerModel#JumpRoutine", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    pos,
                    jumpTime,
                    half,
                    jumpPower,
                    t,
                    d,
                    t1,
                    d1,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if (this.state === Spine.Unity.Examples.SpineBeginnerBodyState.Jumping) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 2;
                                        continue;
                                }
                                case 1: {
                                    return false;
                                }
                                case 2: {
                                    // Don't jump when already jumping.

                                        this.state = Spine.Unity.Examples.SpineBeginnerBodyState.Jumping;

                                        // Fake jumping.
                                        pos = this.transform.localPosition.$clone();
                                        jumpTime = 1.2;
                                        half = 0.6;
                                        jumpPower = 20.0;
                                        t = 0;
                                        $step = 3;
                                        continue;
                                }
                                case 3: {
                                    if ( t < half ) {
                                            $step = 4;
                                            continue;
                                        }
                                    $step = 7;
                                    continue;
                                }
                                case 4: {
                                    d = jumpPower * (half - t);
                                        this.transform.Translate$1(pc.Vec3.UP.clone().clone().scale( (d * UnityEngine.Time.deltaTime) ));
                                        $enumerator.current = null;
                                        $step = 5;
                                        return true;
                                }
                                case 5: {
                                    $step = 6;
                                    continue;
                                }
                                case 6: {
                                    t += UnityEngine.Time.deltaTime;
                                    $step = 3;
                                    continue;
                                }
                                case 7: {
                                    t1 = 0;
                                        $step = 8;
                                        continue;
                                }
                                case 8: {
                                    if ( t1 < half ) {
                                            $step = 9;
                                            continue;
                                        }
                                    $step = 12;
                                    continue;
                                }
                                case 9: {
                                    d1 = jumpPower * t1;
                                        this.transform.Translate$1(pc.Vec3.DOWN.clone().clone().scale( (d1 * UnityEngine.Time.deltaTime) ));
                                        $enumerator.current = null;
                                        $step = 10;
                                        return true;
                                }
                                case 10: {
                                    $step = 11;
                                    continue;
                                }
                                case 11: {
                                    t1 += UnityEngine.Time.deltaTime;
                                    $step = 8;
                                    continue;
                                }
                                case 12: {
                                    this.transform.localPosition = pos.$clone();

                                        this.state = Spine.Unity.Examples.SpineBeginnerBodyState.Idle;

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Spine.Unity.Examples.SpineboyBeginnerModel.JumpRoutine end.*/


        }
    });
    /*Spine.Unity.Examples.SpineboyBeginnerModel end.*/

    /*Spine.Unity.Examples.SpineboyBeginnerView start.*/
    Bridge.define("Spine.Unity.Examples.SpineboyBeginnerView", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            model: null,
            skeletonAnimation: null,
            run: null,
            idle: null,
            aim: null,
            shoot: null,
            jump: null,
            footstepEvent: null,
            footstepPitchOffset: 0,
            gunsoundPitchOffset: 0,
            footstepSource: null,
            gunSource: null,
            jumpSource: null,
            gunParticles: null,
            previousViewState: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyBeginnerView#init", this ); }

                this.footstepPitchOffset = 0.2;
                this.gunsoundPitchOffset = 0.13;
            }
        },
        methods: {
            /*Spine.Unity.Examples.SpineboyBeginnerView.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyBeginnerView#Start", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonAnimation, null)) {
                    return;
                }
                this.model.addShootEvent(Bridge.fn.cacheBind(this, this.PlayShoot));
                this.model.addStartAimEvent(Bridge.fn.cacheBind(this, this.StartPlayingAim));
                this.model.addStopAimEvent(Bridge.fn.cacheBind(this, this.StopPlayingAim));
                this.skeletonAnimation.AnimationState.addEvent(Bridge.fn.cacheBind(this, this.HandleEvent));
            },
            /*Spine.Unity.Examples.SpineboyBeginnerView.Start end.*/

            /*Spine.Unity.Examples.SpineboyBeginnerView.HandleEvent start.*/
            HandleEvent: function (trackEntry, e) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyBeginnerView#HandleEvent", this ); }

                if (Bridge.referenceEquals(e.data, this.footstepEvent.EventData)) {
                    this.PlayFootstepSound();
                }
            },
            /*Spine.Unity.Examples.SpineboyBeginnerView.HandleEvent end.*/

            /*Spine.Unity.Examples.SpineboyBeginnerView.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyBeginnerView#Update", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonAnimation, null)) {
                    return;
                }
                if (UnityEngine.MonoBehaviour.op_Equality(this.model, null)) {
                    return;
                }

                if ((this.skeletonAnimation.skeleton.scaleX < 0) !== this.model.facingLeft) { // Detect changes in model.facingLeft
                    this.Turn(this.model.facingLeft);
                }

                // Detect changes in model.state
                var currentModelState = this.model.state;

                if (this.previousViewState !== currentModelState) {
                    this.PlayNewStableAnimation();
                }

                this.previousViewState = currentModelState;
            },
            /*Spine.Unity.Examples.SpineboyBeginnerView.Update end.*/

            /*Spine.Unity.Examples.SpineboyBeginnerView.PlayNewStableAnimation start.*/
            PlayNewStableAnimation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyBeginnerView#PlayNewStableAnimation", this ); }

                var newModelState = this.model.state;
                var nextAnimation;

                // Add conditionals to not interrupt transient animations.

                if (this.previousViewState === Spine.Unity.Examples.SpineBeginnerBodyState.Jumping && newModelState !== Spine.Unity.Examples.SpineBeginnerBodyState.Jumping) {
                    this.PlayFootstepSound();
                }

                if (newModelState === Spine.Unity.Examples.SpineBeginnerBodyState.Jumping) {
                    this.jumpSource.Play();
                    nextAnimation = Spine.Unity.AnimationReferenceAsset.op_Implicit(this.jump);
                } else {
                    if (newModelState === Spine.Unity.Examples.SpineBeginnerBodyState.Running) {
                        nextAnimation = Spine.Unity.AnimationReferenceAsset.op_Implicit(this.run);
                    } else {
                        nextAnimation = Spine.Unity.AnimationReferenceAsset.op_Implicit(this.idle);
                    }
                }

                this.skeletonAnimation.AnimationState.setAnimationWith( 0, nextAnimation, true );
            },
            /*Spine.Unity.Examples.SpineboyBeginnerView.PlayNewStableAnimation end.*/

            /*Spine.Unity.Examples.SpineboyBeginnerView.PlayFootstepSound start.*/
            PlayFootstepSound: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyBeginnerView#PlayFootstepSound", this ); }

                this.footstepSource.Play();
                this.footstepSource.pitch = this.GetRandomPitch(this.footstepPitchOffset);
            },
            /*Spine.Unity.Examples.SpineboyBeginnerView.PlayFootstepSound end.*/

            /*Spine.Unity.Examples.SpineboyBeginnerView.CheckTracks start.*/
            CheckTracks: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyBeginnerView#CheckTracks", this ); }

                var state = this.skeletonAnimation.AnimationState;
                UnityEngine.Debug.Log(state.getCurrent(0));
                UnityEngine.Debug.Log(state.getCurrent(1));
            },
            /*Spine.Unity.Examples.SpineboyBeginnerView.CheckTracks end.*/

            /*Spine.Unity.Examples.SpineboyBeginnerView.PlayShoot start.*/
            PlayShoot: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyBeginnerView#PlayShoot", this ); }

                // Play the shoot animation on track 1.
                var shootTrack = this.skeletonAnimation.AnimationState.setAnimationWith( 1, Spine.Unity.AnimationReferenceAsset.op_Implicit(this.shoot), false );
                shootTrack.attachmentThreshold = 1.0;
                shootTrack.mixDuration = 0.0;
                this.skeletonAnimation.state.addEmptyAnimation(1, 0.5, 0.1);

                // Play the aim animation on track 2 to aim at the mouse target.
                var aimTrack = this.skeletonAnimation.AnimationState.setAnimationWith( 2, Spine.Unity.AnimationReferenceAsset.op_Implicit(this.aim), false );
                aimTrack.attachmentThreshold = 1.0;
                aimTrack.mixDuration = 0.0;
                this.skeletonAnimation.state.addEmptyAnimation(2, 0.5, 0.1);

                this.gunSource.pitch = this.GetRandomPitch(this.gunsoundPitchOffset);
                this.gunSource.Play();
                //gunParticles.randomSeed = (uint)Random.Range(0, 100);
                this.gunParticles.Play();
            },
            /*Spine.Unity.Examples.SpineboyBeginnerView.PlayShoot end.*/

            /*Spine.Unity.Examples.SpineboyBeginnerView.StartPlayingAim start.*/
            StartPlayingAim: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyBeginnerView#StartPlayingAim", this ); }

                // Play the aim animation on track 2 to aim at the mouse target.
                var aimTrack = this.skeletonAnimation.AnimationState.setAnimationWith( 2, Spine.Unity.AnimationReferenceAsset.op_Implicit(this.aim), true );
                aimTrack.attachmentThreshold = 1.0;
                aimTrack.mixDuration = 0.0;
            },
            /*Spine.Unity.Examples.SpineboyBeginnerView.StartPlayingAim end.*/

            /*Spine.Unity.Examples.SpineboyBeginnerView.StopPlayingAim start.*/
            StopPlayingAim: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyBeginnerView#StopPlayingAim", this ); }

                this.skeletonAnimation.state.addEmptyAnimation(2, 0.5, 0.1);
            },
            /*Spine.Unity.Examples.SpineboyBeginnerView.StopPlayingAim end.*/

            /*Spine.Unity.Examples.SpineboyBeginnerView.Turn start.*/
            Turn: function (facingLeft) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyBeginnerView#Turn", this ); }

                this.skeletonAnimation.Skeleton.scaleX = facingLeft ? -1.0 : 1.0;
                // Maybe play a transient turning animation too, then call ChangeStableAnimation.
            },
            /*Spine.Unity.Examples.SpineboyBeginnerView.Turn end.*/

            /*Spine.Unity.Examples.SpineboyBeginnerView.GetRandomPitch start.*/
            GetRandomPitch: function (maxPitchOffset) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyBeginnerView#GetRandomPitch", this ); }

                return 1.0 + UnityEngine.Random.Range$1(-maxPitchOffset, maxPitchOffset);
            },
            /*Spine.Unity.Examples.SpineboyBeginnerView.GetRandomPitch end.*/


        }
    });
    /*Spine.Unity.Examples.SpineboyBeginnerView end.*/

    /*Spine.Unity.Examples.SpineboyBeginnerViewGraphic start.*/
    Bridge.define("Spine.Unity.Examples.SpineboyBeginnerViewGraphic", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            model: null,
            skeletonGraphic: null,
            run: null,
            idle: null,
            aim: null,
            shoot: null,
            jump: null,
            footstepEvent: null,
            footstepPitchOffset: 0,
            gunsoundPitchOffset: 0,
            footstepSource: null,
            gunSource: null,
            jumpSource: null,
            gunParticles: null,
            previousViewState: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyBeginnerViewGraphic#init", this ); }

                this.footstepPitchOffset = 0.2;
                this.gunsoundPitchOffset = 0.13;
            }
        },
        methods: {
            /*Spine.Unity.Examples.SpineboyBeginnerViewGraphic.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyBeginnerViewGraphic#Start", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    return;
                }
                this.model.addShootEvent(Bridge.fn.cacheBind(this, this.PlayShoot));
                this.model.addStartAimEvent(Bridge.fn.cacheBind(this, this.StartPlayingAim));
                this.model.addStopAimEvent(Bridge.fn.cacheBind(this, this.StopPlayingAim));
                this.skeletonGraphic.AnimationState.addEvent(Bridge.fn.cacheBind(this, this.HandleEvent));
            },
            /*Spine.Unity.Examples.SpineboyBeginnerViewGraphic.Start end.*/

            /*Spine.Unity.Examples.SpineboyBeginnerViewGraphic.HandleEvent start.*/
            HandleEvent: function (trackEntry, e) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyBeginnerViewGraphic#HandleEvent", this ); }

                if (Bridge.referenceEquals(e.data, this.footstepEvent.EventData)) {
                    this.PlayFootstepSound();
                }
            },
            /*Spine.Unity.Examples.SpineboyBeginnerViewGraphic.HandleEvent end.*/

            /*Spine.Unity.Examples.SpineboyBeginnerViewGraphic.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyBeginnerViewGraphic#Update", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    return;
                }
                if (UnityEngine.MonoBehaviour.op_Equality(this.model, null)) {
                    return;
                }

                if ((this.skeletonGraphic.Skeleton.scaleX < 0) !== this.model.facingLeft) { // Detect changes in model.facingLeft
                    this.Turn(this.model.facingLeft);
                }

                // Detect changes in model.state
                var currentModelState = this.model.state;

                if (this.previousViewState !== currentModelState) {
                    this.PlayNewStableAnimation();
                }

                this.previousViewState = currentModelState;
            },
            /*Spine.Unity.Examples.SpineboyBeginnerViewGraphic.Update end.*/

            /*Spine.Unity.Examples.SpineboyBeginnerViewGraphic.PlayNewStableAnimation start.*/
            PlayNewStableAnimation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyBeginnerViewGraphic#PlayNewStableAnimation", this ); }

                var newModelState = this.model.state;
                var nextAnimation;

                // Add conditionals to not interrupt transient animations.

                if (this.previousViewState === Spine.Unity.Examples.SpineBeginnerBodyState.Jumping && newModelState !== Spine.Unity.Examples.SpineBeginnerBodyState.Jumping) {
                    this.PlayFootstepSound();
                }

                if (newModelState === Spine.Unity.Examples.SpineBeginnerBodyState.Jumping) {
                    this.jumpSource.Play();
                    nextAnimation = Spine.Unity.AnimationReferenceAsset.op_Implicit(this.jump);
                } else {
                    if (newModelState === Spine.Unity.Examples.SpineBeginnerBodyState.Running) {
                        nextAnimation = Spine.Unity.AnimationReferenceAsset.op_Implicit(this.run);
                    } else {
                        nextAnimation = Spine.Unity.AnimationReferenceAsset.op_Implicit(this.idle);
                    }
                }

                this.skeletonGraphic.AnimationState.setAnimationWith( 0, nextAnimation, true );
            },
            /*Spine.Unity.Examples.SpineboyBeginnerViewGraphic.PlayNewStableAnimation end.*/

            /*Spine.Unity.Examples.SpineboyBeginnerViewGraphic.PlayFootstepSound start.*/
            PlayFootstepSound: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyBeginnerViewGraphic#PlayFootstepSound", this ); }

                this.footstepSource.Play();
                this.footstepSource.pitch = this.GetRandomPitch(this.footstepPitchOffset);
            },
            /*Spine.Unity.Examples.SpineboyBeginnerViewGraphic.PlayFootstepSound end.*/

            /*Spine.Unity.Examples.SpineboyBeginnerViewGraphic.CheckTracks start.*/
            CheckTracks: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyBeginnerViewGraphic#CheckTracks", this ); }

                var state = this.skeletonGraphic.AnimationState;
                UnityEngine.Debug.Log(state.getCurrent(0));
                UnityEngine.Debug.Log(state.getCurrent(1));
            },
            /*Spine.Unity.Examples.SpineboyBeginnerViewGraphic.CheckTracks end.*/

            /*Spine.Unity.Examples.SpineboyBeginnerViewGraphic.PlayShoot start.*/
            PlayShoot: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyBeginnerViewGraphic#PlayShoot", this ); }

                // Play the shoot animation on track 1.
                var shootTrack = this.skeletonGraphic.AnimationState.setAnimationWith( 1, Spine.Unity.AnimationReferenceAsset.op_Implicit(this.shoot), false );
                shootTrack.attachmentThreshold = 1.0;
                shootTrack.mixDuration = 0.0;
                this.skeletonGraphic.AnimationState.addEmptyAnimation(1, 0.5, 0.1);

                // Play the aim animation on track 2 to aim at the mouse target.
                var aimTrack = this.skeletonGraphic.AnimationState.setAnimationWith( 2, Spine.Unity.AnimationReferenceAsset.op_Implicit(this.aim), false );
                aimTrack.attachmentThreshold = 1.0;
                aimTrack.mixDuration = 0.0;
                this.skeletonGraphic.AnimationState.addEmptyAnimation(2, 0.5, 0.1);

                this.gunSource.pitch = this.GetRandomPitch(this.gunsoundPitchOffset);
                this.gunSource.Play();
                //gunParticles.randomSeed = (uint)Random.Range(0, 100);
                this.gunParticles.Play();
            },
            /*Spine.Unity.Examples.SpineboyBeginnerViewGraphic.PlayShoot end.*/

            /*Spine.Unity.Examples.SpineboyBeginnerViewGraphic.StartPlayingAim start.*/
            StartPlayingAim: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyBeginnerViewGraphic#StartPlayingAim", this ); }

                // Play the aim animation on track 2 to aim at the mouse target.
                var aimTrack = this.skeletonGraphic.AnimationState.setAnimationWith( 2, Spine.Unity.AnimationReferenceAsset.op_Implicit(this.aim), true );
                aimTrack.attachmentThreshold = 1.0;
                aimTrack.mixDuration = 0.0;
            },
            /*Spine.Unity.Examples.SpineboyBeginnerViewGraphic.StartPlayingAim end.*/

            /*Spine.Unity.Examples.SpineboyBeginnerViewGraphic.StopPlayingAim start.*/
            StopPlayingAim: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyBeginnerViewGraphic#StopPlayingAim", this ); }

                this.skeletonGraphic.AnimationState.addEmptyAnimation(2, 0.5, 0.1);
            },
            /*Spine.Unity.Examples.SpineboyBeginnerViewGraphic.StopPlayingAim end.*/

            /*Spine.Unity.Examples.SpineboyBeginnerViewGraphic.Turn start.*/
            Turn: function (facingLeft) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyBeginnerViewGraphic#Turn", this ); }

                this.skeletonGraphic.Skeleton.scaleX = facingLeft ? -1.0 : 1.0;
                // Maybe play a transient turning animation too, then call ChangeStableAnimation.
            },
            /*Spine.Unity.Examples.SpineboyBeginnerViewGraphic.Turn end.*/

            /*Spine.Unity.Examples.SpineboyBeginnerViewGraphic.GetRandomPitch start.*/
            GetRandomPitch: function (maxPitchOffset) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyBeginnerViewGraphic#GetRandomPitch", this ); }

                return 1.0 + UnityEngine.Random.Range$1(-maxPitchOffset, maxPitchOffset);
            },
            /*Spine.Unity.Examples.SpineboyBeginnerViewGraphic.GetRandomPitch end.*/


        }
    });
    /*Spine.Unity.Examples.SpineboyBeginnerViewGraphic end.*/

    /*Spine.Unity.Examples.SpineboyBodyTilt start.*/
    Bridge.define("Spine.Unity.Examples.SpineboyBodyTilt", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            planter: null,
            hip: null,
            head: null,
            hipTiltScale: 0,
            headTiltScale: 0,
            hipRotationMoveScale: 0,
            hipRotationTarget: 0,
            hipRotationSmoothed: 0,
            baseHeadRotation: 0,
            hipBone: null,
            headBone: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyBodyTilt#init", this ); }

                this.hip = "hip";
                this.head = "head";
                this.hipTiltScale = 7;
                this.headTiltScale = 0.7;
                this.hipRotationMoveScale = 60.0;
            }
        },
        methods: {
            /*Spine.Unity.Examples.SpineboyBodyTilt.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyBodyTilt#Start", this ); }

                var skeletonAnimation = this.GetComponent(Spine.Unity.SkeletonAnimation);
                var skeleton = skeletonAnimation.Skeleton;

                this.hipBone = skeleton.findBone(this.hip);
                this.headBone = skeleton.findBone(this.head);
                this.baseHeadRotation = this.headBone.rotation;

                skeletonAnimation.addUpdateLocal(Bridge.fn.cacheBind(this, this.UpdateLocal));
            },
            /*Spine.Unity.Examples.SpineboyBodyTilt.Start end.*/

            /*Spine.Unity.Examples.SpineboyBodyTilt.UpdateLocal start.*/
            UpdateLocal: function (animated) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyBodyTilt#UpdateLocal", this ); }

                this.hipRotationTarget = this.planter.Balance * this.hipTiltScale;
                this.hipRotationSmoothed = UnityEngine.Mathf.MoveTowards(this.hipRotationSmoothed, this.hipRotationTarget, UnityEngine.Time.deltaTime * this.hipRotationMoveScale * Math.abs(2.0 * this.planter.Balance / this.planter.offBalanceThreshold));
                this.hipBone.rotation = this.hipRotationSmoothed;
                this.headBone.rotation = this.baseHeadRotation + (-this.hipRotationSmoothed * this.headTiltScale);
            },
            /*Spine.Unity.Examples.SpineboyBodyTilt.UpdateLocal end.*/


        }
    });
    /*Spine.Unity.Examples.SpineboyBodyTilt end.*/

    /*Spine.Unity.Examples.SpineboyFacialExpression start.*/
    Bridge.define("Spine.Unity.Examples.SpineboyFacialExpression", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            footPlanter: null,
            eyeSlotName: null,
            mouthSlotName: null,
            shockEyeName: null,
            normalEyeName: null,
            shockMouthName: null,
            normalMouthName: null,
            eyeSlot: null,
            mouthSlot: null,
            shockEye: null,
            normalEye: null,
            shockMouth: null,
            normalMouth: null,
            balanceThreshold: 0,
            shockDuration: 0,
            shockTimer: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyFacialExpression#init", this ); }

                this.balanceThreshold = 2.5;
                this.shockDuration = 1.0;
                this.shockTimer = 0.0;
            }
        },
        methods: {
            /*Spine.Unity.Examples.SpineboyFacialExpression.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyFacialExpression#Start", this ); }

                var skeletonAnimation = this.GetComponent(Spine.Unity.SkeletonAnimation);
                var skeleton = skeletonAnimation.Skeleton;
                this.eyeSlot = skeleton.findSlot(this.eyeSlotName);
                this.mouthSlot = skeleton.findSlot(this.mouthSlotName);

                var eyeSlotIndex = skeleton.data.findSlot(this.eyeSlotName).index;
                this.shockEye = skeleton.getAttachment(eyeSlotIndex, this.shockEyeName);
                this.normalEye = skeleton.getAttachment(eyeSlotIndex, this.normalEyeName);

                var mouthSlotIndex = skeleton.data.findSlot(this.mouthSlotName).index;
                this.shockMouth = skeleton.getAttachment(mouthSlotIndex, this.shockMouthName);
                this.normalMouth = skeleton.getAttachment(mouthSlotIndex, this.normalMouthName);
            },
            /*Spine.Unity.Examples.SpineboyFacialExpression.Start end.*/

            /*Spine.Unity.Examples.SpineboyFacialExpression.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyFacialExpression#Update", this ); }

                if (Math.abs(this.footPlanter.Balance) > this.balanceThreshold) {
                    this.shockTimer = this.shockDuration;
                }

                if (this.shockTimer > 0) {
                    this.shockTimer -= UnityEngine.Time.deltaTime;
                }

                if (this.shockTimer > 0) {
                    this.eyeSlot.setAttachment( this.shockEye );
                    this.mouthSlot.setAttachment( this.shockMouth );
                } else {
                    this.eyeSlot.setAttachment( this.normalEye );
                    this.mouthSlot.setAttachment( this.normalMouth );
                }
            },
            /*Spine.Unity.Examples.SpineboyFacialExpression.Update end.*/


        }
    });
    /*Spine.Unity.Examples.SpineboyFacialExpression end.*/

    /*Spine.Unity.Examples.SpineboyFootplanter start.*/
    Bridge.define("Spine.Unity.Examples.SpineboyFootplanter", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            timeScale: 0,
            nearBoneName: null,
            farBoneName: null,
            footSize: null,
            footRayRaise: 0,
            comfyDistance: 0,
            centerOfGravityXOffset: 0,
            feetTooFarApartThreshold: 0,
            offBalanceThreshold: 0,
            minimumSpaceBetweenFeet: 0,
            maxNewStepDisplacement: 0,
            shuffleDistance: 0,
            baseLerpSpeed: 0,
            forward: null,
            backward: null,
            balance: 0,
            distanceBetweenFeet: 0,
            nearFoot: null,
            farFoot: null,
            skeleton: null,
            nearFootBone: null,
            farFootBone: null,
            hits: null
        },
        props: {
            Balance: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyFootplanter#Balance#get", this ); }

                    return this.balance;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyFootplanter#init", this ); }

                this.footSize = new UnityEngine.Vector2();
                this.timeScale = 0.5;
                this.footRayRaise = 2.0;
                this.comfyDistance = 1.0;
                this.centerOfGravityXOffset = -0.25;
                this.feetTooFarApartThreshold = 3.0;
                this.offBalanceThreshold = 1.4;
                this.minimumSpaceBetweenFeet = 0.5;
                this.maxNewStepDisplacement = 2.0;
                this.shuffleDistance = 1.0;
                this.baseLerpSpeed = 3.5;
                this.hits = System.Array.init(1, function (){
                    return new UnityEngine.RaycastHit2D();
                }, UnityEngine.RaycastHit2D);
            }
        },
        methods: {
            /*Spine.Unity.Examples.SpineboyFootplanter.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyFootplanter#Start", this ); }

                var $t, $t1;
                UnityEngine.Time.timeScale = this.timeScale;
                var tpos = this.transform.position.$clone();

                // Default starting positions.
                this.nearFoot.worldPos = UnityEngine.Vector2.FromVector3(tpos.$clone());
                this.nearFoot.worldPos.x -= this.comfyDistance;
                this.nearFoot.worldPosPrev = ($t = this.nearFoot.worldPos.$clone(), this.nearFoot.worldPosNext = $t.$clone(), $t);

                this.farFoot.worldPos = UnityEngine.Vector2.FromVector3(tpos.$clone());
                this.farFoot.worldPos.x += this.comfyDistance;
                this.farFoot.worldPosPrev = ($t1 = this.farFoot.worldPos.$clone(), this.farFoot.worldPosNext = $t1.$clone(), $t1);

                var skeletonAnimation = this.GetComponent(Spine.Unity.SkeletonAnimation);
                this.skeleton = skeletonAnimation.Skeleton;

                skeletonAnimation.addUpdateLocal(Bridge.fn.cacheBind(this, this.UpdateLocal));

                this.nearFootBone = this.skeleton.findBone(this.nearBoneName);
                this.farFootBone = this.skeleton.findBone(this.farBoneName);

                this.nearFoot.lerp = 1.0;
                this.farFoot.lerp = 1.0;
            },
            /*Spine.Unity.Examples.SpineboyFootplanter.Start end.*/

            /*Spine.Unity.Examples.SpineboyFootplanter.UpdateLocal start.*/
            UpdateLocal: function (animated) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyFootplanter#UpdateLocal", this ); }

                var thisTransform = this.transform;

                var thisTransformPosition = UnityEngine.Vector2.FromVector3(thisTransform.position.$clone());
                var centerOfGravityX = thisTransformPosition.x + this.centerOfGravityXOffset;

                this.nearFoot.UpdateDistance(centerOfGravityX);
                this.farFoot.UpdateDistance(centerOfGravityX);
                this.balance = this.nearFoot.displacementFromCenter + this.farFoot.displacementFromCenter;
                this.distanceBetweenFeet = Math.abs(this.nearFoot.worldPos.x - this.farFoot.worldPos.x);

                // Detect time to make a new step
                var isTooOffBalance = Math.abs(this.balance) > this.offBalanceThreshold;
                var isFeetTooFarApart = this.distanceBetweenFeet > this.feetTooFarApartThreshold;
                var timeForNewStep = isFeetTooFarApart || isTooOffBalance;
                if (timeForNewStep) {

                    // Choose which foot to use for next step.
                    var stepFoot, otherFoot;
                    var stepLegIsNearLeg = this.nearFoot.distanceFromCenter > this.farFoot.distanceFromCenter;
                    if (stepLegIsNearLeg) {
                        stepFoot = this.nearFoot;
                        otherFoot = this.farFoot;
                    } else {
                        stepFoot = this.farFoot;
                        otherFoot = this.nearFoot;
                    }

                    // Start a new step.
                    if (!stepFoot.IsStepInProgress && otherFoot.IsPrettyMuchDoneStepping) {
                        var newDisplacement = Spine.Unity.Examples.SpineboyFootplanter.Foot.GetNewDisplacement(otherFoot.displacementFromCenter, this.comfyDistance, this.minimumSpaceBetweenFeet, this.maxNewStepDisplacement, this.forward, this.backward);
                        stepFoot.StartNewStep(newDisplacement, centerOfGravityX, thisTransformPosition.y, this.footRayRaise, this.hits, this.footSize);
                    }

                }


                var deltaTime = UnityEngine.Time.deltaTime;
                var stepSpeed = this.baseLerpSpeed;
                stepSpeed += (Math.abs(this.balance) - 0.6) * 2.5;

                // Animate steps that are in progress.
                this.nearFoot.UpdateStepProgress(deltaTime, stepSpeed, this.shuffleDistance, this.forward, this.backward);
                this.farFoot.UpdateStepProgress(deltaTime, stepSpeed, this.shuffleDistance, this.forward, this.backward);

                Spine.Unity.SkeletonExtensions.SetLocalPosition$1(this.nearFootBone, thisTransform.InverseTransformPoint(UnityEngine.Vector3.FromVector2(this.nearFoot.worldPos)));
                Spine.Unity.SkeletonExtensions.SetLocalPosition$1(this.farFootBone, thisTransform.InverseTransformPoint(UnityEngine.Vector3.FromVector2(this.farFoot.worldPos)));
            },
            /*Spine.Unity.Examples.SpineboyFootplanter.UpdateLocal end.*/

            /*Spine.Unity.Examples.SpineboyFootplanter.OnDrawGizmos start.*/
            OnDrawGizmos: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyFootplanter#OnDrawGizmos", this ); }

                if (UnityEngine.Application.isPlaying) {
                    var Radius = 0.15;

                    pc.generateStubProxy( 'UnityEngine.Gizmos', true ).color = new pc.Color( 0, 1, 0, 1 );
                    pc.stubProxy.reportMethod( 'UnityEngine.Gizmos.DrawSphere', null );
                    pc.stubProxy.reportMethod( 'UnityEngine.Gizmos.DrawWireSphere', null );

                    pc.generateStubProxy( 'UnityEngine.Gizmos', true ).color = new pc.Color( 1, 0, 1, 1 );
                    pc.stubProxy.reportMethod( 'UnityEngine.Gizmos.DrawSphere', null );
                    pc.stubProxy.reportMethod( 'UnityEngine.Gizmos.DrawWireSphere', null );
                }
            },
            /*Spine.Unity.Examples.SpineboyFootplanter.OnDrawGizmos end.*/


        }
    });
    /*Spine.Unity.Examples.SpineboyFootplanter end.*/

    /*Spine.Unity.Examples.SpineboyFootplanter+Foot start.*/
    Bridge.define("Spine.Unity.Examples.SpineboyFootplanter.Foot", {
        $kind: 1002,
        statics: {
            methods: {
                /*Spine.Unity.Examples.SpineboyFootplanter+Foot.GetNewDisplacement:static start.*/
                GetNewDisplacement: function (otherLegDisplacementFromCenter, comfyDistance, minimumFootDistanceX, maxNewStepDisplacement, forwardMovement, backwardMovement) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyFootplanter.Foot#GetNewDisplacement", this ); }

                    var movement = (otherLegDisplacementFromCenter === 0 ? 1 : Math.sign(otherLegDisplacementFromCenter)) < 0 ? forwardMovement : backwardMovement;
                    var randomCompensate = UnityEngine.Random.Range$1(movement.minDistanceCompensate, movement.maxDistanceCompensate);

                    var newDisplacement = (otherLegDisplacementFromCenter * randomCompensate);
                    if (Math.abs(newDisplacement) > maxNewStepDisplacement || Math.abs(otherLegDisplacementFromCenter) < minimumFootDistanceX) {
                        newDisplacement = comfyDistance * (newDisplacement === 0 ? 1 : Math.sign(newDisplacement)) * randomCompensate;
                    }

                    return newDisplacement;
                },
                /*Spine.Unity.Examples.SpineboyFootplanter+Foot.GetNewDisplacement:static end.*/


            }
        },
        fields: {
            worldPos: null,
            displacementFromCenter: 0,
            distanceFromCenter: 0,
            lerp: 0,
            worldPosPrev: null,
            worldPosNext: null
        },
        props: {
            IsStepInProgress: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyFootplanter.Foot#IsStepInProgress#get", this ); }

                    return this.lerp < 1.0;
                }
            },
            IsPrettyMuchDoneStepping: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyFootplanter.Foot#IsPrettyMuchDoneStepping#get", this ); }

                    return this.lerp > 0.7;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyFootplanter.Foot#init", this ); }

                this.worldPos = new UnityEngine.Vector2();
                this.worldPosPrev = new UnityEngine.Vector2();
                this.worldPosNext = new UnityEngine.Vector2();
            }
        },
        methods: {
            /*Spine.Unity.Examples.SpineboyFootplanter+Foot.UpdateDistance start.*/
            UpdateDistance: function (centerOfGravityX) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyFootplanter.Foot#UpdateDistance", this ); }

                this.displacementFromCenter = this.worldPos.x - centerOfGravityX;
                this.distanceFromCenter = Math.abs(this.displacementFromCenter);
            },
            /*Spine.Unity.Examples.SpineboyFootplanter+Foot.UpdateDistance end.*/

            /*Spine.Unity.Examples.SpineboyFootplanter+Foot.StartNewStep start.*/
            StartNewStep: function (newDistance, centerOfGravityX, tentativeY, footRayRaise, hits, footSize) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyFootplanter.Foot#StartNewStep", this ); }

                var $t;
                this.lerp = 0.0;
                this.worldPosPrev = this.worldPos.$clone();
                var newX = centerOfGravityX - newDistance;
                var origin = new pc.Vec2( newX, tentativeY + footRayRaise );
                //int hitCount = Physics2D.BoxCastNonAlloc(origin, footSize, 0f, Vector2.down, hits);
                var hitCount = UnityEngine.Physics2D.BoxCast$1(origin, footSize, 0.0, new pc.Vec2( pc.Vec2.UP.x, -pc.Vec2.UP.y ), ($t = new UnityEngine.ContactFilter2D(), $t.useTriggers = false, $t), hits);
                this.worldPosNext = hitCount > 0 ? hits[0].point.$clone() : new pc.Vec2( newX, tentativeY );
            },
            /*Spine.Unity.Examples.SpineboyFootplanter+Foot.StartNewStep end.*/

            /*Spine.Unity.Examples.SpineboyFootplanter+Foot.UpdateStepProgress start.*/
            UpdateStepProgress: function (deltaTime, stepSpeed, shuffleDistance, forwardMovement, backwardMovement) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyFootplanter.Foot#UpdateStepProgress", this ); }

                if (!this.IsStepInProgress) {
                    return;
                }

                this.lerp += deltaTime * stepSpeed;

                var strideSignedSize = this.worldPosNext.x - this.worldPosPrev.x;
                var strideSign = (strideSignedSize === 0 ? 1 : Math.sign(strideSignedSize));
                var strideSize = (Math.abs(strideSignedSize));

                var movement = strideSign > 0 ? forwardMovement : backwardMovement;

                this.worldPos.x = pc.math.lerp(this.worldPosPrev.x, this.worldPosNext.x, movement.xMoveCurve.value(this.lerp));
                var groundLevel = pc.math.lerp(this.worldPosPrev.y, this.worldPosNext.y, this.lerp);

                if (strideSize > shuffleDistance) {
                    var strideSizeFootRaise = Math.max(1.0, Math.min((strideSize * 0.5), 2.0));
                    this.worldPos.y = groundLevel + (movement.raiseCurve.value(this.lerp) * movement.maxRaise * strideSizeFootRaise);
                } else {
                    this.lerp += UnityEngine.Time.deltaTime;
                    this.worldPos.y = groundLevel;
                }

                if (this.lerp > 1.0) {
                    this.lerp = 1.0;
                }
            },
            /*Spine.Unity.Examples.SpineboyFootplanter+Foot.UpdateStepProgress end.*/


        }
    });
    /*Spine.Unity.Examples.SpineboyFootplanter+Foot end.*/

    /*Spine.Unity.Examples.SpineboyFootplanter+FootMovement start.*/
    Bridge.define("Spine.Unity.Examples.SpineboyFootplanter.FootMovement", {
        $kind: 1002,
        fields: {
            xMoveCurve: null,
            raiseCurve: null,
            maxRaise: 0,
            minDistanceCompensate: 0,
            maxDistanceCompensate: 0
        }
    });
    /*Spine.Unity.Examples.SpineboyFootplanter+FootMovement end.*/

    /*Spine.Unity.Examples.SpineboyFreeze start.*/
    Bridge.define("Spine.Unity.Examples.SpineboyFreeze", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonAnimation: null,
            freeze: null,
            idle: null,
            freezeColor: null,
            freezeBlackColor: null,
            particles: null,
            freezePoint: 0,
            colorProperty: null,
            blackTintProperty: null,
            block: null,
            meshRenderer: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyFreeze#init", this ); }

                this.freezeColor = new UnityEngine.Color();
                this.freezeBlackColor = new UnityEngine.Color();
                this.freezePoint = 0.5;
                this.colorProperty = "_Color";
                this.blackTintProperty = "_Black";
            }
        },
        methods: {
            /*Spine.Unity.Examples.SpineboyFreeze.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyFreeze#Start", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    main,
                    state,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    this.block = new UnityEngine.MaterialPropertyBlock();
                                        this.meshRenderer = this.GetComponent(UnityEngine.MeshRenderer);

                                        this.particles.Stop();
                                        this.particles.Clear();
                                        main = this.particles.main;
                                        main.loop = false;

                                        state = this.skeletonAnimation.AnimationState;
                                    $step = 1;
                                    continue;
                                }
                                case 1: {
                                    if ( true ) {
                                            $step = 2;
                                            continue;
                                        } 
                                        $step = 7;
                                        continue;
                                }
                                case 2: {
                                    $enumerator.current = new UnityEngine.WaitForSeconds(1.0);
                                        $step = 3;
                                        return true;
                                }
                                case 3: {
                                    // Play freeze animation
                                        state.setAnimationWith( 0, Spine.Unity.AnimationReferenceAsset.op_Implicit(this.freeze), false );
                                        $enumerator.current = new UnityEngine.WaitForSeconds(this.freezePoint);
                                        $step = 4;
                                        return true;
                                }
                                case 4: {
                                    // Freeze effects
                                        this.particles.Play();
                                        this.block.SetColor$1(this.colorProperty, this.freezeColor);
                                        this.block.SetColor$1(this.blackTintProperty, this.freezeBlackColor);
                                        this.meshRenderer.SetPropertyBlock(this.block);


                                        $enumerator.current = new UnityEngine.WaitForSeconds(2.0);
                                        $step = 5;
                                        return true;
                                }
                                case 5: {
                                    // Return to Idle
                                        state.setAnimationWith( 0, Spine.Unity.AnimationReferenceAsset.op_Implicit(this.idle), true );
                                        this.block.SetColor$1(this.colorProperty, new pc.Color( 1, 1, 1, 1 ));
                                        this.block.SetColor$1(this.blackTintProperty, new pc.Color( 0, 0, 0, 1 ));
                                        this.meshRenderer.SetPropertyBlock(this.block);


                                        $enumerator.current = null;
                                        $step = 6;
                                        return true;
                                }
                                case 6: {
                                    
                                        $step = 1;
                                        continue;
                                }
                                case 7: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Spine.Unity.Examples.SpineboyFreeze.Start end.*/


        }
    });
    /*Spine.Unity.Examples.SpineboyFreeze end.*/

    /*Spine.Unity.Examples.SpineboyPole start.*/
    Bridge.define("Spine.Unity.Examples.SpineboyPole", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                Speed: 0,
                RunTimeScale: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyPole#init", this ); }

                    this.Speed = 18.0;
                    this.RunTimeScale = 1.5;
                }
            }
        },
        fields: {
            skeletonAnimation: null,
            separator: null,
            run: null,
            pole: null,
            startX: 0,
            endX: 0
        },
        methods: {
            /*Spine.Unity.Examples.SpineboyPole.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyPole#Start", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    state,
                    poleTrack,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    state = this.skeletonAnimation.state;
                                    $step = 1;
                                    continue;
                                }
                                case 1: {
                                    if ( true ) {
                                            $step = 2;
                                            continue;
                                        } 
                                        $step = 9;
                                        continue;
                                }
                                case 2: {
                                    // Run phase
                                        this.SetXPosition(this.startX);
                                        this.separator.enabled = false; // Disable Separator during run.
                                        state.setAnimationWith( 0, Spine.Unity.AnimationReferenceAsset.op_Implicit(this.run), true );
                                        state.timeScale = Spine.Unity.Examples.SpineboyPole.RunTimeScale;
                                    $step = 3;
                                    continue;
                                }
                                case 3: {
                                    if ( this.transform.localPosition.x < this.endX ) {
                                            $step = 4;
                                            continue;
                                        } 
                                        $step = 6;
                                        continue;
                                }
                                case 4: {
                                    this.transform.Translate$1(pc.Vec3.RIGHT.clone().clone().scale( Spine.Unity.Examples.SpineboyPole.Speed ).clone().scale( UnityEngine.Time.deltaTime ));
                                        $enumerator.current = null;
                                        $step = 5;
                                        return true;
                                }
                                case 5: {
                                    
                                        $step = 3;
                                        continue;
                                }
                                case 6: {
                                    // Hit phase
                                        this.SetXPosition(this.endX);
                                        this.separator.enabled = true; // Enable Separator when hit
                                        poleTrack = state.setAnimationWith( 0, Spine.Unity.AnimationReferenceAsset.op_Implicit(this.pole), false );
                                        $enumerator.current = new Spine.Unity.WaitForSpineAnimationComplete(poleTrack);
                                        $step = 7;
                                        return true;
                                }
                                case 7: {
                                    $enumerator.current = new UnityEngine.WaitForSeconds(1.0);
                                        $step = 8;
                                        return true;
                                }
                                case 8: {
                                    
                                        $step = 1;
                                        continue;
                                }
                                case 9: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Spine.Unity.Examples.SpineboyPole.Start end.*/

            /*Spine.Unity.Examples.SpineboyPole.SetXPosition start.*/
            SetXPosition: function (x) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyPole#SetXPosition", this ); }

                var tp = this.transform.localPosition.$clone();
                tp.x = x;
                this.transform.localPosition = tp.$clone();
            },
            /*Spine.Unity.Examples.SpineboyPole.SetXPosition end.*/


        }
    });
    /*Spine.Unity.Examples.SpineboyPole end.*/

    /*Spine.Unity.Examples.SpineboyPoleGraphic start.*/
    Bridge.define("Spine.Unity.Examples.SpineboyPoleGraphic", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                Speed: 0,
                RunTimeScale: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyPoleGraphic#init", this ); }

                    this.Speed = 18.0;
                    this.RunTimeScale = 1.5;
                }
            }
        },
        fields: {
            skeletonGraphic: null,
            run: null,
            pole: null,
            startX: 0,
            endX: 0
        },
        methods: {
            /*Spine.Unity.Examples.SpineboyPoleGraphic.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyPoleGraphic#Start", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    state,
                    poleTrack,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    state = this.skeletonGraphic.AnimationState;
                                    $step = 1;
                                    continue;
                                }
                                case 1: {
                                    if ( true ) {
                                            $step = 2;
                                            continue;
                                        } 
                                        $step = 9;
                                        continue;
                                }
                                case 2: {
                                    // Run phase
                                        this.SetXPosition(this.startX);
                                        this.skeletonGraphic.enableSeparatorSlots = false; // Disable Separator during run.
                                        state.setAnimationWith( 0, Spine.Unity.AnimationReferenceAsset.op_Implicit(this.run), true );
                                        state.timeScale = Spine.Unity.Examples.SpineboyPoleGraphic.RunTimeScale;
                                    $step = 3;
                                    continue;
                                }
                                case 3: {
                                    if ( this.transform.localPosition.x < this.endX ) {
                                            $step = 4;
                                            continue;
                                        } 
                                        $step = 6;
                                        continue;
                                }
                                case 4: {
                                    this.transform.Translate$1(pc.Vec3.RIGHT.clone().clone().scale( Spine.Unity.Examples.SpineboyPoleGraphic.Speed ).clone().scale( UnityEngine.Time.deltaTime ));
                                        $enumerator.current = null;
                                        $step = 5;
                                        return true;
                                }
                                case 5: {
                                    
                                        $step = 3;
                                        continue;
                                }
                                case 6: {
                                    // Hit phase
                                        this.SetXPosition(this.endX);
                                        this.skeletonGraphic.enableSeparatorSlots = true; // Enable Separator when hit
                                        poleTrack = state.setAnimationWith( 0, Spine.Unity.AnimationReferenceAsset.op_Implicit(this.pole), false );
                                        $enumerator.current = new Spine.Unity.WaitForSpineAnimationComplete(poleTrack);
                                        $step = 7;
                                        return true;
                                }
                                case 7: {
                                    $enumerator.current = new UnityEngine.WaitForSeconds(1.0);
                                        $step = 8;
                                        return true;
                                }
                                case 8: {
                                    
                                        $step = 1;
                                        continue;
                                }
                                case 9: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Spine.Unity.Examples.SpineboyPoleGraphic.Start end.*/

            /*Spine.Unity.Examples.SpineboyPoleGraphic.SetXPosition start.*/
            SetXPosition: function (x) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyPoleGraphic#SetXPosition", this ); }

                var tp = this.transform.localPosition.$clone();
                tp.x = x;
                this.transform.localPosition = tp.$clone();
            },
            /*Spine.Unity.Examples.SpineboyPoleGraphic.SetXPosition end.*/


        }
    });
    /*Spine.Unity.Examples.SpineboyPoleGraphic end.*/

    /*Spine.Unity.Examples.SpineboyTargetController start.*/
    Bridge.define("Spine.Unity.Examples.SpineboyTargetController", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonAnimation: null,
            boneName: null,
            cam: null,
            bone: null
        },
        methods: {
            /*Spine.Unity.Examples.SpineboyTargetController.OnValidate start.*/
            OnValidate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyTargetController#OnValidate", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonAnimation, null)) {
                    this.skeletonAnimation = this.GetComponent(Spine.Unity.SkeletonAnimation);
                }
            },
            /*Spine.Unity.Examples.SpineboyTargetController.OnValidate end.*/

            /*Spine.Unity.Examples.SpineboyTargetController.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyTargetController#Start", this ); }

                this.bone = this.skeletonAnimation.Skeleton.findBone(this.boneName);
            },
            /*Spine.Unity.Examples.SpineboyTargetController.Start end.*/

            /*Spine.Unity.Examples.SpineboyTargetController.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyTargetController#Update", this ); }

                var mousePosition = UnityEngine.Input.mousePosition.$clone();
                var worldMousePosition = this.cam.ScreenToWorldPoint(mousePosition);
                var skeletonSpacePoint = this.skeletonAnimation.transform.InverseTransformPoint(worldMousePosition);
                skeletonSpacePoint.x *= this.skeletonAnimation.Skeleton.scaleX;
                skeletonSpacePoint.y *= this.skeletonAnimation.Skeleton.scaleY;
                Spine.Unity.SkeletonExtensions.SetLocalPosition$1(this.bone, skeletonSpacePoint.$clone());
            },
            /*Spine.Unity.Examples.SpineboyTargetController.Update end.*/


        }
    });
    /*Spine.Unity.Examples.SpineboyTargetController end.*/

    /*Spine.Unity.Examples.SpineboyTargetControllerGraphic start.*/
    Bridge.define("Spine.Unity.Examples.SpineboyTargetControllerGraphic", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonGraphic: null,
            boneName: null,
            cam: null,
            canvas: null,
            bone: null
        },
        methods: {
            /*Spine.Unity.Examples.SpineboyTargetControllerGraphic.OnValidate start.*/
            OnValidate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyTargetControllerGraphic#OnValidate", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic = this.GetComponent(Spine.Unity.SkeletonGraphic);
                }
            },
            /*Spine.Unity.Examples.SpineboyTargetControllerGraphic.OnValidate end.*/

            /*Spine.Unity.Examples.SpineboyTargetControllerGraphic.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyTargetControllerGraphic#Start", this ); }

                this.bone = this.skeletonGraphic.Skeleton.findBone(this.boneName);
            },
            /*Spine.Unity.Examples.SpineboyTargetControllerGraphic.Start end.*/

            /*Spine.Unity.Examples.SpineboyTargetControllerGraphic.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineboyTargetControllerGraphic#Update", this ); }

                var mousePosition = UnityEngine.Input.mousePosition.$clone();
                var localRectPosition = { v : new UnityEngine.Vector2() };
                UnityEngine.RectTransformUtility.ScreenPointToLocalPointInRectangle(this.skeletonGraphic.rectTransform, UnityEngine.Vector2.FromVector3(mousePosition), null, localRectPosition);
                var skeletonSpacePoint = UnityEngine.Vector3.FromVector2(localRectPosition.v.$clone().scale( 1.0 / ( this.skeletonGraphic.MeshScale ) ));
                skeletonSpacePoint.x *= this.skeletonGraphic.Skeleton.scaleX;
                skeletonSpacePoint.y *= this.skeletonGraphic.Skeleton.scaleY;
                Spine.Unity.SkeletonExtensions.SetLocalPosition$1(this.bone, skeletonSpacePoint.$clone());
            },
            /*Spine.Unity.Examples.SpineboyTargetControllerGraphic.Update end.*/


        }
    });
    /*Spine.Unity.Examples.SpineboyTargetControllerGraphic end.*/

    /*Spine.Unity.Examples.SpineGauge start.*/
    Bridge.define("Spine.Unity.Examples.SpineGauge", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            fillPercent: 0,
            fillAnimation: null,
            skeletonRenderer: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineGauge#init", this ); }

                this.fillPercent = 0;
            }
        },
        methods: {
            /*Spine.Unity.Examples.SpineGauge.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineGauge#Awake", this ); }

                this.skeletonRenderer = this.GetComponent(Spine.Unity.SkeletonRenderer);
            },
            /*Spine.Unity.Examples.SpineGauge.Awake end.*/

            /*Spine.Unity.Examples.SpineGauge.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineGauge#Update", this ); }

                this.SetGaugePercent(this.fillPercent);
            },
            /*Spine.Unity.Examples.SpineGauge.Update end.*/

            /*Spine.Unity.Examples.SpineGauge.SetGaugePercent start.*/
            SetGaugePercent: function (percent) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineGauge#SetGaugePercent", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    return;
                }
                var skeleton = this.skeletonRenderer.skeleton;
                if (skeleton == null) {
                    return;
                }

                this.fillAnimation.Animation.apply(skeleton, 0, percent, false, null, 1.0, spine.MixBlend.setup, spine.MixDirection.mixIn);
                skeleton.updateWorldTransform();
            },
            /*Spine.Unity.Examples.SpineGauge.SetGaugePercent end.*/


        }
    });
    /*Spine.Unity.Examples.SpineGauge end.*/

    /*Spine.Unity.Examples.SpriteAttacher start.*/
    Bridge.define("Spine.Unity.Examples.SpriteAttacher", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                DefaultPMAShader: null,
                DefaultStraightAlphaShader: null,
                atlasPageCache: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpriteAttacher#init", this ); }

                    this.DefaultPMAShader = "Spine/Skeleton";
                    this.DefaultStraightAlphaShader = "Sprites/Default";
                }
            },
            methods: {
                /*Spine.Unity.Examples.SpriteAttacher.GetPageFor:static start.*/
                GetPageFor: function (texture, shader) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpriteAttacher#GetPageFor", this ); }

                    if (Spine.Unity.Examples.SpriteAttacher.atlasPageCache == null) {
                        Spine.Unity.Examples.SpriteAttacher.atlasPageCache = new (System.Collections.Generic.Dictionary$2(UnityEngine.Texture,Spine.AtlasPage)).ctor();
                    }
                    var atlasPage = { };
                    Spine.Unity.Examples.SpriteAttacher.atlasPageCache.tryGetValue(texture, atlasPage);
                    if (atlasPage.v == null) {
                        var newMaterial = new UnityEngine.Material.$ctor2(shader);
                        atlasPage.v = Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(newMaterial);
                        Spine.Unity.Examples.SpriteAttacher.atlasPageCache.setItem(texture, atlasPage.v);
                    }
                    return atlasPage.v;
                },
                /*Spine.Unity.Examples.SpriteAttacher.GetPageFor:static end.*/


            }
        },
        fields: {
            attachOnStart: false,
            overrideAnimation: false,
            sprite: null,
            slot: null,
            attachment: null,
            spineSlot: null,
            applyPMA: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpriteAttacher#init", this ); }

                this.attachOnStart = true;
                this.overrideAnimation = true;
            }
        },
        methods: {
            /*Spine.Unity.Examples.SpriteAttacher.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpriteAttacher#Start", this ); }

                // Initialize slot and attachment references.
                this.Initialize(false);

                if (this.attachOnStart) {
                    this.Attach();
                }
            },
            /*Spine.Unity.Examples.SpriteAttacher.Start end.*/

            /*Spine.Unity.Examples.SpriteAttacher.AnimationOverrideSpriteAttach start.*/
            AnimationOverrideSpriteAttach: function (animated) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpriteAttacher#AnimationOverrideSpriteAttach", this ); }

                if (this.overrideAnimation && this.isActiveAndEnabled) {
                    this.Attach();
                }
            },
            /*Spine.Unity.Examples.SpriteAttacher.AnimationOverrideSpriteAttach end.*/

            /*Spine.Unity.Examples.SpriteAttacher.Initialize start.*/
            Initialize: function (overwrite) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpriteAttacher#Initialize", this ); }

                if (overwrite === void 0) { overwrite = true; }
                if (overwrite || this.attachment == null) {
                    // Get the applyPMA value.
                    var skeletonComponent = this.GetComponent(Spine.Unity.ISkeletonComponent);
                    var skeletonRenderer = Bridge.as(skeletonComponent, Spine.Unity.SkeletonRenderer);
                    if (UnityEngine.MonoBehaviour.op_Inequality(skeletonRenderer, null)) {
                        this.applyPMA = skeletonRenderer.pmaVertexColors;
                    } else {
                        var skeletonGraphic = Bridge.as(skeletonComponent, Spine.Unity.SkeletonGraphic);
                        if (UnityEngine.MonoBehaviour.op_Inequality(skeletonGraphic, null)) {
                            this.applyPMA = skeletonGraphic.MeshGenerator.settings.pmaVertexColors;
                        }
                    }

                    // Subscribe to UpdateComplete to override animation keys.
                    if (this.overrideAnimation) {
                        var animatedSkeleton = Bridge.as(skeletonComponent, Spine.Unity.ISkeletonAnimation);
                        if (animatedSkeleton != null) {
                            animatedSkeleton.Spine$Unity$ISkeletonAnimation$removeUpdateComplete(Bridge.fn.cacheBind(this, this.AnimationOverrideSpriteAttach));
                            animatedSkeleton.Spine$Unity$ISkeletonAnimation$addUpdateComplete(Bridge.fn.cacheBind(this, this.AnimationOverrideSpriteAttach));
                        }
                    }

                    this.spineSlot = this.spineSlot || skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.findSlot(this.slot);
                    var attachmentShader = this.applyPMA ? UnityEngine.Shader.Find(Spine.Unity.Examples.SpriteAttacher.DefaultPMAShader) : UnityEngine.Shader.Find(Spine.Unity.Examples.SpriteAttacher.DefaultStraightAlphaShader);
                    if (this.sprite == null) {
                        this.attachment = null;
                    } else {
                        this.attachment = this.applyPMA ? Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachmentPMAClone$1(this.sprite, attachmentShader) : Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment$1(this.sprite, Spine.Unity.Examples.SpriteAttacher.GetPageFor(this.sprite.texture, attachmentShader));
                    }
                }
            },
            /*Spine.Unity.Examples.SpriteAttacher.Initialize end.*/

            /*Spine.Unity.Examples.SpriteAttacher.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpriteAttacher#OnDestroy", this ); }

                var animatedSkeleton = this.GetComponent(Spine.Unity.ISkeletonAnimation);
                if (animatedSkeleton != null) {
                    animatedSkeleton.Spine$Unity$ISkeletonAnimation$removeUpdateComplete(Bridge.fn.cacheBind(this, this.AnimationOverrideSpriteAttach));
                }
            },
            /*Spine.Unity.Examples.SpriteAttacher.OnDestroy end.*/

            /*Spine.Unity.Examples.SpriteAttacher.Attach start.*/
            /**
             * Update the slot's attachment to the Attachment generated from the sprite.
             *
             * @instance
             * @public
             * @this Spine.Unity.Examples.SpriteAttacher
             * @memberof Spine.Unity.Examples.SpriteAttacher
             * @return  {void}
             */
            Attach: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpriteAttacher#Attach", this ); }

                if (this.spineSlot != null) {
                    this.spineSlot.setAttachment( this.attachment );
                }
            },
            /*Spine.Unity.Examples.SpriteAttacher.Attach end.*/


        }
    });
    /*Spine.Unity.Examples.SpriteAttacher end.*/

    /*Spine.Unity.Examples.SpriteAttachmentExtensions start.*/
    Bridge.define("Spine.Unity.Examples.SpriteAttachmentExtensions", {
        statics: {
            methods: {
                /*Spine.Unity.Examples.SpriteAttachmentExtensions.AttachUnitySprite:static start.*/
                AttachUnitySprite: function (skeleton, slotName, sprite, shaderName, applyPMA, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpriteAttachmentExtensions#AttachUnitySprite", this ); }

                    if (shaderName === void 0) { shaderName = "Spine/Skeleton"; }
                    if (applyPMA === void 0) { applyPMA = true; }
                    if (rotation === void 0) { rotation = 0.0; }
                    return Spine.Unity.Examples.SpriteAttachmentExtensions.AttachUnitySprite$1(skeleton, slotName, sprite, UnityEngine.Shader.Find(shaderName), applyPMA, rotation);
                },
                /*Spine.Unity.Examples.SpriteAttachmentExtensions.AttachUnitySprite:static end.*/

                /*Spine.Unity.Examples.SpriteAttachmentExtensions.AttachUnitySprite$1:static start.*/
                AttachUnitySprite$1: function (skeleton, slotName, sprite, shader, applyPMA, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpriteAttachmentExtensions#AttachUnitySprite$1", this ); }

                    if (rotation === void 0) { rotation = 0.0; }
                    var att = applyPMA ? Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachmentPMAClone$1(sprite, shader, 4, false, void 0, rotation) : Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment$2(sprite, new UnityEngine.Material.$ctor2(shader), rotation);
                    skeleton.findSlot(slotName).setAttachment( att );
                    return att;
                },
                /*Spine.Unity.Examples.SpriteAttachmentExtensions.AttachUnitySprite$1:static end.*/

                /*Spine.Unity.Examples.SpriteAttachmentExtensions.AddUnitySprite:static start.*/
                AddUnitySprite: function (skeletonData, slotName, sprite, skinName, shaderName, applyPMA, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpriteAttachmentExtensions#AddUnitySprite", this ); }

                    if (skinName === void 0) { skinName = ""; }
                    if (shaderName === void 0) { shaderName = "Spine/Skeleton"; }
                    if (applyPMA === void 0) { applyPMA = true; }
                    if (rotation === void 0) { rotation = 0.0; }
                    return Spine.Unity.Examples.SpriteAttachmentExtensions.AddUnitySprite$1(skeletonData, slotName, sprite, skinName, UnityEngine.Shader.Find(shaderName), applyPMA, rotation);
                },
                /*Spine.Unity.Examples.SpriteAttachmentExtensions.AddUnitySprite:static end.*/

                /*Spine.Unity.Examples.SpriteAttachmentExtensions.AddUnitySprite$1:static start.*/
                AddUnitySprite$1: function (skeletonData, slotName, sprite, skinName, shader, applyPMA, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpriteAttachmentExtensions#AddUnitySprite$1", this ); }

                    if (rotation === void 0) { rotation = 0.0; }
                    var att = applyPMA ? Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachmentPMAClone$1(sprite, shader, 4, false, void 0, rotation) : Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment$2(sprite, new UnityEngine.Material.$ctor2(shader), rotation);

                    var slotIndex = skeletonData.findSlot(slotName).index;
                    var skin = skeletonData.defaultSkin;
                    if (!Bridge.referenceEquals(skinName, "")) {
                        skin = skeletonData.findSkin(skinName);
                    }

                    if (skin != null) {
                        skin.setAttachment(slotIndex, att.name, att);
                    }

                    return att;
                },
                /*Spine.Unity.Examples.SpriteAttachmentExtensions.AddUnitySprite$1:static end.*/


            }
        }
    });
    /*Spine.Unity.Examples.SpriteAttachmentExtensions end.*/

    /*Spine.Unity.Examples.TransitionDictionaryExample start.*/
    Bridge.define("Spine.Unity.Examples.TransitionDictionaryExample", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            transitions: null,
            dictionary: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.TransitionDictionaryExample#init", this ); }

                this.transitions = new (System.Collections.Generic.List$1(Spine.Unity.Examples.TransitionDictionaryExample.SerializedEntry)).ctor();
                this.dictionary = new (System.Collections.Generic.Dictionary$2(spine.AnimationStateData.AnimationPair,Spine.Animation)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.Examples.TransitionDictionaryExample.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.TransitionDictionaryExample#Start", this ); }

                var $t;
                this.dictionary.clear();
                $t = Bridge.getEnumerator(this.transitions);
                try {
                    while ($t.moveNext()) {
                        var e = $t.Current.$clone();
                        this.dictionary.add(new spine.AnimationStateData.AnimationPair(e.from.Animation, e.to.Animation), e.transition.Animation);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.Examples.TransitionDictionaryExample.Start end.*/

            /*Spine.Unity.Examples.TransitionDictionaryExample.GetTransition start.*/
            GetTransition: function (from, to) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.TransitionDictionaryExample#GetTransition", this ); }

                var result = { };
                this.dictionary.tryGetValue(new spine.AnimationStateData.AnimationPair(from, to), result);
                return result.v;
            },
            /*Spine.Unity.Examples.TransitionDictionaryExample.GetTransition end.*/


        }
    });
    /*Spine.Unity.Examples.TransitionDictionaryExample end.*/

    /*Spine.Unity.Examples.TransitionDictionaryExample+SerializedEntry start.*/
    Bridge.define("Spine.Unity.Examples.TransitionDictionaryExample.SerializedEntry", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.TransitionDictionaryExample.SerializedEntry#getDefaultValue", this ); }
 return new Spine.Unity.Examples.TransitionDictionaryExample.SerializedEntry(); }
            }
        },
        fields: {
            from: null,
            to: null,
            transition: null
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.TransitionDictionaryExample.SerializedEntry#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.TransitionDictionaryExample.SerializedEntry#getHashCode", this ); }

                var h = Bridge.addHash([5680834701, this.from, this.to, this.transition]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.TransitionDictionaryExample.SerializedEntry#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.Examples.TransitionDictionaryExample.SerializedEntry)) {
                    return false;
                }
                return Bridge.equals(this.from, o.from) && Bridge.equals(this.to, o.to) && Bridge.equals(this.transition, o.transition);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.TransitionDictionaryExample.SerializedEntry#$clone", this ); }

                var s = to || new Spine.Unity.Examples.TransitionDictionaryExample.SerializedEntry();
                s.from = this.from;
                s.to = this.to;
                s.transition = this.transition;
                return s;
            }
        }
    });
    /*Spine.Unity.Examples.TransitionDictionaryExample+SerializedEntry end.*/

    /*Spine.Unity.Examples.TwoByTwoTransformEffectExample start.*/
    Bridge.define("Spine.Unity.Examples.TwoByTwoTransformEffectExample", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            xAxis: null,
            yAxis: null,
            skeletonRenderer: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.TwoByTwoTransformEffectExample#init", this ); }

                this.xAxis = new UnityEngine.Vector2();
                this.yAxis = new UnityEngine.Vector2();
                this.xAxis = new pc.Vec2( 1, 0 );
                this.yAxis = new pc.Vec2( 0, 1 );
            }
        },
        methods: {
            /*Spine.Unity.Examples.TwoByTwoTransformEffectExample.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.TwoByTwoTransformEffectExample#OnEnable", this ); }

                this.skeletonRenderer = this.GetComponent(Spine.Unity.SkeletonRenderer);
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    return;
                }

                // Use the OnPostProcessVertices callback to modify the vertices at the correct time.
                this.skeletonRenderer.removeOnPostProcessVertices(Bridge.fn.cacheBind(this, this.ProcessVertices));
                this.skeletonRenderer.addOnPostProcessVertices(Bridge.fn.cacheBind(this, this.ProcessVertices));

                UnityEngine.Debug.Log$1("2x2 Transform Effect Enabled.");
            },
            /*Spine.Unity.Examples.TwoByTwoTransformEffectExample.OnEnable end.*/

            /*Spine.Unity.Examples.TwoByTwoTransformEffectExample.ProcessVertices start.*/
            ProcessVertices: function (buffers) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.TwoByTwoTransformEffectExample#ProcessVertices", this ); }

                if (!this.enabled) {
                    return;
                }

                var vertexCount = buffers.vertexCount; // For efficiency, limit your effect to the actual mesh vertex count using vertexCount

                // Modify vertex positions by accessing Vector3[] vertexBuffer
                var vertices = buffers.vertexBuffer;
                var transformedPos = Bridge.getDefaultValue(UnityEngine.Vector3);
                for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                    var originalPos = vertices[i].$clone();
                    transformedPos.x = (this.xAxis.x * originalPos.x) + (this.yAxis.x * originalPos.y);
                    transformedPos.y = (this.xAxis.y * originalPos.x) + (this.yAxis.y * originalPos.y);
                    vertices[i] = transformedPos.$clone();
                }

            },
            /*Spine.Unity.Examples.TwoByTwoTransformEffectExample.ProcessVertices end.*/

            /*Spine.Unity.Examples.TwoByTwoTransformEffectExample.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.TwoByTwoTransformEffectExample#OnDisable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    return;
                }
                this.skeletonRenderer.removeOnPostProcessVertices(Bridge.fn.cacheBind(this, this.ProcessVertices));
                UnityEngine.Debug.Log$1("2x2 Transform Effect Disabled.");
            },
            /*Spine.Unity.Examples.TwoByTwoTransformEffectExample.OnDisable end.*/


        }
    });
    /*Spine.Unity.Examples.TwoByTwoTransformEffectExample end.*/

    /*Spine.Unity.ISpineComponentExtensions start.*/
    Bridge.define("Spine.Unity.ISpineComponentExtensions", {
        statics: {
            methods: {
                /*Spine.Unity.ISpineComponentExtensions.IsNullOrDestroyed:static start.*/
                IsNullOrDestroyed: function (component) {
if ( TRACE ) { TRACE( "Spine.Unity.ISpineComponentExtensions#IsNullOrDestroyed", this ); }

                    if (component == null) {
                        return true;
                    }
                    return Bridge.cast(component, UnityEngine.Object) == null;
                },
                /*Spine.Unity.ISpineComponentExtensions.IsNullOrDestroyed:static end.*/


            }
        }
    });
    /*Spine.Unity.ISpineComponentExtensions end.*/

    /*Spine.Unity.MaterialsTextureLoader start.*/
    Bridge.define("Spine.Unity.MaterialsTextureLoader", {
        inherits: [Spine.TextureLoader],
        fields: {
            atlasAsset: null
        },
        alias: [
            "Load", "Spine$TextureLoader$Load",
            "Unload", "Spine$TextureLoader$Unload"
        ],
        ctors: {
            ctor: function (atlasAsset) {
if ( TRACE ) { TRACE( "Spine.Unity.MaterialsTextureLoader#ctor", this ); }

                this.$initialize();
                this.atlasAsset = atlasAsset;
            }
        },
        methods: {
            /*Spine.Unity.MaterialsTextureLoader.Load start.*/
            Load: function (page, path) {
if ( TRACE ) { TRACE( "Spine.Unity.MaterialsTextureLoader#Load", this ); }

                var $t;
                var name = System.IO.Path.GetFileNameWithoutExtension(path);
                var material = null;
                $t = Bridge.getEnumerator(this.atlasAsset.materials);
                try {
                    while ($t.moveNext()) {
                        var other = $t.Current;
                        if (other.mainTexture == null) {
                            UnityEngine.Debug.LogError$2("Material is missing texture: " + (other.name || ""), other);
                            return;
                        }
                        var textureName = other.mainTexture.name;
                        if (Bridge.referenceEquals(textureName, name) || (this.atlasAsset.OnDemandTextureLoader != null && Bridge.referenceEquals(textureName, this.atlasAsset.OnDemandTextureLoader.GetPlaceholderTextureName(name)))) {
                            material = other;
                            break;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                if (material == null) {
                    UnityEngine.Debug.LogError$2("Material with texture name \"" + (name || "") + "\" not found for atlas asset: " + (this.atlasAsset.name || ""), this.atlasAsset);
                    return;
                }
                page.rendererObject = material;

                // Very old atlas files expected the texture's actual size to be used at runtime.
                if (page.width === 0 || page.height === 0) {
                    page.width = material.mainTexture.width;
                    page.height = material.mainTexture.height;
                }
            },
            /*Spine.Unity.MaterialsTextureLoader.Load end.*/

            /*Spine.Unity.MaterialsTextureLoader.Unload start.*/
            Unload: function (texture) {
if ( TRACE ) { TRACE( "Spine.Unity.MaterialsTextureLoader#Unload", this ); }
 },
            /*Spine.Unity.MaterialsTextureLoader.Unload end.*/


        }
    });
    /*Spine.Unity.MaterialsTextureLoader end.*/

    /*Spine.Unity.MathUtilities start.*/
    Bridge.define("Spine.Unity.MathUtilities", {
        statics: {
            methods: {
                /*Spine.Unity.MathUtilities.InverseLerp:static start.*/
                InverseLerp: function (a, b, value) {
if ( TRACE ) { TRACE( "Spine.Unity.MathUtilities#InverseLerp", this ); }

                    return (value - a) / (b - a);
                },
                /*Spine.Unity.MathUtilities.InverseLerp:static end.*/

                /*Spine.Unity.MathUtilities.InverseLerp$1:static start.*/
                /**
                 * Returns the linear interpolation ratio of <pre><code>a</code></pre> to <pre><code>b</code></pre> that <pre><code>value</code></pre> lies on.
                 This is the t value that fulfills <pre><code>value = lerp(a, b, t)</code></pre>.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.MathUtilities
                 * @memberof Spine.Unity.MathUtilities
                 * @param   {UnityEngine.Vector2}    a        
                 * @param   {UnityEngine.Vector2}    b        
                 * @param   {UnityEngine.Vector2}    value
                 * @return  {UnityEngine.Vector2}
                 */
                InverseLerp$1: function (a, b, value) {
if ( TRACE ) { TRACE( "Spine.Unity.MathUtilities#InverseLerp$1", this ); }

                    return new pc.Vec2( (value.x - a.x) / (b.x - a.x), (value.y - a.y) / (b.y - a.y) );
                },
                /*Spine.Unity.MathUtilities.InverseLerp$1:static end.*/

                /*Spine.Unity.MathUtilities.InverseLerp$2:static start.*/
                /**
                 * Returns the linear interpolation ratio of <pre><code>a</code></pre> to <pre><code>b</code></pre> that <pre><code>value</code></pre> lies on.
                 This is the t value that fulfills <pre><code>value = lerp(a, b, t)</code></pre>.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.MathUtilities
                 * @memberof Spine.Unity.MathUtilities
                 * @param   {UnityEngine.Vector3}    a        
                 * @param   {UnityEngine.Vector3}    b        
                 * @param   {UnityEngine.Vector3}    value
                 * @return  {UnityEngine.Vector3}
                 */
                InverseLerp$2: function (a, b, value) {
if ( TRACE ) { TRACE( "Spine.Unity.MathUtilities#InverseLerp$2", this ); }

                    return new pc.Vec3( (value.x - a.x) / (b.x - a.x), (value.y - a.y) / (b.y - a.y), (value.z - a.z) / (b.z - a.z) );
                },
                /*Spine.Unity.MathUtilities.InverseLerp$2:static end.*/

                /*Spine.Unity.MathUtilities.InverseLerp$3:static start.*/
                /**
                 * Returns the linear interpolation ratio of <pre><code>a</code></pre> to <pre><code>b</code></pre> that <pre><code>value</code></pre> lies on.
                 This is the t value that fulfills <pre><code>value = lerp(a, b, t)</code></pre>.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.MathUtilities
                 * @memberof Spine.Unity.MathUtilities
                 * @param   {UnityEngine.Vector4}    a        
                 * @param   {UnityEngine.Vector4}    b        
                 * @param   {UnityEngine.Vector4}    value
                 * @return  {UnityEngine.Vector4}
                 */
                InverseLerp$3: function (a, b, value) {
if ( TRACE ) { TRACE( "Spine.Unity.MathUtilities#InverseLerp$3", this ); }

                    return new pc.Vec4( (value.x - a.x) / (b.x - a.x), (value.y - a.y) / (b.y - a.y), (value.z - a.z) / (b.z - a.z), (value.w - a.w) / (b.w - a.w) );
                },
                /*Spine.Unity.MathUtilities.InverseLerp$3:static end.*/


            }
        }
    });
    /*Spine.Unity.MathUtilities end.*/

    /*Spine.Unity.MeshGenerator start.*/
    /**
     * Holds several methods to prepare and generate a UnityEngine mesh based on a skeleton. Contains buffers needed to perform the operation, and serializes settings for mesh generation.
     *
     * @public
     * @class Spine.Unity.MeshGenerator
     */
    Bridge.define("Spine.Unity.MeshGenerator", {
        statics: {
            fields: {
                BoundsMinDefault: 0,
                BoundsMaxDefault: 0,
                AttachmentVerts: null,
                AttachmentUVs: null,
                AttachmentColors32: null,
                AttachmentIndices: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#init", this ); }

                    this.BoundsMinDefault = Number.POSITIVE_INFINITY;
                    this.BoundsMaxDefault = Number.NEGATIVE_INFINITY;
                    this.AttachmentVerts = new (System.Collections.Generic.List$1(UnityEngine.Vector3)).ctor();
                    this.AttachmentUVs = new (System.Collections.Generic.List$1(UnityEngine.Vector2)).ctor();
                    this.AttachmentColors32 = new (System.Collections.Generic.List$1(UnityEngine.Color32)).ctor();
                    this.AttachmentIndices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                }
            },
            methods: {
                /*Spine.Unity.MeshGenerator.GenerateSingleSubmeshInstruction:static start.*/
                /**
                 * A specialized variant of {@link }.
                 Generates renderer instructions using a single submesh, using only a single material and texture.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.MeshGenerator
                 * @memberof Spine.Unity.MeshGenerator
                 * @param   {Spine.Unity.SkeletonRendererInstruction}    instructionOutput    The resulting instructions.
                 * @param   {Spine.Skeleton}                             skeleton             The skeleton to generate renderer instructions for.
                 * @param   {UnityEngine.Material}                       material             Material to be set at the renderer instruction. When null, the last attachment
                 in the draw order list is assigned as the instruction's material.
                 * @return  {void}
                 */
                GenerateSingleSubmeshInstruction: function (instructionOutput, skeleton, material) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#GenerateSingleSubmeshInstruction", this ); }

                    var $t;
                    var drawOrder = skeleton.DrawOrder;
                    var drawOrderCount = drawOrder.Count;

                    // Clear last state of attachments and submeshes
                    instructionOutput.Clear(); // submeshInstructions.Clear(); attachments.Clear();
                    var workingSubmeshInstructions = instructionOutput.submeshInstructions;

                    instructionOutput.attachments.Resize(drawOrderCount);
                    var workingAttachmentsItems = instructionOutput.attachments.Items;
                    var totalRawVertexCount = 0;

                    var current = ($t = new Spine.Unity.SubmeshInstruction(), $t.skeleton = skeleton, $t.preActiveClippingSlotSource = -1, $t.startSlot = 0, $t.rawFirstVertexIndex = 0, $t.material = material, $t.forceSeparate = false, $t.endSlot = drawOrderCount, $t);

                    var rendererObject = null;
                    var skeletonHasClipping = false;
                    var drawOrderItems = drawOrder.Items;
                    for (var i = 0; i < drawOrderCount; i = (i + 1) | 0) {
                        var slot = drawOrderItems[i];
                        if (!slot.bone.isActive()) {
                            workingAttachmentsItems[i] = null;
                            continue;
                        }
                        if (slot.data.blendMode === spine.BlendMode.Additive) {
                            current.hasPMAAdditiveSlot = true;
                        }
                        var attachment = slot.getAttachment();

                        workingAttachmentsItems[i] = attachment;
                        var attachmentTriangleCount;
                        var attachmentVertexCount;

                        var regionAttachment = Bridge.as(attachment, Spine.RegionAttachment);
                        if (regionAttachment != null) {
                            if (regionAttachment.sequence != null) {
                                regionAttachment.sequence.apply(slot, regionAttachment);
                            }
                            rendererObject = regionAttachment.region;
                            attachmentVertexCount = 4;
                            attachmentTriangleCount = 6;
                        } else {
                            var meshAttachment = Bridge.as(attachment, Spine.MeshAttachment);
                            if (meshAttachment != null) {
                                if (meshAttachment.sequence != null) {
                                    meshAttachment.sequence.apply(slot, meshAttachment);
                                }
                                rendererObject = meshAttachment.region;
                                attachmentVertexCount = meshAttachment.worldVerticesLength >> 1;
                                attachmentTriangleCount = meshAttachment.triangles.length;
                            } else {
                                var clippingAttachment = Bridge.as(attachment, spine.ClippingAttachment);
                                if (clippingAttachment != null) {
                                    current.hasClipping = true;
                                    skeletonHasClipping = true;
                                }
                                attachmentVertexCount = 0;
                                attachmentTriangleCount = 0;
                            }
                        }
                        current.rawTriangleCount = (current.rawTriangleCount + attachmentTriangleCount) | 0;
                        current.rawVertexCount = (current.rawVertexCount + attachmentVertexCount) | 0;
                        totalRawVertexCount = (totalRawVertexCount + attachmentVertexCount) | 0;
                    }

                    if (material == null && rendererObject != null) {
                        current.material = Bridge.cast(Bridge.cast(rendererObject, Spine.AtlasRegion).page.rendererObject, UnityEngine.Material);
                    }

                    instructionOutput.hasActiveClipping = skeletonHasClipping;
                    instructionOutput.rawVertexCount = totalRawVertexCount;

                    if (totalRawVertexCount > 0) {
                        workingSubmeshInstructions.Resize(1);
                        workingSubmeshInstructions.Items[0] = current.$clone();
                    } else {
                        workingSubmeshInstructions.Resize(0);
                    }
                },
                /*Spine.Unity.MeshGenerator.GenerateSingleSubmeshInstruction:static end.*/

                /*Spine.Unity.MeshGenerator.RequiresMultipleSubmeshesByDrawOrder:static start.*/
                RequiresMultipleSubmeshesByDrawOrder: function (skeleton) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#RequiresMultipleSubmeshesByDrawOrder", this ); }


                    var drawOrder = skeleton.DrawOrder;
                    var drawOrderCount = drawOrder.Count;
                    var drawOrderItems = drawOrder.Items;

                    var lastRendererMaterial = null;
                    for (var i = 0; i < drawOrderCount; i = (i + 1) | 0) {
                        var slot = drawOrderItems[i];
                        if (!slot.bone.isActive()) {
                            continue;
                        }
                        var attachment = slot.getAttachment();
                        var rendererAttachment = Bridge.as(attachment, Spine.IHasTextureRegion);
                        if (rendererAttachment != null) {
                            if (rendererAttachment.Spine$IHasTextureRegion$Sequence != null) {
                                rendererAttachment.Spine$IHasTextureRegion$Sequence.apply(slot, rendererAttachment);
                            }
                            var atlasRegion = Bridge.cast(rendererAttachment.Spine$IHasTextureRegion$Region, Spine.AtlasRegion);
                            var material = Bridge.cast(atlasRegion.page.rendererObject, UnityEngine.Material);
                            if (!Bridge.referenceEquals(lastRendererMaterial, material)) {
                                if (lastRendererMaterial != null) {
                                    return true;
                                }
                                lastRendererMaterial = material;
                            }
                        }
                    }
                    return false;
                },
                /*Spine.Unity.MeshGenerator.RequiresMultipleSubmeshesByDrawOrder:static end.*/

                /*Spine.Unity.MeshGenerator.GenerateSkeletonRendererInstruction:static start.*/
                GenerateSkeletonRendererInstruction: function (instructionOutput, skeleton, customSlotMaterials, separatorSlots, generateMeshOverride, immutableTriangles) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#GenerateSkeletonRendererInstruction", this ); }

                    var $t;
                    if (immutableTriangles === void 0) { immutableTriangles = false; }
                    //			if (skeleton == null) throw new ArgumentNullException("skeleton");
                    //			if (instructionOutput == null) throw new ArgumentNullException("instructionOutput");

                    var drawOrder = skeleton.DrawOrder;
                    var drawOrderCount = drawOrder.Count;

                    // Clear last state of attachments and submeshes
                    instructionOutput.Clear(); // submeshInstructions.Clear(); attachments.Clear();
                    var workingSubmeshInstructions = instructionOutput.submeshInstructions;
                    instructionOutput.attachments.Resize(drawOrderCount);
                    var workingAttachmentsItems = instructionOutput.attachments.Items;
                    var totalRawVertexCount = 0;
                    var skeletonHasClipping = false;

                    var current = ($t = new Spine.Unity.SubmeshInstruction(), $t.skeleton = skeleton, $t.preActiveClippingSlotSource = -1, $t);

                    var isCustomSlotMaterialsPopulated = customSlotMaterials != null && customSlotMaterials.Count > 0;

                    var separatorCount = separatorSlots == null ? 0 : separatorSlots.Count;
                    var hasSeparators = separatorCount > 0;

                    var clippingAttachmentSource = -1;
                    var lastPreActiveClipping = -1; // The index of the last slot that had an active ClippingAttachment.
                    var clippingEndSlot = null;
                    var submeshIndex = 0;
                    var drawOrderItems = drawOrder.Items;
                    for (var i = 0; i < drawOrderCount; i = (i + 1) | 0) {
                        var slot = drawOrderItems[i];
                        if (!slot.bone.isActive()) {
                            workingAttachmentsItems[i] = null;
                            continue;
                        }
                        if (slot.data.blendMode === spine.BlendMode.Additive) {
                            current.hasPMAAdditiveSlot = true;
                        }
                        var attachment = slot.getAttachment();
                        workingAttachmentsItems[i] = attachment;
                        var attachmentVertexCount = 0, attachmentTriangleCount = 0;

                        var region = null;
                        var noRender = false; // Using this allows empty slots as separators, and keeps separated parts more stable despite slots being reordered

                        var regionAttachment = Bridge.as(attachment, Spine.RegionAttachment);
                        if (regionAttachment != null) {
                            if (regionAttachment.sequence != null) {
                                regionAttachment.sequence.apply(slot, regionAttachment);
                            }
                            region = regionAttachment.region;
                            attachmentVertexCount = 4;
                            attachmentTriangleCount = 6;
                        } else {
                            var meshAttachment = Bridge.as(attachment, Spine.MeshAttachment);
                            if (meshAttachment != null) {
                                if (meshAttachment.sequence != null) {
                                    meshAttachment.sequence.apply(slot, meshAttachment);
                                }
                                region = meshAttachment.region;
                                attachmentVertexCount = meshAttachment.worldVerticesLength >> 1;
                                attachmentTriangleCount = meshAttachment.triangles.length;
                            } else {
                                var clippingAttachment = Bridge.as(attachment, spine.ClippingAttachment);
                                if (clippingAttachment != null) {
                                    clippingEndSlot = clippingAttachment.endSlot;
                                    clippingAttachmentSource = i;
                                    current.hasClipping = true;
                                    skeletonHasClipping = true;
                                }
                                noRender = true;
                            }
                        }

                        // Create a new SubmeshInstruction when material changes. (or when forced to separate by a submeshSeparator)
                        // Slot with a separator/new material will become the starting slot of the next new instruction.
                        if (hasSeparators) { //current.forceSeparate = hasSeparators && separatorSlots.Contains(slot);
                            current.forceSeparate = false;
                            for (var s = 0; s < separatorCount; s = (s + 1) | 0) {
                                if (Bridge.referenceEquals(slot, separatorSlots.getItem(s))) {
                                    current.forceSeparate = true;
                                    break;
                                }
                            }
                        }

                        if (noRender) {
                            if (current.forceSeparate && generateMeshOverride) { // && current.rawVertexCount > 0) {
                                { // Add
                                    current.endSlot = i;
                                    current.preActiveClippingSlotSource = lastPreActiveClipping;

                                    workingSubmeshInstructions.Resize(((submeshIndex + 1) | 0));
                                    workingSubmeshInstructions.Items[submeshIndex] = current.$clone();

                                    submeshIndex = (submeshIndex + 1) | 0;
                                }

                                current.startSlot = i;
                                lastPreActiveClipping = clippingAttachmentSource;
                                current.rawTriangleCount = 0;
                                current.rawVertexCount = 0;
                                current.rawFirstVertexIndex = totalRawVertexCount;
                                current.hasClipping = clippingAttachmentSource >= 0;
                            }
                        } else {
                            var material = { };
                            if (isCustomSlotMaterialsPopulated) {
                                if (!customSlotMaterials.tryGetValue(slot, material)) {
                                    material.v = Bridge.cast(Bridge.cast(region, Spine.AtlasRegion).page.rendererObject, UnityEngine.Material);
                                }
                            } else {
                                material.v = Bridge.cast(Bridge.cast(region, Spine.AtlasRegion).page.rendererObject, UnityEngine.Material);
                            }

                            if (current.forceSeparate || (current.rawVertexCount > 0 && !Bridge.referenceEquals(current.material, material.v))) { // Material changed. Add the previous submesh.
                                { // Add
                                    current.endSlot = i;
                                    current.preActiveClippingSlotSource = lastPreActiveClipping;

                                    workingSubmeshInstructions.Resize(((submeshIndex + 1) | 0));
                                    workingSubmeshInstructions.Items[submeshIndex] = current.$clone();
                                    submeshIndex = (submeshIndex + 1) | 0;
                                }
                                current.startSlot = i;
                                lastPreActiveClipping = clippingAttachmentSource;
                                current.rawTriangleCount = 0;
                                current.rawVertexCount = 0;
                                current.rawFirstVertexIndex = totalRawVertexCount;
                                current.hasClipping = clippingAttachmentSource >= 0;
                            }

                            // Update state for the next Attachment.
                            current.material = material.v;
                            current.rawTriangleCount = (current.rawTriangleCount + attachmentTriangleCount) | 0;
                            current.rawVertexCount = (current.rawVertexCount + attachmentVertexCount) | 0;
                            current.rawFirstVertexIndex = totalRawVertexCount;
                            totalRawVertexCount = (totalRawVertexCount + attachmentVertexCount) | 0;
                        }

                        if (clippingEndSlot != null && Bridge.referenceEquals(slot.data, clippingEndSlot) && i !== clippingAttachmentSource) {
                            clippingEndSlot = null;
                            clippingAttachmentSource = -1;
                        }
                    }

                    if (current.rawVertexCount > 0) {
                        { // Add last or only submesh.
                            current.endSlot = drawOrderCount;
                            current.preActiveClippingSlotSource = lastPreActiveClipping;
                            current.forceSeparate = false;

                            workingSubmeshInstructions.Resize(((submeshIndex + 1) | 0));
                            workingSubmeshInstructions.Items[submeshIndex] = current.$clone();
                            //submeshIndex++;
                        }
                    }

                    instructionOutput.hasActiveClipping = skeletonHasClipping;
                    instructionOutput.rawVertexCount = totalRawVertexCount;
                    instructionOutput.immutableTriangles = immutableTriangles;
                },
                /*Spine.Unity.MeshGenerator.GenerateSkeletonRendererInstruction:static end.*/

                /*Spine.Unity.MeshGenerator.TryReplaceMaterials:static start.*/
                TryReplaceMaterials: function (workingSubmeshInstructions, customMaterialOverride) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#TryReplaceMaterials", this ); }

                    // Material overrides are done here so they can be applied per submesh instead of per slot
                    // but they will still be passed through the GenerateMeshOverride delegate,
                    // and will still go through the normal material match check step in STEP 3.
                    var wsii = workingSubmeshInstructions.Items;
                    for (var i = 0; i < workingSubmeshInstructions.Count; i = (i + 1) | 0) {
                        var material = wsii[i].material;
                        if (material == null) {
                            continue;
                        }

                        var overrideMaterial = { };
                        if (customMaterialOverride.tryGetValue(material, overrideMaterial)) {
                            wsii[i].material = overrideMaterial.v;
                        }
                    }
                },
                /*Spine.Unity.MeshGenerator.TryReplaceMaterials:static end.*/

                /*Spine.Unity.MeshGenerator.SolveTangents2DEnsureSize:static start.*/
                /**
                 * Step 1 of solving tangents. Ensure you have buffers of the correct size.
                 *
                 * @static
                 * @this Spine.Unity.MeshGenerator
                 * @memberof Spine.Unity.MeshGenerator
                 * @param   {UnityEngine.Vector4}    tangentBuffer         Eventual Vector4[] tangent buffer to assign to Mesh.tangents.
                 * @param   {UnityEngine.Vector2}    tempTanBuffer         Temporary Vector2 buffer for calculating directions.
                 * @param   {number}                 vertexCount           Number of vertices that require tangents (or the size of the vertex array)
                 * @param   {number}                 vertexBufferLength
                 * @return  {void}
                 */
                SolveTangents2DEnsureSize: function (tangentBuffer, tempTanBuffer, vertexCount, vertexBufferLength) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#SolveTangents2DEnsureSize", this ); }

                    if (tangentBuffer.v == null || tangentBuffer.v.length !== vertexBufferLength) {
                        tangentBuffer.v = System.Array.init(vertexBufferLength, function (){
                            return new UnityEngine.Vector4();
                        }, UnityEngine.Vector4);
                    }

                    if (tempTanBuffer.v == null || tempTanBuffer.v.length < Bridge.Int.mul(vertexCount, 2)) {
                        tempTanBuffer.v = System.Array.init(Bridge.Int.mul(vertexCount, 2), function (){
                            return new UnityEngine.Vector2();
                        }, UnityEngine.Vector2);
                    } // two arrays in one.
                },
                /*Spine.Unity.MeshGenerator.SolveTangents2DEnsureSize:static end.*/

                /*Spine.Unity.MeshGenerator.SolveTangents2DTriangles:static start.*/
                /**
                 * Step 2 of solving tangents. Fills (part of) a temporary tangent-solution buffer based on the vertices and uvs defined by a submesh's triangle buffer. Only needs to be called once for single-submesh meshes.
                 *
                 * @static
                 * @this Spine.Unity.MeshGenerator
                 * @memberof Spine.Unity.MeshGenerator
                 * @param   {Array.<UnityEngine.Vector2>}    tempTanBuffer    A temporary Vector3[] for calculating tangents.
                 * @param   {Array.<number>}                 triangles        The mesh's current triangles buffer.
                 * @param   {number}                         triangleCount    The number of triangle indexes in the triangle array to be used.
                 * @param   {Array.<UnityEngine.Vector3>}    vertices         The mesh's current vertex position buffer.
                 * @param   {Array.<UnityEngine.Vector2>}    uvs              The mesh's current uvs buffer.
                 * @param   {number}                         vertexCount      Number of vertices that require tangents (or the size of the vertex array)
                 * @return  {void}
                 */
                SolveTangents2DTriangles: function (tempTanBuffer, triangles, triangleCount, vertices, uvs, vertexCount) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#SolveTangents2DTriangles", this ); }

                    var $t, $t1;
                    var sdir = new UnityEngine.Vector2();
                    var tdir = new UnityEngine.Vector2();
                    for (var t = 0; t < triangleCount; t = (t + 3) | 0) {
                        var i1 = triangles[((t + 0) | 0)];
                        var i2 = triangles[((t + 1) | 0)];
                        var i3 = triangles[((t + 2) | 0)];

                        var v1 = vertices[i1].$clone();
                        var v2 = vertices[i2].$clone();
                        var v3 = vertices[i3].$clone();

                        var w1 = uvs[i1].$clone();
                        var w2 = uvs[i2].$clone();
                        var w3 = uvs[i3].$clone();

                        var x1 = v2.x - v1.x;
                        var x2 = v3.x - v1.x;
                        var y1 = v2.y - v1.y;
                        var y2 = v3.y - v1.y;

                        var s1 = w2.x - w1.x;
                        var s2 = w3.x - w1.x;
                        var t1 = w2.y - w1.y;
                        var t2 = w3.y - w1.y;

                        var div = s1 * t2 - s2 * t1;
                        var r = (div === 0.0) ? 0.0 : 1.0 / div;

                        sdir.x = (t2 * x1 - t1 * x2) * r;
                        sdir.y = (t2 * y1 - t1 * y2) * r;
                        tempTanBuffer[i1] = ($t = (tempTanBuffer[i3] = sdir.$clone(), sdir.$clone()), tempTanBuffer[i2] = $t.$clone(), $t);

                        tdir.x = (s1 * x2 - s2 * x1) * r;
                        tdir.y = (s1 * y2 - s2 * y1) * r;
                        tempTanBuffer[((vertexCount + i1) | 0)] = ($t1 = (tempTanBuffer[((vertexCount + i3) | 0)] = tdir.$clone(), tdir.$clone()), tempTanBuffer[((vertexCount + i2) | 0)] = $t1.$clone(), $t1);
                    }
                },
                /*Spine.Unity.MeshGenerator.SolveTangents2DTriangles:static end.*/

                /*Spine.Unity.MeshGenerator.SolveTangents2DBuffer:static start.*/
                /**
                 * Step 3 of solving tangents. Fills a Vector4[] tangents array according to values calculated in step 2.
                 *
                 * @static
                 * @this Spine.Unity.MeshGenerator
                 * @memberof Spine.Unity.MeshGenerator
                 * @param   {Array.<UnityEngine.Vector4>}    tangents         A Vector4[] that will eventually be used to set Mesh.tangents
                 * @param   {Array.<UnityEngine.Vector2>}    tempTanBuffer    A temporary Vector3[] for calculating tangents.
                 * @param   {number}                         vertexCount      Number of vertices that require tangents (or the size of the vertex array)
                 * @return  {void}
                 */
                SolveTangents2DBuffer: function (tangents, tempTanBuffer, vertexCount) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#SolveTangents2DBuffer", this ); }

                    var tangent = new UnityEngine.Vector4();
                    tangent.z = 0;
                    for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                        var t = tempTanBuffer[i].$clone();

                        // t.Normalize() (aggressively inlined). Even better if offloaded to GPU via vertex shader.
                        var magnitude = Math.sqrt(t.x * t.x + t.y * t.y);
                        if (magnitude > 1E-05) {
                            var reciprocalMagnitude = 1.0 / magnitude;
                            t.x *= reciprocalMagnitude;
                            t.y *= reciprocalMagnitude;
                        }

                        var t2 = tempTanBuffer[((vertexCount + i) | 0)].$clone();
                        tangent.x = t.x;
                        tangent.y = t.y;
                        //tangent.z = 0;
                        tangent.w = (t.y * t2.x > t.x * t2.y) ? 1 : -1; // 2D direction calculation. Used for binormals.
                        tangents[i] = tangent.$clone();
                    }
                },
                /*Spine.Unity.MeshGenerator.SolveTangents2DBuffer:static end.*/

                /*Spine.Unity.MeshGenerator.FillMeshLocal$1:static start.*/
                /**
                 * Fills mesh vertex data to render a RegionAttachment.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.MeshGenerator
                 * @memberof Spine.Unity.MeshGenerator
                 * @param   {UnityEngine.Mesh}          mesh                
                 * @param   {Spine.RegionAttachment}    regionAttachment
                 * @return  {void}
                 */
                FillMeshLocal$1: function (mesh, regionAttachment) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#FillMeshLocal$1", this ); }

                    if (mesh == null) {
                        return;
                    }
                    if (regionAttachment == null) {
                        return;
                    }

                    Spine.Unity.MeshGenerator.AttachmentVerts.clear();
                    var offsets = regionAttachment.offset;
                    Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( offsets[0], offsets[1], 0 ));
                    Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( offsets[2], offsets[3], 0 ));
                    Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( offsets[4], offsets[5], 0 ));
                    Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( offsets[6], offsets[7], 0 ));

                    Spine.Unity.MeshGenerator.AttachmentUVs.clear();
                    var uvs = regionAttachment.uvs;
                    Spine.Unity.MeshGenerator.AttachmentUVs.add(new pc.Vec2( uvs[2], uvs[3] ));
                    Spine.Unity.MeshGenerator.AttachmentUVs.add(new pc.Vec2( uvs[4], uvs[5] ));
                    Spine.Unity.MeshGenerator.AttachmentUVs.add(new pc.Vec2( uvs[6], uvs[7] ));
                    Spine.Unity.MeshGenerator.AttachmentUVs.add(new pc.Vec2( uvs[0], uvs[1] ));

                    Spine.Unity.MeshGenerator.AttachmentColors32.clear();
                    var c = UnityEngine.Color32.op_Implicit$1((new pc.Color( regionAttachment.color.r, regionAttachment.color.g, regionAttachment.color.b, regionAttachment.color.a )));
                    for (var i = 0; i < 4; i = (i + 1) | 0) {
                        Spine.Unity.MeshGenerator.AttachmentColors32.add(c.$clone());
                    }

                    Spine.Unity.MeshGenerator.AttachmentIndices.clear();
                    Spine.Unity.MeshGenerator.AttachmentIndices.AddRange(System.Array.init([0, 2, 1, 0, 3, 2], System.Int32));

                    mesh.Clear();
                    mesh.name = regionAttachment.name;
                    mesh.SetVertices(Spine.Unity.MeshGenerator.AttachmentVerts);
                    mesh.SetUVs(0, Spine.Unity.MeshGenerator.AttachmentUVs);
                    mesh.SetColors$1(Spine.Unity.MeshGenerator.AttachmentColors32);
                    mesh.SetTriangles(Spine.Unity.MeshGenerator.AttachmentIndices, 0);
                    mesh.RecalculateBounds();

                    Spine.Unity.MeshGenerator.AttachmentVerts.clear();
                    Spine.Unity.MeshGenerator.AttachmentUVs.clear();
                    Spine.Unity.MeshGenerator.AttachmentColors32.clear();
                    Spine.Unity.MeshGenerator.AttachmentIndices.clear();
                },
                /*Spine.Unity.MeshGenerator.FillMeshLocal$1:static end.*/

                /*Spine.Unity.MeshGenerator.FillMeshLocal:static start.*/
                FillMeshLocal: function (mesh, meshAttachment, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#FillMeshLocal", this ); }

                    var $t;
                    if (mesh == null) {
                        return;
                    }
                    if (meshAttachment == null) {
                        return;
                    }
                    var vertexCount = (Bridge.Int.div(meshAttachment.worldVerticesLength, 2)) | 0;

                    Spine.Unity.MeshGenerator.AttachmentVerts.clear();
                    if (Spine.SpineSkeletonExtensions.IsWeighted(meshAttachment)) {
                        var count = meshAttachment.worldVerticesLength;
                        var meshAttachmentBones = meshAttachment.bones;
                        var v = 0;

                        var vertices = meshAttachment.vertices;
                        for (var w = 0, b = 0; w < count; w = (w + 2) | 0) {
                            var wx = 0, wy = 0;
                            var n = meshAttachmentBones[Bridge.identity(v, ((v = (v + 1) | 0)))];
                            n = (n + v) | 0;
                            for (; v < n; v = (v + 1) | 0, b = (b + 3) | 0) {
                                var bm = Spine.BoneMatrix.CalculateSetupWorld(($t = skeletonData.Bones.Items)[meshAttachmentBones[v]]);
                                var vx = vertices[b], vy = vertices[((b + 1) | 0)], weight = vertices[((b + 2) | 0)];
                                wx += (vx * bm.a + vy * bm.b + bm.x) * weight;
                                wy += (vx * bm.c + vy * bm.d + bm.y) * weight;
                            }
                            Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( wx, wy, 0 ));
                        }
                    } else {
                        var localVerts = meshAttachment.vertices;
                        var pos = Bridge.getDefaultValue(UnityEngine.Vector3);
                        for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                            var ii = Bridge.Int.mul(i, 2);
                            pos.x = localVerts[ii];
                            pos.y = localVerts[((ii + 1) | 0)];
                            Spine.Unity.MeshGenerator.AttachmentVerts.add(pos.$clone());
                        }
                    }

                    var uvs = meshAttachment.uvs;
                    var uv = Bridge.getDefaultValue(UnityEngine.Vector2);
                    var c = UnityEngine.Color32.op_Implicit$1((new pc.Color( meshAttachment.color.r, meshAttachment.color.g, meshAttachment.color.b, meshAttachment.color.a )));
                    Spine.Unity.MeshGenerator.AttachmentUVs.clear();
                    Spine.Unity.MeshGenerator.AttachmentColors32.clear();
                    for (var i1 = 0; i1 < vertexCount; i1 = (i1 + 1) | 0) {
                        var ii1 = Bridge.Int.mul(i1, 2);
                        uv.x = uvs[ii1];
                        uv.y = uvs[((ii1 + 1) | 0)];
                        Spine.Unity.MeshGenerator.AttachmentUVs.add(uv.$clone());

                        Spine.Unity.MeshGenerator.AttachmentColors32.add(c.$clone());
                    }

                    Spine.Unity.MeshGenerator.AttachmentIndices.clear();
                    Spine.Unity.MeshGenerator.AttachmentIndices.AddRange(meshAttachment.triangles);

                    mesh.Clear();
                    mesh.name = meshAttachment.name;
                    mesh.SetVertices(Spine.Unity.MeshGenerator.AttachmentVerts);
                    mesh.SetUVs(0, Spine.Unity.MeshGenerator.AttachmentUVs);
                    mesh.SetColors$1(Spine.Unity.MeshGenerator.AttachmentColors32);
                    mesh.SetTriangles(Spine.Unity.MeshGenerator.AttachmentIndices, 0);
                    mesh.RecalculateBounds();

                    Spine.Unity.MeshGenerator.AttachmentVerts.clear();
                    Spine.Unity.MeshGenerator.AttachmentUVs.clear();
                    Spine.Unity.MeshGenerator.AttachmentColors32.clear();
                    Spine.Unity.MeshGenerator.AttachmentIndices.clear();
                },
                /*Spine.Unity.MeshGenerator.FillMeshLocal:static end.*/


            }
        },
        fields: {
            settings: null,
            vertexBuffer: null,
            uvBuffer: null,
            colorBuffer: null,
            submeshes: null,
            meshBoundsMin: null,
            meshBoundsMax: null,
            meshBoundsThickness: 0,
            submeshIndex: 0,
            clipper: null,
            tempVerts: null,
            regionTriangles: null,
            normals: null,
            tangents: null,
            tempTanBuffer: null,
            uv2: null,
            uv3: null
        },
        props: {
            VertexCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#VertexCount#get", this ); }

                    return this.vertexBuffer.Count;
                }
            },
            /**
             * A set of mesh arrays whose values are modifiable by the user. Modify these values before they are passed to the UnityEngine mesh object in order to see the effect.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.MeshGenerator
             * @function Buffers
             * @type Spine.Unity.MeshGeneratorBuffers
             */
            Buffers: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#Buffers#get", this ); }

                    var $t;
                    return ($t = new Spine.Unity.MeshGeneratorBuffers(), $t.vertexCount = this.VertexCount, $t.vertexBuffer = this.vertexBuffer.Items, $t.uvBuffer = this.uvBuffer.Items, $t.colorBuffer = this.colorBuffer.Items, $t.meshGenerator = this, $t);
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#init", this ); }

                this.settings = new Spine.Unity.MeshGenerator.Settings();
                this.meshBoundsMin = new UnityEngine.Vector2();
                this.meshBoundsMax = new UnityEngine.Vector2();
                this.settings = Spine.Unity.MeshGenerator.Settings.Default.$clone();
                this.vertexBuffer = new (Spine.ExposedList$1(UnityEngine.Vector3)).$ctor3(4);
                this.uvBuffer = new (Spine.ExposedList$1(UnityEngine.Vector2)).$ctor3(4);
                this.colorBuffer = new (Spine.ExposedList$1(UnityEngine.Color32)).$ctor3(4);
                this.submeshes = function (_o1) {
                        _o1.Add(new (Spine.ExposedList$1(System.Int32)).$ctor3(6));
                        return _o1;
                    }(new (Spine.ExposedList$1(Spine.ExposedList$1(System.Int32))).ctor());
                this.submeshIndex = 0;
                this.clipper = new Spine.SkeletonClipping();
                this.tempVerts = System.Array.init(8, 0, System.Single);
                this.regionTriangles = System.Array.init([
                    0, 
                    1, 
                    2, 
                    2, 
                    3, 
                    0
                ], System.Int32);
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#ctor", this ); }

                this.$initialize();
                this.submeshes.TrimExcess();
            }
        },
        methods: {
            /*Spine.Unity.MeshGenerator.SubmeshIndexCount start.*/
            SubmeshIndexCount: function (submeshIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#SubmeshIndexCount", this ); }

                var $t;
                return ($t = this.submeshes.Items)[submeshIndex].Count;
            },
            /*Spine.Unity.MeshGenerator.SubmeshIndexCount end.*/

            /*Spine.Unity.MeshGenerator.Begin start.*/
            Begin: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#Begin", this ); }

                this.vertexBuffer.Clear(false);
                this.colorBuffer.Clear(false);
                this.uvBuffer.Clear(false);
                this.clipper.clipEnd();

                {
                    this.meshBoundsMin.x = Spine.Unity.MeshGenerator.BoundsMinDefault;
                    this.meshBoundsMin.y = Spine.Unity.MeshGenerator.BoundsMinDefault;
                    this.meshBoundsMax.x = Spine.Unity.MeshGenerator.BoundsMaxDefault;
                    this.meshBoundsMax.y = Spine.Unity.MeshGenerator.BoundsMaxDefault;
                    this.meshBoundsThickness = 0.0;
                }

                this.submeshIndex = 0;
                this.submeshes.Count = 1;
                //submeshes.Items[0].Clear(false);
            },
            /*Spine.Unity.MeshGenerator.Begin end.*/

            /*Spine.Unity.MeshGenerator.AddSubmesh start.*/
            AddSubmesh: function (instruction, updateTriangles) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#AddSubmesh", this ); }

                var $t, $t1, $t2;
                if (updateTriangles === void 0) { updateTriangles = true; }
                var settings = this.settings.$clone();

                var newSubmeshCount = (this.submeshIndex + 1) | 0;
                if (this.submeshes.Items.length < newSubmeshCount) {
                    this.submeshes.Resize(newSubmeshCount);
                }
                this.submeshes.Count = newSubmeshCount;
                var submesh = ($t = this.submeshes.Items)[this.submeshIndex];
                if (submesh == null) {
                    ($t1 = this.submeshes.Items)[this.submeshIndex] = (submesh = new (Spine.ExposedList$1(System.Int32)).ctor());
                }
                submesh.Clear(false);

                var skeleton = instruction.skeleton;
                var drawOrderItems = skeleton.DrawOrder.Items;

                var color = Bridge.getDefaultValue(UnityEngine.Color32);
                var skeletonA = skeleton.color.a, skeletonR = skeleton.color.r, skeletonG = skeleton.color.g, skeletonB = skeleton.color.b;
                var meshBoundsMin = this.meshBoundsMin.$clone(), meshBoundsMax = this.meshBoundsMax.$clone();

                // Settings
                var zSpacing = settings.zSpacing;
                var pmaVertexColors = settings.pmaVertexColors;
                var tintBlack = settings.tintBlack;
                var useClipping = settings.useClipping && instruction.hasClipping;
                var canvasGroupTintBlack = settings.tintBlack && settings.canvasGroupTintBlack;

                if (useClipping) {
                    if (instruction.preActiveClippingSlotSource >= 0) {
                        var slot = drawOrderItems[instruction.preActiveClippingSlotSource];
                        this.clipper.clipStart(slot, Bridge.as(slot.getAttachment(), spine.ClippingAttachment));
                    }
                }

                for (var slotIndex = instruction.startSlot; slotIndex < instruction.endSlot; slotIndex = (slotIndex + 1) | 0) {
                    var slot1 = drawOrderItems[slotIndex];
                    if (!slot1.bone.isActive()) {
                        this.clipper.clipEndWithSlot( slot1 );
                        continue;
                    }
                    var attachment = slot1.getAttachment();
                    var z = zSpacing * slotIndex;

                    var workingVerts = this.tempVerts;
                    var uvs;
                    var attachmentTriangleIndices;
                    var attachmentVertexCount;
                    var attachmentIndexCount;

                    var c = Bridge.getDefaultValue(UnityEngine.Color);

                    // Identify and prepare values.
                    var region = Bridge.as(attachment, Spine.RegionAttachment);
                    if (region != null) {
                        region.computeWorldVertices(slot1, workingVerts, 0);
                        uvs = region.uvs;
                        attachmentTriangleIndices = this.regionTriangles;
                        c.r = region.color.r;
                        c.g = region.color.g;
                        c.b = region.color.b;
                        c.a = region.color.a;
                        attachmentVertexCount = 4;
                        attachmentIndexCount = 6;
                    } else {
                        var mesh = Bridge.as(attachment, Spine.MeshAttachment);
                        if (mesh != null) {
                            var meshVerticesLength = mesh.worldVerticesLength;
                            if (workingVerts.length < meshVerticesLength) {
                                workingVerts = System.Array.init(meshVerticesLength, 0, System.Single);
                                this.tempVerts = workingVerts;
                            }
                            mesh.computeWorldVertices( slot1, 0, meshVerticesLength, workingVerts, 0, 2 || 2 ); //meshAttachment.ComputeWorldVertices(slot, tempVerts);
                            uvs = mesh.uvs;
                            attachmentTriangleIndices = mesh.triangles;
                            c.r = mesh.color.r;
                            c.g = mesh.color.g;
                            c.b = mesh.color.b;
                            c.a = mesh.color.a;
                            attachmentVertexCount = meshVerticesLength >> 1; // meshVertexCount / 2;
                            attachmentIndexCount = mesh.triangles.length;
                        } else {
                            if (useClipping) {
                                var clippingAttachment = Bridge.as(attachment, spine.ClippingAttachment);
                                if (clippingAttachment != null) {
                                    this.clipper.clipStart(slot1, clippingAttachment);
                                    continue;
                                }
                            }

                            // If not any renderable attachment.
                            this.clipper.clipEndWithSlot( slot1 );
                            continue;
                        }
                    }

                    var tintBlackAlpha = 1.0;
                    if (pmaVertexColors) {
                        var colorA = skeletonA * slot1.color.a * c.a;
                        color.a = Bridge.Int.clipu8(colorA * 255);
                        color.r = Bridge.Int.clipu8(skeletonR * slot1.color.r * c.r * color.a);
                        color.g = Bridge.Int.clipu8(skeletonG * slot1.color.g * c.g * color.a);
                        color.b = Bridge.Int.clipu8(skeletonB * slot1.color.b * c.b * color.a);
                        if (slot1.data.blendMode === spine.BlendMode.Additive) {
                            if (canvasGroupTintBlack) {
                                tintBlackAlpha = 0;
                            } else {
                                color.a = 0;
                            }
                        } else if (canvasGroupTintBlack) { // other blend modes
                            tintBlackAlpha = colorA;
                        }
                    } else {
                        color.a = Bridge.Int.clipu8(skeletonA * slot1.color.a * c.a * 255);
                        color.r = Bridge.Int.clipu8(skeletonR * slot1.color.r * c.r * 255);
                        color.g = Bridge.Int.clipu8(skeletonG * slot1.color.g * c.g * 255);
                        color.b = Bridge.Int.clipu8(skeletonB * slot1.color.b * c.b * 255);
                    }

                    if (useClipping && this.clipper.isClipping()) {
                        this.clipper.ClipTriangles(workingVerts, attachmentVertexCount << 1, attachmentTriangleIndices, attachmentIndexCount, uvs);
                        workingVerts = this.clipper.ClippedVertices.Items;
                        attachmentVertexCount = this.clipper.ClippedVertices.Count >> 1;
                        attachmentTriangleIndices = this.clipper.ClippedTriangles.Items;
                        attachmentIndexCount = this.clipper.ClippedTriangles.Count;
                        uvs = this.clipper.ClippedUVs.Items;
                    }

                    // Actually add slot/attachment data into buffers.
                    if (attachmentVertexCount !== 0 && attachmentIndexCount !== 0) {
                        if (tintBlack) {
                            var r2 = slot1.darkColor.r || 0;
                            var g2 = slot1.darkColor.g || 0;
                            var b2 = slot1.darkColor.b || 0;
                            if (pmaVertexColors) {
                                var alpha = skeletonA * slot1.color.a * c.a;
                                r2 *= alpha;
                                g2 *= alpha;
                                b2 *= alpha;
                            }
                            this.AddAttachmentTintBlack(r2, g2, b2, tintBlackAlpha, attachmentVertexCount);
                        }

                        //AddAttachment(workingVerts, uvs, color, attachmentTriangleIndices, attachmentVertexCount, attachmentIndexCount, ref meshBoundsMin, ref meshBoundsMax, z);
                        var ovc = this.vertexBuffer.Count;
                        // Add data to vertex buffers
                        {
                            var newVertexCount = (ovc + attachmentVertexCount) | 0;
                            var oldArraySize = this.vertexBuffer.Items.length;
                            if (newVertexCount > oldArraySize) {
                                var newArraySize = Bridge.Int.clip32(oldArraySize * 1.3);
                                if (newArraySize < newVertexCount) {
                                    newArraySize = newVertexCount;
                                }
                                System.Array.resize(Bridge.ref(this.vertexBuffer, "Items"), newArraySize, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector3);
                                }, UnityEngine.Vector3);
                                System.Array.resize(Bridge.ref(this.uvBuffer, "Items"), newArraySize, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                                }, UnityEngine.Vector2);
                                System.Array.resize(Bridge.ref(this.colorBuffer, "Items"), newArraySize, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Color32);
                                }, UnityEngine.Color32);
                            }
                            this.vertexBuffer.Count = ($t2 = (this.colorBuffer.Count = newVertexCount, newVertexCount), this.uvBuffer.Count = $t2, $t2);
                        }

                        var vbi = this.vertexBuffer.Items;
                        var ubi = this.uvBuffer.Items;
                        var cbi = this.colorBuffer.Items;
                        if (ovc === 0) {
                            for (var i = 0; i < attachmentVertexCount; i = (i + 1) | 0) {
                                var vi = (ovc + i) | 0;
                                var i2 = i << 1; // i * 2
                                var x = workingVerts[i2];
                                var y = workingVerts[((i2 + 1) | 0)];

                                vbi[vi].x = x;
                                vbi[vi].y = y;
                                vbi[vi].z = z;
                                ubi[vi].x = uvs[i2];
                                ubi[vi].y = uvs[((i2 + 1) | 0)];
                                cbi[vi] = color.$clone();

                                // Calculate bounds.
                                if (x < meshBoundsMin.x) {
                                    meshBoundsMin.x = x;
                                }
                                if (x > meshBoundsMax.x) {
                                    meshBoundsMax.x = x;
                                }
                                if (y < meshBoundsMin.y) {
                                    meshBoundsMin.y = y;
                                }
                                if (y > meshBoundsMax.y) {
                                    meshBoundsMax.y = y;
                                }
                            }
                        } else {
                            for (var i1 = 0; i1 < attachmentVertexCount; i1 = (i1 + 1) | 0) {
                                var vi1 = (ovc + i1) | 0;
                                var i21 = i1 << 1; // i * 2
                                var x1 = workingVerts[i21];
                                var y1 = workingVerts[((i21 + 1) | 0)];

                                vbi[vi1].x = x1;
                                vbi[vi1].y = y1;
                                vbi[vi1].z = z;
                                ubi[vi1].x = uvs[i21];
                                ubi[vi1].y = uvs[((i21 + 1) | 0)];
                                cbi[vi1] = color.$clone();

                                // Calculate bounds.
                                if (x1 < meshBoundsMin.x) {
                                    meshBoundsMin.x = x1;
                                } else {
                                    if (x1 > meshBoundsMax.x) {
                                        meshBoundsMax.x = x1;
                                    }
                                }
                                if (y1 < meshBoundsMin.y) {
                                    meshBoundsMin.y = y1;
                                } else {
                                    if (y1 > meshBoundsMax.y) {
                                        meshBoundsMax.y = y1;
                                    }
                                }
                            }
                        }


                        // Add data to triangle buffer
                        if (updateTriangles) {
                            var oldTriangleCount = submesh.Count;
                            { //submesh.Resize(oldTriangleCount + attachmentIndexCount);
                                var newTriangleCount = (oldTriangleCount + attachmentIndexCount) | 0;
                                if (newTriangleCount > submesh.Items.length) {
                                    System.Array.resize(Bridge.ref(submesh, "Items"), newTriangleCount, 0, System.Int32);
                                }
                                submesh.Count = newTriangleCount;
                            }
                            var submeshItems = submesh.Items;
                            for (var i2 = 0; i2 < attachmentIndexCount; i2 = (i2 + 1) | 0) {
                                submeshItems[((oldTriangleCount + i2) | 0)] = (attachmentTriangleIndices[i2] + ovc) | 0;
                            }
                        }
                    }

                    this.clipper.clipEndWithSlot( slot1 );
                }
                this.clipper.clipEnd();

                this.meshBoundsMin = meshBoundsMin.$clone();
                this.meshBoundsMax = meshBoundsMax.$clone();
                this.meshBoundsThickness = instruction.endSlot * zSpacing;

                // Trim or zero submesh triangles.
                var currentSubmeshItems = submesh.Items;
                for (var i3 = submesh.Count, n = currentSubmeshItems.length; i3 < n; i3 = (i3 + 1) | 0) {
                    currentSubmeshItems[i3] = 0;
                }

                this.submeshIndex = (this.submeshIndex + 1) | 0; // Next AddSubmesh will use a new submeshIndex value.
            },
            /*Spine.Unity.MeshGenerator.AddSubmesh end.*/

            /*Spine.Unity.MeshGenerator.BuildMesh start.*/
            BuildMesh: function (instruction, updateTriangles) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#BuildMesh", this ); }

                var wsii = instruction.submeshInstructions.Items;
                for (var i = 0, n = instruction.submeshInstructions.Count; i < n; i = (i + 1) | 0) {
                    this.AddSubmesh(wsii[i], updateTriangles);
                }
            },
            /*Spine.Unity.MeshGenerator.BuildMesh end.*/

            /*Spine.Unity.MeshGenerator.BuildMeshWithArrays start.*/
            BuildMeshWithArrays: function (instruction, updateTriangles) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#BuildMeshWithArrays", this ); }

                var $t, $t1, $t2, $t3, $t4;
                var settings = this.settings.$clone();
                var canvasGroupTintBlack = settings.tintBlack && settings.canvasGroupTintBlack;
                var totalVertexCount = instruction.rawVertexCount;

                // Add data to vertex buffers
                {
                    if (totalVertexCount > this.vertexBuffer.Items.length) { // Manual ExposedList.Resize()
                        System.Array.resize(Bridge.ref(this.vertexBuffer, "Items"), totalVertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Vector3);
                        }, UnityEngine.Vector3);
                        System.Array.resize(Bridge.ref(this.uvBuffer, "Items"), totalVertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Vector2);
                        }, UnityEngine.Vector2);
                        System.Array.resize(Bridge.ref(this.colorBuffer, "Items"), totalVertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Color32);
                        }, UnityEngine.Color32);
                    }
                    this.vertexBuffer.Count = ($t = (this.colorBuffer.Count = totalVertexCount, totalVertexCount), this.uvBuffer.Count = $t, $t);
                }

                // Populate Verts
                var color = Bridge.getDefaultValue(UnityEngine.Color32);

                var vertexIndex = 0;
                var tempVerts = this.tempVerts;
                var bmin = this.meshBoundsMin.$clone();
                var bmax = this.meshBoundsMax.$clone();

                var vbi = this.vertexBuffer.Items;
                var ubi = this.uvBuffer.Items;
                var cbi = this.colorBuffer.Items;
                var lastSlotIndex = 0;

                // drawOrder[endSlot] is excluded
                for (var si = 0, n = instruction.submeshInstructions.Count; si < n; si = (si + 1) | 0) {
                    var submesh = ($t1 = instruction.submeshInstructions.Items)[si].$clone();
                    var skeleton = submesh.skeleton;
                    var drawOrderItems = skeleton.DrawOrder.Items;
                    var a = skeleton.color.a, r = skeleton.color.r, g = skeleton.color.g, b = skeleton.color.b;

                    var endSlot = submesh.endSlot;
                    var startSlot = submesh.startSlot;
                    lastSlotIndex = endSlot;

                    if (settings.tintBlack) {
                        var rg = new UnityEngine.Vector2(), b2 = new UnityEngine.Vector2();
                        var vi = vertexIndex;
                        b2.y = 1.0;

                        {
                            if (this.uv2 == null) {
                                this.uv2 = new (Spine.ExposedList$1(UnityEngine.Vector2)).ctor();
                                this.uv3 = new (Spine.ExposedList$1(UnityEngine.Vector2)).ctor();
                            }
                            if (totalVertexCount > this.uv2.Items.length) { // Manual ExposedList.Resize()
                                System.Array.resize(Bridge.ref(this.uv2, "Items"), totalVertexCount, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                                }, UnityEngine.Vector2);
                                System.Array.resize(Bridge.ref(this.uv3, "Items"), totalVertexCount, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                                }, UnityEngine.Vector2);
                            }
                            this.uv2.Count = (this.uv3.Count = totalVertexCount, totalVertexCount);
                        }

                        var uv2i = this.uv2.Items;
                        var uv3i = this.uv3.Items;

                        for (var slotIndex = startSlot; slotIndex < endSlot; slotIndex = (slotIndex + 1) | 0) {
                            var slot = drawOrderItems[slotIndex];
                            if (!slot.bone.isActive()) {
                                continue;
                            }
                            var attachment = slot.getAttachment();

                            rg.x = slot.darkColor.r || 0; //r
                            rg.y = slot.darkColor.g || 0; //g
                            b2.x = slot.darkColor.b || 0; //b
                            b2.y = 1.0;

                            var regionAttachment = Bridge.as(attachment, Spine.RegionAttachment);
                            if (regionAttachment != null) {
                                if (settings.pmaVertexColors) {
                                    var alpha = a * slot.color.a * regionAttachment.color.a;
                                    rg.x *= alpha;
                                    rg.y *= alpha;
                                    b2.x *= alpha;
                                    b2.y = slot.data.blendMode === spine.BlendMode.Additive ? 0 : alpha;
                                }
                                uv2i[vi] = rg.$clone();
                                uv2i[((vi + 1) | 0)] = rg.$clone();
                                uv2i[((vi + 2) | 0)] = rg.$clone();
                                uv2i[((vi + 3) | 0)] = rg.$clone();
                                uv3i[vi] = b2.$clone();
                                uv3i[((vi + 1) | 0)] = b2.$clone();
                                uv3i[((vi + 2) | 0)] = b2.$clone();
                                uv3i[((vi + 3) | 0)] = b2.$clone();
                                vi = (vi + 4) | 0;
                            } else { //} if (settings.renderMeshes) {
                                var meshAttachment = Bridge.as(attachment, Spine.MeshAttachment);
                                if (meshAttachment != null) {
                                    if (settings.pmaVertexColors) {
                                        var alpha1 = a * slot.color.a * meshAttachment.color.a;
                                        rg.x *= alpha1;
                                        rg.y *= alpha1;
                                        b2.x *= alpha1;
                                        b2.y = slot.data.blendMode === spine.BlendMode.Additive ? 0 : alpha1;
                                    }
                                    var verticesArrayLength = meshAttachment.worldVerticesLength;
                                    for (var iii = 0; iii < verticesArrayLength; iii = (iii + 2) | 0) {
                                        uv2i[vi] = rg.$clone();
                                        uv3i[vi] = b2.$clone();
                                        vi = (vi + 1) | 0;
                                    }
                                }
                            }
                        }
                    }

                    for (var slotIndex1 = startSlot; slotIndex1 < endSlot; slotIndex1 = (slotIndex1 + 1) | 0) {
                        var slot1 = drawOrderItems[slotIndex1];
                        if (!slot1.bone.isActive()) {
                            continue;
                        }
                        var attachment1 = slot1.getAttachment();
                        var z = slotIndex1 * settings.zSpacing;

                        var regionAttachment1 = Bridge.as(attachment1, Spine.RegionAttachment);
                        if (regionAttachment1 != null) {
                            regionAttachment1.computeWorldVertices(slot1, tempVerts, 0);

                            var x1 = tempVerts[0], y1 = tempVerts[1];
                            var x2 = tempVerts[2], y2 = tempVerts[3];
                            var x3 = tempVerts[4], y3 = tempVerts[5];
                            var x4 = tempVerts[6], y4 = tempVerts[7];
                            vbi[vertexIndex].x = x1;
                            vbi[vertexIndex].y = y1;
                            vbi[vertexIndex].z = z;
                            vbi[((vertexIndex + 1) | 0)].x = x4;
                            vbi[((vertexIndex + 1) | 0)].y = y4;
                            vbi[((vertexIndex + 1) | 0)].z = z;
                            vbi[((vertexIndex + 2) | 0)].x = x2;
                            vbi[((vertexIndex + 2) | 0)].y = y2;
                            vbi[((vertexIndex + 2) | 0)].z = z;
                            vbi[((vertexIndex + 3) | 0)].x = x3;
                            vbi[((vertexIndex + 3) | 0)].y = y3;
                            vbi[((vertexIndex + 3) | 0)].z = z;

                            if (settings.pmaVertexColors) {
                                color.a = Bridge.Int.clipu8(a * slot1.color.a * regionAttachment1.color.a * 255);
                                color.r = Bridge.Int.clipu8(r * slot1.color.r * regionAttachment1.color.r * color.a);
                                color.g = Bridge.Int.clipu8(g * slot1.color.g * regionAttachment1.color.g * color.a);
                                color.b = Bridge.Int.clipu8(b * slot1.color.b * regionAttachment1.color.b * color.a);
                                if (slot1.data.blendMode === spine.BlendMode.Additive && !canvasGroupTintBlack) {
                                    color.a = 0;
                                }
                            } else {
                                color.a = Bridge.Int.clipu8(a * slot1.color.a * regionAttachment1.color.a * 255);
                                color.r = Bridge.Int.clipu8(r * slot1.color.r * regionAttachment1.color.r * 255);
                                color.g = Bridge.Int.clipu8(g * slot1.color.g * regionAttachment1.color.g * 255);
                                color.b = Bridge.Int.clipu8(b * slot1.color.b * regionAttachment1.color.b * 255);
                            }

                            cbi[vertexIndex] = color.$clone();
                            cbi[((vertexIndex + 1) | 0)] = color.$clone();
                            cbi[((vertexIndex + 2) | 0)] = color.$clone();
                            cbi[((vertexIndex + 3) | 0)] = color.$clone();

                            var regionUVs = regionAttachment1.uvs;
                            ubi[vertexIndex].x = regionUVs[0];
                            ubi[vertexIndex].y = regionUVs[1];
                            ubi[((vertexIndex + 1) | 0)].x = regionUVs[6];
                            ubi[((vertexIndex + 1) | 0)].y = regionUVs[7];
                            ubi[((vertexIndex + 2) | 0)].x = regionUVs[2];
                            ubi[((vertexIndex + 2) | 0)].y = regionUVs[3];
                            ubi[((vertexIndex + 3) | 0)].x = regionUVs[4];
                            ubi[((vertexIndex + 3) | 0)].y = regionUVs[5];

                            if (x1 < bmin.x) {
                                bmin.x = x1;
                            } // Potential first attachment bounds initialization. Initial min should not block initial max. Same for Y below.
                            if (x1 > bmax.x) {
                                bmax.x = x1;
                            }
                            if (x2 < bmin.x) {
                                bmin.x = x2;
                            } else {
                                if (x2 > bmax.x) {
                                    bmax.x = x2;
                                }
                            }
                            if (x3 < bmin.x) {
                                bmin.x = x3;
                            } else {
                                if (x3 > bmax.x) {
                                    bmax.x = x3;
                                }
                            }
                            if (x4 < bmin.x) {
                                bmin.x = x4;
                            } else {
                                if (x4 > bmax.x) {
                                    bmax.x = x4;
                                }
                            }

                            if (y1 < bmin.y) {
                                bmin.y = y1;
                            }
                            if (y1 > bmax.y) {
                                bmax.y = y1;
                            }
                            if (y2 < bmin.y) {
                                bmin.y = y2;
                            } else {
                                if (y2 > bmax.y) {
                                    bmax.y = y2;
                                }
                            }
                            if (y3 < bmin.y) {
                                bmin.y = y3;
                            } else {
                                if (y3 > bmax.y) {
                                    bmax.y = y3;
                                }
                            }
                            if (y4 < bmin.y) {
                                bmin.y = y4;
                            } else {
                                if (y4 > bmax.y) {
                                    bmax.y = y4;
                                }
                            }

                            vertexIndex = (vertexIndex + 4) | 0;
                        } else { //if (settings.renderMeshes) {
                            var meshAttachment1 = Bridge.as(attachment1, Spine.MeshAttachment);
                            if (meshAttachment1 != null) {
                                var verticesArrayLength1 = meshAttachment1.worldVerticesLength;
                                if (tempVerts.length < verticesArrayLength1) {
                                    this.tempVerts = (tempVerts = System.Array.init(verticesArrayLength1, 0, System.Single));
                                }
                                meshAttachment1.computeWorldVertices( slot1, 0, meshAttachment1.worldVerticesLength, tempVerts, 0, 2 );

                                if (settings.pmaVertexColors) {
                                    color.a = Bridge.Int.clipu8(a * slot1.color.a * meshAttachment1.color.a * 255);
                                    color.r = Bridge.Int.clipu8(r * slot1.color.r * meshAttachment1.color.r * color.a);
                                    color.g = Bridge.Int.clipu8(g * slot1.color.g * meshAttachment1.color.g * color.a);
                                    color.b = Bridge.Int.clipu8(b * slot1.color.b * meshAttachment1.color.b * color.a);
                                    if (slot1.data.blendMode === spine.BlendMode.Additive && !canvasGroupTintBlack) {
                                        color.a = 0;
                                    }
                                } else {
                                    color.a = Bridge.Int.clipu8(a * slot1.color.a * meshAttachment1.color.a * 255);
                                    color.r = Bridge.Int.clipu8(r * slot1.color.r * meshAttachment1.color.r * 255);
                                    color.g = Bridge.Int.clipu8(g * slot1.color.g * meshAttachment1.color.g * 255);
                                    color.b = Bridge.Int.clipu8(b * slot1.color.b * meshAttachment1.color.b * 255);
                                }

                                var attachmentUVs = meshAttachment1.uvs;

                                // Potential first attachment bounds initialization. See conditions in RegionAttachment logic.
                                if (vertexIndex === 0) {
                                    // Initial min should not block initial max.
                                    // vi == vertexIndex does not always mean the bounds are fresh. It could be a submesh. Do not nuke old values by omitting the check.
                                    // Should know that this is the first attachment in the submesh. slotIndex == startSlot could be an empty slot.
                                    var fx = tempVerts[0], fy = tempVerts[1];
                                    if (fx < bmin.x) {
                                        bmin.x = fx;
                                    }
                                    if (fx > bmax.x) {
                                        bmax.x = fx;
                                    }
                                    if (fy < bmin.y) {
                                        bmin.y = fy;
                                    }
                                    if (fy > bmax.y) {
                                        bmax.y = fy;
                                    }
                                }

                                for (var iii1 = 0; iii1 < verticesArrayLength1; iii1 = (iii1 + 2) | 0) {
                                    var x = tempVerts[iii1], y = tempVerts[((iii1 + 1) | 0)];
                                    vbi[vertexIndex].x = x;
                                    vbi[vertexIndex].y = y;
                                    vbi[vertexIndex].z = z;
                                    cbi[vertexIndex] = color.$clone();
                                    ubi[vertexIndex].x = attachmentUVs[iii1];
                                    ubi[vertexIndex].y = attachmentUVs[((iii1 + 1) | 0)];

                                    if (x < bmin.x) {
                                        bmin.x = x;
                                    } else {
                                        if (x > bmax.x) {
                                            bmax.x = x;
                                        }
                                    }

                                    if (y < bmin.y) {
                                        bmin.y = y;
                                    } else {
                                        if (y > bmax.y) {
                                            bmax.y = y;
                                        }
                                    }

                                    vertexIndex = (vertexIndex + 1) | 0;
                                }
                            }
                        }
                    }
                }

                this.meshBoundsMin = bmin.$clone();
                this.meshBoundsMax = bmax.$clone();
                this.meshBoundsThickness = lastSlotIndex * settings.zSpacing;

                var submeshInstructionCount = instruction.submeshInstructions.Count;
                this.submeshes.Count = submeshInstructionCount;

                // Add triangles
                if (updateTriangles) {
                    // Match submesh buffers count with submeshInstruction count.
                    if (this.submeshes.Items.length < submeshInstructionCount) {
                        this.submeshes.Resize(submeshInstructionCount);
                        for (var i = 0, n1 = submeshInstructionCount; i < n1; i = (i + 1) | 0) {
                            var submeshBuffer = ($t2 = this.submeshes.Items)[i];
                            if (submeshBuffer == null) {
                                ($t3 = this.submeshes.Items)[i] = new (Spine.ExposedList$1(System.Int32)).ctor();
                            } else {
                                submeshBuffer.Clear(false);
                            }
                        }
                    }

                    var submeshInstructionsItems = instruction.submeshInstructions.Items; // This relies on the resize above.

                    // Fill the buffers.
                    var attachmentFirstVertex = 0;
                    for (var smbi = 0; smbi < submeshInstructionCount; smbi = (smbi + 1) | 0) {
                        var submeshInstruction = submeshInstructionsItems[smbi].$clone();
                        var currentSubmeshBuffer = ($t4 = this.submeshes.Items)[smbi];
                        { //submesh.Resize(submesh.rawTriangleCount);
                            var newTriangleCount = submeshInstruction.rawTriangleCount;
                            if (newTriangleCount > currentSubmeshBuffer.Items.length) {
                                System.Array.resize(Bridge.ref(currentSubmeshBuffer, "Items"), newTriangleCount, 0, System.Int32);
                            } else {
                                if (newTriangleCount < currentSubmeshBuffer.Items.length) {
                                    // Zero the extra.
                                    var sbi = currentSubmeshBuffer.Items;
                                    for (var ei = newTriangleCount, nn = sbi.length; ei < nn; ei = (ei + 1) | 0) {
                                        sbi[ei] = 0;
                                    }
                                }
                            }
                            currentSubmeshBuffer.Count = newTriangleCount;
                        }

                        var tris = currentSubmeshBuffer.Items;
                        var triangleIndex = 0;
                        var skeleton1 = submeshInstruction.skeleton;
                        var drawOrderItems1 = skeleton1.DrawOrder.Items;
                        for (var slotIndex2 = submeshInstruction.startSlot, endSlot1 = submeshInstruction.endSlot; slotIndex2 < endSlot1; slotIndex2 = (slotIndex2 + 1) | 0) {
                            var slot2 = drawOrderItems1[slotIndex2];
                            if (!slot2.bone.isActive()) {
                                continue;
                            }

                            var attachment2 = drawOrderItems1[slotIndex2].getAttachment();
                            if (Bridge.is(attachment2, Spine.RegionAttachment)) {
                                tris[triangleIndex] = attachmentFirstVertex;
                                tris[((triangleIndex + 1) | 0)] = (attachmentFirstVertex + 2) | 0;
                                tris[((triangleIndex + 2) | 0)] = (attachmentFirstVertex + 1) | 0;
                                tris[((triangleIndex + 3) | 0)] = (attachmentFirstVertex + 2) | 0;
                                tris[((triangleIndex + 4) | 0)] = (attachmentFirstVertex + 3) | 0;
                                tris[((triangleIndex + 5) | 0)] = (attachmentFirstVertex + 1) | 0;
                                triangleIndex = (triangleIndex + 6) | 0;
                                attachmentFirstVertex = (attachmentFirstVertex + 4) | 0;
                                continue;
                            }
                            var meshAttachment2 = Bridge.as(attachment2, Spine.MeshAttachment);
                            if (meshAttachment2 != null) {
                                var attachmentTriangles = meshAttachment2.triangles;
                                for (var ii = 0, nn1 = attachmentTriangles.length; ii < nn1; ii = (ii + 1) | 0, triangleIndex = (triangleIndex + 1) | 0) {
                                    tris[triangleIndex] = (attachmentFirstVertex + attachmentTriangles[ii]) | 0;
                                }
                                attachmentFirstVertex = (attachmentFirstVertex + (meshAttachment2.worldVerticesLength >> 1)) | 0; // length/2;
                            }
                        }
                    }
                }
            },
            /*Spine.Unity.MeshGenerator.BuildMeshWithArrays end.*/

            /*Spine.Unity.MeshGenerator.ScaleVertexData start.*/
            ScaleVertexData: function (scale) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#ScaleVertexData", this ); }

                var vbi = this.vertexBuffer.Items;
                for (var i = 0, n = this.vertexBuffer.Count; i < n; i = (i + 1) | 0) {
                    vbi[i] = vbi[i].$clone().clone().scale( scale ); // vbi[i].x *= scale; vbi[i].y *= scale;
                }

                this.meshBoundsMin = this.meshBoundsMin.$clone().scale( scale );
                this.meshBoundsMax = this.meshBoundsMax.$clone().scale( scale );
                this.meshBoundsThickness *= scale;
            },
            /*Spine.Unity.MeshGenerator.ScaleVertexData end.*/

            /*Spine.Unity.MeshGenerator.GetMeshBounds start.*/
            GetMeshBounds: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#GetMeshBounds", this ); }

                var $t;
                if ((Math.abs(this.meshBoundsMin.x) === Number.POSITIVE_INFINITY)) { // meshBoundsMin.x == BoundsMinDefault // == doesn't work on float Infinity constants.
                    return new pc.BoundingBox.ctor();
                } else {
                    //mesh.bounds = ArraysMeshGenerator.ToBounds(meshBoundsMin, meshBoundsMax);
                    var halfWidth = (this.meshBoundsMax.x - this.meshBoundsMin.x) * 0.5;
                    var halfHeight = (this.meshBoundsMax.y - this.meshBoundsMin.y) * 0.5;
                    return ($t = new pc.BoundingBox.ctor(), $t.center = new pc.Vec3( this.meshBoundsMin.x + halfWidth, this.meshBoundsMin.y + halfHeight, 0 ), $t.halfExtents = new pc.Vec3( halfWidth, halfHeight, this.meshBoundsThickness * 0.5 ), $t);
                }
            },
            /*Spine.Unity.MeshGenerator.GetMeshBounds end.*/

            /*Spine.Unity.MeshGenerator.AddAttachmentTintBlack start.*/
            AddAttachmentTintBlack: function (r2, g2, b2, a, vertexCount) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#AddAttachmentTintBlack", this ); }

                var rg = new pc.Vec2( r2, g2 );
                var bo = new pc.Vec2( b2, a );

                var ovc = this.vertexBuffer.Count;
                var newVertexCount = (ovc + vertexCount) | 0;
                {
                    if (this.uv2 == null) {
                        this.uv2 = new (Spine.ExposedList$1(UnityEngine.Vector2)).ctor();
                        this.uv3 = new (Spine.ExposedList$1(UnityEngine.Vector2)).ctor();
                    }
                    if (newVertexCount > this.uv2.Items.length) { // Manual ExposedList.Resize()
                        System.Array.resize(Bridge.ref(this.uv2, "Items"), newVertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Vector2);
                        }, UnityEngine.Vector2);
                        System.Array.resize(Bridge.ref(this.uv3, "Items"), newVertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Vector2);
                        }, UnityEngine.Vector2);
                    }
                    this.uv2.Count = (this.uv3.Count = newVertexCount, newVertexCount);
                }

                var uv2i = this.uv2.Items;
                var uv3i = this.uv3.Items;
                for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                    uv2i[((ovc + i) | 0)] = rg.$clone();
                    uv3i[((ovc + i) | 0)] = bo.$clone();
                }
            },
            /*Spine.Unity.MeshGenerator.AddAttachmentTintBlack end.*/

            /*Spine.Unity.MeshGenerator.FillVertexData start.*/
            FillVertexData: function (mesh) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#FillVertexData", this ); }

                var vbi = this.vertexBuffer.Items;
                var ubi = this.uvBuffer.Items;
                var cbi = this.colorBuffer.Items;
                var vbiLength = vbi.length;

                // Zero the extra.
                {
                    var listCount = this.vertexBuffer.Count;
                    var vector3zero = pc.Vec3.ZERO.clone();
                    for (var i = listCount; i < vbiLength; i = (i + 1) | 0) {
                        vbi[i] = vector3zero.$clone();
                    }
                }

                // Set the vertex buffer.
                {
                    mesh.vertices = vbi;
                    mesh.uv = ubi;
                    mesh.colors32 = cbi;
                    mesh.bounds = this.GetMeshBounds();
                }

                {
                    if (this.settings.addNormals) {
                        var oldLength = 0;

                        if (this.normals == null) {
                            this.normals = System.Array.init(vbiLength, function (){
                                return new UnityEngine.Vector3();
                            }, UnityEngine.Vector3);
                        } else {
                            oldLength = this.normals.length;
                        }

                        if (oldLength !== vbiLength) {
                            System.Array.resize(Bridge.ref(this, "normals"), vbiLength, function () {
                                return Bridge.getDefaultValue(UnityEngine.Vector3);
                            }, UnityEngine.Vector3);
                            var localNormals = this.normals;
                            for (var i1 = oldLength; i1 < vbiLength; i1 = (i1 + 1) | 0) {
                                localNormals[i1] = new pc.Vec3( 0, 0, -1 );
                            }
                        }
                        mesh.normals = this.normals;
                    }

                    if (this.settings.tintBlack) {
                        if (this.uv2 != null) {
                            // Sometimes, the vertex buffer becomes smaller. We need to trim the size of the tint black buffers to match.
                            if (vbiLength !== this.uv2.Items.length) {
                                System.Array.resize(Bridge.ref(this.uv2, "Items"), vbiLength, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                                }, UnityEngine.Vector2);
                                System.Array.resize(Bridge.ref(this.uv3, "Items"), vbiLength, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                                }, UnityEngine.Vector2);
                                this.uv2.Count = (this.uv3.Count = vbiLength, vbiLength);
                            }
                            mesh.uv2 = this.uv2.Items;
                            mesh.uv3 = this.uv3.Items;
                        }
                    }
                }
            },
            /*Spine.Unity.MeshGenerator.FillVertexData end.*/

            /*Spine.Unity.MeshGenerator.FillLateVertexData start.*/
            FillLateVertexData: function (mesh) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#FillLateVertexData", this ); }

                if (this.settings.calculateTangents) {
                    var vertexCount = this.vertexBuffer.Count;
                    var sbi = this.submeshes.Items;
                    var submeshCount = this.submeshes.Count;
                    var vbi = this.vertexBuffer.Items;
                    var ubi = this.uvBuffer.Items;

                    Spine.Unity.MeshGenerator.SolveTangents2DEnsureSize(Bridge.ref(this, "tangents"), Bridge.ref(this, "tempTanBuffer"), vertexCount, vbi.length);
                    for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                        var submesh = sbi[i].Items;
                        var triangleCount = sbi[i].Count;
                        Spine.Unity.MeshGenerator.SolveTangents2DTriangles(this.tempTanBuffer, submesh, triangleCount, vbi, ubi, vertexCount);
                    }
                    Spine.Unity.MeshGenerator.SolveTangents2DBuffer(this.tangents, this.tempTanBuffer, vertexCount);
                    mesh.tangents = this.tangents;
                }
            },
            /*Spine.Unity.MeshGenerator.FillLateVertexData end.*/

            /*Spine.Unity.MeshGenerator.FillTriangles start.*/
            FillTriangles: function (mesh) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#FillTriangles", this ); }

                var submeshCount = this.submeshes.Count;
                var submeshesItems = this.submeshes.Items;
                mesh.subMeshCount = submeshCount;

                for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                    mesh.SetTriangles$4(submeshesItems[i].Items, 0, submeshesItems[i].Count, i, false);
                }
            },
            /*Spine.Unity.MeshGenerator.FillTriangles end.*/

            /*Spine.Unity.MeshGenerator.EnsureVertexCapacity start.*/
            EnsureVertexCapacity: function (minimumVertexCount, inlcudeTintBlack, includeTangents, includeNormals) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#EnsureVertexCapacity", this ); }

                if (inlcudeTintBlack === void 0) { inlcudeTintBlack = false; }
                if (includeTangents === void 0) { includeTangents = false; }
                if (includeNormals === void 0) { includeNormals = false; }
                if (minimumVertexCount > this.vertexBuffer.Items.length) {
                    System.Array.resize(Bridge.ref(this.vertexBuffer, "Items"), minimumVertexCount, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector3);
                    }, UnityEngine.Vector3);
                    System.Array.resize(Bridge.ref(this.uvBuffer, "Items"), minimumVertexCount, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector2);
                    }, UnityEngine.Vector2);
                    System.Array.resize(Bridge.ref(this.colorBuffer, "Items"), minimumVertexCount, function () {
                        return Bridge.getDefaultValue(UnityEngine.Color32);
                    }, UnityEngine.Color32);

                    if (inlcudeTintBlack) {
                        if (this.uv2 == null) {
                            this.uv2 = new (Spine.ExposedList$1(UnityEngine.Vector2)).$ctor3(minimumVertexCount);
                            this.uv3 = new (Spine.ExposedList$1(UnityEngine.Vector2)).$ctor3(minimumVertexCount);
                        }
                        this.uv2.Resize(minimumVertexCount);
                        this.uv3.Resize(minimumVertexCount);
                    }

                    if (includeNormals) {
                        if (this.normals == null) {
                            this.normals = System.Array.init(minimumVertexCount, function (){
                                return new UnityEngine.Vector3();
                            }, UnityEngine.Vector3);
                        } else {
                            System.Array.resize(Bridge.ref(this, "normals"), minimumVertexCount, function () {
                                return Bridge.getDefaultValue(UnityEngine.Vector3);
                            }, UnityEngine.Vector3);
                        }

                    }

                    if (includeTangents) {
                        if (this.tangents == null) {
                            this.tangents = System.Array.init(minimumVertexCount, function (){
                                return new UnityEngine.Vector4();
                            }, UnityEngine.Vector4);
                        } else {
                            System.Array.resize(Bridge.ref(this, "tangents"), minimumVertexCount, function () {
                                return Bridge.getDefaultValue(UnityEngine.Vector4);
                            }, UnityEngine.Vector4);
                        }
                    }
                }
            },
            /*Spine.Unity.MeshGenerator.EnsureVertexCapacity end.*/

            /*Spine.Unity.MeshGenerator.TrimExcess start.*/
            /**
             * Trims internal buffers to reduce the resulting mesh data stream size.
             *
             * @instance
             * @public
             * @this Spine.Unity.MeshGenerator
             * @memberof Spine.Unity.MeshGenerator
             * @return  {void}
             */
            TrimExcess: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#TrimExcess", this ); }

                this.vertexBuffer.TrimExcess();
                this.uvBuffer.TrimExcess();
                this.colorBuffer.TrimExcess();

                if (this.uv2 != null) {
                    this.uv2.TrimExcess();
                }
                if (this.uv3 != null) {
                    this.uv3.TrimExcess();
                }

                var vbiLength = this.vertexBuffer.Items.length;
                if (this.normals != null) {
                    System.Array.resize(Bridge.ref(this, "normals"), vbiLength, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector3);
                    }, UnityEngine.Vector3);
                }
                if (this.tangents != null) {
                    System.Array.resize(Bridge.ref(this, "tangents"), vbiLength, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector4);
                    }, UnityEngine.Vector4);
                }
            },
            /*Spine.Unity.MeshGenerator.TrimExcess end.*/


        }
    });
    /*Spine.Unity.MeshGenerator end.*/

    /*Spine.Unity.MeshGenerator+Settings start.*/
    Bridge.define("Spine.Unity.MeshGenerator.Settings", {
        $kind: 1004,
        statics: {
            props: {
                Default: {
                    get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#Default#get", this ); }

                        var $t;
                        return ($t = new Spine.Unity.MeshGenerator.Settings(), $t.pmaVertexColors = true, $t.zSpacing = 0.0, $t.useClipping = true, $t.tintBlack = false, $t.calculateTangents = false, $t.addNormals = false, $t.immutableTriangles = false, $t);
                    }
                }
            },
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#getDefaultValue", this ); }
 return new Spine.Unity.MeshGenerator.Settings(); }
            }
        },
        fields: {
            useClipping: false,
            zSpacing: 0,
            pmaVertexColors: false,
            tintBlack: false,
            canvasGroupTintBlack: false,
            calculateTangents: false,
            addNormals: false,
            immutableTriangles: false
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#getHashCode", this ); }

                var h = Bridge.addHash([3889943484, this.useClipping, this.zSpacing, this.pmaVertexColors, this.tintBlack, this.canvasGroupTintBlack, this.calculateTangents, this.addNormals, this.immutableTriangles]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.MeshGenerator.Settings)) {
                    return false;
                }
                return Bridge.equals(this.useClipping, o.useClipping) && Bridge.equals(this.zSpacing, o.zSpacing) && Bridge.equals(this.pmaVertexColors, o.pmaVertexColors) && Bridge.equals(this.tintBlack, o.tintBlack) && Bridge.equals(this.canvasGroupTintBlack, o.canvasGroupTintBlack) && Bridge.equals(this.calculateTangents, o.calculateTangents) && Bridge.equals(this.addNormals, o.addNormals) && Bridge.equals(this.immutableTriangles, o.immutableTriangles);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#$clone", this ); }

                var s = to || new Spine.Unity.MeshGenerator.Settings();
                s.useClipping = this.useClipping;
                s.zSpacing = this.zSpacing;
                s.pmaVertexColors = this.pmaVertexColors;
                s.tintBlack = this.tintBlack;
                s.canvasGroupTintBlack = this.canvasGroupTintBlack;
                s.calculateTangents = this.calculateTangents;
                s.addNormals = this.addNormals;
                s.immutableTriangles = this.immutableTriangles;
                return s;
            }
        }
    });
    /*Spine.Unity.MeshGenerator+Settings end.*/

    /*Spine.Unity.MeshGeneratorBuffers start.*/
    Bridge.define("Spine.Unity.MeshGeneratorBuffers", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#getDefaultValue", this ); }
 return new Spine.Unity.MeshGeneratorBuffers(); }
            }
        },
        fields: {
            /**
             * The vertex count that will actually be used for the mesh. The Lengths of the buffer arrays may be larger than this number.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @type number
             */
            vertexCount: 0,
            /**
             * Vertex positions. To be used for UnityEngine.Mesh.vertices.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @type Array.<UnityEngine.Vector3>
             */
            vertexBuffer: null,
            /**
             * Vertex UVs. To be used for UnityEngine.Mesh.uvs.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @type Array.<UnityEngine.Vector2>
             */
            uvBuffer: null,
            /**
             * Vertex colors. To be used for UnityEngine.Mesh.colors32.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @type Array.<UnityEngine.Color32>
             */
            colorBuffer: null,
            /**
             * The Spine rendering component's MeshGenerator.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @type Spine.Unity.MeshGenerator
             */
            meshGenerator: null
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#getHashCode", this ); }

                var h = Bridge.addHash([8979862494, this.vertexCount, this.vertexBuffer, this.uvBuffer, this.colorBuffer, this.meshGenerator]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.MeshGeneratorBuffers)) {
                    return false;
                }
                return Bridge.equals(this.vertexCount, o.vertexCount) && Bridge.equals(this.vertexBuffer, o.vertexBuffer) && Bridge.equals(this.uvBuffer, o.uvBuffer) && Bridge.equals(this.colorBuffer, o.colorBuffer) && Bridge.equals(this.meshGenerator, o.meshGenerator);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#$clone", this ); }

                var s = to || new Spine.Unity.MeshGeneratorBuffers();
                s.vertexCount = this.vertexCount;
                s.vertexBuffer = this.vertexBuffer;
                s.uvBuffer = this.uvBuffer;
                s.colorBuffer = this.colorBuffer;
                s.meshGenerator = this.meshGenerator;
                return s;
            }
        }
    });
    /*Spine.Unity.MeshGeneratorBuffers end.*/

    /*Spine.Unity.MeshRendererBuffers start.*/
    /**
     * A double-buffered Mesh, and a shared material array, bundled for use by Spine components that need to push a Mesh and materials to a Unity MeshRenderer and MeshFilter.
     *
     * @public
     * @class Spine.Unity.MeshRendererBuffers
     * @implements  System.IDisposable
     */
    Bridge.define("Spine.Unity.MeshRendererBuffers", {
        inherits: [System.IDisposable],
        fields: {
            doubleBufferedMesh: null,
            submeshMaterials: null,
            sharedMaterials: null
        },
        alias: ["Dispose", "System$IDisposable$Dispose"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#init", this ); }

                this.submeshMaterials = new (Spine.ExposedList$1(UnityEngine.Material)).ctor();
                this.sharedMaterials = System.Array.init(0, null, UnityEngine.Material);
            }
        },
        methods: {
            /*Spine.Unity.MeshRendererBuffers.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#Initialize", this ); }

                if (this.doubleBufferedMesh != null) {
                    this.doubleBufferedMesh.GetNext().Clear();
                    this.doubleBufferedMesh.GetNext().Clear();
                    this.submeshMaterials.Clear();
                } else {
                    this.doubleBufferedMesh = new (Spine.Unity.DoubleBuffered$1(Spine.Unity.MeshRendererBuffers.SmartMesh))();
                }
            },
            /*Spine.Unity.MeshRendererBuffers.Initialize end.*/

            /*Spine.Unity.MeshRendererBuffers.GetUpdatedSharedMaterialsArray start.*/
            /**
             * Returns a sharedMaterials array for use on a MeshRenderer.
             *
             * @instance
             * @public
             * @this Spine.Unity.MeshRendererBuffers
             * @memberof Spine.Unity.MeshRendererBuffers
             * @return  {Array.<UnityEngine.Material>}
             */
            GetUpdatedSharedMaterialsArray: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#GetUpdatedSharedMaterialsArray", this ); }

                if (this.submeshMaterials.Count === this.sharedMaterials.length) {
                    this.submeshMaterials.CopyTo(this.sharedMaterials);
                } else {
                    this.sharedMaterials = this.submeshMaterials.ToArray();
                }

                return this.sharedMaterials;
            },
            /*Spine.Unity.MeshRendererBuffers.GetUpdatedSharedMaterialsArray end.*/

            /*Spine.Unity.MeshRendererBuffers.MaterialsChangedInLastUpdate start.*/
            /**
             * Returns true if the materials were modified since the buffers were last updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.MeshRendererBuffers
             * @memberof Spine.Unity.MeshRendererBuffers
             * @return  {boolean}
             */
            MaterialsChangedInLastUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#MaterialsChangedInLastUpdate", this ); }

                var newSubmeshMaterials = this.submeshMaterials.Count;
                var sharedMaterials = this.sharedMaterials;
                if (newSubmeshMaterials !== sharedMaterials.length) {
                    return true;
                }

                var submeshMaterialsItems = this.submeshMaterials.Items;
                for (var i = 0; i < newSubmeshMaterials; i = (i + 1) | 0) {
                    if (!Bridge.referenceEquals(submeshMaterialsItems[i], sharedMaterials[i])) {
                        return true;
                    }
                } //if (submeshMaterialsItems[i].GetInstanceID() != sharedMaterials[i].GetInstanceID()) return true;

                return false;
            },
            /*Spine.Unity.MeshRendererBuffers.MaterialsChangedInLastUpdate end.*/

            /*Spine.Unity.MeshRendererBuffers.UpdateSharedMaterials start.*/
            /**
             * Updates the internal shared materials array with the given instruction list.
             *
             * @instance
             * @public
             * @this Spine.Unity.MeshRendererBuffers
             * @memberof Spine.Unity.MeshRendererBuffers
             * @param   {Spine.ExposedList$1}    instructions
             * @return  {void}
             */
            UpdateSharedMaterials: function (instructions) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#UpdateSharedMaterials", this ); }

                var newSize = instructions.Count;
                { //submeshMaterials.Resize(instructions.Count);
                    if (newSize > this.submeshMaterials.Items.length) {
                        System.Array.resize(Bridge.ref(this.submeshMaterials, "Items"), newSize, null, UnityEngine.Material);
                    }
                    this.submeshMaterials.Count = newSize;
                }

                var submeshMaterialsItems = this.submeshMaterials.Items;
                var instructionsItems = instructions.Items;
                for (var i = 0; i < newSize; i = (i + 1) | 0) {
                    submeshMaterialsItems[i] = instructionsItems[i].material;
                }
            },
            /*Spine.Unity.MeshRendererBuffers.UpdateSharedMaterials end.*/

            /*Spine.Unity.MeshRendererBuffers.GetNextMesh start.*/
            GetNextMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#GetNextMesh", this ); }

                return this.doubleBufferedMesh.GetNext();
            },
            /*Spine.Unity.MeshRendererBuffers.GetNextMesh end.*/

            /*Spine.Unity.MeshRendererBuffers.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#Clear", this ); }

                this.sharedMaterials = System.Array.init(0, null, UnityEngine.Material);
                this.submeshMaterials.Clear();
            },
            /*Spine.Unity.MeshRendererBuffers.Clear end.*/

            /*Spine.Unity.MeshRendererBuffers.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#Dispose", this ); }

                if (this.doubleBufferedMesh == null) {
                    return;
                }
                this.doubleBufferedMesh.GetNext().Dispose();
                this.doubleBufferedMesh.GetNext().Dispose();
                this.doubleBufferedMesh = null;
            },
            /*Spine.Unity.MeshRendererBuffers.Dispose end.*/


        }
    });
    /*Spine.Unity.MeshRendererBuffers end.*/

    /*Spine.Unity.MeshRendererBuffers+SmartMesh start.*/
    /**
     * This is a Mesh that also stores the instructions SkeletonRenderer generated for it.
     *
     * @public
     * @class Spine.Unity.MeshRendererBuffers.SmartMesh
     * @implements  System.IDisposable
     */
    Bridge.define("Spine.Unity.MeshRendererBuffers.SmartMesh", {
        inherits: [System.IDisposable],
        $kind: 1002,
        fields: {
            mesh: null,
            instructionUsed: null
        },
        alias: ["Dispose", "System$IDisposable$Dispose"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers.SmartMesh#init", this ); }

                this.mesh = Spine.Unity.SpineMesh.NewSkeletonMesh();
                this.instructionUsed = new Spine.Unity.SkeletonRendererInstruction();
            }
        },
        methods: {
            /*Spine.Unity.MeshRendererBuffers+SmartMesh.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers.SmartMesh#Clear", this ); }

                this.mesh.Clear();
                this.instructionUsed.Clear();
            },
            /*Spine.Unity.MeshRendererBuffers+SmartMesh.Clear end.*/

            /*Spine.Unity.MeshRendererBuffers+SmartMesh.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers.SmartMesh#Dispose", this ); }

                if (this.mesh != null) {
                    UnityEngine.Object.Destroy(this.mesh);
                }
                this.mesh = null;
            },
            /*Spine.Unity.MeshRendererBuffers+SmartMesh.Dispose end.*/


        }
    });
    /*Spine.Unity.MeshRendererBuffers+SmartMesh end.*/

    /*Spine.Unity.NoOpTextureLoader start.*/
    Bridge.define("Spine.Unity.NoOpTextureLoader", {
        inherits: [Spine.TextureLoader],
        alias: [
            "Load", "Spine$TextureLoader$Load",
            "Unload", "Spine$TextureLoader$Unload"
        ],
        methods: {
            /*Spine.Unity.NoOpTextureLoader.Load start.*/
            Load: function (page, path) {
if ( TRACE ) { TRACE( "Spine.Unity.NoOpTextureLoader#Load", this ); }
 },
            /*Spine.Unity.NoOpTextureLoader.Load end.*/

            /*Spine.Unity.NoOpTextureLoader.Unload start.*/
            Unload: function (texture) {
if ( TRACE ) { TRACE( "Spine.Unity.NoOpTextureLoader#Unload", this ); }
 },
            /*Spine.Unity.NoOpTextureLoader.Unload end.*/


        }
    });
    /*Spine.Unity.NoOpTextureLoader end.*/

    /*Spine.Unity.OnDemandTextureLoader start.*/
    Bridge.define("Spine.Unity.OnDemandTextureLoader", {
        inherits: [UnityEngine.ScriptableObject],
        fields: {
            atlasAsset: null
        },
        events: {
            onTextureRequested: null,
            onTextureLoaded: null,
            onTextureUnloaded: null
        },
        methods: {
            addTextureRequested: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#addTextureRequested", this ); }

                this.addonTextureRequested(value);
            },
            removeTextureRequested: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#removeTextureRequested", this ); }

                this.removeonTextureRequested(value);
            },
            addTextureLoaded: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#addTextureLoaded", this ); }

                this.addonTextureLoaded(value);
            },
            removeTextureLoaded: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#removeTextureLoaded", this ); }

                this.removeonTextureLoaded(value);
            },
            addTextureUnloaded: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#addTextureUnloaded", this ); }

                this.addonTextureUnloaded(value);
            },
            removeTextureUnloaded: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#removeTextureUnloaded", this ); }

                this.removeonTextureUnloaded(value);
            },
            /*Spine.Unity.OnDemandTextureLoader.HasNullMainTexturesAssigned start.*/
            /**
             * Returns whether any main texture is null at a Material of the associated AtlasAssetBase.
             *
             * @instance
             * @public
             * @this Spine.Unity.OnDemandTextureLoader
             * @memberof Spine.Unity.OnDemandTextureLoader
             * @param   {System.Collections.Generic.List}    nullTextureMaterials    A newly created list of materials which has a null main texture assigned.
             * @return  {boolean}                                                    True, if any null main texture is assigned at a Material of the associated AtlasAssetBase.
             */
            HasNullMainTexturesAssigned: function (nullTextureMaterials) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#HasNullMainTexturesAssigned", this ); }

                var $t;
                nullTextureMaterials.v = null;
                if (!UnityEngine.Object.op_Implicit(this.atlasAsset)) {
                    return false;
                }

                var anyNullTexture = false;
                $t = Bridge.getEnumerator(this.atlasAsset.Materials, UnityEngine.Material);
                try {
                    while ($t.moveNext()) {
                        var material = $t.Current;
                        if (material.mainTexture == null) {
                            anyNullTexture = true;
                            if (nullTextureMaterials.v == null) {
                                nullTextureMaterials.v = new (System.Collections.Generic.List$1(UnityEngine.Material)).ctor();
                            }
                            nullTextureMaterials.v.add(material);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return anyNullTexture;
            },
            /*Spine.Unity.OnDemandTextureLoader.HasNullMainTexturesAssigned end.*/

            /*Spine.Unity.OnDemandTextureLoader.OnTextureRequested start.*/
            OnTextureRequested: function (material, textureIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#OnTextureRequested", this ); }

                if (!Bridge.staticEquals(this.onTextureRequested, null)) {
                    this.onTextureRequested(this, material, textureIndex);
                }
            },
            /*Spine.Unity.OnDemandTextureLoader.OnTextureRequested end.*/

            /*Spine.Unity.OnDemandTextureLoader.OnTextureLoaded start.*/
            OnTextureLoaded: function (material, textureIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#OnTextureLoaded", this ); }

                if (!Bridge.staticEquals(this.onTextureLoaded, null)) {
                    this.onTextureLoaded(this, material, textureIndex);
                }
            },
            /*Spine.Unity.OnDemandTextureLoader.OnTextureLoaded end.*/

            /*Spine.Unity.OnDemandTextureLoader.OnTextureUnloaded start.*/
            OnTextureUnloaded: function (material, textureIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#OnTextureUnloaded", this ); }

                if (!Bridge.staticEquals(this.onTextureUnloaded, null)) {
                    this.onTextureUnloaded(this, material, textureIndex);
                }
            },
            /*Spine.Unity.OnDemandTextureLoader.OnTextureUnloaded end.*/


        }
    });
    /*Spine.Unity.OnDemandTextureLoader end.*/

    /*Spine.Unity.Prototyping.SkeletonColorInitialize start.*/
    /** @namespace Spine.Unity.Prototyping */

    /**
     * Stores and serializes initial settings for a Spine Skeleton component. The settings only get applied on Start at runtime.
     *
     * @public
     * @class Spine.Unity.Prototyping.SkeletonColorInitialize
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.Prototyping.SkeletonColorInitialize", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonColor: null,
            slotSettings: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Prototyping.SkeletonColorInitialize#init", this ); }

                this.skeletonColor = new UnityEngine.Color();
                this.skeletonColor = new pc.Color( 1, 1, 1, 1 );
                this.slotSettings = new (System.Collections.Generic.List$1(Spine.Unity.Prototyping.SkeletonColorInitialize.SlotSettings)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.Prototyping.SkeletonColorInitialize.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Prototyping.SkeletonColorInitialize#Start", this ); }

                this.ApplySettings();
            },
            /*Spine.Unity.Prototyping.SkeletonColorInitialize.Start end.*/

            /*Spine.Unity.Prototyping.SkeletonColorInitialize.ApplySettings start.*/
            ApplySettings: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Prototyping.SkeletonColorInitialize#ApplySettings", this ); }

                var $t;
                var skeletonComponent = this.GetComponent(Spine.Unity.ISkeletonComponent);
                if (skeletonComponent != null) {
                    var skeleton = skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                    Spine.Unity.SkeletonExtensions.SetColor$4(skeleton, this.skeletonColor.$clone());

                    $t = Bridge.getEnumerator(this.slotSettings);
                    try {
                        while ($t.moveNext()) {
                            var s = $t.Current;
                            var slot = skeleton.findSlot(s.slot);
                            if (slot != null) {
                                Spine.Unity.SkeletonExtensions.SetColor$6(slot, s.color.$clone());
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                }
            },
            /*Spine.Unity.Prototyping.SkeletonColorInitialize.ApplySettings end.*/


        }
    });
    /*Spine.Unity.Prototyping.SkeletonColorInitialize end.*/

    /*Spine.Unity.Prototyping.SkeletonColorInitialize+SlotSettings start.*/
    Bridge.define("Spine.Unity.Prototyping.SkeletonColorInitialize.SlotSettings", {
        $kind: 1002,
        fields: {
            slot: null,
            color: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Prototyping.SkeletonColorInitialize.SlotSettings#init", this ); }

                this.color = new UnityEngine.Color();
                this.slot = "";
                this.color = new pc.Color( 1, 1, 1, 1 );
            }
        }
    });
    /*Spine.Unity.Prototyping.SkeletonColorInitialize+SlotSettings end.*/

    /*Spine.Unity.Prototyping.SpineEventUnityHandler start.*/
    Bridge.define("Spine.Unity.Prototyping.SpineEventUnityHandler", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            events: null,
            skeletonComponent: null,
            animationStateComponent: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Prototyping.SpineEventUnityHandler#init", this ); }

                this.events = new (System.Collections.Generic.List$1(Spine.Unity.Prototyping.SpineEventUnityHandler.EventPair)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.Prototyping.SpineEventUnityHandler.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Prototyping.SpineEventUnityHandler#Start", this ); }

                var $t;
                if (this.skeletonComponent == null) {
                    this.skeletonComponent = this.GetComponent(Spine.Unity.ISkeletonComponent);
                }
                if (this.skeletonComponent == null) {
                    return;
                }
                if (this.animationStateComponent == null) {
                    this.animationStateComponent = Bridge.as(this.skeletonComponent, Spine.Unity.IAnimationStateComponent);
                }
                if (this.animationStateComponent == null) {
                    return;
                }
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                if (skeleton == null) {
                    return;
                }


                var skeletonData = skeleton.data;
                var state = this.animationStateComponent.Spine$Unity$IAnimationStateComponent$AnimationState;
                $t = Bridge.getEnumerator(this.events);
                try {
                    while ($t.moveNext()) {
                        var ep = { v : $t.Current };
                        var eventData = { v : skeletonData.findEvent(ep.v.spineEvent) };
                        ep.v.eventDelegate = ep.v.eventDelegate || (function ($me, eventData, ep) {
                            return function (trackEntry, e) {
                                if (Bridge.referenceEquals(e.data, eventData.v)) {
                                    ep.v.unityHandler.Invoke();
                                }
                            };
                        })(this, eventData, ep);
                        state.addEvent(ep.v.eventDelegate);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.Prototyping.SpineEventUnityHandler.Start end.*/

            /*Spine.Unity.Prototyping.SpineEventUnityHandler.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Prototyping.SpineEventUnityHandler#OnDestroy", this ); }

                var $t;
                if (this.animationStateComponent == null) {
                    this.animationStateComponent = this.GetComponent(Spine.Unity.IAnimationStateComponent);
                }
                if (Spine.Unity.ISpineComponentExtensions.IsNullOrDestroyed(this.animationStateComponent)) {
                    return;
                }

                var state = this.animationStateComponent.Spine$Unity$IAnimationStateComponent$AnimationState;
                $t = Bridge.getEnumerator(this.events);
                try {
                    while ($t.moveNext()) {
                        var ep = $t.Current;
                        if (!Bridge.staticEquals(ep.eventDelegate, null)) {
                            state.removeEvent(ep.eventDelegate);
                        }
                        ep.eventDelegate = null;
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.Prototyping.SpineEventUnityHandler.OnDestroy end.*/


        }
    });
    /*Spine.Unity.Prototyping.SpineEventUnityHandler end.*/

    /*Spine.Unity.Prototyping.SpineEventUnityHandler+EventPair start.*/
    Bridge.define("Spine.Unity.Prototyping.SpineEventUnityHandler.EventPair", {
        $kind: 1002,
        fields: {
            spineEvent: null,
            unityHandler: null,
            eventDelegate: null
        }
    });
    /*Spine.Unity.Prototyping.SpineEventUnityHandler+EventPair end.*/

    /*Spine.Unity.RegionlessAttachmentLoader start.*/
    Bridge.define("Spine.Unity.RegionlessAttachmentLoader", {
        inherits: [Spine.AttachmentLoader],
        statics: {
            fields: {
                emptyRegion: null
            },
            props: {
                EmptyRegion: {
                    get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#EmptyRegion#get", this ); }

                        var $t, $t1, $t2;
                        if (Spine.Unity.RegionlessAttachmentLoader.emptyRegion == null) {
                            Spine.Unity.RegionlessAttachmentLoader.emptyRegion = ($t = new Spine.AtlasRegion(), $t.name = "Empty AtlasRegion", $t.page = ($t1 = new Spine.AtlasPage(), $t1.name = "Empty AtlasPage", $t1.rendererObject = ($t2 = new UnityEngine.Material.$ctor2(UnityEngine.Shader.Find("Spine/Special/HiddenPass")), $t2.name = "NoRender Material", $t2), $t1), $t);
                        }
                        return Spine.Unity.RegionlessAttachmentLoader.emptyRegion;
                    }
                }
            }
        },
        alias: [
            "NewBoundingBoxAttachment", "Spine$AttachmentLoader$NewBoundingBoxAttachment",
            "NewPathAttachment", "Spine$AttachmentLoader$NewPathAttachment",
            "NewPointAttachment", "Spine$AttachmentLoader$NewPointAttachment",
            "NewClippingAttachment", "Spine$AttachmentLoader$NewClippingAttachment"
        ],
        methods: {
            /*Spine.Unity.RegionlessAttachmentLoader.NewRegionAttachment start.*/
            NewRegionAttachment: function (skin, name, path, sequence) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewRegionAttachment", this ); }

                var $t;
                var attachment = ($t = new Spine.RegionAttachment(name), $t.region = Spine.Unity.RegionlessAttachmentLoader.EmptyRegion, $t);
                return attachment;
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewRegionAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewMeshAttachment start.*/
            NewMeshAttachment: function (skin, name, path, sequence) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewMeshAttachment", this ); }

                var $t;
                var attachment = ($t = new Spine.MeshAttachment(name), $t.region = Spine.Unity.RegionlessAttachmentLoader.EmptyRegion, $t);
                return attachment;
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewMeshAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewBoundingBoxAttachment start.*/
            NewBoundingBoxAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewBoundingBoxAttachment", this ); }

                return new spine.BoundingBoxAttachment( name );
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewBoundingBoxAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewPathAttachment start.*/
            NewPathAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewPathAttachment", this ); }

                return new spine.PathAttachment( name );
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewPathAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewPointAttachment start.*/
            NewPointAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewPointAttachment", this ); }

                return new spine.PointAttachment( name );
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewPointAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewClippingAttachment start.*/
            NewClippingAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewClippingAttachment", this ); }

                return new spine.ClippingAttachment( name );
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewClippingAttachment end.*/


        }
    });
    /*Spine.Unity.RegionlessAttachmentLoader end.*/

    /*Spine.Unity.SkeletonAnimationFixedTimestep start.*/
    Bridge.define("Spine.Unity.SkeletonAnimationFixedTimestep", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonAnimation: null,
            frameDeltaTime: 0,
            maxFrameSkip: 0,
            frameskipMeshUpdate: false,
            timeOffset: 0,
            accumulatedTime: 0,
            requiresNewMesh: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimationFixedTimestep#init", this ); }

                this.frameDeltaTime = 0.06666667;
                this.maxFrameSkip = 4;
                this.frameskipMeshUpdate = true;
                this.accumulatedTime = 0;
            }
        },
        methods: {
            /*Spine.Unity.SkeletonAnimationFixedTimestep.OnValidate start.*/
            OnValidate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimationFixedTimestep#OnValidate", this ); }

                this.skeletonAnimation = this.GetComponent(Spine.Unity.SkeletonAnimation);
                if (this.frameDeltaTime <= 0) {
                    this.frameDeltaTime = 0.0166666675;
                }
                if (this.maxFrameSkip < 1) {
                    this.maxFrameSkip = 1;
                }
            },
            /*Spine.Unity.SkeletonAnimationFixedTimestep.OnValidate end.*/

            /*Spine.Unity.SkeletonAnimationFixedTimestep.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimationFixedTimestep#Awake", this ); }

                this.requiresNewMesh = true;
                this.accumulatedTime = this.timeOffset;
            },
            /*Spine.Unity.SkeletonAnimationFixedTimestep.Awake end.*/

            /*Spine.Unity.SkeletonAnimationFixedTimestep.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimationFixedTimestep#Update", this ); }

                if (this.skeletonAnimation.enabled) {
                    this.skeletonAnimation.enabled = false;
                }

                this.accumulatedTime += UnityEngine.Time.deltaTime;

                var frames = 0;
                while (this.accumulatedTime >= this.frameDeltaTime) {
                    frames++;
                    if (frames > this.maxFrameSkip) {
                        break;
                    }
                    this.accumulatedTime -= this.frameDeltaTime;
                }

                if (frames > 0) {
                    this.skeletonAnimation.Update(frames * this.frameDeltaTime);
                    this.requiresNewMesh = true;
                }
            },
            /*Spine.Unity.SkeletonAnimationFixedTimestep.Update end.*/

            /*Spine.Unity.SkeletonAnimationFixedTimestep.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimationFixedTimestep#LateUpdate", this ); }

                if (this.frameskipMeshUpdate && !this.requiresNewMesh) {
                    return;
                }

                this.skeletonAnimation.LateUpdate();
                this.requiresNewMesh = false;
            },
            /*Spine.Unity.SkeletonAnimationFixedTimestep.LateUpdate end.*/


        }
    });
    /*Spine.Unity.SkeletonAnimationFixedTimestep end.*/

    /*Spine.Unity.SkeletonAnimationMulti start.*/
    Bridge.define("Spine.Unity.SkeletonAnimationMulti", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                MainTrackIndex: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimationMulti#init", this ); }

                    this.MainTrackIndex = 0;
                }
            }
        },
        fields: {
            initialFlipX: false,
            initialFlipY: false,
            initialAnimation: null,
            initialLoop: false,
            skeletonDataAssets: null,
            meshGeneratorSettings: null,
            skeletonAnimations: null,
            animationNameTable: null,
            animationSkeletonTable: null,
            currentSkeletonAnimation: null
        },
        props: {
            AnimationSkeletonTable: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimationMulti#AnimationSkeletonTable#get", this ); }

                    return this.animationSkeletonTable;
                }
            },
            AnimationNameTable: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimationMulti#AnimationNameTable#get", this ); }

                    return this.animationNameTable;
                }
            },
            CurrentSkeletonAnimation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimationMulti#CurrentSkeletonAnimation#get", this ); }

                    return this.currentSkeletonAnimation;
                }
            },
            SkeletonAnimations: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimationMulti#SkeletonAnimations#get", this ); }

                    return this.skeletonAnimations;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimationMulti#init", this ); }

                this.meshGeneratorSettings = new Spine.Unity.MeshGenerator.Settings();
                this.skeletonDataAssets = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonDataAsset)).ctor();
                this.meshGeneratorSettings = Spine.Unity.MeshGenerator.Settings.Default.$clone();
                this.skeletonAnimations = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonAnimation)).ctor();
                this.animationNameTable = new (System.Collections.Generic.Dictionary$2(System.String,Spine.Animation)).ctor();
                this.animationSkeletonTable = new (System.Collections.Generic.Dictionary$2(Spine.Animation,Spine.Unity.SkeletonAnimation)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonAnimationMulti.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimationMulti#Clear", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.skeletonAnimations);
                try {
                    while ($t.moveNext()) {
                        var skeletonAnimation = $t.Current;
                        UnityEngine.MonoBehaviour.Destroy(skeletonAnimation.gameObject);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                this.skeletonAnimations.clear();
                this.animationNameTable.clear();
                this.animationSkeletonTable.clear();
            },
            /*Spine.Unity.SkeletonAnimationMulti.Clear end.*/

            /*Spine.Unity.SkeletonAnimationMulti.SetActiveSkeleton$1 start.*/
            SetActiveSkeleton$1: function (index) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimationMulti#SetActiveSkeleton$1", this ); }

                if (index < 0 || index >= this.skeletonAnimations.Count) {
                    this.SetActiveSkeleton(null);
                } else {
                    this.SetActiveSkeleton(this.skeletonAnimations.getItem(index));
                }
            },
            /*Spine.Unity.SkeletonAnimationMulti.SetActiveSkeleton$1 end.*/

            /*Spine.Unity.SkeletonAnimationMulti.SetActiveSkeleton start.*/
            SetActiveSkeleton: function (skeletonAnimation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimationMulti#SetActiveSkeleton", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.skeletonAnimations);
                try {
                    while ($t.moveNext()) {
                        var iter = $t.Current;
                        iter.gameObject.SetActive(UnityEngine.MonoBehaviour.op_Equality(iter, skeletonAnimation));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                this.currentSkeletonAnimation = skeletonAnimation;
            },
            /*Spine.Unity.SkeletonAnimationMulti.SetActiveSkeleton end.*/

            /*Spine.Unity.SkeletonAnimationMulti.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimationMulti#Awake", this ); }

                this.Initialize(false);
            },
            /*Spine.Unity.SkeletonAnimationMulti.Awake end.*/

            /*Spine.Unity.SkeletonAnimationMulti.Initialize start.*/
            Initialize: function (overwrite) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimationMulti#Initialize", this ); }

                var $t, $t1, $t2;
                if (this.skeletonAnimations.Count !== 0 && !overwrite) {
                    return;
                }

                this.Clear();

                var settings = this.meshGeneratorSettings.$clone();
                var thisTransform = this.transform;
                $t = Bridge.getEnumerator(this.skeletonDataAssets);
                try {
                    while ($t.moveNext()) {
                        var dataAsset = $t.Current;
                        var newSkeletonAnimation = Spine.Unity.SkeletonAnimation.NewSkeletonAnimationGameObject(dataAsset);
                        newSkeletonAnimation.transform.SetParent(thisTransform, false);

                        newSkeletonAnimation.SetMeshSettings(settings);
                        newSkeletonAnimation.initialFlipX = this.initialFlipX;
                        newSkeletonAnimation.initialFlipY = this.initialFlipY;
                        var skeleton = newSkeletonAnimation.skeleton;
                        skeleton.scaleX = this.initialFlipX ? -1 : 1;
                        skeleton.scaleY = this.initialFlipY ? -1 : 1;

                        newSkeletonAnimation.Initialize(false);
                        this.skeletonAnimations.add(newSkeletonAnimation);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                // Build cache
                var animationNameTable = this.animationNameTable;
                var animationSkeletonTable = this.animationSkeletonTable;
                $t1 = Bridge.getEnumerator(this.skeletonAnimations);
                try {
                    while ($t1.moveNext()) {
                        var skeletonAnimation = $t1.Current;
                        $t2 = Bridge.getEnumerator(skeletonAnimation.Skeleton.data.Animations);
                        try {
                            while ($t2.moveNext()) {
                                var animationObject = $t2.Current;
                                animationNameTable.setItem(animationObject.name, animationObject);
                                animationSkeletonTable.setItem(animationObject, skeletonAnimation);
                            }
                        } finally {
                            if (Bridge.is($t2, System.IDisposable)) {
                                $t2.System$IDisposable$Dispose();
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }

                this.SetActiveSkeleton(this.skeletonAnimations.getItem(0));
                this.SetAnimation$1(this.initialAnimation, this.initialLoop);
            },
            /*Spine.Unity.SkeletonAnimationMulti.Initialize end.*/

            /*Spine.Unity.SkeletonAnimationMulti.FindAnimation start.*/
            FindAnimation: function (animationName) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimationMulti#FindAnimation", this ); }

                var animation = { };
                this.animationNameTable.tryGetValue(animationName, animation);
                return animation.v;
            },
            /*Spine.Unity.SkeletonAnimationMulti.FindAnimation end.*/

            /*Spine.Unity.SkeletonAnimationMulti.SetAnimation$1 start.*/
            SetAnimation$1: function (animationName, loop) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimationMulti#SetAnimation$1", this ); }

                return this.SetAnimation(this.FindAnimation(animationName), loop);
            },
            /*Spine.Unity.SkeletonAnimationMulti.SetAnimation$1 end.*/

            /*Spine.Unity.SkeletonAnimationMulti.SetAnimation start.*/
            SetAnimation: function (animation, loop) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimationMulti#SetAnimation", this ); }

                if (animation == null) {
                    return null;
                }

                var skeletonAnimation = { };
                this.animationSkeletonTable.tryGetValue(animation, skeletonAnimation);

                if (UnityEngine.MonoBehaviour.op_Inequality(skeletonAnimation.v, null)) {
                    this.SetActiveSkeleton(skeletonAnimation.v);
                    skeletonAnimation.v.skeleton.setToSetupPose();
                    var trackEntry = skeletonAnimation.v.state.setAnimationWith( Spine.Unity.SkeletonAnimationMulti.MainTrackIndex, animation, loop );
                    skeletonAnimation.v.Update(0);
                    return trackEntry;
                }
                return null;
            },
            /*Spine.Unity.SkeletonAnimationMulti.SetAnimation end.*/

            /*Spine.Unity.SkeletonAnimationMulti.SetEmptyAnimation start.*/
            SetEmptyAnimation: function (mixDuration) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimationMulti#SetEmptyAnimation", this ); }

                this.currentSkeletonAnimation.state.setEmptyAnimation(Spine.Unity.SkeletonAnimationMulti.MainTrackIndex, mixDuration);
            },
            /*Spine.Unity.SkeletonAnimationMulti.SetEmptyAnimation end.*/

            /*Spine.Unity.SkeletonAnimationMulti.ClearAnimation start.*/
            ClearAnimation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimationMulti#ClearAnimation", this ); }

                this.currentSkeletonAnimation.state.clearTrack(Spine.Unity.SkeletonAnimationMulti.MainTrackIndex);
            },
            /*Spine.Unity.SkeletonAnimationMulti.ClearAnimation end.*/

            /*Spine.Unity.SkeletonAnimationMulti.GetCurrent start.*/
            GetCurrent: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimationMulti#GetCurrent", this ); }

                return this.currentSkeletonAnimation.state.getCurrent(Spine.Unity.SkeletonAnimationMulti.MainTrackIndex);
            },
            /*Spine.Unity.SkeletonAnimationMulti.GetCurrent end.*/


        },
        overloads: {
            "SetActiveSkeleton(int)": "SetActiveSkeleton$1",
            "SetAnimation(string, bool)": "SetAnimation$1"
        }
    });
    /*Spine.Unity.SkeletonAnimationMulti end.*/

    /*Spine.Unity.SkeletonDataAsset start.*/
    Bridge.define("Spine.Unity.SkeletonDataAsset", {
        inherits: [UnityEngine.ScriptableObject],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance:static start.*/
                /**
                 * Creates a runtime SkeletonDataAsset.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonDataAsset
                 * @memberof Spine.Unity.SkeletonDataAsset
                 * @param   {UnityEngine.TextAsset}            skeletonDataFile    
                 * @param   {Spine.Unity.AtlasAssetBase}       atlasAsset          
                 * @param   {boolean}                          initialize          
                 * @param   {number}                           scale
                 * @return  {Spine.Unity.SkeletonDataAsset}
                 */
                CreateRuntimeInstance: function (skeletonDataFile, atlasAsset, initialize, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#CreateRuntimeInstance", this ); }

                    if (scale === void 0) { scale = 0.01; }
                    return Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance$1(skeletonDataFile, System.Array.init([atlasAsset], Spine.Unity.AtlasAssetBase), initialize, scale);
                },
                /*Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance:static end.*/

                /*Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance$1:static start.*/
                /**
                 * Creates a runtime SkeletonDataAsset.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonDataAsset
                 * @memberof Spine.Unity.SkeletonDataAsset
                 * @param   {UnityEngine.TextAsset}                 skeletonDataFile    
                 * @param   {Array.<Spine.Unity.AtlasAssetBase>}    atlasAssets         
                 * @param   {boolean}                               initialize          
                 * @param   {number}                                scale
                 * @return  {Spine.Unity.SkeletonDataAsset}
                 */
                CreateRuntimeInstance$1: function (skeletonDataFile, atlasAssets, initialize, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#CreateRuntimeInstance$1", this ); }

                    if (scale === void 0) { scale = 0.01; }
                    var skeletonDataAsset = UnityEngine.ScriptableObject.CreateInstance(Spine.Unity.SkeletonDataAsset);
                    skeletonDataAsset.Clear();
                    skeletonDataAsset.skeletonJSON = skeletonDataFile;
                    skeletonDataAsset.atlasAssets = atlasAssets;
                    skeletonDataAsset.scale = scale;

                    if (initialize) {
                        skeletonDataAsset.GetSkeletonData(true);
                    }

                    return skeletonDataAsset;
                },
                /*Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance$1:static end.*/

                /*Spine.Unity.SkeletonDataAsset.ReadSkeletonData:static start.*/
                ReadSkeletonData: function (bytes, attachmentLoader, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#ReadSkeletonData", this ); }

                    var $t;
                    var input = new System.IO.MemoryStream.$ctor1(bytes);
                    try {
                        var binary = ($t = new Spine.SkeletonBinary(attachmentLoader), $t.scale = scale, $t);
                        return binary.ReadSkeletonData(input);
                    }
                    finally {
                        if (Bridge.hasValue(input)) {
                            input.System$IDisposable$Dispose();
                        }
                    }
                },
                /*Spine.Unity.SkeletonDataAsset.ReadSkeletonData:static end.*/

                /*Spine.Unity.SkeletonDataAsset.ReadSkeletonData$1:static start.*/
                ReadSkeletonData$1: function (text, attachmentLoader, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#ReadSkeletonData$1", this ); }

                    var $t;
                    var input = new System.IO.StringReader(text);
                    var json = ($t = new Spine.SkeletonJson(attachmentLoader), $t.scale = scale, $t);
                    return json.ReadSkeletonData(input);
                },
                /*Spine.Unity.SkeletonDataAsset.ReadSkeletonData$1:static end.*/


            }
        },
        fields: {
            atlasAssets: null,
            scale: 0,
            skeletonJSON: null,
            isUpgradingBlendModeMaterials: false,
            blendModeMaterials: null,
            skeletonDataModifiers: null,
            fromAnimation: null,
            toAnimation: null,
            duration: null,
            defaultMix: 0,
            controller: null,
            skeletonData: null,
            stateData: null
        },
        props: {
            IsLoaded: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#IsLoaded#get", this ); }

                    return this.skeletonData != null;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#init", this ); }

                this.atlasAssets = System.Array.init(0, null, Spine.Unity.AtlasAssetBase);
                this.scale = 0.01;
                this.isUpgradingBlendModeMaterials = false;
                this.blendModeMaterials = new Spine.Unity.BlendModeMaterials();
                this.skeletonDataModifiers = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonDataModifierAsset)).ctor();
                this.fromAnimation = System.Array.init(0, null, System.String);
                this.toAnimation = System.Array.init(0, null, System.String);
                this.duration = System.Array.init(0, 0, System.Single);
            }
        },
        methods: {
            /*Spine.Unity.SkeletonDataAsset.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#Reset", this ); }

                this.Clear();
            },
            /*Spine.Unity.SkeletonDataAsset.Reset end.*/

            /*Spine.Unity.SkeletonDataAsset.Clear start.*/
            /**
             * Clears the loaded SkeletonData and AnimationStateData. Use this to force a reload for the next time GetSkeletonData is called.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonDataAsset
             * @memberof Spine.Unity.SkeletonDataAsset
             * @return  {void}
             */
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#Clear", this ); }

                this.skeletonData = null;
                this.stateData = null;
            },
            /*Spine.Unity.SkeletonDataAsset.Clear end.*/

            /*Spine.Unity.SkeletonDataAsset.GetAnimationStateData start.*/
            GetAnimationStateData: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#GetAnimationStateData", this ); }

                if (this.stateData != null) {
                    return this.stateData;
                }
                this.GetSkeletonData(false);
                return this.stateData;
            },
            /*Spine.Unity.SkeletonDataAsset.GetAnimationStateData end.*/

            /*Spine.Unity.SkeletonDataAsset.GetSkeletonData start.*/
            /**
             * Loads, caches and returns the SkeletonData from the skeleton data file. Returns the cached SkeletonData after the first time it is called. Pass false to prevent direct errors from being logged.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonDataAsset
             * @memberof Spine.Unity.SkeletonDataAsset
             * @param   {boolean}               quiet
             * @return  {Spine.SkeletonData}
             */
            GetSkeletonData: function (quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#GetSkeletonData", this ); }

                var $t;
                if (this.skeletonJSON == null) {
                    if (!quiet) {
                        UnityEngine.Debug.LogError$2("Skeleton JSON file not set for SkeletonData asset: " + (this.name || ""), this);
                    }
                    this.Clear();
                    return null;
                }

                // Disabled to support attachmentless/skinless SkeletonData.
                //			if (atlasAssets == null) {
                //				atlasAssets = new AtlasAsset[0];
                //				if (!quiet)
                //					Debug.LogError("Atlas not set for SkeletonData asset: " + name, this);
                //				Clear();
                //				return null;
                //			}
                //			#if !SPINE_TK2D
                //			if (atlasAssets.Length == 0) {
                //				Clear();
                //				return null;
                //			}
                //			#else
                //			if (atlasAssets.Length == 0 && spriteCollection == null) {
                //				Clear();
                //				return null;
                //			}
                //			#endif

                if (this.skeletonData != null) {
                    return this.skeletonData;
                }

                var attachmentLoader;
                var skeletonDataScale;
                var atlasArray = this.GetAtlasArray();

                attachmentLoader = (atlasArray.length === 0) ? Bridge.cast(new Spine.Unity.RegionlessAttachmentLoader(), Spine.AttachmentLoader) : Bridge.cast(new Spine.AtlasAttachmentLoader(atlasArray), Spine.AttachmentLoader);
                skeletonDataScale = this.scale;

                var hasBinaryExtension = System.String.contains(this.skeletonJSON.name.toLowerCase(),".skel");
                var loadedSkeletonData = null;

                try {
                    if (hasBinaryExtension) {
                        loadedSkeletonData = Spine.Unity.SkeletonDataAsset.ReadSkeletonData(this.skeletonJSON.bytes, attachmentLoader, skeletonDataScale);
                    } else {
                        loadedSkeletonData = Spine.Unity.SkeletonDataAsset.ReadSkeletonData$1(this.skeletonJSON.text, attachmentLoader, skeletonDataScale);
                    }
                } catch (ex) {
                    ex = System.Exception.create(ex);
                    if (!quiet) {
                        UnityEngine.Debug.LogError$2("Error reading skeleton JSON file for SkeletonData asset: " + (this.name || "") + "\n" + (ex.Message || "") + "\n" + (ex.StackTrace || ""), this.skeletonJSON);
                    }
                }

                if (loadedSkeletonData == null) {
                    return null;
                }

                if (this.skeletonDataModifiers != null) {
                    $t = Bridge.getEnumerator(this.skeletonDataModifiers);
                    try {
                        while ($t.moveNext()) {
                            var modifier = $t.Current;
                            if (modifier != null && !(this.isUpgradingBlendModeMaterials && Bridge.is(modifier, Spine.Unity.BlendModeMaterialsAsset))) {
                                modifier.Apply(loadedSkeletonData);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }
                if (!this.isUpgradingBlendModeMaterials) {
                    this.blendModeMaterials.ApplyMaterials(loadedSkeletonData);
                }

                this.InitializeWithData(loadedSkeletonData);

                return this.skeletonData;
            },
            /*Spine.Unity.SkeletonDataAsset.GetSkeletonData end.*/

            /*Spine.Unity.SkeletonDataAsset.InitializeWithData start.*/
            InitializeWithData: function (sd) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#InitializeWithData", this ); }

                this.skeletonData = sd;
                this.stateData = new spine.AnimationStateData( this.skeletonData );
                this.FillStateData();
            },
            /*Spine.Unity.SkeletonDataAsset.InitializeWithData end.*/

            /*Spine.Unity.SkeletonDataAsset.FillStateData start.*/
            FillStateData: function (quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#FillStateData", this ); }

                if (quiet === void 0) { quiet = false; }
                if (this.stateData != null) {
                    this.stateData.defaultMix = this.defaultMix;

                    for (var i = 0, n = this.fromAnimation.length; i < n; i = (i + 1) | 0) {
                        var fromAnimationName = this.fromAnimation[i];
                        var toAnimationName = this.toAnimation[i];
                        if (fromAnimationName.length === 0 || toAnimationName.length === 0) {
                            continue;
                        }
                        this.stateData.setMix(fromAnimationName, toAnimationName, this.duration[i]);
                    }
                }
            },
            /*Spine.Unity.SkeletonDataAsset.FillStateData end.*/

            /*Spine.Unity.SkeletonDataAsset.GetAtlasArray start.*/
            GetAtlasArray: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#GetAtlasArray", this ); }

                var returnList = new (System.Collections.Generic.List$1(Spine.Atlas)).$ctor2(this.atlasAssets.length);
                for (var i = 0; i < this.atlasAssets.length; i = (i + 1) | 0) {
                    var aa = this.atlasAssets[i];
                    if (aa == null) {
                        continue;
                    }
                    var a = aa.GetAtlas();
                    if (a == null) {
                        continue;
                    }
                    returnList.add(a);
                }
                return returnList.ToArray();
            },
            /*Spine.Unity.SkeletonDataAsset.GetAtlasArray end.*/


        }
    });
    /*Spine.Unity.SkeletonDataAsset end.*/

    /*Spine.Unity.SkeletonDataCompatibility start.*/
    Bridge.define("Spine.Unity.SkeletonDataCompatibility");
    /*Spine.Unity.SkeletonDataCompatibility end.*/

    /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo start.*/
    Bridge.define("Spine.Unity.SkeletonDataCompatibility.CompatibilityProblemInfo", {
        $kind: 1002,
        fields: {
            actualVersion: null,
            compatibleVersions: null,
            explicitProblemDescription: null
        },
        methods: {
            /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo.DescriptionString start.*/
            DescriptionString: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataCompatibility.CompatibilityProblemInfo#DescriptionString", this ); }

                var $t, $t1, $t2;
                if (!System.String.isNullOrEmpty(this.explicitProblemDescription)) {
                    return this.explicitProblemDescription;
                }

                var compatibleVersionString = "";
                var optionalOr = null;
                $t = Bridge.getEnumerator(this.compatibleVersions);
                try {
                    while ($t.moveNext()) {
                        var version = $t.Current;
                        compatibleVersionString = (compatibleVersionString || "") + ((System.String.format("{0}{1}.{2}", optionalOr, Bridge.box(version[0], System.Int32), Bridge.box(version[1], System.Int32))) || "");
                        optionalOr = " or ";
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return System.String.format("Skeleton data could not be loaded. Data version: {0}. Required version: {1}.\nPlease re-export skeleton data with Spine {1} or change runtime to version {2}.{3}.", this.actualVersion.rawVersion, compatibleVersionString, Bridge.box(($t1 = this.actualVersion.version)[0], System.Int32), Bridge.box(($t2 = this.actualVersion.version)[1], System.Int32));
            },
            /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo.DescriptionString end.*/


        }
    });
    /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo end.*/

    /*Spine.Unity.SkeletonDataCompatibility+SourceType start.*/
    Bridge.define("Spine.Unity.SkeletonDataCompatibility.SourceType", {
        $kind: 1006,
        statics: {
            fields: {
                Json: 0,
                Binary: 1
            }
        }
    });
    /*Spine.Unity.SkeletonDataCompatibility+SourceType end.*/

    /*Spine.Unity.SkeletonDataCompatibility+VersionInfo start.*/
    Bridge.define("Spine.Unity.SkeletonDataCompatibility.VersionInfo", {
        $kind: 1002,
        fields: {
            rawVersion: null,
            version: null,
            sourceType: 0
        }
    });
    /*Spine.Unity.SkeletonDataCompatibility+VersionInfo end.*/

    /*Spine.Unity.SkeletonExtensions start.*/
    Bridge.define("Spine.Unity.SkeletonExtensions", {
        statics: {
            fields: {
                ByteToFloat: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#init", this ); }

                    this.ByteToFloat = 0.003921569;
                }
            },
            methods: {
                /*Spine.Unity.SkeletonExtensions.GetColor$2:static start.*/
                GetColor$2: function (s) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetColor$2", this ); }

                    return new pc.Color( s.color.r, s.color.g, s.color.b, s.color.a );
                },
                /*Spine.Unity.SkeletonExtensions.GetColor$2:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetColor$1:static start.*/
                GetColor$1: function (a) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetColor$1", this ); }

                    return new pc.Color( a.color.r, a.color.g, a.color.b, a.color.a );
                },
                /*Spine.Unity.SkeletonExtensions.GetColor$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetColor:static start.*/
                GetColor: function (a) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetColor", this ); }

                    return new pc.Color( a.color.r, a.color.g, a.color.b, a.color.a );
                },
                /*Spine.Unity.SkeletonExtensions.GetColor:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetColor$3:static start.*/
                GetColor$3: function (s) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetColor$3", this ); }

                    return new pc.Color( s.color.r, s.color.g, s.color.b, s.color.a );
                },
                /*Spine.Unity.SkeletonExtensions.GetColor$3:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetColorTintBlack:static start.*/
                GetColorTintBlack: function (s) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetColorTintBlack", this ); }

                    return new pc.Color( s.darkColor.r || 0, s.darkColor.g || 0, s.darkColor.b || 0, 1.0 );
                },
                /*Spine.Unity.SkeletonExtensions.GetColorTintBlack:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$4:static start.*/
                SetColor$4: function (skeleton, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$4", this ); }

                    skeleton.color.a = color.a;
                    skeleton.color.r = color.r;
                    skeleton.color.g = color.g;
                    skeleton.color.b = color.b;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$4:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$5:static start.*/
                SetColor$5: function (skeleton, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$5", this ); }

                    skeleton.color.a = color.a * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    skeleton.color.r = color.r * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    skeleton.color.g = color.g * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    skeleton.color.b = color.b * Spine.Unity.SkeletonExtensions.ByteToFloat;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$5:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$6:static start.*/
                SetColor$6: function (slot, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$6", this ); }

                    slot.color.a = color.a;
                    slot.color.r = color.r;
                    slot.color.g = color.g;
                    slot.color.b = color.b;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$6:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$7:static start.*/
                SetColor$7: function (slot, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$7", this ); }

                    slot.color.a = color.a * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    slot.color.r = color.r * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    slot.color.g = color.g * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    slot.color.b = color.b * Spine.Unity.SkeletonExtensions.ByteToFloat;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$7:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$2:static start.*/
                SetColor$2: function (attachment, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$2", this ); }

                    attachment.color.a = color.a;
                    attachment.color.r = color.r;
                    attachment.color.g = color.g;
                    attachment.color.b = color.b;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$2:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$3:static start.*/
                SetColor$3: function (attachment, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$3", this ); }

                    attachment.color.a = color.a * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.color.r = color.r * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.color.g = color.g * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.color.b = color.b * Spine.Unity.SkeletonExtensions.ByteToFloat;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$3:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor:static start.*/
                SetColor: function (attachment, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor", this ); }

                    attachment.color.a = color.a;
                    attachment.color.r = color.r;
                    attachment.color.g = color.g;
                    attachment.color.b = color.b;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$1:static start.*/
                SetColor$1: function (attachment, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$1", this ); }

                    attachment.color.a = color.a * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.color.r = color.r * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.color.g = color.g * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.color.b = color.b * Spine.Unity.SkeletonExtensions.ByteToFloat;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetLocalScale:static start.*/
                /**
                 * Sets the Skeleton's local scale using a UnityEngine.Vector2. If only individual components need to be set, set Skeleton.ScaleX or Skeleton.ScaleY.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Skeleton}         skeleton    
                 * @param   {UnityEngine.Vector2}    scale
                 * @return  {void}
                 */
                SetLocalScale: function (skeleton, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetLocalScale", this ); }

                    skeleton.scaleX = scale.x;
                    skeleton.scaleY = scale.y;
                },
                /*Spine.Unity.SkeletonExtensions.SetLocalScale:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetMatrix4x4:static start.*/
                /**
                 * Gets the internal bone matrix as a Unity bonespace-to-skeletonspace transformation matrix.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}               bone
                 * @return  {UnityEngine.Matrix4x4}
                 */
                GetMatrix4x4: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetMatrix4x4", this ); }

                    var $t;
                    return ($t = new pc.Mat4.ctor(), $t.e00 = bone.a, $t.e01 = bone.b, $t.e03 = bone.worldX, $t.e10 = bone.c, $t.e11 = bone.d, $t.e13 = bone.worldY, $t.e33 = 1, $t);
                },
                /*Spine.Unity.SkeletonExtensions.GetMatrix4x4:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetLocalPosition:static start.*/
                /**
                 * Sets the bone's (local) X and Y according to a Vector2
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone        
                 * @param   {UnityEngine.Vector2}    position
                 * @return  {void}
                 */
                SetLocalPosition: function (bone, position) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetLocalPosition", this ); }

                    bone.x = position.x;
                    bone.y = position.y;
                },
                /*Spine.Unity.SkeletonExtensions.SetLocalPosition:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetLocalPosition$1:static start.*/
                /**
                 * Sets the bone's (local) X and Y according to a Vector3. The z component is ignored.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone        
                 * @param   {UnityEngine.Vector3}    position
                 * @return  {void}
                 */
                SetLocalPosition$1: function (bone, position) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetLocalPosition$1", this ); }

                    bone.x = position.x;
                    bone.y = position.y;
                },
                /*Spine.Unity.SkeletonExtensions.SetLocalPosition$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetLocalPosition:static start.*/
                /**
                 * Gets the bone's local X and Y as a Vector2.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone
                 * @return  {UnityEngine.Vector2}
                 */
                GetLocalPosition: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetLocalPosition", this ); }

                    return new pc.Vec2( bone.x, bone.y );
                },
                /*Spine.Unity.SkeletonExtensions.GetLocalPosition:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetSkeletonSpacePosition:static start.*/
                /**
                 * Gets the position of the bone in Skeleton-space.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone
                 * @return  {UnityEngine.Vector2}
                 */
                GetSkeletonSpacePosition: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetSkeletonSpacePosition", this ); }

                    return new pc.Vec2( bone.worldX, bone.worldY );
                },
                /*Spine.Unity.SkeletonExtensions.GetSkeletonSpacePosition:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetSkeletonSpacePosition$1:static start.*/
                /**
                 * Gets a local offset from the bone and converts it into Skeleton-space.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone         
                 * @param   {UnityEngine.Vector2}    boneLocal
                 * @return  {UnityEngine.Vector2}
                 */
                GetSkeletonSpacePosition$1: function (bone, boneLocal) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetSkeletonSpacePosition$1", this ); }

                    var o = new UnityEngine.Vector2();
                    bone.LocalToWorld(boneLocal.x, boneLocal.y, Bridge.ref(o, "x"), Bridge.ref(o, "y"));
                    return o.$clone();
                },
                /*Spine.Unity.SkeletonExtensions.GetSkeletonSpacePosition$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldPosition:static start.*/
                /**
                 * Gets the bone's Unity World position using its Spine GameObject Transform. UpdateWorldTransform needs to have been called for this to return the correct, updated value.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}               bone                        
                 * @param   {UnityEngine.Transform}    spineGameObjectTransform
                 * @return  {UnityEngine.Vector3}
                 */
                GetWorldPosition: function (bone, spineGameObjectTransform) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldPosition", this ); }

                    return spineGameObjectTransform.TransformPoint$1(new pc.Vec3( bone.worldX, bone.worldY, 0 ));
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldPosition:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$1:static start.*/
                GetWorldPosition$1: function (bone, spineGameObjectTransform, positionScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldPosition$1", this ); }

                    return spineGameObjectTransform.TransformPoint$1(new pc.Vec3( bone.worldX * positionScale, bone.worldY * positionScale, 0 ));
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$3:static start.*/
                /**
                 * Gets the PointAttachment's Unity World position using its Spine GameObject Transform.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.PointAttachment}    attachment                  
                 * @param   {Spine.Slot}               slot                        
                 * @param   {UnityEngine.Transform}    spineGameObjectTransform
                 * @return  {UnityEngine.Vector3}
                 */
                GetWorldPosition$3: function (attachment, slot, spineGameObjectTransform) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldPosition$3", this ); }

                    var skeletonSpacePosition = new UnityEngine.Vector3();
                    skeletonSpacePosition.z = 0;
                    attachment.ComputeWorldPosition(slot.bone, Bridge.ref(skeletonSpacePosition, "x"), Bridge.ref(skeletonSpacePosition, "y"));
                    return spineGameObjectTransform.TransformPoint$1(skeletonSpacePosition);
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$3:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$2:static start.*/
                /**
                 * Gets the PointAttachment's Unity World position using its Spine GameObject Transform.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.PointAttachment}    attachment                  
                 * @param   {Spine.Bone}               bone                        
                 * @param   {UnityEngine.Transform}    spineGameObjectTransform
                 * @return  {UnityEngine.Vector3}
                 */
                GetWorldPosition$2: function (attachment, bone, spineGameObjectTransform) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldPosition$2", this ); }

                    var skeletonSpacePosition = new UnityEngine.Vector3();
                    skeletonSpacePosition.z = 0;
                    attachment.ComputeWorldPosition(bone, Bridge.ref(skeletonSpacePosition, "x"), Bridge.ref(skeletonSpacePosition, "y"));
                    return spineGameObjectTransform.TransformPoint$1(skeletonSpacePosition);
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$2:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetQuaternion:static start.*/
                /**
                 * Gets a skeleton space UnityEngine.Quaternion representation of bone.WorldRotationX.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}                bone
                 * @return  {UnityEngine.Quaternion}
                 */
                GetQuaternion: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetQuaternion", this ); }

                    var halfRotation = Math.atan2(bone.c, bone.a) * 0.5;
                    return new pc.Quat( 0, 0, Math.sin(halfRotation), Math.cos(halfRotation) );
                },
                /*Spine.Unity.SkeletonExtensions.GetQuaternion:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetLocalQuaternion:static start.*/
                /**
                 * Gets a bone-local space UnityEngine.Quaternion representation of bone.rotation.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}                bone
                 * @return  {UnityEngine.Quaternion}
                 */
                GetLocalQuaternion: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetLocalQuaternion", this ); }

                    var halfRotation = bone.rotation * UnityEngine.Mathf.Deg2Rad * 0.5;
                    return new pc.Quat( 0, 0, Math.sin(halfRotation), Math.cos(halfRotation) );
                },
                /*Spine.Unity.SkeletonExtensions.GetLocalQuaternion:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetLocalScale:static start.*/
                /**
                 * Returns the Skeleton's local scale as a UnityEngine.Vector2. If only individual components are needed, use Skeleton.ScaleX or Skeleton.ScaleY.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Skeleton}         skeleton
                 * @return  {UnityEngine.Vector2}
                 */
                GetLocalScale: function (skeleton) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetLocalScale", this ); }

                    return new pc.Vec2( skeleton.scaleX, skeleton.scaleY );
                },
                /*Spine.Unity.SkeletonExtensions.GetLocalScale:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldToLocalMatrix:static start.*/
                /**
                 * Calculates a 2x2 Transformation Matrix that can convert a skeleton-space position to a bone-local position.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}       bone    
                 * @param   {System.Single}    ia      
                 * @param   {System.Single}    ib      
                 * @param   {System.Single}    ic      
                 * @param   {System.Single}    id
                 * @return  {void}
                 */
                GetWorldToLocalMatrix: function (bone, ia, ib, ic, id) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldToLocalMatrix", this ); }

                    var a = bone.a, b = bone.b, c = bone.c, d = bone.d;
                    var invDet = 1 / (a * d - b * c);
                    ia.v = invDet * d;
                    ib.v = invDet * -b;
                    ic.v = invDet * -c;
                    id.v = invDet * a;
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldToLocalMatrix:static end.*/

                /*Spine.Unity.SkeletonExtensions.WorldToLocal:static start.*/
                /**
                 * UnityEngine.Vector2 override of Bone.WorldToLocal. This converts a skeleton-space position into a bone local position.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone             
                 * @param   {UnityEngine.Vector2}    worldPosition
                 * @return  {UnityEngine.Vector2}
                 */
                WorldToLocal: function (bone, worldPosition) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#WorldToLocal", this ); }

                    var o = new UnityEngine.Vector2();
                    bone.WorldToLocal(worldPosition.x, worldPosition.y, Bridge.ref(o, "x"), Bridge.ref(o, "y"));
                    return o.$clone();
                },
                /*Spine.Unity.SkeletonExtensions.WorldToLocal:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetPositionSkeletonSpace:static start.*/
                /**
                 * Sets the skeleton-space position of a bone.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone                     
                 * @param   {UnityEngine.Vector2}    skeletonSpacePosition
                 * @return  {UnityEngine.Vector2}                             The local position in its parent bone space, or in skeleton space if it is the root bone.
                 */
                SetPositionSkeletonSpace: function (bone, skeletonSpacePosition) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetPositionSkeletonSpace", this ); }

                    if (bone.parent == null) { // root bone
                        Spine.Unity.SkeletonExtensions.SetLocalPosition(bone, skeletonSpacePosition.$clone());
                        return skeletonSpacePosition.$clone();
                    } else {
                        var parent = bone.parent;
                        var parentLocal = Spine.Unity.SkeletonExtensions.WorldToLocal(parent, skeletonSpacePosition.$clone());
                        Spine.Unity.SkeletonExtensions.SetLocalPosition(bone, parentLocal.$clone());
                        return parentLocal.$clone();
                    }
                },
                /*Spine.Unity.SkeletonExtensions.SetPositionSkeletonSpace:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetMaterial:static start.*/
                GetMaterial: function (a) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetMaterial", this ); }

                    var rendererObject = null;
                    var renderableAttachment = Bridge.as(a, Spine.IHasTextureRegion);
                    if (renderableAttachment != null) {
                        rendererObject = renderableAttachment.Spine$IHasTextureRegion$Region;
                    }

                    if (rendererObject == null) {
                        return null;
                    }

                    return Bridge.cast(Bridge.cast(rendererObject, Spine.AtlasRegion).page.rendererObject, UnityEngine.Material);
                },
                /*Spine.Unity.SkeletonExtensions.GetMaterial:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetLocalVertices:static start.*/
                /**
                 * Fills a Vector2 buffer with local vertices.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {spine.VertexAttachment}         va        The VertexAttachment
                 * @param   {Spine.Slot}                     slot      Slot where the attachment belongs.
                 * @param   {Array.<UnityEngine.Vector2>}    buffer    Correctly-sized buffer. Use attachment's .WorldVerticesLength to get the correct size. If null, a new Vector2[] of the correct size will be allocated.
                 * @return  {Array.<UnityEngine.Vector2>}
                 */
                GetLocalVertices: function (va, slot, buffer) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetLocalVertices", this ); }

                    var floatsCount = va.worldVerticesLength;
                    var bufferTargetSize = floatsCount >> 1;
                    buffer = buffer || System.Array.init(bufferTargetSize, function (){
                        return new UnityEngine.Vector2();
                    }, UnityEngine.Vector2);
                    if (buffer.length < bufferTargetSize) {
                        throw new System.ArgumentException.$ctor3(System.String.format("Vector2 buffer too small. {0} requires an array of size {1}. Use the attachment's .WorldVerticesLength to get the correct size.", va.name, Bridge.box(floatsCount, System.Int32)), "buffer");
                    }

                    if (va.bones == null && slot.Deform.Count === 0) {
                        var localVerts = va.vertices;
                        for (var i = 0; i < bufferTargetSize; i = (i + 1) | 0) {
                            var j = Bridge.Int.mul(i, 2);
                            buffer[i] = new pc.Vec2( localVerts[j], localVerts[((j + 1) | 0)] );
                        }
                    } else {
                        var floats = System.Array.init(floatsCount, 0, System.Single);
                        va.computeWorldVertices( slot, 0, va.worldVerticesLength, floats, 0, 2 );

                        var sb = slot.bone;
                        var ia = { }, ib = { }, ic = { }, id = { }, bwx = sb.worldX, bwy = sb.worldY;
                        Spine.Unity.SkeletonExtensions.GetWorldToLocalMatrix(sb, ia, ib, ic, id);

                        for (var i1 = 0; i1 < bufferTargetSize; i1 = (i1 + 1) | 0) {
                            var j1 = Bridge.Int.mul(i1, 2);
                            var x = floats[j1] - bwx, y = floats[((j1 + 1) | 0)] - bwy;
                            buffer[i1] = new pc.Vec2( x * ia.v + y * ib.v, x * ic.v + y * id.v );
                        }
                    }

                    return buffer;
                },
                /*Spine.Unity.SkeletonExtensions.GetLocalVertices:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldVertices:static start.*/
                /**
                 * Calculates world vertices and fills a Vector2 buffer.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {spine.VertexAttachment}         a         The VertexAttachment
                 * @param   {Spine.Slot}                     slot      Slot where the attachment belongs.
                 * @param   {Array.<UnityEngine.Vector2>}    buffer    Correctly-sized buffer. Use attachment's .WorldVerticesLength to get the correct size. If null, a new Vector2[] of the correct size will be allocated.
                 * @return  {Array.<UnityEngine.Vector2>}
                 */
                GetWorldVertices: function (a, slot, buffer) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldVertices", this ); }

                    var worldVertsLength = a.worldVerticesLength;
                    var bufferTargetSize = worldVertsLength >> 1;
                    buffer = buffer || System.Array.init(bufferTargetSize, function (){
                        return new UnityEngine.Vector2();
                    }, UnityEngine.Vector2);
                    if (buffer.length < bufferTargetSize) {
                        throw new System.ArgumentException.$ctor3(System.String.format("Vector2 buffer too small. {0} requires an array of size {1}. Use the attachment's .WorldVerticesLength to get the correct size.", a.name, Bridge.box(worldVertsLength, System.Int32)), "buffer");
                    }

                    var floats = System.Array.init(worldVertsLength, 0, System.Single);
                    a.computeWorldVertices( slot, 0, a.worldVerticesLength, floats, 0, 2 );

                    for (var i = 0, n = worldVertsLength >> 1; i < n; i = (i + 1) | 0) {
                        var j = Bridge.Int.mul(i, 2);
                        buffer[i] = new pc.Vec2( floats[j], floats[((j + 1) | 0)] );
                    }

                    return buffer;
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldVertices:static end.*/


            }
        }
    });
    /*Spine.Unity.SkeletonExtensions end.*/

    /*Spine.Unity.SkeletonGraphic+LayoutMode start.*/
    Bridge.define("Spine.Unity.SkeletonGraphic.LayoutMode", {
        $kind: 1006,
        statics: {
            fields: {
                None: 0,
                WidthControlsHeight: 1,
                HeightControlsWidth: 2,
                FitInParent: 3,
                EnvelopeParent: 4
            }
        }
    });
    /*Spine.Unity.SkeletonGraphic+LayoutMode end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials start.*/
    Bridge.define("Spine.Unity.SkeletonGraphicCustomMaterials", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonGraphic: null,
            customMaterialOverrides: null,
            customTextureOverrides: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#init", this ); }

                this.customMaterialOverrides = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride)).ctor();
                this.customTextureOverrides = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonGraphicCustomMaterials.SetCustomMaterialOverrides start.*/
            SetCustomMaterialOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#SetCustomMaterialOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                for (var i = 0; i < this.customMaterialOverrides.Count; i = (i + 1) | 0) {
                    var atlasMaterialOverride = this.customMaterialOverrides.getItem(i).$clone();
                    if (atlasMaterialOverride.overrideEnabled) {
                        this.skeletonGraphic.CustomMaterialOverride.setItem(atlasMaterialOverride.originalTexture, atlasMaterialOverride.replacementMaterial);
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.SetCustomMaterialOverrides end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.RemoveCustomMaterialOverrides start.*/
            RemoveCustomMaterialOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#RemoveCustomMaterialOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                for (var i = 0; i < this.customMaterialOverrides.Count; i = (i + 1) | 0) {
                    var atlasMaterialOverride = this.customMaterialOverrides.getItem(i).$clone();
                    var currentMaterial = { };

                    if (!this.skeletonGraphic.CustomMaterialOverride.tryGetValue(atlasMaterialOverride.originalTexture, currentMaterial)) {
                        continue;
                    }

                    // Do not revert the material if it was changed by something else
                    if (!Bridge.referenceEquals(currentMaterial.v, atlasMaterialOverride.replacementMaterial)) {
                        continue;
                    }

                    this.skeletonGraphic.CustomMaterialOverride.remove(atlasMaterialOverride.originalTexture);
                }
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.RemoveCustomMaterialOverrides end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.SetCustomTextureOverrides start.*/
            SetCustomTextureOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#SetCustomTextureOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                for (var i = 0; i < this.customTextureOverrides.Count; i = (i + 1) | 0) {
                    var atlasTextureOverride = this.customTextureOverrides.getItem(i).$clone();
                    if (atlasTextureOverride.overrideEnabled) {
                        this.skeletonGraphic.CustomTextureOverride.setItem(atlasTextureOverride.originalTexture, atlasTextureOverride.replacementTexture);
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.SetCustomTextureOverrides end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.RemoveCustomTextureOverrides start.*/
            RemoveCustomTextureOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#RemoveCustomTextureOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                for (var i = 0; i < this.customTextureOverrides.Count; i = (i + 1) | 0) {
                    var atlasTextureOverride = this.customTextureOverrides.getItem(i).$clone();
                    var currentTexture = { };

                    if (!this.skeletonGraphic.CustomTextureOverride.tryGetValue(atlasTextureOverride.originalTexture, currentTexture)) {
                        continue;
                    }

                    // Do not revert the material if it was changed by something else
                    if (!Bridge.referenceEquals(currentTexture.v, atlasTextureOverride.replacementTexture)) {
                        continue;
                    }

                    this.skeletonGraphic.CustomTextureOverride.remove(atlasTextureOverride.originalTexture);
                }
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.RemoveCustomTextureOverrides end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic = this.GetComponent(Spine.Unity.SkeletonGraphic);
                }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                this.skeletonGraphic.Initialize(false);
                this.SetCustomMaterialOverrides();
                this.SetCustomTextureOverrides();
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.OnEnable end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#OnDisable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                this.RemoveCustomMaterialOverrides();
                this.RemoveCustomTextureOverrides();
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.OnDisable end.*/


        }
    });
    /*Spine.Unity.SkeletonGraphicCustomMaterials end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride start.*/
    Bridge.define("Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride", {
        inherits: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#inherits", this ); }
 return [System.IEquatable$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride)]; },
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#getDefaultValue", this ); }
 return new Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride(); }
            }
        },
        fields: {
            overrideEnabled: false,
            originalTexture: null,
            replacementMaterial: null
        },
        alias: ["equalsT", "System$IEquatable$1$Spine$Unity$SkeletonGraphicCustomMaterials$AtlasMaterialOverride$equalsT"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride.equalsT start.*/
            equalsT: function (other) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#equalsT", this ); }

                return this.overrideEnabled === other.overrideEnabled && Bridge.referenceEquals(this.originalTexture, other.originalTexture) && Bridge.referenceEquals(this.replacementMaterial, other.replacementMaterial);
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride.equalsT end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#getHashCode", this ); }

                var h = Bridge.addHash([8608216668, this.overrideEnabled, this.originalTexture, this.replacementMaterial]);
                return h;
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#$clone", this ); }

                var s = to || new Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride();
                s.overrideEnabled = this.overrideEnabled;
                s.originalTexture = this.originalTexture;
                s.replacementMaterial = this.replacementMaterial;
                return s;
            }
        },
        overloads: {
            "Equals(AtlasMaterialOverride)": "equalsT"
        }
    });
    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride start.*/
    Bridge.define("Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride", {
        inherits: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#inherits", this ); }
 return [System.IEquatable$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride)]; },
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#getDefaultValue", this ); }
 return new Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride(); }
            }
        },
        fields: {
            overrideEnabled: false,
            originalTexture: null,
            replacementTexture: null
        },
        alias: ["equalsT", "System$IEquatable$1$Spine$Unity$SkeletonGraphicCustomMaterials$AtlasTextureOverride$equalsT"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride.equalsT start.*/
            equalsT: function (other) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#equalsT", this ); }

                return this.overrideEnabled === other.overrideEnabled && Bridge.referenceEquals(this.originalTexture, other.originalTexture) && Bridge.referenceEquals(this.replacementTexture, other.replacementTexture);
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride.equalsT end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#getHashCode", this ); }

                var h = Bridge.addHash([8976735721, this.overrideEnabled, this.originalTexture, this.replacementTexture]);
                return h;
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#$clone", this ); }

                var s = to || new Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride();
                s.overrideEnabled = this.overrideEnabled;
                s.originalTexture = this.originalTexture;
                s.replacementTexture = this.replacementTexture;
                return s;
            }
        },
        overloads: {
            "Equals(AtlasTextureOverride)": "equalsT"
        }
    });
    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator", {
        $kind: 1002,
        statics: {
            fields: {
                WeightEpsilon: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#init", this ); }

                    this.WeightEpsilon = 0.0001;
                }
            },
            methods: {
                /*Spine.Unity.SkeletonMecanim+MecanimTranslator.AnimationTime:static start.*/
                AnimationTime: function (normalizedTime, clipLength, loop, reversed) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#AnimationTime", this ); }

                    var time = Spine.Unity.SkeletonMecanim.MecanimTranslator.ToSpineAnimationTime(normalizedTime, clipLength, loop, reversed);
                    if (loop) {
                        return time;
                    }
                    var EndSnapEpsilon = 0.0333333351; // Workaround for end-duration keys not being applied.
                    return (clipLength - time < EndSnapEpsilon) ? clipLength : time; // return a time snapped to clipLength;
                },
                /*Spine.Unity.SkeletonMecanim+MecanimTranslator.AnimationTime:static end.*/

                /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ToSpineAnimationTime:static start.*/
                ToSpineAnimationTime: function (normalizedTime, clipLength, loop, reversed) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#ToSpineAnimationTime", this ); }

                    if (reversed) {
                        normalizedTime = (1 - normalizedTime);
                    }
                    if (normalizedTime < 0.0) {
                        normalizedTime = loop ? (normalizedTime % 1.0) + 1.0 : 0.0;
                    }
                    return normalizedTime * clipLength;
                },
                /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ToSpineAnimationTime:static end.*/


            }
        },
        fields: {
            autoReset: false,
            useCustomMixMode: false,
            layerMixModes: null,
            layerBlendModes: null,
            animationTable: null,
            clipNameHashCodeTable: null,
            previousAnimations: null,
            layerClipInfos: null,
            animator: null
        },
        events: {
            _OnClipApplied: null
        },
        props: {
            Animator: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#Animator#get", this ); }

                    return this.animator;
                }
            },
            MecanimLayerCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#MecanimLayerCount#get", this ); }

                    if (!UnityEngine.Object.op_Implicit(this.animator)) {
                        return 0;
                    }
                    return this.animator.layerCount;
                }
            },
            MecanimLayerNames: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#MecanimLayerNames#get", this ); }

                    if (!UnityEngine.Object.op_Implicit(this.animator)) {
                        return System.Array.init(0, null, System.String);
                    }
                    var layerNames = System.Array.init(this.animator.layerCount, null, System.String);
                    for (var i = 0; i < this.animator.layerCount; i = (i + 1) | 0) {
                        layerNames[i] = this.animator.GetLayerName(i);
                    }
                    return layerNames;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#init", this ); }

                this.autoReset = true;
                this.useCustomMixMode = true;
                this.layerMixModes = System.Array.init(0, 0, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode);
                this.layerBlendModes = System.Array.init(0, 0, spine.MixBlend);
                this.animationTable = new (System.Collections.Generic.Dictionary$2(System.Int32,Spine.Animation)).$ctor3(Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer.Instance);
                this.clipNameHashCodeTable = new (System.Collections.Generic.Dictionary$2(UnityEngine.AnimationClip,System.Int32)).$ctor3(Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer.Instance);
                this.previousAnimations = new (System.Collections.Generic.List$1(Spine.Animation)).ctor();
                this.layerClipInfos = System.Array.init(0, null, Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos);
            }
        },
        methods: {
            addOnClipApplied: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#addOnClipApplied", this ); }

                this.add_OnClipApplied(value);
            },
            removeOnClipApplied: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#removeOnClipApplied", this ); }

                this.remove_OnClipApplied(value);
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.Initialize start.*/
            Initialize: function (animator, skeletonDataAsset) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#Initialize", this ); }

                var $t;
                this.animator = animator;

                this.previousAnimations.clear();

                this.animationTable.clear();
                var data = skeletonDataAsset.GetSkeletonData(true);
                $t = Bridge.getEnumerator(data.Animations);
                try {
                    while ($t.moveNext()) {
                        var a = $t.Current;
                        this.animationTable.add(Bridge.getHashCode(a.name), a);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                this.clipNameHashCodeTable.clear();
                this.ClearClipInfosForLayers();
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.Initialize end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ApplyAnimation start.*/
            ApplyAnimation: function (skeleton, info, stateInfo, layerIndex, layerWeight, layerBlendMode, useClipWeight1) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#ApplyAnimation", this ); }

                if (useClipWeight1 === void 0) { useClipWeight1 = false; }
                var weight = info.weight * layerWeight;
                if (weight < Spine.Unity.SkeletonMecanim.MecanimTranslator.WeightEpsilon) {
                    return false;
                }

                var clip = this.GetAnimation(info.clip);
                if (clip == null) {
                    return false;
                }
                var time = Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationTime(stateInfo.normalizedTime, info.clip.length, info.clip.isLooping, stateInfo.speed < 0);
                weight = useClipWeight1 ? layerWeight : weight;
                clip.apply(skeleton, 0, time, info.clip.isLooping, null, weight, layerBlendMode, spine.MixDirection.mixIn);
                if (!Bridge.staticEquals(this._OnClipApplied, null)) {
                    this.OnClipAppliedCallback(clip, stateInfo, layerIndex, time, info.clip.isLooping, weight);
                }
                return true;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ApplyAnimation end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ApplyInterruptionAnimation start.*/
            ApplyInterruptionAnimation: function (skeleton, interpolateWeightTo1, info, stateInfo, layerIndex, layerWeight, layerBlendMode, interruptingClipTimeAddition, useClipWeight1) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#ApplyInterruptionAnimation", this ); }

                if (useClipWeight1 === void 0) { useClipWeight1 = false; }

                var clipWeight = interpolateWeightTo1 ? (info.weight + 1.0) * 0.5 : info.weight;
                var weight = clipWeight * layerWeight;
                if (weight < Spine.Unity.SkeletonMecanim.MecanimTranslator.WeightEpsilon) {
                    return false;
                }

                var clip = this.GetAnimation(info.clip);
                if (clip == null) {
                    return false;
                }

                var time = Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationTime(stateInfo.normalizedTime + interruptingClipTimeAddition, info.clip.length, info.clip.isLooping, stateInfo.speed < 0);
                weight = useClipWeight1 ? layerWeight : weight;
                clip.apply(skeleton, 0, time, info.clip.isLooping, null, weight, layerBlendMode, spine.MixDirection.mixIn);
                if (!Bridge.staticEquals(this._OnClipApplied, null)) {
                    this.OnClipAppliedCallback(clip, stateInfo, layerIndex, time, info.clip.isLooping, weight);
                }
                return true;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ApplyInterruptionAnimation end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.OnClipAppliedCallback start.*/
            OnClipAppliedCallback: function (clip, stateInfo, layerIndex, time, isLooping, weight) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#OnClipAppliedCallback", this ); }


                var speedFactor = stateInfo.speedMultiplier * stateInfo.speed;
                var lastTime = time - (UnityEngine.Time.deltaTime * speedFactor);
                var clipDuration = clip.duration;
                if (isLooping && clipDuration !== 0) {
                    time %= clipDuration;
                    lastTime %= clipDuration;
                }
                this._OnClipApplied(clip, layerIndex, weight, time, lastTime, speedFactor < 0);
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.OnClipAppliedCallback end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.Apply start.*/
            Apply: function (skeleton) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#Apply", this ); }


                if (this.layerMixModes.length < this.animator.layerCount) {
                    var oldSize = this.layerMixModes.length;
                    System.Array.resize(Bridge.ref(this, "layerMixModes"), this.animator.layerCount, 0, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode);
                    for (var layer = oldSize; layer < this.animator.layerCount; layer = (layer + 1) | 0) {
                        var isAdditiveLayer = false;
                        if (layer < this.layerBlendModes.length) {
                            isAdditiveLayer = this.layerBlendModes[layer] === spine.MixBlend.add;
                        }
                        this.layerMixModes[layer] = isAdditiveLayer ? Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.AlwaysMix : Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.MixNext;
                    }
                }

                this.InitClipInfosForLayers();
                for (var layer1 = 0, n = this.animator.layerCount; layer1 < n; layer1 = (layer1 + 1) | 0) {
                    this.GetStateUpdatesFromAnimator(layer1);
                }

                // Clear Previous
                if (this.autoReset) {
                    var previousAnimations = this.previousAnimations;
                    for (var i = 0, n1 = previousAnimations.Count; i < n1; i = (i + 1) | 0) {
                        previousAnimations.getItem(i).apply(skeleton, 0, 0, false, null, 0, spine.MixBlend.setup, spine.MixDirection.mixOut);
                    } // SetKeyedItemsToSetupPose

                    previousAnimations.clear();
                    for (var layer2 = 0, n2 = this.animator.layerCount; layer2 < n2; layer2 = (layer2 + 1) | 0) {
                        var layerWeight = (layer2 === 0) ? 1 : this.animator.GetLayerWeight(layer2); // Animator.GetLayerWeight always returns 0 on the first layer. Should be interpreted as 1.
                        if (layerWeight <= 0) {
                            continue;
                        }

                        var nextStateInfo = this.animator.GetNextAnimatorStateInfo(layer2);

                        var hasNext = nextStateInfo.fullPathHash !== 0;

                        var clipInfoCount = { }, nextClipInfoCount = { }, interruptingClipInfoCount = { };
                        var clipInfo = { }, nextClipInfo = { }, interruptingClipInfo = { };
                        var isInterruptionActive = { }, shallInterpolateWeightTo1 = { };
                        this.GetAnimatorClipInfos(layer2, isInterruptionActive, clipInfoCount, nextClipInfoCount, interruptingClipInfoCount, clipInfo, nextClipInfo, interruptingClipInfo, shallInterpolateWeightTo1);

                        for (var c = 0; c < clipInfoCount.v; c = (c + 1) | 0) {
                            var info = System.Array.getItem(clipInfo.v, c, UnityEngine.AnimatorClipInfo).$clone();
                            var weight = info.weight * layerWeight;
                            if (weight < Spine.Unity.SkeletonMecanim.MecanimTranslator.WeightEpsilon) {
                                continue;
                            }
                            var clip = this.GetAnimation(info.clip);
                            if (clip != null) {
                                previousAnimations.add(clip);
                            }
                        }

                        if (hasNext) {
                            for (var c1 = 0; c1 < nextClipInfoCount.v; c1 = (c1 + 1) | 0) {
                                var info1 = System.Array.getItem(nextClipInfo.v, c1, UnityEngine.AnimatorClipInfo).$clone();
                                var weight1 = info1.weight * layerWeight;
                                if (weight1 < Spine.Unity.SkeletonMecanim.MecanimTranslator.WeightEpsilon) {
                                    continue;
                                }
                                var clip1 = this.GetAnimation(info1.clip);
                                if (clip1 != null) {
                                    previousAnimations.add(clip1);
                                }
                            }
                        }

                        if (isInterruptionActive.v) {
                            for (var c2 = 0; c2 < interruptingClipInfoCount.v; c2 = (c2 + 1) | 0) {
                                var info2 = System.Array.getItem(interruptingClipInfo.v, c2, UnityEngine.AnimatorClipInfo).$clone();
                                var clipWeight = shallInterpolateWeightTo1.v ? (info2.weight + 1.0) * 0.5 : info2.weight;
                                var weight2 = clipWeight * layerWeight;
                                if (weight2 < Spine.Unity.SkeletonMecanim.MecanimTranslator.WeightEpsilon) {
                                    continue;
                                }
                                var clip2 = this.GetAnimation(info2.clip);
                                if (clip2 != null) {
                                    previousAnimations.add(clip2);
                                }
                            }
                        }
                    }
                }

                // Apply
                for (var layer3 = 0, n3 = this.animator.layerCount; layer3 < n3; layer3 = (layer3 + 1) | 0) {
                    var layerWeight1 = (layer3 === 0) ? 1 : this.animator.GetLayerWeight(layer3); // Animator.GetLayerWeight always returns 0 on the first layer. Should be interpreted as 1.

                    var isInterruptionActive1 = { };
                    var stateInfo = { };
                    var nextStateInfo1 = { };
                    var interruptingStateInfo = { };
                    var interruptingClipTimeAddition = { };
                    this.GetAnimatorStateInfos(layer3, isInterruptionActive1, stateInfo, nextStateInfo1, interruptingStateInfo, interruptingClipTimeAddition);

                    var hasNext1 = nextStateInfo1.v.fullPathHash !== 0;

                    var clipInfoCount1 = { }, nextClipInfoCount1 = { }, interruptingClipInfoCount1 = { };
                    var clipInfo1 = { }, nextClipInfo1 = { }, interruptingClipInfo1 = { };
                    var interpolateWeightTo1 = { };
                    this.GetAnimatorClipInfos(layer3, isInterruptionActive1, clipInfoCount1, nextClipInfoCount1, interruptingClipInfoCount1, clipInfo1, nextClipInfo1, interruptingClipInfo1, interpolateWeightTo1);

                    var layerBlendMode = (layer3 < this.layerBlendModes.length) ? this.layerBlendModes[layer3] : spine.MixBlend.replace;
                    var mode = this.GetMixMode(layer3, layerBlendMode);
                    if (mode === Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.AlwaysMix) {
                        // Always use Mix instead of Applying the first non-zero weighted clip.
                        for (var c3 = 0; c3 < clipInfoCount1.v; c3 = (c3 + 1) | 0) {
                            this.ApplyAnimation(skeleton, System.Array.getItem(clipInfo1.v, c3, UnityEngine.AnimatorClipInfo), stateInfo.v, layer3, layerWeight1, layerBlendMode);
                        }
                        if (hasNext1) {
                            for (var c4 = 0; c4 < nextClipInfoCount1.v; c4 = (c4 + 1) | 0) {
                                this.ApplyAnimation(skeleton, System.Array.getItem(nextClipInfo1.v, c4, UnityEngine.AnimatorClipInfo), nextStateInfo1.v, layer3, layerWeight1, layerBlendMode);
                            }
                        }
                        if (isInterruptionActive1.v) {
                            for (var c5 = 0; c5 < interruptingClipInfoCount1.v; c5 = (c5 + 1) | 0) {
                                this.ApplyInterruptionAnimation(skeleton, interpolateWeightTo1.v, System.Array.getItem(interruptingClipInfo1.v, c5, UnityEngine.AnimatorClipInfo), interruptingStateInfo.v, layer3, layerWeight1, layerBlendMode, interruptingClipTimeAddition.v);
                            }
                        }
                    } else { // case MixNext || Hard
                        // Apply first non-zero weighted clip
                        var c6 = 0;
                        for (; c6 < clipInfoCount1.v; c6 = (c6 + 1) | 0) {
                            if (!this.ApplyAnimation(skeleton, System.Array.getItem(clipInfo1.v, c6, UnityEngine.AnimatorClipInfo), stateInfo.v, layer3, layerWeight1, layerBlendMode, true)) {
                                continue;
                            }
                            c6 = (c6 + 1) | 0;
                            break;
                        }
                        // Mix the rest
                        for (; c6 < clipInfoCount1.v; c6 = (c6 + 1) | 0) {
                            this.ApplyAnimation(skeleton, System.Array.getItem(clipInfo1.v, c6, UnityEngine.AnimatorClipInfo), stateInfo.v, layer3, layerWeight1, layerBlendMode);
                        }

                        c6 = 0;
                        if (hasNext1) {
                            // Apply next clip directly instead of mixing (ie: no crossfade, ignores mecanim transition weights)
                            if (mode === Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.Hard) {
                                for (; c6 < nextClipInfoCount1.v; c6 = (c6 + 1) | 0) {
                                    if (!this.ApplyAnimation(skeleton, System.Array.getItem(nextClipInfo1.v, c6, UnityEngine.AnimatorClipInfo), nextStateInfo1.v, layer3, layerWeight1, layerBlendMode, true)) {
                                        continue;
                                    }
                                    c6 = (c6 + 1) | 0;
                                    break;
                                }
                            }
                            // Mix the rest
                            for (; c6 < nextClipInfoCount1.v; c6 = (c6 + 1) | 0) {
                                if (!this.ApplyAnimation(skeleton, System.Array.getItem(nextClipInfo1.v, c6, UnityEngine.AnimatorClipInfo), nextStateInfo1.v, layer3, layerWeight1, layerBlendMode)) {
                                    continue;
                                }
                            }
                        }

                        c6 = 0;
                        if (isInterruptionActive1.v) {
                            // Apply next clip directly instead of mixing (ie: no crossfade, ignores mecanim transition weights)
                            if (mode === Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.Hard) {
                                for (; c6 < interruptingClipInfoCount1.v; c6 = (c6 + 1) | 0) {
                                    if (this.ApplyInterruptionAnimation(skeleton, interpolateWeightTo1.v, System.Array.getItem(interruptingClipInfo1.v, c6, UnityEngine.AnimatorClipInfo), interruptingStateInfo.v, layer3, layerWeight1, layerBlendMode, interruptingClipTimeAddition.v, true)) {

                                        c6 = (c6 + 1) | 0;
                                        break;
                                    }
                                }
                            }
                            // Mix the rest
                            for (; c6 < interruptingClipInfoCount1.v; c6 = (c6 + 1) | 0) {
                                this.ApplyInterruptionAnimation(skeleton, interpolateWeightTo1.v, System.Array.getItem(interruptingClipInfo1.v, c6, UnityEngine.AnimatorClipInfo), interruptingStateInfo.v, layer3, layerWeight1, layerBlendMode, interruptingClipTimeAddition.v);
                            }
                        }
                    }
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.Apply end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetActiveAnimationAndTime start.*/
            GetActiveAnimationAndTime: function (layer) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetActiveAnimationAndTime", this ); }

                if (layer >= this.layerClipInfos.length) {
                    return new (System.Collections.Generic.KeyValuePair$2(Spine.Animation,System.Single)).$ctor1(null, 0);
                }

                var layerInfos = this.layerClipInfos[layer];
                var isInterruptionActive = layerInfos.isInterruptionActive;
                var clip = null;
                var animation = null;
                var stateInfo;
                if (isInterruptionActive && layerInfos.interruptingClipInfoCount > 0) {
                    clip = layerInfos.interruptingClipInfos.getItem(0).$clone().clip;
                    stateInfo = layerInfos.interruptingStateInfo;
                } else {
                    clip = layerInfos.clipInfos.getItem(0).$clone().clip;
                    stateInfo = layerInfos.stateInfo;
                }
                animation = this.GetAnimation(clip);
                var time = Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationTime(stateInfo.normalizedTime, clip.length, clip.isLooping, stateInfo.speed < 0);
                return new (System.Collections.Generic.KeyValuePair$2(Spine.Animation,System.Single)).$ctor1(animation, time);
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetActiveAnimationAndTime end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.InitClipInfosForLayers start.*/
            InitClipInfosForLayers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#InitClipInfosForLayers", this ); }

                if (this.layerClipInfos.length < this.animator.layerCount) {
                    System.Array.resize(Bridge.ref(this, "layerClipInfos"), this.animator.layerCount, null, Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos);
                    for (var layer = 0, n = this.animator.layerCount; layer < n; layer = (layer + 1) | 0) {
                        if (this.layerClipInfos[layer] == null) {
                            this.layerClipInfos[layer] = new Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos();
                        }
                    }
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.InitClipInfosForLayers end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ClearClipInfosForLayers start.*/
            ClearClipInfosForLayers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#ClearClipInfosForLayers", this ); }

                for (var layer = 0, n = this.layerClipInfos.length; layer < n; layer = (layer + 1) | 0) {
                    if (this.layerClipInfos[layer] == null) {
                        this.layerClipInfos[layer] = new Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos();
                    } else {
                        this.layerClipInfos[layer].isInterruptionActive = false;
                        this.layerClipInfos[layer].isLastFrameOfInterruption = false;
                        this.layerClipInfos[layer].clipInfos.clear();
                        this.layerClipInfos[layer].nextClipInfos.clear();
                        this.layerClipInfos[layer].interruptingClipInfos.clear();
                    }
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ClearClipInfosForLayers end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetMixMode start.*/
            GetMixMode: function (layer, layerBlendMode) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetMixMode", this ); }

                if (this.useCustomMixMode) {
                    var mode = this.layerMixModes[layer];
                    // Note: at additive blending it makes no sense to use constant weight 1 at a fadeout anim add1 as
                    // with override layers, so we use AlwaysMix instead to use the proper weights.
                    // AlwaysMix leads to the expected result = lower_layer + lerp(add1, add2, transition_weight).
                    if (layerBlendMode === spine.MixBlend.add && mode === Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.MixNext) {
                        mode = Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.AlwaysMix;
                        this.layerMixModes[layer] = mode;
                    }
                    return mode;
                } else {
                    return layerBlendMode === spine.MixBlend.add ? Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.AlwaysMix : Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.MixNext;
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetMixMode end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetStateUpdatesFromAnimator start.*/
            GetStateUpdatesFromAnimator: function (layer) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetStateUpdatesFromAnimator", this ); }


                var layerInfos = this.layerClipInfos[layer];
                var clipInfoCount = this.animator.GetCurrentAnimatorClipInfoCount(layer);
                var nextClipInfoCount = this.animator.GetNextAnimatorClipInfoCount(layer);

                var clipInfos = layerInfos.clipInfos;
                var nextClipInfos = layerInfos.nextClipInfos;
                var interruptingClipInfos = layerInfos.interruptingClipInfos;

                layerInfos.isInterruptionActive = (clipInfoCount === 0 && clipInfos.Count !== 0 && nextClipInfoCount === 0 && nextClipInfos.Count !== 0);

                // Note: during interruption, GetCurrentAnimatorClipInfoCount and GetNextAnimatorClipInfoCount
                // are returning 0 in calls above. Therefore we keep previous clipInfos and nextClipInfos
                // until the interruption is over.
                if (layerInfos.isInterruptionActive) {

                    // Note: The last frame of a transition interruption
                    // will have fullPathHash set to 0, therefore we have to use previous
                    // frame's infos about interruption clips and correct some values
                    // accordingly (normalizedTime and weight).
                    var interruptingStateInfo = this.animator.GetNextAnimatorStateInfo(layer);
                    layerInfos.isLastFrameOfInterruption = interruptingStateInfo.fullPathHash === 0;
                    if (!layerInfos.isLastFrameOfInterruption) {
                        this.animator.GetNextAnimatorClipInfo(layer, interruptingClipInfos);
                        layerInfos.interruptingClipInfoCount = interruptingClipInfos.Count;
                        var oldTime = layerInfos.interruptingStateInfo.normalizedTime;
                        var newTime = interruptingStateInfo.normalizedTime;
                        layerInfos.interruptingClipTimeAddition = newTime - oldTime;
                        layerInfos.interruptingStateInfo = interruptingStateInfo;
                    }
                } else {
                    layerInfos.clipInfoCount = clipInfoCount;
                    layerInfos.nextClipInfoCount = nextClipInfoCount;
                    layerInfos.interruptingClipInfoCount = 0;
                    layerInfos.isLastFrameOfInterruption = false;

                    if (clipInfos.Capacity < clipInfoCount) {
                        clipInfos.Capacity = clipInfoCount;
                    }
                    if (nextClipInfos.Capacity < nextClipInfoCount) {
                        nextClipInfos.Capacity = nextClipInfoCount;
                    }

                    this.animator.GetCurrentAnimatorClipInfo(layer, clipInfos);
                    this.animator.GetNextAnimatorClipInfo(layer, nextClipInfos);

                    layerInfos.stateInfo = this.animator.GetCurrentAnimatorStateInfo(layer);
                    layerInfos.nextStateInfo = this.animator.GetNextAnimatorStateInfo(layer);
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetStateUpdatesFromAnimator end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimatorClipInfos start.*/
            GetAnimatorClipInfos: function (layer, isInterruptionActive, clipInfoCount, nextClipInfoCount, interruptingClipInfoCount, clipInfo, nextClipInfo, interruptingClipInfo, shallInterpolateWeightTo1) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimatorClipInfos", this ); }


                var layerInfos = this.layerClipInfos[layer];
                isInterruptionActive.v = layerInfos.isInterruptionActive;

                clipInfoCount.v = layerInfos.clipInfoCount;
                nextClipInfoCount.v = layerInfos.nextClipInfoCount;
                interruptingClipInfoCount.v = layerInfos.interruptingClipInfoCount;

                clipInfo.v = layerInfos.clipInfos;
                nextClipInfo.v = layerInfos.nextClipInfos;
                interruptingClipInfo.v = isInterruptionActive.v ? layerInfos.interruptingClipInfos : null;
                shallInterpolateWeightTo1.v = layerInfos.isLastFrameOfInterruption;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimatorClipInfos end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimatorStateInfos start.*/
            GetAnimatorStateInfos: function (layer, isInterruptionActive, stateInfo, nextStateInfo, interruptingStateInfo, interruptingClipTimeAddition) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimatorStateInfos", this ); }


                var layerInfos = this.layerClipInfos[layer];
                isInterruptionActive.v = layerInfos.isInterruptionActive;

                stateInfo.v = layerInfos.stateInfo;
                nextStateInfo.v = layerInfos.nextStateInfo;
                interruptingStateInfo.v = layerInfos.interruptingStateInfo;
                interruptingClipTimeAddition.v = layerInfos.isLastFrameOfInterruption ? layerInfos.interruptingClipTimeAddition : 0;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimatorStateInfos end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimation start.*/
            GetAnimation: function (clip) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimation", this ); }

                var clipNameHashCode = { };
                if (!this.clipNameHashCodeTable.tryGetValue(clip, clipNameHashCode)) {
                    clipNameHashCode.v = Bridge.getHashCode(clip.name);
                    this.clipNameHashCodeTable.add(clip, clipNameHashCode.v);
                }
                var animation = { };
                this.animationTable.tryGetValue(clipNameHashCode.v, animation);
                return animation.v;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimation end.*/


        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer", {
        inherits: [System.Collections.Generic.IEqualityComparer$1(UnityEngine.AnimationClip)],
        $kind: 1002,
        statics: {
            fields: {
                Instance: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#init", this ); }

                    this.Instance = new Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer();
                }
            }
        },
        alias: [
            "equals2", ["System$Collections$Generic$IEqualityComparer$1$UnityEngine$AnimationClip$equals2", "System$Collections$Generic$IEqualityComparer$1$equals2"],
            "getHashCode2", ["System$Collections$Generic$IEqualityComparer$1$UnityEngine$AnimationClip$getHashCode2", "System$Collections$Generic$IEqualityComparer$1$getHashCode2"]
        ],
        methods: {
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer.equals2 start.*/
            equals2: function (x, y) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#equals2", this ); }

                return x.GetInstanceID() === y.GetInstanceID();
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer.equals2 end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer.getHashCode2 start.*/
            getHashCode2: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#getHashCode2", this ); }

                return o.GetInstanceID();
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer.getHashCode2 end.*/


        },
        overloads: {
            "Equals(AnimationClip, AnimationClip)": "equals2",
            "GetHashCode(AnimationClip)": "getHashCode2"
        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+ClipInfos start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos", {
        $kind: 1002,
        fields: {
            isInterruptionActive: false,
            isLastFrameOfInterruption: false,
            clipInfoCount: 0,
            nextClipInfoCount: 0,
            interruptingClipInfoCount: 0,
            clipInfos: null,
            nextClipInfos: null,
            interruptingClipInfos: null,
            stateInfo: null,
            nextStateInfo: null,
            interruptingStateInfo: null,
            interruptingClipTimeAddition: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos#init", this ); }

                this.isInterruptionActive = false;
                this.isLastFrameOfInterruption = false;
                this.clipInfoCount = 0;
                this.nextClipInfoCount = 0;
                this.interruptingClipInfoCount = 0;
                this.clipInfos = new (System.Collections.Generic.List$1(UnityEngine.AnimatorClipInfo)).ctor();
                this.nextClipInfos = new (System.Collections.Generic.List$1(UnityEngine.AnimatorClipInfo)).ctor();
                this.interruptingClipInfos = new (System.Collections.Generic.List$1(UnityEngine.AnimatorClipInfo)).ctor();
                this.interruptingClipTimeAddition = 0;
            }
        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+ClipInfos end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer", {
        inherits: [System.Collections.Generic.IEqualityComparer$1(System.Int32)],
        $kind: 1002,
        statics: {
            fields: {
                Instance: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#init", this ); }

                    this.Instance = new Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer();
                }
            }
        },
        alias: [
            "equals2", ["System$Collections$Generic$IEqualityComparer$1$System$Int32$equals2", "System$Collections$Generic$IEqualityComparer$1$equals2"],
            "getHashCode2", ["System$Collections$Generic$IEqualityComparer$1$System$Int32$getHashCode2", "System$Collections$Generic$IEqualityComparer$1$getHashCode2"]
        ],
        methods: {
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer.equals2 start.*/
            equals2: function (x, y) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#equals2", this ); }

                return x === y;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer.equals2 end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer.getHashCode2 start.*/
            getHashCode2: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#getHashCode2", this ); }

                return o;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer.getHashCode2 end.*/


        },
        overloads: {
            "Equals(int, int)": "equals2",
            "GetHashCode(int)": "getHashCode2"
        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+MixMode start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode", {
        $kind: 1006,
        statics: {
            fields: {
                AlwaysMix: 0,
                MixNext: 1,
                Hard: 2
            }
        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+MixMode end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonRootMotionBase.RootMotionDelegate
     * @param   {Spine.Unity.SkeletonRootMotionBase}    component      
     * @param   {UnityEngine.Vector2}                   translation    
     * @param   {number}                                rotation
     * @return  {void}
     */


    /*Spine.Unity.SkeletonRootMotionBase start.*/
    /**
     * Base class for skeleton root motion components.
     *
     * @abstract
     * @public
     * @class Spine.Unity.SkeletonRootMotionBase
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.SkeletonRootMotionBase", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            rootMotionBoneName: null,
            transformPositionX: false,
            transformPositionY: false,
            transformRotation: false,
            rootMotionScaleX: 0,
            rootMotionScaleY: 0,
            rootMotionScaleRotation: 0,
            /**
             * Skeleton space X translation per skeleton space Y translation root motion.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @default 0
             * @type number
             */
            rootMotionTranslateXPerY: 0,
            /**
             * Skeleton space Y translation per skeleton space X translation root motion.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @default 0
             * @type number
             */
            rootMotionTranslateYPerX: 0,
            rigidBody2D: null,
            applyRigidbody2DGravity: false,
            rigidBody: null,
            /**
             * When true, root-motion is not applied to the Transform or Rigidbody.
             Otherwise the delegate callbacks are issued additionally.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @default true
             * @type boolean
             */
            disableOnOverride: false,
            skeletonComponent: null,
            rootMotionBone: null,
            rootMotionBoneIndex: 0,
            transformConstraintIndices: null,
            transformConstraintLastPos: null,
            transformConstraintLastRotation: null,
            topLevelBones: null,
            initialOffset: null,
            accumulatedUntilFixedUpdate: false,
            tempSkeletonDisplacement: null,
            rigidbodyDisplacement: null,
            previousRigidbodyRootMotion: null,
            additionalRigidbody2DMovement: null,
            rigidbodyLocalRotation: null,
            rigidbody2DRotation: 0,
            initialOffsetRotation: 0,
            tempSkeletonRotation: 0
        },
        events: {
            /**
             * This callback can be used to apply root-motion in a custom way. It is raised after evaluating
             this animation frame's root-motion, before it is potentially applied (see {@link })
             to either Transform or Rigidbody.
             When {@link } is set to {@link }, multiple
             animation frames might take place before <pre><code>FixedUpdate</code></pre> is called once.
             The callback parameters <pre><code>translation</code></pre> and <pre><code>rotation</code></pre> are filled out with
             this animation frame's skeleton-space root-motion (not cumulated). You can use
             e.g. <pre><code>transform.TransformVector()</code></pre> to transform skeleton-space root-motion to world space.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRootMotionBase
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @function addProcessRootMotionOverride
             * @param   {Spine.Unity.SkeletonRootMotionBase.RootMotionDelegate}    value
             * @return  {void}
             * @see {@link PhysicsUpdateRootMotionOverride}
             */
            /**
             * This callback can be used to apply root-motion in a custom way. It is raised after evaluating
             this animation frame's root-motion, before it is potentially applied (see {@link })
             to either Transform or Rigidbody.
             When {@link } is set to {@link }, multiple
             animation frames might take place before <pre><code>FixedUpdate</code></pre> is called once.
             The callback parameters <pre><code>translation</code></pre> and <pre><code>rotation</code></pre> are filled out with
             this animation frame's skeleton-space root-motion (not cumulated). You can use
             e.g. <pre><code>transform.TransformVector()</code></pre> to transform skeleton-space root-motion to world space.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRootMotionBase
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @function removeProcessRootMotionOverride
             * @param   {Spine.Unity.SkeletonRootMotionBase.RootMotionDelegate}    value
             * @return  {void}
             * @see {@link PhysicsUpdateRootMotionOverride}
             */
            ProcessRootMotionOverride: null,
            /**
             * This callback can be used to apply root-motion in a custom way. It is raised in FixedUpdate
             after (when {@link } is set to false) or instead of when root-motion
             would be applied at the Rigidbody.
             When {@link } is set to {@link }, multiple
             animation frames might take place before before <pre><code>FixedUpdate</code></pre> is called once.
             The callback parameters <pre><code>translation</code></pre> and <pre><code>rotation</code></pre> are filled out with the
             (cumulated) skeleton-space root-motion since the the last <pre><code>FixedUpdate</code></pre> call. You can use
             e.g. <pre><code>transform.TransformVector()</code></pre> to transform skeleton-space root-motion to world space.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRootMotionBase
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @function addPhysicsUpdateRootMotionOverride
             * @param   {Spine.Unity.SkeletonRootMotionBase.RootMotionDelegate}    value
             * @return  {void}
             * @see {@link ProcessRootMotionOverride}
             */
            /**
             * This callback can be used to apply root-motion in a custom way. It is raised in FixedUpdate
             after (when {@link } is set to false) or instead of when root-motion
             would be applied at the Rigidbody.
             When {@link } is set to {@link }, multiple
             animation frames might take place before before <pre><code>FixedUpdate</code></pre> is called once.
             The callback parameters <pre><code>translation</code></pre> and <pre><code>rotation</code></pre> are filled out with the
             (cumulated) skeleton-space root-motion since the the last <pre><code>FixedUpdate</code></pre> call. You can use
             e.g. <pre><code>transform.TransformVector()</code></pre> to transform skeleton-space root-motion to world space.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRootMotionBase
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @function removePhysicsUpdateRootMotionOverride
             * @param   {Spine.Unity.SkeletonRootMotionBase.RootMotionDelegate}    value
             * @return  {void}
             * @see {@link ProcessRootMotionOverride}
             */
            PhysicsUpdateRootMotionOverride: null
        },
        props: {
            RootMotionBone: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#RootMotionBone#get", this ); }

                    return this.rootMotionBone;
                }
            },
            UsesRigidbody: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#UsesRigidbody#get", this ); }

                    return UnityEngine.Component.op_Inequality(this.rigidBody, null) || UnityEngine.Component.op_Inequality(this.rigidBody2D, null);
                }
            },
            /**
             * Root motion translation that has been applied in the preceding <pre><code>FixedUpdate</code></pre> call
             if a rigidbody is assigned at either <pre><code>rigidbody</code></pre> or <pre><code>rigidbody2D</code></pre>.
             Returns <pre><code>Vector2.zero</code></pre> when <pre><code>rigidbody</code></pre> and <pre><code>rigidbody2D</code></pre> are null.
             This can be necessary when multiple scripts call <pre><code>Rigidbody2D.MovePosition</code></pre>,
             where the last call overwrites the effect of preceding ones.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @function PreviousRigidbodyRootMotion2D
             * @type UnityEngine.Vector2
             */
            PreviousRigidbodyRootMotion2D: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#PreviousRigidbodyRootMotion2D#get", this ); }

                    return new pc.Vec2( this.previousRigidbodyRootMotion.x, this.previousRigidbodyRootMotion.y );
                }
            },
            /**
             * Root motion translation that has been applied in the preceding <pre><code>FixedUpdate</code></pre> call
             if a rigidbody is assigned at either <pre><code>rigidbody</code></pre> or <pre><code>rigidbody2D</code></pre>.
             Returns <pre><code>Vector3.zero</code></pre> when <pre><code>rigidbody</code></pre> and <pre><code>rigidbody2D</code></pre> are null.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @function PreviousRigidbodyRootMotion3D
             * @type UnityEngine.Vector3
             */
            PreviousRigidbodyRootMotion3D: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#PreviousRigidbodyRootMotion3D#get", this ); }

                    return this.previousRigidbodyRootMotion.$clone();
                }
            },
            /**
             * Additional translation to add to <pre><code>Rigidbody2D.MovePosition</code></pre>
             called in FixedUpdate. This can be necessary when multiple scripts call
             <pre><code>MovePosition</code></pre>, where the last call overwrites the effect of preceding ones.
             Has no effect if <pre><code>rigidBody2D</code></pre> is null.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @function AdditionalRigidbody2DMovement
             * @type UnityEngine.Vector2
             */
            AdditionalRigidbody2DMovement: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#AdditionalRigidbody2DMovement#get", this ); }

                    return this.additionalRigidbody2DMovement.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#AdditionalRigidbody2DMovement#set", this ); }

                    this.additionalRigidbody2DMovement = value.$clone();
                }
            },
            SkeletonAnimationUsesFixedUpdate: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#SkeletonAnimationUsesFixedUpdate#get", this ); }

                    var skeletonAnimation = Bridge.as(this.skeletonComponent, Spine.Unity.ISkeletonAnimation);
                    if (skeletonAnimation != null) {
                        return skeletonAnimation.Spine$Unity$ISkeletonAnimation$UpdateTiming === Spine.Unity.UpdateTiming.InFixedUpdate;
                    }
                    return false;
                }
            },
            AdditionalScale: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#AdditionalScale#get", this ); }

                    return 1.0;
                }
            },
            TargetSkeletonComponent: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#TargetSkeletonComponent#get", this ); }

                    if (this.skeletonComponent == null) {
                        this.skeletonComponent = this.GetComponent(Spine.Unity.ISkeletonComponent);
                    }
                    return this.skeletonComponent;
                }
            },
            TargetSkeletonAnimationComponent: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#TargetSkeletonAnimationComponent#get", this ); }

                    return Bridge.as(this.TargetSkeletonComponent, Spine.Unity.ISkeletonAnimation);
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#init", this ); }

                this.initialOffset = new UnityEngine.Vector2();
                this.tempSkeletonDisplacement = new UnityEngine.Vector2();
                this.rigidbodyDisplacement = new UnityEngine.Vector3();
                this.previousRigidbodyRootMotion = new UnityEngine.Vector3();
                this.additionalRigidbody2DMovement = new UnityEngine.Vector2();
                this.rigidbodyLocalRotation = new UnityEngine.Quaternion();
                this.rootMotionBoneName = "root";
                this.transformPositionX = true;
                this.transformPositionY = true;
                this.transformRotation = false;
                this.rootMotionScaleX = 1;
                this.rootMotionScaleY = 1;
                this.rootMotionScaleRotation = 1;
                this.rootMotionTranslateXPerY = 0;
                this.rootMotionTranslateYPerX = 0;
                this.applyRigidbody2DGravity = false;
                this.disableOnOverride = true;
                this.transformConstraintIndices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                this.transformConstraintLastPos = new (System.Collections.Generic.List$1(UnityEngine.Vector2)).ctor();
                this.transformConstraintLastRotation = new (System.Collections.Generic.List$1(System.Single)).ctor();
                this.topLevelBones = new (System.Collections.Generic.List$1(Spine.Bone)).ctor();
                this.initialOffset = pc.Vec2.ZERO.clone();
                this.accumulatedUntilFixedUpdate = false;
                this.previousRigidbodyRootMotion = UnityEngine.Vector3.FromVector2(pc.Vec2.ZERO.clone());
                this.additionalRigidbody2DMovement = pc.Vec2.ZERO.clone();
                this.rigidbodyLocalRotation = pc.Quat.IDENTITY.clone();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRootMotionBase.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#Reset", this ); }

                this.FindRigidbodyComponent();
            },
            /*Spine.Unity.SkeletonRootMotionBase.Reset end.*/

            /*Spine.Unity.SkeletonRootMotionBase.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#Start", this ); }

                this.skeletonComponent = this.GetComponent(Spine.Unity.ISkeletonComponent);
                this.GatherTopLevelBones();
                this.SetRootMotionBone(this.rootMotionBoneName);
                if (this.rootMotionBone != null) {
                    this.initialOffset = new pc.Vec2( this.rootMotionBone.x, this.rootMotionBone.y );
                    this.initialOffsetRotation = this.rootMotionBone.rotation;
                }

                var skeletonAnimation = Bridge.as(this.skeletonComponent, Spine.Unity.ISkeletonAnimation);
                if (skeletonAnimation != null) {
                    skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateLocal(Bridge.fn.cacheBind(this, this.HandleUpdateLocal));
                    skeletonAnimation.Spine$Unity$ISkeletonAnimation$addUpdateLocal(Bridge.fn.cacheBind(this, this.HandleUpdateLocal));
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.Start end.*/

            /*Spine.Unity.SkeletonRootMotionBase.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#FixedUpdate", this ); }

                // Root motion is only applied when component is enabled.
                if (!this.isActiveAndEnabled) {
                    return;
                }
                // When SkeletonAnimation component uses UpdateTiming.InFixedUpdate,
                // we directly call PhysicsUpdate in HandleUpdateLocal instead of here.
                if (!this.SkeletonAnimationUsesFixedUpdate) {
                    this.PhysicsUpdate(false);
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.FixedUpdate end.*/

            /*Spine.Unity.SkeletonRootMotionBase.PhysicsUpdate start.*/
            PhysicsUpdate: function (skeletonAnimationUsesFixedUpdate) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#PhysicsUpdate", this ); }

                var callbackDisplacement = this.tempSkeletonDisplacement.$clone();
                var callbackRotation = this.tempSkeletonRotation;

                var isApplyAtRigidbodyAllowed = Bridge.staticEquals(this.PhysicsUpdateRootMotionOverride, null) || !this.disableOnOverride;
                if (isApplyAtRigidbodyAllowed) {
                    if (UnityEngine.Component.op_Inequality(this.rigidBody2D, null)) {
                        var gravityAndVelocityMovement = pc.Vec2.ZERO.clone();
                        if (this.applyRigidbody2DGravity) {
                            var deltaTime = UnityEngine.Time.fixedDeltaTime;
                            var deltaTimeSquared = (deltaTime * deltaTime);

                            this.rigidBody2D.velocity = this.rigidBody2D.velocity.$clone().add( UnityEngine.Physics2D.gravity.$clone().scale( this.rigidBody2D.gravityScale ).scale( deltaTime ) );
                            gravityAndVelocityMovement = UnityEngine.Physics2D.gravity.$clone().scale( 0.5 * this.rigidBody2D.gravityScale ).scale( deltaTimeSquared ).add( this.rigidBody2D.velocity.$clone().scale( deltaTime ) );
                        }

                        var rigidbodyDisplacement2D = new pc.Vec2( this.rigidbodyDisplacement.x, this.rigidbodyDisplacement.y );
                        this.rigidBody2D.MovePosition(gravityAndVelocityMovement.$clone().add( new pc.Vec2( this.rigidBody2D.position.x, this.rigidBody2D.position.y ) ).add( rigidbodyDisplacement2D ).add( this.additionalRigidbody2DMovement ));
                        this.rigidBody2D.MoveRotation(this.rigidbody2DRotation + this.rigidBody2D.rotation);
                    } else if (UnityEngine.Component.op_Inequality(this.rigidBody, null)) {
                        this.rigidBody.MovePosition(this.rigidBody.position.$clone().add( new pc.Vec3( this.rigidbodyDisplacement.x, this.rigidbodyDisplacement.y, this.rigidbodyDisplacement.z ) ));
                        this.rigidBody.MoveRotation(this.rigidBody.rotation.clone().mul( this.rigidbodyLocalRotation ));
                    }
                }

                this.previousRigidbodyRootMotion = this.rigidbodyDisplacement.$clone();
                if (this.accumulatedUntilFixedUpdate) {
                    var parentBoneScale = { v : new UnityEngine.Vector2() };
                    this.GetScaleAffectingRootMotion$1(parentBoneScale);
                    this.ClearEffectiveBoneOffsets(parentBoneScale.v);
                    this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.updateWorldTransform();
                }
                this.ClearRigidbodyTempMovement();

                if (!Bridge.staticEquals(this.PhysicsUpdateRootMotionOverride, null)) {
                    this.PhysicsUpdateRootMotionOverride(this, callbackDisplacement.$clone(), callbackRotation);
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.PhysicsUpdate end.*/

            /*Spine.Unity.SkeletonRootMotionBase.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#OnDisable", this ); }

                this.ClearRigidbodyTempMovement();
            },
            /*Spine.Unity.SkeletonRootMotionBase.OnDisable end.*/

            /*Spine.Unity.SkeletonRootMotionBase.FindRigidbodyComponent start.*/
            FindRigidbodyComponent: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#FindRigidbodyComponent", this ); }

                this.rigidBody2D = this.GetComponent(UnityEngine.Rigidbody2D);
                if (!UnityEngine.Object.op_Implicit(this.rigidBody2D)) {
                    this.rigidBody = this.GetComponent(UnityEngine.Rigidbody);
                }

                if (!UnityEngine.Object.op_Implicit(this.rigidBody2D) && !UnityEngine.Object.op_Implicit(this.rigidBody)) {
                    this.rigidBody2D = this.GetComponentInParent(UnityEngine.Rigidbody2D);
                    if (!UnityEngine.Object.op_Implicit(this.rigidBody2D)) {
                        this.rigidBody = this.GetComponentInParent(UnityEngine.Rigidbody);
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.FindRigidbodyComponent end.*/

            /*Spine.Unity.SkeletonRootMotionBase.CalculateAnimationsRotationDelta start.*/
            CalculateAnimationsRotationDelta: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#CalculateAnimationsRotationDelta", this ); }

                return 0;
            },
            /*Spine.Unity.SkeletonRootMotionBase.CalculateAnimationsRotationDelta end.*/

            /*Spine.Unity.SkeletonRootMotionBase.SetRootMotionBone start.*/
            SetRootMotionBone: function (name) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#SetRootMotionBone", this ); }

                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                var bone = skeleton.findBone(name);
                if (bone != null) {
                    this.rootMotionBoneIndex = bone.data.index;
                    this.rootMotionBone = bone;
                    this.FindTransformConstraintsAffectingBone();
                } else {
                    UnityEngine.Debug.Log$1("Bone named \"" + (name || "") + "\" could not be found.");
                    this.rootMotionBoneIndex = 0;
                    this.rootMotionBone = skeleton.getRootBone();
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.SetRootMotionBone end.*/

            /*Spine.Unity.SkeletonRootMotionBase.AdjustRootMotionToDistance start.*/
            AdjustRootMotionToDistance: function (distanceToTarget, trackIndex, adjustX, adjustY, minX, maxX, minY, maxY, allowXTranslation, allowYTranslation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#AdjustRootMotionToDistance", this ); }

                if (trackIndex === void 0) { trackIndex = 0; }
                if (adjustX === void 0) { adjustX = true; }
                if (adjustY === void 0) { adjustY = true; }
                if (minX === void 0) { minX = 0.0; }
                if (maxX === void 0) { maxX = 3.40282347E+38; }
                if (minY === void 0) { minY = 0.0; }
                if (maxY === void 0) { maxY = 3.40282347E+38; }
                if (allowXTranslation === void 0) { allowXTranslation = false; }
                if (allowYTranslation === void 0) { allowYTranslation = false; }

                var distanceToTargetSkeletonSpace = UnityEngine.Vector2.FromVector3(this.transform.InverseTransformVector(UnityEngine.Vector3.FromVector2(distanceToTarget)));
                var scaleAffectingRootMotion = this.GetScaleAffectingRootMotion();
                if (this.UsesRigidbody) {
                    distanceToTargetSkeletonSpace = distanceToTargetSkeletonSpace.$clone().sub( this.tempSkeletonDisplacement.$clone() );
                }

                var remainingRootMotionSkeletonSpace = this.GetRemainingRootMotion(trackIndex);
                remainingRootMotionSkeletonSpace.mul( scaleAffectingRootMotion );
                if (remainingRootMotionSkeletonSpace.x === 0) {
                    remainingRootMotionSkeletonSpace.x = 0.0001;
                }
                if (remainingRootMotionSkeletonSpace.y === 0) {
                    remainingRootMotionSkeletonSpace.y = 0.0001;
                }

                if (adjustX) {
                    this.rootMotionScaleX = Math.min(maxX, Math.max(minX, distanceToTargetSkeletonSpace.x / remainingRootMotionSkeletonSpace.x));
                }
                if (adjustY) {
                    this.rootMotionScaleY = Math.min(maxY, Math.max(minY, distanceToTargetSkeletonSpace.y / remainingRootMotionSkeletonSpace.y));
                }

                if (allowXTranslation) {
                    this.rootMotionTranslateXPerY = (distanceToTargetSkeletonSpace.x - remainingRootMotionSkeletonSpace.x * this.rootMotionScaleX) / remainingRootMotionSkeletonSpace.y;
                }
                if (allowYTranslation) {
                    this.rootMotionTranslateYPerX = (distanceToTargetSkeletonSpace.y - remainingRootMotionSkeletonSpace.y * this.rootMotionScaleY) / remainingRootMotionSkeletonSpace.x;
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.AdjustRootMotionToDistance end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotion start.*/
            GetAnimationRootMotion: function (animation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotion", this ); }

                return this.GetAnimationRootMotion$1(0, animation.duration, animation);
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotion end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotion$1 start.*/
            GetAnimationRootMotion$1: function (startTime, endTime, animation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotion$1", this ); }

                var $t, $t1;

                if (startTime === endTime) {
                    return pc.Vec2.ZERO.clone();
                }

                var translateTimeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTranslateTimelineForBone(animation, this.rootMotionBoneIndex);
                var xTimeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone(spine.TranslateXTimeline, animation, this.rootMotionBoneIndex);
                var yTimeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone(spine.TranslateYTimeline, animation, this.rootMotionBoneIndex);

                // Non-looped base
                var endPos = { v : pc.Vec2.ZERO.clone() };
                var startPos = { v : pc.Vec2.ZERO.clone() };
                if (translateTimeline != null) {
                    endPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(translateTimeline, endTime);
                    startPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(translateTimeline, startTime);
                } else if (xTimeline != null || yTimeline != null) {
                    endPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, endTime);
                    startPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, startTime);
                }
                var transformConstraintsItems = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.TransformConstraints.Items;
                $t = Bridge.getEnumerator(this.transformConstraintIndices);
                try {
                    while ($t.moveNext()) {
                        var constraintIndex = $t.Current;
                        var constraint = transformConstraintsItems[constraintIndex];
                        this.ApplyConstraintToPos(animation, constraint, constraintIndex, endTime, false, endPos);
                        this.ApplyConstraintToPos(animation, constraint, constraintIndex, startTime, true, startPos);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                var currentDelta = endPos.v.$clone().sub( startPos.v );

                // Looped additions
                if (startTime > endTime) {
                    var loopPos = { v : pc.Vec2.ZERO.clone() };
                    var zeroPos = { v : pc.Vec2.ZERO.clone() };
                    if (translateTimeline != null) {
                        loopPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(translateTimeline, animation.duration);
                        zeroPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(translateTimeline, 0);
                    } else if (xTimeline != null || yTimeline != null) {
                        loopPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, animation.duration);
                        zeroPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, 0);
                    }
                    $t1 = Bridge.getEnumerator(this.transformConstraintIndices);
                    try {
                        while ($t1.moveNext()) {
                            var constraintIndex1 = $t1.Current;
                            var constraint1 = transformConstraintsItems[constraintIndex1];
                            this.ApplyConstraintToPos(animation, constraint1, constraintIndex1, animation.duration, false, loopPos);
                            this.ApplyConstraintToPos(animation, constraint1, constraintIndex1, 0, false, zeroPos);
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                    currentDelta = currentDelta.$clone().add( loopPos.v.$clone().sub( zeroPos.v ) );
                }
                this.UpdateLastConstraintPos(transformConstraintsItems);
                return currentDelta.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotion$1 end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionRotation start.*/
            GetAnimationRootMotionRotation: function (animation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotionRotation", this ); }

                return this.GetAnimationRootMotionRotation$1(0, animation.duration, animation);
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionRotation end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionRotation$1 start.*/
            GetAnimationRootMotionRotation$1: function (startTime, endTime, animation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotionRotation$1", this ); }

                var $t, $t1;

                if (startTime === endTime) {
                    return 0;
                }

                var rotateTimeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone(spine.RotateTimeline, animation, this.rootMotionBoneIndex);

                // Non-looped base
                var endRotation = { v : 0 };
                var startRotation = { v : 0 };
                if (rotateTimeline != null) {
                    endRotation.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(rotateTimeline, endTime);
                    startRotation.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(rotateTimeline, startTime);
                }
                var transformConstraintsItems = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.TransformConstraints.Items;
                $t = Bridge.getEnumerator(this.transformConstraintIndices);
                try {
                    while ($t.moveNext()) {
                        var constraintIndex = $t.Current;
                        var constraint = transformConstraintsItems[constraintIndex];
                        this.ApplyConstraintToRotation(animation, constraint, constraintIndex, endTime, false, endRotation);
                        this.ApplyConstraintToRotation(animation, constraint, constraintIndex, startTime, true, startRotation);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                var currentDelta = endRotation.v - startRotation.v;

                // Looped additions
                if (startTime > endTime) {
                    var loopRotation = { v : 0 };
                    var zeroPos = { v : 0 };
                    if (rotateTimeline != null) {
                        loopRotation.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(rotateTimeline, animation.duration);
                        zeroPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(rotateTimeline, 0);
                    }
                    $t1 = Bridge.getEnumerator(this.transformConstraintIndices);
                    try {
                        while ($t1.moveNext()) {
                            var constraintIndex1 = $t1.Current;
                            var constraint1 = transformConstraintsItems[constraintIndex1];
                            this.ApplyConstraintToRotation(animation, constraint1, constraintIndex1, animation.duration, false, loopRotation);
                            this.ApplyConstraintToRotation(animation, constraint1, constraintIndex1, 0, false, zeroPos);
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                    currentDelta += loopRotation.v - zeroPos.v;
                }
                this.UpdateLastConstraintRotation(transformConstraintsItems);
                return currentDelta;
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionRotation$1 end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ApplyConstraintToPos start.*/
            ApplyConstraintToPos: function (animation, constraint, constraintIndex, time, useLastConstraintPos, pos) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#ApplyConstraintToPos", this ); }

                var timeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTransformConstraintTimeline(animation, constraintIndex);
                if (timeline == null) {
                    return;
                }
                var mixXY = Spine.Unity.AnimationTools.TimelineExtensions.EvaluateTranslateXYMix(timeline, time);
                var invMixXY = Spine.Unity.AnimationTools.TimelineExtensions.EvaluateTranslateXYMix(timeline, time);
                var constraintPos = new UnityEngine.Vector2();
                if (useLastConstraintPos) {
                    constraintPos = this.transformConstraintLastPos.getItem(this.GetConstraintLastPosIndex(constraintIndex)).$clone();
                } else {
                    var targetBone = constraint.target;
                    constraintPos = new pc.Vec2( targetBone.x, targetBone.y );
                }
                pos.v = new pc.Vec2( pos.v.x * invMixXY.x + constraintPos.x * mixXY.x, pos.v.y * invMixXY.y + constraintPos.y * mixXY.y );
            },
            /*Spine.Unity.SkeletonRootMotionBase.ApplyConstraintToPos end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ApplyConstraintToRotation start.*/
            ApplyConstraintToRotation: function (animation, constraint, constraintIndex, time, useLastConstraintRotation, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#ApplyConstraintToRotation", this ); }

                var timeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTransformConstraintTimeline(animation, constraintIndex);
                if (timeline == null) {
                    return;
                }
                var mixRotate = Spine.Unity.AnimationTools.TimelineExtensions.EvaluateRotateMix(timeline, time);
                var invMixRotate = Spine.Unity.AnimationTools.TimelineExtensions.EvaluateRotateMix(timeline, time);
                var constraintRotation;
                if (useLastConstraintRotation) {
                    constraintRotation = this.transformConstraintLastRotation.getItem(this.GetConstraintLastPosIndex(constraintIndex));
                } else {
                    var targetBone = constraint.target;
                    constraintRotation = targetBone.rotation;
                }
                rotation.v = rotation.v * invMixRotate + constraintRotation * mixRotate;
            },
            /*Spine.Unity.SkeletonRootMotionBase.ApplyConstraintToRotation end.*/

            /*Spine.Unity.SkeletonRootMotionBase.UpdateLastConstraintPos start.*/
            UpdateLastConstraintPos: function (transformConstraintsItems) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#UpdateLastConstraintPos", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.transformConstraintIndices);
                try {
                    while ($t.moveNext()) {
                        var constraintIndex = $t.Current;
                        var constraint = transformConstraintsItems[constraintIndex];
                        var targetBone = constraint.target;
                        this.transformConstraintLastPos.setItem(this.GetConstraintLastPosIndex(constraintIndex), new pc.Vec2( targetBone.x, targetBone.y ));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.UpdateLastConstraintPos end.*/

            /*Spine.Unity.SkeletonRootMotionBase.UpdateLastConstraintRotation start.*/
            UpdateLastConstraintRotation: function (transformConstraintsItems) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#UpdateLastConstraintRotation", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.transformConstraintIndices);
                try {
                    while ($t.moveNext()) {
                        var constraintIndex = $t.Current;
                        var constraint = transformConstraintsItems[constraintIndex];
                        var targetBone = constraint.target;
                        this.transformConstraintLastRotation.setItem(this.GetConstraintLastPosIndex(constraintIndex), targetBone.rotation);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.UpdateLastConstraintRotation end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionInfo start.*/
            GetAnimationRootMotionInfo: function (animation, currentTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotionInfo", this ); }

                var rootMotion = new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo();
                var duration = animation.duration;
                var mid = duration * 0.5;
                rootMotion.timeIsPastMid = currentTime > mid;
                var timeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTranslateTimelineForBone(animation, this.rootMotionBoneIndex);
                if (timeline != null) {
                    rootMotion.start = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(timeline, 0);
                    rootMotion.current = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(timeline, currentTime);
                    rootMotion.mid = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(timeline, mid);
                    rootMotion.end = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(timeline, duration);
                    return rootMotion.$clone();
                }
                var xTimeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone(spine.TranslateXTimeline, animation, this.rootMotionBoneIndex);
                var yTimeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone(spine.TranslateYTimeline, animation, this.rootMotionBoneIndex);
                if (xTimeline != null || yTimeline != null) {
                    rootMotion.start = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, 0);
                    rootMotion.current = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, currentTime);
                    rootMotion.mid = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, mid);
                    rootMotion.end = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, duration);
                    return rootMotion.$clone();
                }
                return rootMotion.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionInfo end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetConstraintLastPosIndex start.*/
            GetConstraintLastPosIndex: function (constraintIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetConstraintLastPosIndex", this ); }

                var constraints = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.TransformConstraints;
                return this.transformConstraintIndices.FindIndex$2(function (addedIndex) {
                    return addedIndex === constraintIndex;
                });
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetConstraintLastPosIndex end.*/

            /*Spine.Unity.SkeletonRootMotionBase.FindTransformConstraintsAffectingBone start.*/
            FindTransformConstraintsAffectingBone: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#FindTransformConstraintsAffectingBone", this ); }

                var constraints = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.TransformConstraints;
                var constraintsItems = constraints.Items;
                for (var i = 0, n = constraints.Count; i < n; i = (i + 1) | 0) {
                    var constraint = constraintsItems[i];
                    if (constraint.Bones.Contains(this.rootMotionBone)) {
                        this.transformConstraintIndices.add(i);
                        var targetBone = constraint.target;
                        var constraintPos = new pc.Vec2( targetBone.x, targetBone.y );
                        this.transformConstraintLastPos.add(constraintPos.$clone());
                        this.transformConstraintLastRotation.add(targetBone.rotation);
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.FindTransformConstraintsAffectingBone end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetTimelineMovementDelta start.*/
            GetTimelineMovementDelta: function (startTime, endTime, xTimeline, yTimeline, animation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetTimelineMovementDelta", this ); }


                var currentDelta = new UnityEngine.Vector2();
                if (startTime > endTime) {
                    currentDelta = (Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, animation.duration).sub( Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, startTime) )).add( (Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, endTime).sub( Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, 0) )) );
                } else {
                    if (startTime !== endTime) {
                        currentDelta = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, endTime).sub( Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, startTime) );
                    } else {
                        currentDelta = pc.Vec2.ZERO.clone();
                    }
                }
                return currentDelta.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetTimelineMovementDelta end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GatherTopLevelBones start.*/
            GatherTopLevelBones: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GatherTopLevelBones", this ); }

                var $t;
                this.topLevelBones.clear();
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                $t = Bridge.getEnumerator(skeleton.bones);
                try {
                    while ($t.moveNext()) {
                        var bone = $t.Current;
                        if (bone.parent == null) {
                            this.topLevelBones.add(bone);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.GatherTopLevelBones end.*/

            /*Spine.Unity.SkeletonRootMotionBase.HandleUpdateLocal start.*/
            HandleUpdateLocal: function (animatedSkeletonComponent) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#HandleUpdateLocal", this ); }

                if (!this.isActiveAndEnabled) {
                    return;
                } // Root motion is only applied when component is enabled.

                var boneLocalDelta = this.CalculateAnimationsMovementDelta();
                var parentBoneScale = { v : new UnityEngine.Vector2() };
                var totalScale = { v : new UnityEngine.Vector2() };
                var skeletonTranslationDelta = this.GetSkeletonSpaceMovementDelta(boneLocalDelta.$clone(), parentBoneScale, totalScale);
                var skeletonRotationDelta = 0;
                if (this.transformRotation) {
                    var boneLocalDeltaRotation = this.CalculateAnimationsRotationDelta();
                    boneLocalDeltaRotation *= this.rootMotionScaleRotation;
                    skeletonRotationDelta = this.GetSkeletonSpaceRotationDelta(boneLocalDeltaRotation, totalScale.v);
                }

                var usesFixedUpdate = this.SkeletonAnimationUsesFixedUpdate;
                this.ApplyRootMotion(skeletonTranslationDelta, skeletonRotationDelta, parentBoneScale.v, usesFixedUpdate);

                if (usesFixedUpdate) {
                    this.PhysicsUpdate(usesFixedUpdate);
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.HandleUpdateLocal end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ApplyRootMotion start.*/
            ApplyRootMotion: function (skeletonTranslationDelta, skeletonRotationDelta, parentBoneScale, skeletonAnimationUsesFixedUpdate) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#ApplyRootMotion", this ); }


                // Accumulated displacement is applied on the next Physics update in FixedUpdate.
                // Until the next Physics update, tempSkeletonDisplacement and tempSkeletonRotation
                // are offsetting bone locations to prevent stutter which would otherwise occur if
                // we don't move every Update.
                var usesRigidbody = this.UsesRigidbody;
                var applyToTransform = !usesRigidbody && (Bridge.staticEquals(this.ProcessRootMotionOverride, null) || !this.disableOnOverride);
                this.accumulatedUntilFixedUpdate = !applyToTransform && !skeletonAnimationUsesFixedUpdate;

                if (!Bridge.staticEquals(this.ProcessRootMotionOverride, null)) {
                    this.ProcessRootMotionOverride(this, skeletonTranslationDelta.$clone(), skeletonRotationDelta);
                }

                // Apply root motion to Transform or update values applied to RigidBody later (must happen in FixedUpdate).
                if (usesRigidbody) {
                    this.rigidbodyDisplacement = this.rigidbodyDisplacement.$clone().add( this.transform.TransformVector(UnityEngine.Vector3.FromVector2(skeletonTranslationDelta)) );
                    if (skeletonRotationDelta !== 0.0) {
                        if (UnityEngine.Component.op_Inequality(this.rigidBody, null)) {
                            var addedWorldRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, skeletonRotationDelta );
                            this.rigidbodyLocalRotation = this.rigidbodyLocalRotation.clone().mul( addedWorldRotation );
                        } else if (UnityEngine.Component.op_Inequality(this.rigidBody2D, null)) {
                            var lossyScale = this.transform.lossyScale.$clone();
                            var rotationSign = lossyScale.x * lossyScale.y > 0 ? 1 : -1;
                            this.rigidbody2DRotation += rotationSign * skeletonRotationDelta;
                        }
                    }
                } else if (applyToTransform) {
                    this.transform.position = this.transform.position.$clone().add( this.transform.TransformVector(UnityEngine.Vector3.FromVector2(skeletonTranslationDelta)) );
                    if (skeletonRotationDelta !== 0.0) {
                        var lossyScale1 = this.transform.lossyScale.$clone();
                        var rotationSign1 = lossyScale1.x * lossyScale1.y > 0 ? 1 : -1;
                        this.transform.Rotate(0, 0, rotationSign1 * skeletonRotationDelta);
                    }
                }

                this.tempSkeletonDisplacement = this.tempSkeletonDisplacement.$clone().add( skeletonTranslationDelta.$clone() );
                this.tempSkeletonRotation += skeletonRotationDelta;
                if (this.accumulatedUntilFixedUpdate) {
                    this.SetEffectiveBoneOffsetsTo(this.tempSkeletonDisplacement, this.tempSkeletonRotation, parentBoneScale);
                } else {
                    this.ClearEffectiveBoneOffsets(parentBoneScale);
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.ApplyRootMotion end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ApplyTransformConstraints start.*/
            ApplyTransformConstraints: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#ApplyTransformConstraints", this ); }

                var $t;
                this.rootMotionBone.ax = this.rootMotionBone.x;
                this.rootMotionBone.ay = this.rootMotionBone.y;
                this.rootMotionBone.arotation = this.rootMotionBone.rotation;
                var transformConstraintsItems = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.TransformConstraints.Items;
                $t = Bridge.getEnumerator(this.transformConstraintIndices);
                try {
                    while ($t.moveNext()) {
                        var constraintIndex = $t.Current;
                        var constraint = transformConstraintsItems[constraintIndex];
                        // apply the constraint and sets Bone.ax, Bone.ay and Bone.arotation values.
                        constraint.update();
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.ApplyTransformConstraints end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetScaleAffectingRootMotion start.*/
            GetScaleAffectingRootMotion: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetScaleAffectingRootMotion", this ); }

                var parentBoneScale = { v : new UnityEngine.Vector2() };
                return this.GetScaleAffectingRootMotion$1(parentBoneScale);
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetScaleAffectingRootMotion end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetScaleAffectingRootMotion$1 start.*/
            GetScaleAffectingRootMotion$1: function (parentBoneScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetScaleAffectingRootMotion$1", this ); }

                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                var totalScale = pc.Vec2.ONE.clone();
                totalScale.x *= skeleton.scaleX;
                totalScale.y *= skeleton.scaleY;

                parentBoneScale.v = pc.Vec2.ONE.clone();
                var scaleBone = this.rootMotionBone;
                while (((scaleBone = scaleBone.parent)) != null) {
                    parentBoneScale.v.x *= scaleBone.scaleX;
                    parentBoneScale.v.y *= scaleBone.scaleY;
                }
                totalScale = new pc.Vec2( totalScale.x * parentBoneScale.v.x, totalScale.y * parentBoneScale.v.y );
                totalScale = totalScale.$clone().scale( this.AdditionalScale );
                return totalScale.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetScaleAffectingRootMotion$1 end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetSkeletonSpaceMovementDelta start.*/
            GetSkeletonSpaceMovementDelta: function (boneLocalDelta, parentBoneScale, totalScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetSkeletonSpaceMovementDelta", this ); }

                var skeletonDelta = boneLocalDelta.$clone();
                totalScale.v = this.GetScaleAffectingRootMotion$1(parentBoneScale);
                skeletonDelta.mul( totalScale.v );

                var rootMotionTranslation = new pc.Vec2( this.rootMotionTranslateXPerY * skeletonDelta.y, this.rootMotionTranslateYPerX * skeletonDelta.x );

                skeletonDelta.x *= this.rootMotionScaleX;
                skeletonDelta.y *= this.rootMotionScaleY;
                skeletonDelta.x += rootMotionTranslation.x;
                skeletonDelta.y += rootMotionTranslation.y;

                if (!this.transformPositionX) {
                    skeletonDelta.x = 0.0;
                }
                if (!this.transformPositionY) {
                    skeletonDelta.y = 0.0;
                }
                return skeletonDelta.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetSkeletonSpaceMovementDelta end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetSkeletonSpaceRotationDelta start.*/
            GetSkeletonSpaceRotationDelta: function (boneLocalDelta, totalScaleAffectingRootMotion) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetSkeletonSpaceRotationDelta", this ); }

                var rotationSign = totalScaleAffectingRootMotion.x * totalScaleAffectingRootMotion.y > 0 ? 1 : -1;
                return rotationSign * boneLocalDelta;
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetSkeletonSpaceRotationDelta end.*/

            /*Spine.Unity.SkeletonRootMotionBase.SetEffectiveBoneOffsetsTo start.*/
            SetEffectiveBoneOffsetsTo: function (displacementSkeletonSpace, rotationSkeletonSpace, parentBoneScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#SetEffectiveBoneOffsetsTo", this ); }

                var $t;

                this.ApplyTransformConstraints();

                // Move top level bones in opposite direction of the root motion bone
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                $t = Bridge.getEnumerator(this.topLevelBones);
                try {
                    while ($t.moveNext()) {
                        var topLevelBone = $t.Current;
                        if (Bridge.referenceEquals(topLevelBone, this.rootMotionBone)) {
                            if (this.transformPositionX) {
                                topLevelBone.x = displacementSkeletonSpace.x / skeleton.scaleX;
                            }
                            if (this.transformPositionY) {
                                topLevelBone.y = displacementSkeletonSpace.y / skeleton.scaleY;
                            }
                            if (this.transformRotation) {
                                var rotationSign = skeleton.scaleX * skeleton.scaleY > 0 ? 1 : -1;
                                topLevelBone.rotation = rotationSign * rotationSkeletonSpace;
                            }
                        } else {
                            var useAppliedTransform = this.transformConstraintIndices.Count > 0;
                            var rootMotionBoneX = useAppliedTransform ? this.rootMotionBone.ax : this.rootMotionBone.x;
                            var rootMotionBoneY = useAppliedTransform ? this.rootMotionBone.ay : this.rootMotionBone.y;

                            var offsetX = (this.initialOffset.x - rootMotionBoneX) * parentBoneScale.x;
                            var offsetY = (this.initialOffset.y - rootMotionBoneY) * parentBoneScale.y;

                            if (this.transformPositionX) {
                                topLevelBone.x = (displacementSkeletonSpace.x / skeleton.scaleX) + offsetX;
                            }
                            if (this.transformPositionY) {
                                topLevelBone.y = (displacementSkeletonSpace.y / skeleton.scaleY) + offsetY;
                            }

                            if (this.transformRotation) {
                                var rootMotionBoneRotation = useAppliedTransform ? this.rootMotionBone.arotation : this.rootMotionBone.rotation;

                                var parentBoneRotationSign = (parentBoneScale.x * parentBoneScale.y > 0 ? 1 : -1);
                                var offsetRotation = (this.initialOffsetRotation - rootMotionBoneRotation) * parentBoneRotationSign;

                                var skeletonRotationSign = skeleton.scaleX * skeleton.scaleY > 0 ? 1 : -1;
                                topLevelBone.rotation = (rotationSkeletonSpace * skeletonRotationSign) + offsetRotation;
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.SetEffectiveBoneOffsetsTo end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ClearEffectiveBoneOffsets start.*/
            ClearEffectiveBoneOffsets: function (parentBoneScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#ClearEffectiveBoneOffsets", this ); }

                this.SetEffectiveBoneOffsetsTo(pc.Vec2.ZERO.clone(), 0, parentBoneScale);
            },
            /*Spine.Unity.SkeletonRootMotionBase.ClearEffectiveBoneOffsets end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ClearRigidbodyTempMovement start.*/
            ClearRigidbodyTempMovement: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#ClearRigidbodyTempMovement", this ); }

                this.rigidbodyDisplacement = UnityEngine.Vector3.FromVector2(pc.Vec2.ZERO.clone());
                this.tempSkeletonDisplacement = pc.Vec2.ZERO.clone();
                this.rigidbodyLocalRotation = pc.Quat.IDENTITY.clone();
                this.rigidbody2DRotation = 0;
                this.tempSkeletonRotation = 0;
            },
            /*Spine.Unity.SkeletonRootMotionBase.ClearRigidbodyTempMovement end.*/


        },
        overloads: {
            "GetAnimationRootMotion(float, float, Animation)": "GetAnimationRootMotion$1",
            "GetAnimationRootMotionRotation(float, float, Animation)": "GetAnimationRootMotionRotation$1",
            "GetScaleAffectingRootMotion(Vector2)": "GetScaleAffectingRootMotion$1"
        }
    });
    /*Spine.Unity.SkeletonRootMotionBase end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonPartsRenderer.SkeletonPartsRendererDelegate
     * @param   {Spine.Unity.SkeletonPartsRenderer}    skeletonPartsRenderer
     * @return  {void}
     */


    /*Spine.Unity.SkeletonPartsRenderer start.*/
    Bridge.define("Spine.Unity.SkeletonPartsRenderer", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonPartsRenderer.NewPartsRendererGameObject:static start.*/
                NewPartsRendererGameObject: function (parent, name, sortingOrder) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#NewPartsRendererGameObject", this ); }

                    if (sortingOrder === void 0) { sortingOrder = 0; }
                    var go = new UnityEngine.GameObject.$ctor4(name, [UnityEngine.MeshFilter, UnityEngine.MeshRenderer]);
                    go.transform.SetParent(parent, false);
                    var returnComponent = go.AddComponent(Spine.Unity.SkeletonPartsRenderer);
                    returnComponent.MeshRenderer.sortingOrder = sortingOrder;

                    return returnComponent;
                },
                /*Spine.Unity.SkeletonPartsRenderer.NewPartsRendererGameObject:static end.*/


            }
        },
        fields: {
            meshGenerator: null,
            meshRenderer: null,
            meshFilter: null,
            buffers: null,
            currentInstructions: null
        },
        events: {
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonPartsRenderer
             * @memberof Spine.Unity.SkeletonPartsRenderer
             * @function addOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonPartsRenderer.SkeletonPartsRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonPartsRenderer
             * @memberof Spine.Unity.SkeletonPartsRenderer
             * @function removeOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonPartsRenderer.SkeletonPartsRendererDelegate}    value
             * @return  {void}
             */
            OnMeshAndMaterialsUpdated: null
        },
        props: {
            MeshGenerator: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#MeshGenerator#get", this ); }

                    this.LazyIntialize();
                    return this.meshGenerator;
                }
            },
            MeshRenderer: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#MeshRenderer#get", this ); }

                    this.LazyIntialize();
                    return this.meshRenderer;
                }
            },
            MeshFilter: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#MeshFilter#get", this ); }

                    this.LazyIntialize();
                    return this.meshFilter;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#init", this ); }

                this.currentInstructions = new Spine.Unity.SkeletonRendererInstruction();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonPartsRenderer.LazyIntialize start.*/
            LazyIntialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#LazyIntialize", this ); }

                if (this.buffers == null) {
                    this.buffers = new Spine.Unity.MeshRendererBuffers();
                    this.buffers.Initialize();

                    if (this.meshGenerator != null) {
                        return;
                    }
                    this.meshGenerator = new Spine.Unity.MeshGenerator();
                    this.meshFilter = this.GetComponent(UnityEngine.MeshFilter);
                    this.meshRenderer = this.GetComponent(UnityEngine.MeshRenderer);
                    this.currentInstructions.Clear();
                }
            },
            /*Spine.Unity.SkeletonPartsRenderer.LazyIntialize end.*/

            /*Spine.Unity.SkeletonPartsRenderer.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#OnDestroy", this ); }

                if (this.buffers != null) {
                    this.buffers.Dispose();
                }
            },
            /*Spine.Unity.SkeletonPartsRenderer.OnDestroy end.*/

            /*Spine.Unity.SkeletonPartsRenderer.ClearMesh start.*/
            ClearMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#ClearMesh", this ); }

                this.LazyIntialize();
                this.meshFilter.sharedMesh = null;
            },
            /*Spine.Unity.SkeletonPartsRenderer.ClearMesh end.*/

            /*Spine.Unity.SkeletonPartsRenderer.RenderParts start.*/
            RenderParts: function (instructions, startSubmesh, endSubmesh) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#RenderParts", this ); }

                this.LazyIntialize();

                // STEP 1: Create instruction
                var smartMesh = this.buffers.GetNextMesh();
                this.currentInstructions.SetWithSubset(instructions, startSubmesh, endSubmesh);
                var updateTriangles = Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual(this.currentInstructions, smartMesh.instructionUsed);

                // STEP 2: Generate mesh buffers.
                var currentInstructionsSubmeshesItems = this.currentInstructions.submeshInstructions.Items;
                this.meshGenerator.Begin();
                if (this.currentInstructions.hasActiveClipping) {
                    for (var i = 0; i < this.currentInstructions.submeshInstructions.Count; i = (i + 1) | 0) {
                        this.meshGenerator.AddSubmesh(currentInstructionsSubmeshesItems[i], updateTriangles);
                    }
                } else {
                    this.meshGenerator.BuildMeshWithArrays(this.currentInstructions, updateTriangles);
                }

                this.buffers.UpdateSharedMaterials(this.currentInstructions.submeshInstructions);

                // STEP 3: modify mesh.
                var mesh = smartMesh.mesh;

                if (this.meshGenerator.VertexCount <= 0) { // Clear an empty mesh
                    updateTriangles = false;
                    mesh.Clear();
                } else {
                    this.meshGenerator.FillVertexData(mesh);
                    if (updateTriangles) {
                        this.meshGenerator.FillTriangles(mesh);
                        this.meshRenderer.sharedMaterials = this.buffers.GetUpdatedSharedMaterialsArray();
                    } else if (this.buffers.MaterialsChangedInLastUpdate()) {
                        this.meshRenderer.sharedMaterials = this.buffers.GetUpdatedSharedMaterialsArray();
                    }
                    this.meshGenerator.FillLateVertexData(mesh);
                }

                this.meshFilter.sharedMesh = mesh;
                smartMesh.instructionUsed.Set(this.currentInstructions);

                if (!Bridge.staticEquals(this.OnMeshAndMaterialsUpdated, null)) {
                    this.OnMeshAndMaterialsUpdated(this);
                }
            },
            /*Spine.Unity.SkeletonPartsRenderer.RenderParts end.*/

            /*Spine.Unity.SkeletonPartsRenderer.SetPropertyBlock start.*/
            SetPropertyBlock: function (block) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#SetPropertyBlock", this ); }

                this.LazyIntialize();
                this.meshRenderer.SetPropertyBlock(block);
            },
            /*Spine.Unity.SkeletonPartsRenderer.SetPropertyBlock end.*/


        }
    });
    /*Spine.Unity.SkeletonPartsRenderer end.*/

    /*Spine.Unity.SkeletonRenderer+SpriteMaskInteractionMaterials start.*/
    Bridge.define("Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials", {
        $kind: 1002,
        fields: {
            /**
             * Material references for switching material sets at runtime when {@link } changes to {@link }.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials
             * @type Array.<UnityEngine.Material>
             */
            materialsMaskDisabled: null,
            /**
             * Material references for switching material sets at runtime when {@link } changes to {@link }.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials
             * @type Array.<UnityEngine.Material>
             */
            materialsInsideMask: null,
            /**
             * Material references for switching material sets at runtime when {@link } changes to {@link }.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials
             * @type Array.<UnityEngine.Material>
             */
            materialsOutsideMask: null
        },
        props: {
            AnyMaterialCreated: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials#AnyMaterialCreated#get", this ); }

                    return this.materialsMaskDisabled.length > 0 || this.materialsInsideMask.length > 0 || this.materialsOutsideMask.length > 0;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials#init", this ); }

                this.materialsMaskDisabled = System.Array.init(0, null, UnityEngine.Material);
                this.materialsInsideMask = System.Array.init(0, null, UnityEngine.Material);
                this.materialsOutsideMask = System.Array.init(0, null, UnityEngine.Material);
            }
        }
    });
    /*Spine.Unity.SkeletonRenderer+SpriteMaskInteractionMaterials end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials start.*/
    Bridge.define("Spine.Unity.SkeletonRendererCustomMaterials", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonRenderer: null,
            customSlotMaterials: null,
            customMaterialOverrides: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#init", this ); }

                this.customSlotMaterials = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride)).ctor();
                this.customMaterialOverrides = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRendererCustomMaterials.SetCustomSlotMaterials start.*/
            SetCustomSlotMaterials: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#SetCustomSlotMaterials", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                for (var i = 0; i < this.customSlotMaterials.Count; i = (i + 1) | 0) {
                    var slotMaterialOverride = this.customSlotMaterials.getItem(i).$clone();
                    if (slotMaterialOverride.overrideDisabled || System.String.isNullOrEmpty(slotMaterialOverride.slotName)) {
                        continue;
                    }

                    var slotObject = this.skeletonRenderer.skeleton.findSlot(slotMaterialOverride.slotName);
                    if (slotObject != null) {
                        this.skeletonRenderer.CustomSlotMaterials.setItem(slotObject, slotMaterialOverride.material);
                    }
                }
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.SetCustomSlotMaterials end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.RemoveCustomSlotMaterials start.*/
            RemoveCustomSlotMaterials: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#RemoveCustomSlotMaterials", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                for (var i = 0; i < this.customSlotMaterials.Count; i = (i + 1) | 0) {
                    var slotMaterialOverride = this.customSlotMaterials.getItem(i).$clone();
                    if (System.String.isNullOrEmpty(slotMaterialOverride.slotName)) {
                        continue;
                    }

                    var slotObject = this.skeletonRenderer.skeleton.findSlot(slotMaterialOverride.slotName);
                    if (slotObject == null) {
                        continue;
                    }
                    var currentMaterial = { };
                    if (!this.skeletonRenderer.CustomSlotMaterials.tryGetValue(slotObject, currentMaterial)) {
                        continue;
                    }

                    // Do not revert the material if it was changed by something else
                    if (!Bridge.referenceEquals(currentMaterial.v, slotMaterialOverride.material)) {
                        continue;
                    }

                    this.skeletonRenderer.CustomSlotMaterials.remove(slotObject);
                }
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.RemoveCustomSlotMaterials end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.SetCustomMaterialOverrides start.*/
            SetCustomMaterialOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#SetCustomMaterialOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                for (var i = 0; i < this.customMaterialOverrides.Count; i = (i + 1) | 0) {
                    var atlasMaterialOverride = this.customMaterialOverrides.getItem(i).$clone();
                    if (atlasMaterialOverride.overrideDisabled) {
                        continue;
                    }

                    this.skeletonRenderer.CustomMaterialOverride.setItem(atlasMaterialOverride.originalMaterial, atlasMaterialOverride.replacementMaterial);
                }
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.SetCustomMaterialOverrides end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.RemoveCustomMaterialOverrides start.*/
            RemoveCustomMaterialOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#RemoveCustomMaterialOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                for (var i = 0; i < this.customMaterialOverrides.Count; i = (i + 1) | 0) {
                    var atlasMaterialOverride = this.customMaterialOverrides.getItem(i).$clone();
                    var currentMaterial = { };

                    if (!this.skeletonRenderer.CustomMaterialOverride.tryGetValue(atlasMaterialOverride.originalMaterial, currentMaterial)) {
                        continue;
                    }

                    // Do not revert the material if it was changed by something else
                    if (!Bridge.referenceEquals(currentMaterial.v, atlasMaterialOverride.replacementMaterial)) {
                        continue;
                    }

                    this.skeletonRenderer.CustomMaterialOverride.remove(atlasMaterialOverride.originalMaterial);
                }
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.RemoveCustomMaterialOverrides end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer = this.GetComponent(Spine.Unity.SkeletonRenderer);
                }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                this.skeletonRenderer.Initialize(false);
                this.SetCustomMaterialOverrides();
                this.SetCustomSlotMaterials();
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.OnEnable end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#OnDisable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                this.RemoveCustomMaterialOverrides();
                this.RemoveCustomSlotMaterials();
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.OnDisable end.*/


        }
    });
    /*Spine.Unity.SkeletonRendererCustomMaterials end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride start.*/
    Bridge.define("Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride", {
        inherits: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#inherits", this ); }
 return [System.IEquatable$1(Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride)]; },
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#getDefaultValue", this ); }
 return new Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride(); }
            }
        },
        fields: {
            overrideDisabled: false,
            originalMaterial: null,
            replacementMaterial: null
        },
        alias: ["equalsT", "System$IEquatable$1$Spine$Unity$SkeletonRendererCustomMaterials$AtlasMaterialOverride$equalsT"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride.equalsT start.*/
            equalsT: function (other) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#equalsT", this ); }

                return this.overrideDisabled === other.overrideDisabled && Bridge.referenceEquals(this.originalMaterial, other.originalMaterial) && Bridge.referenceEquals(this.replacementMaterial, other.replacementMaterial);
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride.equalsT end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#getHashCode", this ); }

                var h = Bridge.addHash([8608216668, this.overrideDisabled, this.originalMaterial, this.replacementMaterial]);
                return h;
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#$clone", this ); }

                var s = to || new Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride();
                s.overrideDisabled = this.overrideDisabled;
                s.originalMaterial = this.originalMaterial;
                s.replacementMaterial = this.replacementMaterial;
                return s;
            }
        },
        overloads: {
            "Equals(AtlasMaterialOverride)": "equalsT"
        }
    });
    /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride start.*/
    Bridge.define("Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride", {
        inherits: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#inherits", this ); }
 return [System.IEquatable$1(Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride)]; },
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#getDefaultValue", this ); }
 return new Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride(); }
            }
        },
        fields: {
            overrideDisabled: false,
            slotName: null,
            material: null
        },
        alias: ["equalsT", "System$IEquatable$1$Spine$Unity$SkeletonRendererCustomMaterials$SlotMaterialOverride$equalsT"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride.equalsT start.*/
            equalsT: function (other) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#equalsT", this ); }

                return this.overrideDisabled === other.overrideDisabled && Bridge.referenceEquals(this.slotName, other.slotName) && Bridge.referenceEquals(this.material, other.material);
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride.equalsT end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#getHashCode", this ); }

                var h = Bridge.addHash([9094239955, this.overrideDisabled, this.slotName, this.material]);
                return h;
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#$clone", this ); }

                var s = to || new Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride();
                s.overrideDisabled = this.overrideDisabled;
                s.slotName = this.slotName;
                s.material = this.material;
                return s;
            }
        },
        overloads: {
            "Equals(SlotMaterialOverride)": "equalsT"
        }
    });
    /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride end.*/

    /*Spine.Unity.SkeletonRendererInstruction start.*/
    /**
     * Instructions used by a SkeletonRenderer to render a mesh.
     *
     * @public
     * @class Spine.Unity.SkeletonRendererInstruction
     */
    Bridge.define("Spine.Unity.SkeletonRendererInstruction", {
        statics: {
            methods: {
                /*Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual:static start.*/
                GeometryNotEqual: function (a, b) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#GeometryNotEqual", this ); }


                    if (a.hasActiveClipping || b.hasActiveClipping) {
                        return true;
                    } // Triangles are unpredictable when clipping is active.

                    // Everything below assumes the raw vertex and triangle counts were used. (ie, no clipping was done)
                    if (a.rawVertexCount !== b.rawVertexCount) {
                        return true;
                    }

                    if (a.immutableTriangles !== b.immutableTriangles) {
                        return true;
                    }

                    var attachmentCountB = b.attachments.Count;
                    if (a.attachments.Count !== attachmentCountB) {
                        return true;
                    } // Bounds check for the looped storedAttachments count below.

                    // Submesh count changed
                    var submeshCountA = a.submeshInstructions.Count;
                    var submeshCountB = b.submeshInstructions.Count;
                    if (submeshCountA !== submeshCountB) {
                        return true;
                    }

                    // Submesh Instruction mismatch
                    var submeshInstructionsItemsA = a.submeshInstructions.Items;
                    var submeshInstructionsItemsB = b.submeshInstructions.Items;

                    var attachmentsA = a.attachments.Items;
                    var attachmentsB = b.attachments.Items;
                    for (var i = 0; i < attachmentCountB; i = (i + 1) | 0) {
                        if (!Bridge.referenceEquals(attachmentsA[i], attachmentsB[i])) {
                            return true;
                        }
                    }

                    for (var i1 = 0; i1 < submeshCountB; i1 = (i1 + 1) | 0) {
                        var submeshA = submeshInstructionsItemsA[i1].$clone();
                        var submeshB = submeshInstructionsItemsB[i1].$clone();

                        if (!(submeshA.rawVertexCount === submeshB.rawVertexCount && submeshA.startSlot === submeshB.startSlot && submeshA.endSlot === submeshB.endSlot && submeshA.rawTriangleCount === submeshB.rawTriangleCount && submeshA.rawFirstVertexIndex === submeshB.rawFirstVertexIndex)) {
                            return true;
                        }
                    }

                    return false;
                },
                /*Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual:static end.*/


            }
        },
        fields: {
            submeshInstructions: null,
            immutableTriangles: false,
            hasActiveClipping: false,
            rawVertexCount: 0,
            attachments: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#init", this ); }

                this.submeshInstructions = new (Spine.ExposedList$1(Spine.Unity.SubmeshInstruction)).ctor();
                this.rawVertexCount = -1;
                this.attachments = new (Spine.ExposedList$1(spine.Attachment)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRendererInstruction.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#Clear", this ); }

                this.attachments.Clear(false);
                this.rawVertexCount = -1;
                this.hasActiveClipping = false;
                this.submeshInstructions.Clear(false);
            },
            /*Spine.Unity.SkeletonRendererInstruction.Clear end.*/

            /*Spine.Unity.SkeletonRendererInstruction.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#Dispose", this ); }

                this.attachments.Clear(true);
            },
            /*Spine.Unity.SkeletonRendererInstruction.Dispose end.*/

            /*Spine.Unity.SkeletonRendererInstruction.SetWithSubset start.*/
            SetWithSubset: function (instructions, startSubmesh, endSubmesh) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#SetWithSubset", this ); }

                var runningVertexCount = 0;

                var submeshes = this.submeshInstructions;
                submeshes.Clear(false);
                var submeshCount = (endSubmesh - startSubmesh) | 0;
                submeshes.Resize(submeshCount);
                var submeshesItems = submeshes.Items;
                var instructionsItems = instructions.Items;
                for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                    var instruction = instructionsItems[((startSubmesh + i) | 0)].$clone();
                    submeshesItems[i] = instruction.$clone();
                    this.hasActiveClipping = !!(this.hasActiveClipping | instruction.hasClipping);
                    submeshesItems[i].rawFirstVertexIndex = runningVertexCount; // Ensure current instructions have correct cached values.
                    runningVertexCount = (runningVertexCount + instruction.rawVertexCount) | 0; // vertexCount will also be used for the rest of this method.
                }
                this.rawVertexCount = runningVertexCount;

                // assumption: instructions are contiguous. start and end are valid within instructions.

                var startSlot = instructionsItems[startSubmesh].startSlot;
                var endSlot = instructionsItems[((endSubmesh - 1) | 0)].endSlot;
                this.attachments.Clear(false);
                var attachmentCount = (endSlot - startSlot) | 0;
                this.attachments.Resize(attachmentCount);
                var attachmentsItems = this.attachments.Items;

                var drawOrderItems = instructionsItems[0].skeleton.DrawOrder.Items;
                for (var i1 = 0; i1 < attachmentCount; i1 = (i1 + 1) | 0) {
                    var slot = drawOrderItems[((startSlot + i1) | 0)];
                    if (!slot.bone.isActive()) {
                        continue;
                    }
                    attachmentsItems[i1] = slot.getAttachment();
                }

            },
            /*Spine.Unity.SkeletonRendererInstruction.SetWithSubset end.*/

            /*Spine.Unity.SkeletonRendererInstruction.Set start.*/
            Set: function (other) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#Set", this ); }

                this.immutableTriangles = other.immutableTriangles;

                this.hasActiveClipping = other.hasActiveClipping;
                this.rawVertexCount = other.rawVertexCount;
                this.attachments.Clear(false);
                this.attachments.EnsureCapacity(other.attachments.Capacity);
                this.attachments.Count = other.attachments.Count;
                other.attachments.CopyTo(this.attachments.Items);

                this.submeshInstructions.Clear(false);
                this.submeshInstructions.EnsureCapacity(other.submeshInstructions.Capacity);
                this.submeshInstructions.Count = other.submeshInstructions.Count;
                other.submeshInstructions.CopyTo(this.submeshInstructions.Items);
            },
            /*Spine.Unity.SkeletonRendererInstruction.Set end.*/


        }
    });
    /*Spine.Unity.SkeletonRendererInstruction end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate
     * @param   {Spine.Unity.SkeletonRenderer}    skeletonRenderer
     * @return  {void}
     */


    /*Spine.Unity.SkeletonRenderSeparator start.*/
    Bridge.define("Spine.Unity.SkeletonRenderSeparator", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                DefaultSortingOrderIncrement: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#init", this ); }

                    this.DefaultSortingOrderIncrement = 5;
                }
            },
            methods: {
                /*Spine.Unity.SkeletonRenderSeparator.AddToSkeletonRenderer:static start.*/
                /**
                 * Adds a SkeletonRenderSeparator and child SkeletonPartsRenderer GameObjects to a given SkeletonRenderer.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonRenderSeparator
                 * @memberof Spine.Unity.SkeletonRenderSeparator
                 * @param   {Spine.Unity.SkeletonRenderer}           skeletonRenderer            The target SkeletonRenderer or SkeletonAnimation.
                 * @param   {number}                                 sortingLayerID              Sorting layer to be used for the parts renderers.
                 * @param   {number}                                 extraPartsRenderers         Number of additional SkeletonPartsRenderers on top of the ones determined by counting the number of separator slots.
                 * @param   {number}                                 sortingOrderIncrement       The integer to increment the sorting order per SkeletonPartsRenderer to separate them.
                 * @param   {number}                                 baseSortingOrder            The sorting order value of the first SkeletonPartsRenderer.
                 * @param   {boolean}                                addMinimumPartsRenderers    If set to <pre><code>true</code></pre>, a minimum number of SkeletonPartsRenderer GameObjects (determined by separatorSlots.Count + 1) will be added.
                 * @return  {Spine.Unity.SkeletonRenderSeparator}                                The to skeleton renderer.
                 */
                AddToSkeletonRenderer: function (skeletonRenderer, sortingLayerID, extraPartsRenderers, sortingOrderIncrement, baseSortingOrder, addMinimumPartsRenderers) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#AddToSkeletonRenderer", this ); }

                    if (sortingLayerID === void 0) { sortingLayerID = 0; }
                    if (extraPartsRenderers === void 0) { extraPartsRenderers = 0; }
                    if (sortingOrderIncrement === void 0) { sortingOrderIncrement = 5; }
                    if (baseSortingOrder === void 0) { baseSortingOrder = 0; }
                    if (addMinimumPartsRenderers === void 0) { addMinimumPartsRenderers = true; }
                    if (UnityEngine.MonoBehaviour.op_Equality(skeletonRenderer, null)) {
                        UnityEngine.Debug.Log$1("Tried to add SkeletonRenderSeparator to a null SkeletonRenderer reference.");
                        return null;
                    }

                    var srs = skeletonRenderer.gameObject.AddComponent(Spine.Unity.SkeletonRenderSeparator);
                    srs.skeletonRenderer = skeletonRenderer;

                    skeletonRenderer.Initialize(false);
                    var count = extraPartsRenderers;
                    if (addMinimumPartsRenderers) {
                        count = (((extraPartsRenderers + skeletonRenderer.separatorSlots.Count) | 0) + 1) | 0;
                    }

                    var skeletonRendererTransform = skeletonRenderer.transform;
                    var componentRenderers = srs.partsRenderers;

                    for (var i = 0; i < count; i = (i + 1) | 0) {
                        var spr = Spine.Unity.SkeletonPartsRenderer.NewPartsRendererGameObject(skeletonRendererTransform, Bridge.toString(i));
                        var mr = spr.MeshRenderer;
                        mr.sortingLayerID = sortingLayerID;
                        mr.sortingOrder = (baseSortingOrder + (Bridge.Int.mul(i, sortingOrderIncrement))) | 0;
                        componentRenderers.add(spr);
                    }

                    srs.OnEnable();


                    return srs;
                },
                /*Spine.Unity.SkeletonRenderSeparator.AddToSkeletonRenderer:static end.*/


            }
        },
        fields: {
            skeletonRenderer: null,
            mainMeshRenderer: null,
            copyPropertyBlock: false,
            copyMeshRendererFlags: false,
            partsRenderers: null,
            copiedBlock: null
        },
        events: {
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderSeparator
             * @memberof Spine.Unity.SkeletonRenderSeparator
             * @function addOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderSeparator
             * @memberof Spine.Unity.SkeletonRenderSeparator
             * @function removeOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            OnMeshAndMaterialsUpdated: null
        },
        props: {
            SkeletonRenderer: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#SkeletonRenderer#get", this ); }

                    return this.skeletonRenderer;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#SkeletonRenderer#set", this ); }

                    if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                        this.skeletonRenderer.removeGenerateMeshOverride(Bridge.fn.cacheBind(this, this.HandleRender));
                    }

                    this.skeletonRenderer = value;
                    if (UnityEngine.MonoBehaviour.op_Equality(value, null)) {
                        this.enabled = false;
                    }
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#init", this ); }

                this.copyPropertyBlock = true;
                this.copyMeshRendererFlags = true;
                this.partsRenderers = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonPartsRenderer)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRenderSeparator.AddPartsRenderer start.*/
            /**
             * Add a child SkeletonPartsRenderer GameObject to this SkeletonRenderSeparator.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderSeparator
             * @memberof Spine.Unity.SkeletonRenderSeparator
             * @param   {number}                               sortingOrderIncrement    
             * @param   {string}                               name
             * @return  {Spine.Unity.SkeletonPartsRenderer}
             */
            AddPartsRenderer: function (sortingOrderIncrement, name) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#AddPartsRenderer", this ); }

                if (sortingOrderIncrement === void 0) { sortingOrderIncrement = 5; }
                if (name === void 0) { name = null; }
                var sortingLayerID = 0;
                var sortingOrder = 0;
                if (this.partsRenderers.Count > 0) {
                    var previous = this.partsRenderers.getItem(((this.partsRenderers.Count - 1) | 0));
                    var previousMeshRenderer = previous.MeshRenderer;
                    sortingLayerID = previousMeshRenderer.sortingLayerID;
                    sortingOrder = (previousMeshRenderer.sortingOrder + sortingOrderIncrement) | 0;
                }

                if (System.String.isNullOrEmpty(name)) {
                    name = Bridge.toString(this.partsRenderers.Count);
                }

                var spr = Spine.Unity.SkeletonPartsRenderer.NewPartsRendererGameObject(this.skeletonRenderer.transform, name);
                this.partsRenderers.add(spr);

                var mr = spr.MeshRenderer;
                mr.sortingLayerID = sortingLayerID;
                mr.sortingOrder = sortingOrder;

                return spr;
            },
            /*Spine.Unity.SkeletonRenderSeparator.AddPartsRenderer end.*/

            /*Spine.Unity.SkeletonRenderSeparator.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    return;
                }
                if (this.copiedBlock == null) {
                    this.copiedBlock = new UnityEngine.MaterialPropertyBlock();
                }
                this.mainMeshRenderer = this.skeletonRenderer.GetComponent(UnityEngine.MeshRenderer);

                this.skeletonRenderer.removeGenerateMeshOverride(Bridge.fn.cacheBind(this, this.HandleRender));
                this.skeletonRenderer.addGenerateMeshOverride(Bridge.fn.cacheBind(this, this.HandleRender));

                if (this.copyMeshRendererFlags) {
                    var lightProbeUsage = this.mainMeshRenderer.lightProbeUsage;
                    var receiveShadows = this.mainMeshRenderer.receiveShadows;
                    var reflectionProbeUsage = this.mainMeshRenderer.reflectionProbeUsage;
                    var shadowCastingMode = this.mainMeshRenderer.shadowCastingMode;
                    var motionVectorGenerationMode = this.mainMeshRenderer.motionVectorGenerationMode;
                    var probeAnchor = this.mainMeshRenderer.probeAnchor;

                    for (var i = 0; i < this.partsRenderers.Count; i = (i + 1) | 0) {
                        var currentRenderer = this.partsRenderers.getItem(i);
                        if (UnityEngine.MonoBehaviour.op_Equality(currentRenderer, null)) {
                            continue;
                        } // skip null items.

                        var mr = currentRenderer.MeshRenderer;
                        mr.lightProbeUsage = lightProbeUsage;
                        mr.receiveShadows = receiveShadows;
                        mr.reflectionProbeUsage = reflectionProbeUsage;
                        mr.shadowCastingMode = shadowCastingMode;
                        mr.motionVectorGenerationMode = motionVectorGenerationMode;
                        mr.probeAnchor = probeAnchor;
                    }
                }

                if (this.skeletonRenderer.updateWhenInvisible !== Spine.Unity.UpdateMode.FullUpdate) {
                    this.skeletonRenderer.LateUpdateMesh();
                }
            },
            /*Spine.Unity.SkeletonRenderSeparator.OnEnable end.*/

            /*Spine.Unity.SkeletonRenderSeparator.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#OnDisable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    return;
                }
                this.skeletonRenderer.removeGenerateMeshOverride(Bridge.fn.cacheBind(this, this.HandleRender));
                this.skeletonRenderer.LateUpdateMesh();
                this.ClearPartsRendererMeshes();
            },
            /*Spine.Unity.SkeletonRenderSeparator.OnDisable end.*/

            /*Spine.Unity.SkeletonRenderSeparator.HandleRender start.*/
            HandleRender: function (instruction) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#HandleRender", this ); }

                var $t;
                var rendererCount = this.partsRenderers.Count;
                if (rendererCount <= 0) {
                    return;
                }

                var assignPropertyBlock = this.copyPropertyBlock && this.mainMeshRenderer.HasPropertyBlock();
                if (assignPropertyBlock) {
                    this.mainMeshRenderer.GetPropertyBlock(this.copiedBlock);
                }

                var settings = ($t = new Spine.Unity.MeshGenerator.Settings(), $t.addNormals = this.skeletonRenderer.addNormals, $t.calculateTangents = this.skeletonRenderer.calculateTangents, $t.immutableTriangles = false, $t.pmaVertexColors = this.skeletonRenderer.pmaVertexColors, $t.tintBlack = this.skeletonRenderer.tintBlack, $t.useClipping = true, $t.zSpacing = this.skeletonRenderer.zSpacing, $t);

                var submeshInstructions = instruction.submeshInstructions;
                var submeshInstructionsItems = submeshInstructions.Items;
                var lastSubmeshInstruction = (submeshInstructions.Count - 1) | 0;

                var rendererIndex = 0;
                var currentRenderer = this.partsRenderers.getItem(rendererIndex);
                for (var si = 0, start = 0; si <= lastSubmeshInstruction; si = (si + 1) | 0) {
                    if (UnityEngine.MonoBehaviour.op_Equality(currentRenderer, null)) {
                        continue;
                    }
                    if (submeshInstructionsItems[si].forceSeparate || si === lastSubmeshInstruction) {
                        // Apply properties
                        var meshGenerator = currentRenderer.MeshGenerator;
                        meshGenerator.settings = settings.$clone();

                        if (assignPropertyBlock) {
                            currentRenderer.SetPropertyBlock(this.copiedBlock);
                        }
                        // Render
                        currentRenderer.RenderParts(instruction.submeshInstructions, start, ((si + 1) | 0));

                        start = (si + 1) | 0;
                        rendererIndex = (rendererIndex + 1) | 0;
                        if (rendererIndex < rendererCount) {
                            currentRenderer = this.partsRenderers.getItem(rendererIndex);
                        } else {
                            // Not enough renderers. Skip the rest of the instructions.
                            break;
                        }
                    }
                }

                if (!Bridge.staticEquals(this.OnMeshAndMaterialsUpdated, null)) {
                    this.OnMeshAndMaterialsUpdated(this.skeletonRenderer);
                }

                // Clear extra renderers if they exist.
                for (; rendererIndex < rendererCount; rendererIndex = (rendererIndex + 1) | 0) {
                    currentRenderer = this.partsRenderers.getItem(rendererIndex);
                    if (UnityEngine.MonoBehaviour.op_Inequality(currentRenderer, null)) {
                        this.partsRenderers.getItem(rendererIndex).ClearMesh();
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderSeparator.HandleRender end.*/

            /*Spine.Unity.SkeletonRenderSeparator.ClearPartsRendererMeshes start.*/
            ClearPartsRendererMeshes: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#ClearPartsRendererMeshes", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.partsRenderers);
                try {
                    while ($t.moveNext()) {
                        var partsRenderer = $t.Current;
                        if (UnityEngine.MonoBehaviour.op_Inequality(partsRenderer, null)) {
                            partsRenderer.ClearMesh();
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderSeparator.ClearPartsRendererMeshes end.*/


        }
    });
    /*Spine.Unity.SkeletonRenderSeparator end.*/

    /*Spine.Unity.SkeletonRootMotionBase+RootMotionInfo start.*/
    Bridge.define("Spine.Unity.SkeletonRootMotionBase.RootMotionInfo", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#getDefaultValue", this ); }
 return new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo(); }
            }
        },
        fields: {
            start: null,
            current: null,
            mid: null,
            end: null,
            timeIsPastMid: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#init", this ); }

                this.start = new UnityEngine.Vector2();
                this.current = new UnityEngine.Vector2();
                this.mid = new UnityEngine.Vector2();
                this.end = new UnityEngine.Vector2();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#getHashCode", this ); }

                var h = Bridge.addHash([5573033076, this.start, this.current, this.mid, this.end, this.timeIsPastMid]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.SkeletonRootMotionBase.RootMotionInfo)) {
                    return false;
                }
                return Bridge.equals(this.start, o.start) && Bridge.equals(this.current, o.current) && Bridge.equals(this.mid, o.mid) && Bridge.equals(this.end, o.end) && Bridge.equals(this.timeIsPastMid, o.timeIsPastMid);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#$clone", this ); }

                var s = to || new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo();
                s.start = this.start.$clone();
                s.current = this.current.$clone();
                s.mid = this.mid.$clone();
                s.end = this.end.$clone();
                s.timeIsPastMid = this.timeIsPastMid;
                return s;
            }
        }
    });
    /*Spine.Unity.SkeletonRootMotionBase+RootMotionInfo end.*/

    /*Spine.Unity.SkeletonSubmeshGraphic start.*/
    /**
     * A minimal MaskableGraphic subclass for rendering multiple submeshes
     at a {@link }.
     *
     * @public
     * @class Spine.Unity.SkeletonSubmeshGraphic
     * @augments UnityEngine.UI.MaskableGraphic
     */
    Bridge.define("Spine.Unity.SkeletonSubmeshGraphic", {
        inherits: [UnityEngine.UI.MaskableGraphic],
        methods: {
            /*Spine.Unity.SkeletonSubmeshGraphic.SetMaterialDirty start.*/
            SetMaterialDirty: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonSubmeshGraphic#SetMaterialDirty", this ); }
 },
            /*Spine.Unity.SkeletonSubmeshGraphic.SetMaterialDirty end.*/

            /*Spine.Unity.SkeletonSubmeshGraphic.SetVerticesDirty start.*/
            SetVerticesDirty: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonSubmeshGraphic#SetVerticesDirty", this ); }
 },
            /*Spine.Unity.SkeletonSubmeshGraphic.SetVerticesDirty end.*/

            /*Spine.Unity.SkeletonSubmeshGraphic.OnPopulateMesh start.*/
            OnPopulateMesh: function (vh) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonSubmeshGraphic#OnPopulateMesh", this ); }

                vh.Clear();
            },
            /*Spine.Unity.SkeletonSubmeshGraphic.OnPopulateMesh end.*/

            /*Spine.Unity.SkeletonSubmeshGraphic.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonSubmeshGraphic#OnDisable", this ); }

                UnityEngine.UI.MaskableGraphic.prototype.OnDisable.call(this);
                this.canvasRenderer.cull = true;
            },
            /*Spine.Unity.SkeletonSubmeshGraphic.OnDisable end.*/

            /*Spine.Unity.SkeletonSubmeshGraphic.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonSubmeshGraphic#OnEnable", this ); }

                UnityEngine.UI.MaskableGraphic.prototype.OnEnable.call(this);
                this.canvasRenderer.cull = false;
            },
            /*Spine.Unity.SkeletonSubmeshGraphic.OnEnable end.*/


        }
    });
    /*Spine.Unity.SkeletonSubmeshGraphic end.*/

    /*Spine.Unity.SkeletonUtility start.*/
    Bridge.define("Spine.Unity.SkeletonUtility", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject:static start.*/
                AddBoundingBoxGameObject: function (skeleton, skinName, slotName, attachmentName, parent, isTrigger) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#AddBoundingBoxGameObject", this ); }

                    if (isTrigger === void 0) { isTrigger = true; }
                    var skin = System.String.isNullOrEmpty(skinName) ? skeleton.data.defaultSkin : skeleton.data.findSkin(skinName);
                    if (skin == null) {
                        UnityEngine.Debug.LogError$2("Skin " + (skinName || "") + " not found!");
                        return null;
                    }

                    var slot = skeleton.findSlot(slotName);
                    var attachment = slot != null ? skin.getAttachment(slot.data.index, attachmentName) : null;
                    if (attachment == null) {
                        UnityEngine.Debug.LogFormat("Attachment in slot '{0}' named '{1}' not found in skin '{2}'.", [slotName, attachmentName, skin.name]);
                        return null;
                    }

                    var box = Bridge.as(attachment, spine.BoundingBoxAttachment);
                    if (box != null) {
                        return Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject$1(box.name, box, slot, parent, isTrigger);
                    } else {
                        UnityEngine.Debug.LogFormat("Attachment '{0}' was not a Bounding Box.", [attachmentName]);
                        return null;
                    }
                },
                /*Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject:static end.*/

                /*Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject$1:static start.*/
                AddBoundingBoxGameObject$1: function (name, box, slot, parent, isTrigger) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#AddBoundingBoxGameObject$1", this ); }

                    if (isTrigger === void 0) { isTrigger = true; }
                    var go = new UnityEngine.GameObject.$ctor2("[BoundingBox]" + ((System.String.isNullOrEmpty(name) ? box.name : name) || ""));
                    var got = go.transform;
                    got.parent = parent;
                    got.localPosition = pc.Vec3.ZERO.clone();
                    got.localRotation = pc.Quat.IDENTITY.clone();
                    got.localScale = new pc.Vec3( 1, 1, 1 );
                    return Spine.Unity.SkeletonUtility.AddBoundingBoxAsComponent(box, slot, go, isTrigger);
                },
                /*Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject$1:static end.*/

                /*Spine.Unity.SkeletonUtility.AddBoundingBoxAsComponent:static start.*/
                AddBoundingBoxAsComponent: function (box, slot, gameObject, isTrigger) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#AddBoundingBoxAsComponent", this ); }

                    if (isTrigger === void 0) { isTrigger = true; }
                    if (box == null) {
                        return null;
                    }
                    var collider = gameObject.AddComponent(UnityEngine.PolygonCollider2D);
                    collider.isTrigger = isTrigger;
                    Spine.Unity.SkeletonUtility.SetColliderPointsLocal(collider, slot, box);
                    return collider;
                },
                /*Spine.Unity.SkeletonUtility.AddBoundingBoxAsComponent:static end.*/

                /*Spine.Unity.SkeletonUtility.SetColliderPointsLocal:static start.*/
                SetColliderPointsLocal: function (collider, slot, box, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SetColliderPointsLocal", this ); }

                    if (scale === void 0) { scale = 1.0; }
                    if (box == null) {
                        return;
                    }
                    if (Spine.SpineSkeletonExtensions.IsWeighted(box)) {
                        UnityEngine.Debug.LogWarning$1("UnityEngine.PolygonCollider2D does not support weighted or animated points. Collider points will not be animated and may have incorrect orientation. If you want to use it as a collider, please remove weights and animations from the bounding box in Spine editor.");
                    }
                    var verts = Spine.Unity.SkeletonExtensions.GetLocalVertices(box, slot, null);
                    if (scale !== 1.0) {
                        for (var i = 0, n = verts.length; i < n; i = (i + 1) | 0) {
                            verts[i] = verts[i].$clone().scale( scale );
                        }
                    }
                    collider.SetPath$1(0, verts);
                },
                /*Spine.Unity.SkeletonUtility.SetColliderPointsLocal:static end.*/

                /*Spine.Unity.SkeletonUtility.GetBoundingBoxBounds:static start.*/
                GetBoundingBoxBounds: function (boundingBox, depth) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#GetBoundingBoxBounds", this ); }

                    if (depth === void 0) { depth = 0.0; }
                    var floats = boundingBox.vertices;
                    var floatCount = floats.length;

                    var bounds = new pc.BoundingBox.ctor();

                    bounds.center = new pc.Vec3( floats[0], floats[1], 0 );
                    for (var i = 2; i < floatCount; i = (i + 2) | 0) {
                        bounds.expandToPoint( new pc.Vec3( floats[i], floats[((i + 1) | 0)], 0 ) );
                    }

                    var size = bounds.halfExtents.$clone().scale( 2 ).$clone();
                    size.z = depth;
                    bounds.halfExtents = size.$clone().$clone().scale( 0.5 );

                    return bounds;
                },
                /*Spine.Unity.SkeletonUtility.GetBoundingBoxBounds:static end.*/

                /*Spine.Unity.SkeletonUtility.AddBoneRigidbody2D:static start.*/
                AddBoneRigidbody2D: function (gameObject, isKinematic, gravityScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#AddBoneRigidbody2D", this ); }

                    if (isKinematic === void 0) { isKinematic = true; }
                    if (gravityScale === void 0) { gravityScale = 0.0; }
                    var rb = gameObject.GetComponent(UnityEngine.Rigidbody2D);
                    if (UnityEngine.Component.op_Equality(rb, null)) {
                        rb = gameObject.AddComponent(UnityEngine.Rigidbody2D);
                        rb.isKinematic = isKinematic;
                        rb.gravityScale = gravityScale;
                    }
                    return rb;
                },
                /*Spine.Unity.SkeletonUtility.AddBoneRigidbody2D:static end.*/


            }
        },
        fields: {
            boneRoot: null,
            /**
             * If true, {@link } and {@link } are followed
             by 180 degree rotation. If false, negative Transform scale is used.
             Note that using negative scale is consistent with previous behaviour (hence the default),
             however causes serious problems with rigidbodies and physics. Therefore, it is recommended to
             enable this parameter where possible. When creating hinge chains for a chain of skeleton bones
             via {@link }, it is mandatory to have <pre><code>flipBy180DegreeRotation</code></pre> enabled.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonUtility
             * @default false
             * @type boolean
             */
            flipBy180DegreeRotation: false,
            skeletonRenderer: null,
            skeletonGraphic: null,
            skeletonAnimation: null,
            skeletonComponent: null,
            boneComponents: null,
            constraintComponents: null,
            positionScale: 0,
            hasOverrideBones: false,
            hasConstraints: false,
            needToReprocessBones: false
        },
        events: {
            OnReset: null
        },
        props: {
            SkeletonComponent: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SkeletonComponent#get", this ); }

                    if (this.skeletonComponent == null) {
                        this.skeletonComponent = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) ? this.skeletonRenderer.GetComponent(Spine.Unity.ISkeletonComponent) : UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) ? this.skeletonGraphic.GetComponent(Spine.Unity.ISkeletonComponent) : this.GetComponent(Spine.Unity.ISkeletonComponent);
                    }
                    return this.skeletonComponent;
                }
            },
            Skeleton: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#Skeleton#get", this ); }

                    if (this.SkeletonComponent == null) {
                        return null;
                    }
                    return this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                }
            },
            IsValid: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#IsValid#get", this ); }

                    return (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) && this.skeletonRenderer.valid) || (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) && this.skeletonGraphic.IsValid);
                }
            },
            PositionScale: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#PositionScale#get", this ); }

                    return this.positionScale;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#init", this ); }

                this.flipBy180DegreeRotation = false;
                this.boneComponents = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonUtilityBone)).ctor();
                this.constraintComponents = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonUtilityConstraint)).ctor();
                this.positionScale = 1.0;
            }
        },
        methods: {
            /*Spine.Unity.SkeletonUtility.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#Update", this ); }

                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                if (skeleton != null && UnityEngine.Component.op_Inequality(this.boneRoot, null)) {

                    if (this.flipBy180DegreeRotation) {
                        this.boneRoot.localScale = new pc.Vec3( Math.abs(skeleton.scaleX), Math.abs(skeleton.scaleY), 1.0 );
                        this.boneRoot.eulerAngles = new pc.Vec3( skeleton.scaleY > 0 ? 0 : 180, skeleton.scaleX > 0 ? 0 : 180, 0 );
                    } else {
                        this.boneRoot.localScale = new pc.Vec3( skeleton.scaleX, skeleton.scaleY, 1.0 );
                    }
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.positionScale = this.skeletonGraphic.MeshScale;
                }
            },
            /*Spine.Unity.SkeletonUtility.Update end.*/

            /*Spine.Unity.SkeletonUtility.ResubscribeEvents start.*/
            ResubscribeEvents: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#ResubscribeEvents", this ); }

                this.OnDisable();
                this.OnEnable();
            },
            /*Spine.Unity.SkeletonUtility.ResubscribeEvents end.*/

            /*Spine.Unity.SkeletonUtility.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer = this.GetComponent(Spine.Unity.SkeletonRenderer);
                }
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic = this.GetComponent(Spine.Unity.SkeletonGraphic);
                }
                if (this.skeletonAnimation == null) {
                    this.skeletonAnimation = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) ? this.skeletonRenderer.GetComponent(Spine.Unity.ISkeletonAnimation) : UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) ? this.skeletonGraphic.GetComponent(Spine.Unity.ISkeletonAnimation) : this.GetComponent(Spine.Unity.ISkeletonAnimation);
                }
                if (this.skeletonComponent == null) {
                    this.skeletonComponent = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) ? this.skeletonRenderer.GetComponent(Spine.Unity.ISkeletonComponent) : UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) ? this.skeletonGraphic.GetComponent(Spine.Unity.ISkeletonComponent) : this.GetComponent(Spine.Unity.ISkeletonComponent);
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset$1));
                    this.skeletonRenderer.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset$1));
                } else if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset));
                    this.skeletonGraphic.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset));
                }

                if (this.skeletonAnimation != null) {
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateLocal(Bridge.fn.cacheBind(this, this.UpdateLocal));
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$addUpdateLocal(Bridge.fn.cacheBind(this, this.UpdateLocal));
                }

                this.CollectBones();
            },
            /*Spine.Unity.SkeletonUtility.OnEnable end.*/

            /*Spine.Unity.SkeletonUtility.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#Start", this ); }

                //recollect because order of operations failure when switching between game mode and edit mode...
                this.CollectBones();
            },
            /*Spine.Unity.SkeletonUtility.Start end.*/

            /*Spine.Unity.SkeletonUtility.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#OnDisable", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset$1));
                }
                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset));
                }

                if (this.skeletonAnimation != null) {
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateLocal(Bridge.fn.cacheBind(this, this.UpdateLocal));
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateWorld(Bridge.fn.cacheBind(this, this.UpdateWorld));
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateComplete(Bridge.fn.cacheBind(this, this.UpdateComplete));
                }
            },
            /*Spine.Unity.SkeletonUtility.OnDisable end.*/

            /*Spine.Unity.SkeletonUtility.HandleRendererReset$1 start.*/
            HandleRendererReset$1: function (r) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#HandleRendererReset$1", this ); }

                if (!Bridge.staticEquals(this.OnReset, null)) {
                    this.OnReset();
                }
                this.CollectBones();
            },
            /*Spine.Unity.SkeletonUtility.HandleRendererReset$1 end.*/

            /*Spine.Unity.SkeletonUtility.HandleRendererReset start.*/
            HandleRendererReset: function (g) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#HandleRendererReset", this ); }

                if (!Bridge.staticEquals(this.OnReset, null)) {
                    this.OnReset();
                }
                this.CollectBones();
            },
            /*Spine.Unity.SkeletonUtility.HandleRendererReset end.*/

            /*Spine.Unity.SkeletonUtility.RegisterBone start.*/
            RegisterBone: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#RegisterBone", this ); }

                if (this.boneComponents.contains(bone)) {
                    return;
                } else {
                    this.boneComponents.add(bone);
                    this.needToReprocessBones = true;
                }
            },
            /*Spine.Unity.SkeletonUtility.RegisterBone end.*/

            /*Spine.Unity.SkeletonUtility.UnregisterBone start.*/
            UnregisterBone: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UnregisterBone", this ); }

                this.boneComponents.remove(bone);
            },
            /*Spine.Unity.SkeletonUtility.UnregisterBone end.*/

            /*Spine.Unity.SkeletonUtility.RegisterConstraint start.*/
            RegisterConstraint: function (constraint) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#RegisterConstraint", this ); }

                if (this.constraintComponents.contains(constraint)) {
                    return;
                } else {
                    this.constraintComponents.add(constraint);
                    this.needToReprocessBones = true;
                }
            },
            /*Spine.Unity.SkeletonUtility.RegisterConstraint end.*/

            /*Spine.Unity.SkeletonUtility.UnregisterConstraint start.*/
            UnregisterConstraint: function (constraint) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UnregisterConstraint", this ); }

                this.constraintComponents.remove(constraint);
            },
            /*Spine.Unity.SkeletonUtility.UnregisterConstraint end.*/

            /*Spine.Unity.SkeletonUtility.CollectBones start.*/
            CollectBones: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#CollectBones", this ); }

                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                if (skeleton == null) {
                    return;
                }

                if (UnityEngine.Component.op_Inequality(this.boneRoot, null)) {
                    var constraintTargets = new (System.Collections.Generic.List$1(System.Object)).ctor();
                    var ikConstraints = skeleton.IkConstraints;
                    for (var i = 0, n = ikConstraints.Count; i < n; i = (i + 1) | 0) {
                        constraintTargets.add(ikConstraints.Items[i].target);
                    }

                    var transformConstraints = skeleton.TransformConstraints;
                    for (var i1 = 0, n1 = transformConstraints.Count; i1 < n1; i1 = (i1 + 1) | 0) {
                        constraintTargets.add(transformConstraints.Items[i1].target);
                    }

                    var boneComponents = this.boneComponents;
                    for (var i2 = 0, n2 = boneComponents.Count; i2 < n2; i2 = (i2 + 1) | 0) {
                        var b = boneComponents.getItem(i2);
                        if (b.bone == null) {
                            b.DoUpdate(Spine.Unity.SkeletonUtilityBone.UpdatePhase.Local);
                            if (b.bone == null) {
                                continue;
                            }
                        }
                        this.hasOverrideBones = !!(this.hasOverrideBones | (b.mode === Spine.Unity.SkeletonUtilityBone.Mode.Override));
                        this.hasConstraints = !!(this.hasConstraints | constraintTargets.contains(b.bone));
                    }

                    this.hasConstraints = !!(this.hasConstraints | this.constraintComponents.Count > 0);

                    if (this.skeletonAnimation != null) {
                        this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateWorld(Bridge.fn.cacheBind(this, this.UpdateWorld));
                        this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateComplete(Bridge.fn.cacheBind(this, this.UpdateComplete));

                        if (this.hasOverrideBones || this.hasConstraints) {
                            this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$addUpdateWorld(Bridge.fn.cacheBind(this, this.UpdateWorld));
                        }

                        if (this.hasConstraints) {
                            this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$addUpdateComplete(Bridge.fn.cacheBind(this, this.UpdateComplete));
                        }
                    }

                    this.needToReprocessBones = false;
                } else {
                    this.boneComponents.clear();
                    this.constraintComponents.clear();
                }
            },
            /*Spine.Unity.SkeletonUtility.CollectBones end.*/

            /*Spine.Unity.SkeletonUtility.UpdateLocal start.*/
            UpdateLocal: function (anim) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UpdateLocal", this ); }

                if (this.needToReprocessBones) {
                    this.CollectBones();
                }

                var boneComponents = this.boneComponents;
                if (boneComponents == null) {
                    return;
                }
                for (var i = 0, n = boneComponents.Count; i < n; i = (i + 1) | 0) {
                    boneComponents.getItem(i).transformLerpComplete = false;
                }

                this.UpdateAllBones(Spine.Unity.SkeletonUtilityBone.UpdatePhase.Local);
            },
            /*Spine.Unity.SkeletonUtility.UpdateLocal end.*/

            /*Spine.Unity.SkeletonUtility.UpdateWorld start.*/
            UpdateWorld: function (anim) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UpdateWorld", this ); }

                this.UpdateAllBones(Spine.Unity.SkeletonUtilityBone.UpdatePhase.World);
                for (var i = 0, n = this.constraintComponents.Count; i < n; i = (i + 1) | 0) {
                    this.constraintComponents.getItem(i).DoUpdate();
                }
            },
            /*Spine.Unity.SkeletonUtility.UpdateWorld end.*/

            /*Spine.Unity.SkeletonUtility.UpdateComplete start.*/
            UpdateComplete: function (anim) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UpdateComplete", this ); }

                this.UpdateAllBones(Spine.Unity.SkeletonUtilityBone.UpdatePhase.Complete);
            },
            /*Spine.Unity.SkeletonUtility.UpdateComplete end.*/

            /*Spine.Unity.SkeletonUtility.UpdateAllBones start.*/
            UpdateAllBones: function (phase) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UpdateAllBones", this ); }

                if (UnityEngine.Component.op_Equality(this.boneRoot, null)) {
                    this.CollectBones();
                }

                var boneComponents = this.boneComponents;
                if (boneComponents == null) {
                    return;
                }
                for (var i = 0, n = boneComponents.Count; i < n; i = (i + 1) | 0) {
                    boneComponents.getItem(i).DoUpdate(phase);
                }
            },
            /*Spine.Unity.SkeletonUtility.UpdateAllBones end.*/

            /*Spine.Unity.SkeletonUtility.GetBoneRoot start.*/
            GetBoneRoot: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#GetBoneRoot", this ); }

                if (UnityEngine.Component.op_Inequality(this.boneRoot, null)) {
                    return this.boneRoot;
                }

                var boneRootObject = new UnityEngine.GameObject.$ctor2("SkeletonUtility-SkeletonRoot");
                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    boneRootObject.AddComponent(UnityEngine.RectTransform);
                }

                this.boneRoot = boneRootObject.transform;
                this.boneRoot.SetParent(this.transform);
                this.boneRoot.localPosition = pc.Vec3.ZERO.clone();
                this.boneRoot.localRotation = pc.Quat.IDENTITY.clone();
                this.boneRoot.localScale = new pc.Vec3( 1, 1, 1 );

                return this.boneRoot;
            },
            /*Spine.Unity.SkeletonUtility.GetBoneRoot end.*/

            /*Spine.Unity.SkeletonUtility.SpawnRoot start.*/
            SpawnRoot: function (mode, pos, rot, sca) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SpawnRoot", this ); }

                this.GetBoneRoot();
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;

                var go = this.SpawnBone(skeleton.getRootBone(), this.boneRoot, mode, pos, rot, sca);
                this.CollectBones();
                return go;
            },
            /*Spine.Unity.SkeletonUtility.SpawnRoot end.*/

            /*Spine.Unity.SkeletonUtility.SpawnHierarchy start.*/
            SpawnHierarchy: function (mode, pos, rot, sca) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SpawnHierarchy", this ); }

                this.GetBoneRoot();
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                var go = this.SpawnBoneRecursively(skeleton.getRootBone(), this.boneRoot, mode, pos, rot, sca);
                this.CollectBones();
                return go;
            },
            /*Spine.Unity.SkeletonUtility.SpawnHierarchy end.*/

            /*Spine.Unity.SkeletonUtility.SpawnBoneRecursively start.*/
            SpawnBoneRecursively: function (bone, parent, mode, pos, rot, sca) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SpawnBoneRecursively", this ); }

                var go = this.SpawnBone(bone, parent, mode, pos, rot, sca);

                var childrenBones = bone.Children;
                for (var i = 0, n = childrenBones.Count; i < n; i = (i + 1) | 0) {
                    var child = childrenBones.Items[i];
                    this.SpawnBoneRecursively(child, go.transform, mode, pos, rot, sca);
                }

                return go;
            },
            /*Spine.Unity.SkeletonUtility.SpawnBoneRecursively end.*/

            /*Spine.Unity.SkeletonUtility.SpawnBone start.*/
            SpawnBone: function (bone, parent, mode, pos, rot, sca) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SpawnBone", this ); }

                var go = new UnityEngine.GameObject.$ctor2(bone.data.name);
                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    go.AddComponent(UnityEngine.RectTransform);
                }

                var goTransform = go.transform;
                goTransform.SetParent(parent);

                var b = go.AddComponent(Spine.Unity.SkeletonUtilityBone);
                b.hierarchy = this;
                b.position = pos;
                b.rotation = rot;
                b.scale = sca;
                b.mode = mode;
                b.zPosition = true;
                b.Reset();
                b.bone = bone;
                b.boneName = bone.data.name;
                b.valid = true;

                if (mode === Spine.Unity.SkeletonUtilityBone.Mode.Override) {
                    if (rot) {
                        goTransform.localRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, b.bone.arotation );
                    }
                    if (pos) {
                        goTransform.localPosition = new pc.Vec3( b.bone.x * this.positionScale, b.bone.y * this.positionScale, 0 );
                    }
                    goTransform.localScale = new pc.Vec3( b.bone.scaleX, b.bone.scaleY, 0 );
                }

                return go;
            },
            /*Spine.Unity.SkeletonUtility.SpawnBone end.*/


        },
        overloads: {
            "HandleRendererReset(SkeletonRenderer)": "HandleRendererReset$1"
        }
    });
    /*Spine.Unity.SkeletonUtility end.*/

    /*Spine.Unity.SkeletonUtilityBone start.*/
    /**
     * Sets a GameObject's transform to match a bone on a Spine skeleton.
     *
     * @public
     * @class Spine.Unity.SkeletonUtilityBone
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.SkeletonUtilityBone", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible:static start.*/
                BoneTransformModeIncompatible: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#BoneTransformModeIncompatible", this ); }

                    return !Spine.SpineSkeletonExtensions.InheritsScale(bone.data.transformMode);
                },
                /*Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible:static end.*/


            }
        },
        fields: {
            /**
             * If a bone isn't set, boneName is used to find the bone.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonUtilityBone
             * @type string
             */
            boneName: null,
            parentReference: null,
            mode: 0,
            position: false,
            rotation: false,
            scale: false,
            zPosition: false,
            overrideAlpha: 0,
            hierarchy: null,
            bone: null,
            transformLerpComplete: false,
            valid: false,
            cachedTransform: null,
            skeletonTransform: null,
            incompatibleTransformMode: false
        },
        props: {
            IncompatibleTransformMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#IncompatibleTransformMode#get", this ); }

                    return this.incompatibleTransformMode;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#init", this ); }

                this.zPosition = true;
                this.overrideAlpha = 1;
            }
        },
        methods: {
            /*Spine.Unity.SkeletonUtilityBone.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#Reset", this ); }

                this.bone = null;
                this.cachedTransform = this.transform;
                this.valid = UnityEngine.MonoBehaviour.op_Inequality(this.hierarchy, null) && this.hierarchy.IsValid;
                if (!this.valid) {
                    return;
                }
                this.skeletonTransform = this.hierarchy.transform;
                this.hierarchy.removeOnReset(Bridge.fn.cacheBind(this, this.HandleOnReset));
                this.hierarchy.addOnReset(Bridge.fn.cacheBind(this, this.HandleOnReset));
                this.DoUpdate(Spine.Unity.SkeletonUtilityBone.UpdatePhase.Local);
            },
            /*Spine.Unity.SkeletonUtilityBone.Reset end.*/

            /*Spine.Unity.SkeletonUtilityBone.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.hierarchy, null)) {
                    this.hierarchy = this.transform.GetComponentInParent(Spine.Unity.SkeletonUtility);
                }
                if (UnityEngine.MonoBehaviour.op_Equality(this.hierarchy, null)) {
                    return;
                }

                this.hierarchy.RegisterBone(this);
                this.hierarchy.addOnReset(Bridge.fn.cacheBind(this, this.HandleOnReset));
            },
            /*Spine.Unity.SkeletonUtilityBone.OnEnable end.*/

            /*Spine.Unity.SkeletonUtilityBone.HandleOnReset start.*/
            HandleOnReset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#HandleOnReset", this ); }

                this.Reset();
            },
            /*Spine.Unity.SkeletonUtilityBone.HandleOnReset end.*/

            /*Spine.Unity.SkeletonUtilityBone.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#OnDisable", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.hierarchy, null)) {
                    this.hierarchy.removeOnReset(Bridge.fn.cacheBind(this, this.HandleOnReset));
                    this.hierarchy.UnregisterBone(this);
                }
            },
            /*Spine.Unity.SkeletonUtilityBone.OnDisable end.*/

            /*Spine.Unity.SkeletonUtilityBone.DoUpdate start.*/
            DoUpdate: function (phase) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#DoUpdate", this ); }

                var $t;
                if (!this.valid) {
                    this.Reset();
                    return;
                }

                var skeleton = this.hierarchy.Skeleton;

                if (this.bone == null) {
                    if (System.String.isNullOrEmpty(this.boneName)) {
                        return;
                    }
                    this.bone = skeleton.findBone(this.boneName);
                    if (this.bone == null) {
                        UnityEngine.Debug.LogError$2("Bone not found: " + (this.boneName || ""), this);
                        return;
                    }
                }
                if (!this.bone.isActive()) {
                    return;
                }

                var positionScale = this.hierarchy.PositionScale;

                var thisTransform = this.cachedTransform;
                var skeletonFlipRotation = ($t = skeleton.scaleX * skeleton.scaleY, ($t === 0 ? 1 : Math.sign($t)));
                if (this.mode === Spine.Unity.SkeletonUtilityBone.Mode.Follow) {
                    switch (phase) {
                        case Spine.Unity.SkeletonUtilityBone.UpdatePhase.Local: 
                            if (this.position) {
                                thisTransform.localPosition = new pc.Vec3( this.bone.x * positionScale, this.bone.y * positionScale, 0 );
                            }
                            if (this.rotation) {
                                if (Spine.SpineSkeletonExtensions.InheritsRotation(this.bone.data.transformMode)) {
                                    thisTransform.localRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, this.bone.rotation );
                                } else {
                                    var euler = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                                    thisTransform.rotation = new pc.Quat().setFromEulerAngles_Unity( euler.x, euler.y, euler.z + (this.bone.getWorldRotationX() * skeletonFlipRotation) );
                                }
                            }
                            if (this.scale) {
                                thisTransform.localScale = new pc.Vec3( this.bone.scaleX, this.bone.scaleY, 1.0 );
                                this.incompatibleTransformMode = Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible(this.bone);
                            }
                            break;
                        case Spine.Unity.SkeletonUtilityBone.UpdatePhase.World: 
                        case Spine.Unity.SkeletonUtilityBone.UpdatePhase.Complete: 
                            if (this.position) {
                                thisTransform.localPosition = new pc.Vec3( this.bone.ax * positionScale, this.bone.ay * positionScale, 0 );
                            }
                            if (this.rotation) {
                                if (Spine.SpineSkeletonExtensions.InheritsRotation(this.bone.data.transformMode)) {
                                    thisTransform.localRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, this.bone.arotation );
                                } else {
                                    var euler1 = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                                    thisTransform.rotation = new pc.Quat().setFromEulerAngles_Unity( euler1.x, euler1.y, euler1.z + (this.bone.getWorldRotationX() * skeletonFlipRotation) );
                                }
                            }
                            if (this.scale) {
                                thisTransform.localScale = new pc.Vec3( this.bone.ascaleX, this.bone.ascaleY, 1.0 );
                                this.incompatibleTransformMode = Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible(this.bone);
                            }
                            break;
                    }

                } else if (this.mode === Spine.Unity.SkeletonUtilityBone.Mode.Override) {
                    if (this.transformLerpComplete) {
                        return;
                    }

                    if (UnityEngine.Component.op_Equality(this.parentReference, null)) {
                        if (this.position) {
                            var clp = thisTransform.localPosition.$clone().scale( 1.0 / ( positionScale ) );
                            this.bone.x = pc.math.lerp(this.bone.x, clp.x, this.overrideAlpha);
                            this.bone.y = pc.math.lerp(this.bone.y, clp.y, this.overrideAlpha);
                        }

                        if (this.rotation) {
                            var angle = UnityEngine.Mathf.LerpAngle(this.bone.rotation, thisTransform.localRotation.getPositiveEulerAngles().z, this.overrideAlpha);
                            this.bone.rotation = angle;
                            this.bone.arotation = angle;
                        }

                        if (this.scale) {
                            var cls = thisTransform.localScale.$clone();
                            this.bone.scaleX = pc.math.lerp(this.bone.scaleX, cls.x, this.overrideAlpha);
                            this.bone.scaleY = pc.math.lerp(this.bone.scaleY, cls.y, this.overrideAlpha);
                        }

                    } else {
                        if (this.transformLerpComplete) {
                            return;
                        }

                        if (this.position) {
                            var pos = this.parentReference.InverseTransformPoint(thisTransform.position).scale( 1.0 / ( positionScale ) );
                            this.bone.x = pc.math.lerp(this.bone.x, pos.x, this.overrideAlpha);
                            this.bone.y = pc.math.lerp(this.bone.y, pos.y, this.overrideAlpha);
                        }

                        if (this.rotation) {
                            var angle1 = UnityEngine.Mathf.LerpAngle(this.bone.rotation, new pc.Quat().setLookAt( new pc.Vec3( 0, 0, 1 ), this.parentReference.InverseTransformDirection(thisTransform.up) ).getPositiveEulerAngles().z, this.overrideAlpha);
                            this.bone.rotation = angle1;
                            this.bone.arotation = angle1;
                        }

                        if (this.scale) {
                            var cls1 = thisTransform.localScale.$clone();
                            this.bone.scaleX = pc.math.lerp(this.bone.scaleX, cls1.x, this.overrideAlpha);
                            this.bone.scaleY = pc.math.lerp(this.bone.scaleY, cls1.y, this.overrideAlpha);
                        }

                        this.incompatibleTransformMode = Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible(this.bone);
                    }

                    this.transformLerpComplete = true;
                }
            },
            /*Spine.Unity.SkeletonUtilityBone.DoUpdate end.*/

            /*Spine.Unity.SkeletonUtilityBone.AddBoundingBox start.*/
            AddBoundingBox: function (skinName, slotName, attachmentName) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#AddBoundingBox", this ); }

                Spine.Unity.SkeletonUtility.AddBoneRigidbody2D(this.transform.gameObject);
                Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject(this.bone.skeleton, skinName, slotName, attachmentName, this.transform);
            },
            /*Spine.Unity.SkeletonUtilityBone.AddBoundingBox end.*/


        }
    });
    /*Spine.Unity.SkeletonUtilityBone end.*/

    /*Spine.Unity.SkeletonUtilityBone+Mode start.*/
    Bridge.define("Spine.Unity.SkeletonUtilityBone.Mode", {
        $kind: 1006,
        statics: {
            fields: {
                Follow: 0,
                Override: 1
            }
        }
    });
    /*Spine.Unity.SkeletonUtilityBone+Mode end.*/

    /*Spine.Unity.SkeletonUtilityBone+UpdatePhase start.*/
    Bridge.define("Spine.Unity.SkeletonUtilityBone.UpdatePhase", {
        $kind: 1006,
        statics: {
            fields: {
                Local: 0,
                World: 1,
                Complete: 2
            }
        }
    });
    /*Spine.Unity.SkeletonUtilityBone+UpdatePhase end.*/

    /*Spine.Unity.SpineAttributeBase start.*/
    Bridge.define("Spine.Unity.SpineAttributeBase", {
        inherits: [UnityEngine.PropertyAttribute],
        fields: {
            dataField: null,
            startsWith: null,
            includeNone: false,
            fallbackToTextField: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttributeBase#init", this ); }

                this.dataField = "";
                this.startsWith = "";
                this.includeNone = true;
                this.fallbackToTextField = false;
            }
        }
    });
    /*Spine.Unity.SpineAttributeBase end.*/

    /*Spine.Unity.SpineAtlasRegion start.*/
    Bridge.define("Spine.Unity.SpineAtlasRegion", {
        inherits: [UnityEngine.PropertyAttribute],
        fields: {
            atlasAssetField: null
        },
        ctors: {
            ctor: function (atlasAssetField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasRegion#ctor", this ); }

                if (atlasAssetField === void 0) { atlasAssetField = ""; }

                this.$initialize();
                UnityEngine.PropertyAttribute.ctor.call(this);
                this.atlasAssetField = atlasAssetField;
            }
        }
    });
    /*Spine.Unity.SpineAtlasRegion end.*/

    /*Spine.Unity.SpineAttachment+Hierarchy start.*/
    /**
     * A struct that represents 3 strings that help identify and locate an attachment in a skeleton.
     *
     * @public
     * @class Spine.Unity.SpineAttachment.Hierarchy
     */
    Bridge.define("Spine.Unity.SpineAttachment.Hierarchy", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#getDefaultValue", this ); }
 return new Spine.Unity.SpineAttachment.Hierarchy(); }
            }
        },
        fields: {
            skin: null,
            slot: null,
            name: null
        },
        ctors: {
            $ctor1: function (fullPath) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#$ctor1", this ); }

                this.$initialize();
                var chunks = System.String.split(fullPath, System.Array.init([47], System.Char).map(function (i) {{ return String.fromCharCode(i); }}), null, 1);
                if (chunks.length === 0) {
                    this.skin = "";
                    this.slot = "";
                    this.name = "";
                    return;
                } else if (chunks.length < 2) {
                    throw new System.Exception("Cannot generate Attachment Hierarchy from string! Not enough components! [" + (fullPath || "") + "]");
                }
                this.skin = chunks[0];
                this.slot = chunks[1];
                this.name = "";
                for (var i = 2; i < chunks.length; i = (i + 1) | 0) {
                    this.name = (this.name || "") + (chunks[i] || "");
                }
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#getHashCode", this ); }

                var h = Bridge.addHash([3670596642, this.skin, this.slot, this.name]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.SpineAttachment.Hierarchy)) {
                    return false;
                }
                return Bridge.equals(this.skin, o.skin) && Bridge.equals(this.slot, o.slot) && Bridge.equals(this.name, o.name);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#$clone", this ); }

                var s = to || new Spine.Unity.SpineAttachment.Hierarchy();
                s.skin = this.skin;
                s.slot = this.slot;
                s.name = this.name;
                return s;
            }
        }
    });
    /*Spine.Unity.SpineAttachment+Hierarchy end.*/

    /*Spine.Unity.SpineMesh start.*/
    Bridge.define("Spine.Unity.SpineMesh", {
        statics: {
            fields: {
                MeshHideflags: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineMesh#init", this ); }

                    this.MeshHideflags = 20;
                }
            },
            methods: {
                /*Spine.Unity.SpineMesh.NewSkeletonMesh:static start.*/
                /**
                 * Factory method for creating a new mesh for use in Spine components. This can be called in field initializers.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SpineMesh
                 * @memberof Spine.Unity.SpineMesh
                 * @return  {UnityEngine.Mesh}
                 */
                NewSkeletonMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineMesh#NewSkeletonMesh", this ); }

                    var m = new UnityEngine.Mesh.ctor();
                    m.MarkDynamic();
                    m.name = "Skeleton Mesh";
                    m.hideFlags = Spine.Unity.SpineMesh.MeshHideflags;
                    return m;
                },
                /*Spine.Unity.SpineMesh.NewSkeletonMesh:static end.*/


            }
        }
    });
    /*Spine.Unity.SpineMesh end.*/

    /*Spine.Unity.SpineSpriteAtlasAsset+SavedRegionInfo start.*/
    Bridge.define("Spine.Unity.SpineSpriteAtlasAsset.SavedRegionInfo", {
        $kind: 1002,
        fields: {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            packingRotation: 0
        }
    });
    /*Spine.Unity.SpineSpriteAtlasAsset+SavedRegionInfo end.*/

    /*Spine.Unity.SubmeshInstruction start.*/
    /**
     * Instructions for how to generate a mesh or submesh: "Render this skeleton's slots: start slot, up to but not including endSlot, using this material."
     *
     * @public
     * @class Spine.Unity.SubmeshInstruction
     */
    Bridge.define("Spine.Unity.SubmeshInstruction", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#getDefaultValue", this ); }
 return new Spine.Unity.SubmeshInstruction(); }
            }
        },
        fields: {
            skeleton: null,
            startSlot: 0,
            endSlot: 0,
            material: null,
            forceSeparate: false,
            preActiveClippingSlotSource: 0,
            rawTriangleCount: 0,
            rawVertexCount: 0,
            rawFirstVertexIndex: 0,
            hasClipping: false,
            hasPMAAdditiveSlot: false
        },
        props: {
            /**
             * The number of slots in this SubmeshInstruction's range. Not necessarily the number of attachments.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SubmeshInstruction
             * @function SlotCount
             * @type number
             */
            SlotCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#SlotCount#get", this ); }

                    return ((this.endSlot - this.startSlot) | 0);
                }
            }
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SubmeshInstruction.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#toString", this ); }

                return System.String.format("[SubmeshInstruction: slots {0} to {1}. (Material){2}. preActiveClippingSlotSource:{3}]", Bridge.box(this.startSlot, System.Int32), Bridge.box(((this.endSlot - 1) | 0), System.Int32), this.material == null ? "<none>" : this.material.name, Bridge.box(this.preActiveClippingSlotSource, System.Int32));
            },
            /*Spine.Unity.SubmeshInstruction.toString end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#getHashCode", this ); }

                var h = Bridge.addHash([6756249098, this.skeleton, this.startSlot, this.endSlot, this.material, this.forceSeparate, this.preActiveClippingSlotSource, this.rawTriangleCount, this.rawVertexCount, this.rawFirstVertexIndex, this.hasClipping, this.hasPMAAdditiveSlot]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.SubmeshInstruction)) {
                    return false;
                }
                return Bridge.equals(this.skeleton, o.skeleton) && Bridge.equals(this.startSlot, o.startSlot) && Bridge.equals(this.endSlot, o.endSlot) && Bridge.equals(this.material, o.material) && Bridge.equals(this.forceSeparate, o.forceSeparate) && Bridge.equals(this.preActiveClippingSlotSource, o.preActiveClippingSlotSource) && Bridge.equals(this.rawTriangleCount, o.rawTriangleCount) && Bridge.equals(this.rawVertexCount, o.rawVertexCount) && Bridge.equals(this.rawFirstVertexIndex, o.rawFirstVertexIndex) && Bridge.equals(this.hasClipping, o.hasClipping) && Bridge.equals(this.hasPMAAdditiveSlot, o.hasPMAAdditiveSlot);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#$clone", this ); }

                var s = to || new Spine.Unity.SubmeshInstruction();
                s.skeleton = this.skeleton;
                s.startSlot = this.startSlot;
                s.endSlot = this.endSlot;
                s.material = this.material;
                s.forceSeparate = this.forceSeparate;
                s.preActiveClippingSlotSource = this.preActiveClippingSlotSource;
                s.rawTriangleCount = this.rawTriangleCount;
                s.rawVertexCount = this.rawVertexCount;
                s.rawFirstVertexIndex = this.rawFirstVertexIndex;
                s.hasClipping = this.hasClipping;
                s.hasPMAAdditiveSlot = this.hasPMAAdditiveSlot;
                return s;
            }
        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.Unity.SubmeshInstruction end.*/

    /*Spine.Unity.UpdateMode start.*/
    Bridge.define("Spine.Unity.UpdateMode", {
        $kind: 6,
        statics: {
            fields: {
                Nothing: 0,
                OnlyAnimationStatus: 1,
                OnlyEventTimelines: 4,
                EverythingExceptMesh: 2,
                FullUpdate: 3
            }
        }
    });
    /*Spine.Unity.UpdateMode end.*/

    /*Spine.Unity.UpdateTiming start.*/
    Bridge.define("Spine.Unity.UpdateTiming", {
        $kind: 6,
        statics: {
            fields: {
                ManualUpdate: 0,
                InUpdate: 1,
                InFixedUpdate: 2,
                InLateUpdate: 3
            }
        }
    });
    /*Spine.Unity.UpdateTiming end.*/

    /*Spine.Unity.WaitForSpineAnimation start.*/
    /**
     * Use this as a condition-blocking yield instruction for Unity Coroutines.
     The routine will pause until the AnimationState.TrackEntry fires any of the
     configured events.
     <p />
     See the {@link }
     and {@link }
     for more information on when track events will be triggered.
     *
     * @public
     * @class Spine.Unity.WaitForSpineAnimation
     * @implements  System.Collections.IEnumerator
     */
    Bridge.define("Spine.Unity.WaitForSpineAnimation", {
        inherits: [System.Collections.IEnumerator],
        fields: {
            m_WasFired: false
        },
        props: {
            System$Collections$IEnumerator$Current: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#System$Collections$IEnumerator$Current#get", this ); }

                    return null;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#init", this ); }

                this.m_WasFired = false;
            },
            ctor: function (trackEntry, eventsToWaitFor) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#ctor", this ); }

                this.$initialize();
                this.SafeSubscribe(trackEntry, eventsToWaitFor);
            }
        },
        methods: {
            /*Spine.Unity.WaitForSpineAnimation.NowWaitFor start.*/
            /**
             * One optimization high-frequency YieldInstruction returns is to cache instances to minimize GC pressure.
             Use NowWaitFor to reuse the same instance of WaitForSpineAnimationComplete.
             *
             * @instance
             * @public
             * @this Spine.Unity.WaitForSpineAnimation
             * @memberof Spine.Unity.WaitForSpineAnimation
             * @param   {Spine.TrackEntry}                     trackEntry         
             * @param   {number}                               eventsToWaitFor
             * @return  {Spine.Unity.WaitForSpineAnimation}
             */
            NowWaitFor: function (trackEntry, eventsToWaitFor) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#NowWaitFor", this ); }

                this.SafeSubscribe(trackEntry, eventsToWaitFor);
                return this;
            },
            /*Spine.Unity.WaitForSpineAnimation.NowWaitFor end.*/

            /*Spine.Unity.WaitForSpineAnimation.System$Collections$IEnumerator$moveNext start.*/
            System$Collections$IEnumerator$moveNext: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#System$Collections$IEnumerator$moveNext", this ); }

                if (this.m_WasFired) {
                    Bridge.cast(this, System.Collections.IEnumerator).System$Collections$IEnumerator$reset(); // auto-reset for YieldInstruction reuse
                    return false;
                }

                return true;
            },
            /*Spine.Unity.WaitForSpineAnimation.System$Collections$IEnumerator$moveNext end.*/

            /*Spine.Unity.WaitForSpineAnimation.System$Collections$IEnumerator$reset start.*/
            System$Collections$IEnumerator$reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#System$Collections$IEnumerator$reset", this ); }

                this.m_WasFired = false;
            },
            /*Spine.Unity.WaitForSpineAnimation.System$Collections$IEnumerator$reset end.*/

            /*Spine.Unity.WaitForSpineAnimation.SafeSubscribe start.*/
            SafeSubscribe: function (trackEntry, eventsToWaitFor) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#SafeSubscribe", this ); }

                if (trackEntry == null) {
                    // Break immediately if trackEntry is null.
                    UnityEngine.Debug.LogWarning$1("TrackEntry was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                } else {
                    if ((eventsToWaitFor & Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Start) !== 0) {
                        trackEntry.addStart(Bridge.fn.cacheBind(this, this.HandleComplete));
                    }
                    if ((eventsToWaitFor & Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Interrupt) !== 0) {
                        trackEntry.addInterrupt(Bridge.fn.cacheBind(this, this.HandleComplete));
                    }
                    if ((eventsToWaitFor & Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.End) !== 0) {
                        trackEntry.addEnd(Bridge.fn.cacheBind(this, this.HandleComplete));
                    }
                    if ((eventsToWaitFor & Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Dispose) !== 0) {
                        trackEntry.addDispose(Bridge.fn.cacheBind(this, this.HandleComplete));
                    }
                    if ((eventsToWaitFor & Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Complete) !== 0) {
                        trackEntry.addComplete(Bridge.fn.cacheBind(this, this.HandleComplete));
                    }
                }
            },
            /*Spine.Unity.WaitForSpineAnimation.SafeSubscribe end.*/

            /*Spine.Unity.WaitForSpineAnimation.HandleComplete start.*/
            HandleComplete: function (trackEntry) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#HandleComplete", this ); }

                this.m_WasFired = true;
            },
            /*Spine.Unity.WaitForSpineAnimation.HandleComplete end.*/


        }
    });
    /*Spine.Unity.WaitForSpineAnimation end.*/

    /*Spine.Unity.WaitForSpineAnimation+AnimationEventTypes start.*/
    Bridge.define("Spine.Unity.WaitForSpineAnimation.AnimationEventTypes", {
        $kind: 1006,
        statics: {
            fields: {
                Start: 1,
                Interrupt: 2,
                End: 4,
                Dispose: 8,
                Complete: 16
            }
        },
        $flags: true
    });
    /*Spine.Unity.WaitForSpineAnimation+AnimationEventTypes end.*/

    /*Spine.Unity.WaitForSpineEvent start.*/
    /**
     * Use this as a condition-blocking yield instruction for Unity Coroutines.
     The routine will pause until the AnimationState fires an event matching the given event name or EventData reference.
     *
     * @public
     * @class Spine.Unity.WaitForSpineEvent
     * @implements  System.Collections.IEnumerator
     */
    Bridge.define("Spine.Unity.WaitForSpineEvent", {
        inherits: [System.Collections.IEnumerator],
        fields: {
            m_TargetEvent: null,
            m_EventName: null,
            m_AnimationState: null,
            m_WasFired: false,
            m_unsubscribeAfterFiring: false
        },
        props: {
            /**
             * By default, WaitForSpineEvent will unsubscribe from the event immediately after it fires a correct matching event.
             If you want to reuse this WaitForSpineEvent instance on the same event, you can set this to false.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.WaitForSpineEvent
             * @function WillUnsubscribeAfterFiring
             * @type boolean
             */
            WillUnsubscribeAfterFiring: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#WillUnsubscribeAfterFiring#get", this ); }

                    return this.m_unsubscribeAfterFiring;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#WillUnsubscribeAfterFiring#set", this ); }

                    this.m_unsubscribeAfterFiring = value;
                }
            },
            System$Collections$IEnumerator$Current: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$Current#get", this ); }

                    return null;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#init", this ); }

                this.m_WasFired = false;
                this.m_unsubscribeAfterFiring = false;
            },
            ctor: function (state, eventDataReference, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#ctor", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }

                this.$initialize();
                this.Subscribe(state, eventDataReference, unsubscribeAfterFiring);
            },
            $ctor2: function (skeletonAnimation, eventDataReference, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#$ctor2", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }

                this.$initialize();
                // If skeletonAnimation is invalid, its state will be null. Subscribe handles null states just fine.
                this.Subscribe(skeletonAnimation.state, eventDataReference, unsubscribeAfterFiring);
            },
            $ctor1: function (state, eventName, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#$ctor1", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }

                this.$initialize();
                this.SubscribeByName(state, eventName, unsubscribeAfterFiring);
            },
            $ctor3: function (skeletonAnimation, eventName, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#$ctor3", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }

                this.$initialize();
                // If skeletonAnimation is invalid, its state will be null. Subscribe handles null states just fine.
                this.SubscribeByName(skeletonAnimation.state, eventName, unsubscribeAfterFiring);
            }
        },
        methods: {
            /*Spine.Unity.WaitForSpineEvent.Subscribe start.*/
            Subscribe: function (state, eventDataReference, unsubscribe) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#Subscribe", this ); }

                if (state == null) {
                    UnityEngine.Debug.LogWarning$1("AnimationState argument was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                    return;
                } else if (eventDataReference == null) {
                    UnityEngine.Debug.LogWarning$1("eventDataReference argument was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                    return;
                }

                this.m_AnimationState = state;
                this.m_TargetEvent = eventDataReference;
                state.addEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEvent));

                this.m_unsubscribeAfterFiring = unsubscribe;

            },
            /*Spine.Unity.WaitForSpineEvent.Subscribe end.*/

            /*Spine.Unity.WaitForSpineEvent.SubscribeByName start.*/
            SubscribeByName: function (state, eventName, unsubscribe) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#SubscribeByName", this ); }

                if (state == null) {
                    UnityEngine.Debug.LogWarning$1("AnimationState argument was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                    return;
                } else if (System.String.isNullOrEmpty(eventName)) {
                    UnityEngine.Debug.LogWarning$1("eventName argument was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                    return;
                }

                this.m_AnimationState = state;
                this.m_EventName = eventName;
                state.addEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEventByName));

                this.m_unsubscribeAfterFiring = unsubscribe;
            },
            /*Spine.Unity.WaitForSpineEvent.SubscribeByName end.*/

            /*Spine.Unity.WaitForSpineEvent.HandleAnimationStateEventByName start.*/
            HandleAnimationStateEventByName: function (trackEntry, e) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#HandleAnimationStateEventByName", this ); }

                this.m_WasFired = !!(this.m_WasFired | (Bridge.referenceEquals(e.data.name, this.m_EventName))); // Check event name string match.
                if (this.m_WasFired && this.m_unsubscribeAfterFiring) {
                    this.m_AnimationState.removeEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEventByName));
                } // Unsubscribe after correct event fires.
            },
            /*Spine.Unity.WaitForSpineEvent.HandleAnimationStateEventByName end.*/

            /*Spine.Unity.WaitForSpineEvent.HandleAnimationStateEvent start.*/
            HandleAnimationStateEvent: function (trackEntry, e) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#HandleAnimationStateEvent", this ); }

                this.m_WasFired = !!(this.m_WasFired | (Bridge.referenceEquals(e.data, this.m_TargetEvent))); // Check event data reference match.
                if (this.m_WasFired && this.m_unsubscribeAfterFiring) {
                    this.m_AnimationState.removeEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEvent));
                } // Usubscribe after correct event fires.
            },
            /*Spine.Unity.WaitForSpineEvent.HandleAnimationStateEvent end.*/

            /*Spine.Unity.WaitForSpineEvent.NowWaitFor start.*/
            NowWaitFor: function (state, eventDataReference, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#NowWaitFor", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }
                Bridge.cast(this, System.Collections.IEnumerator).System$Collections$IEnumerator$reset();
                this.Clear(state);
                this.Subscribe(state, eventDataReference, unsubscribeAfterFiring);

                return this;
            },
            /*Spine.Unity.WaitForSpineEvent.NowWaitFor end.*/

            /*Spine.Unity.WaitForSpineEvent.NowWaitFor$1 start.*/
            NowWaitFor$1: function (state, eventName, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#NowWaitFor$1", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }
                Bridge.cast(this, System.Collections.IEnumerator).System$Collections$IEnumerator$reset();
                this.Clear(state);
                this.SubscribeByName(state, eventName, unsubscribeAfterFiring);

                return this;
            },
            /*Spine.Unity.WaitForSpineEvent.NowWaitFor$1 end.*/

            /*Spine.Unity.WaitForSpineEvent.Clear start.*/
            Clear: function (state) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#Clear", this ); }

                state.removeEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEvent));
                state.removeEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEventByName));
            },
            /*Spine.Unity.WaitForSpineEvent.Clear end.*/

            /*Spine.Unity.WaitForSpineEvent.System$Collections$IEnumerator$moveNext start.*/
            System$Collections$IEnumerator$moveNext: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$moveNext", this ); }

                if (this.m_WasFired) {
                    Bridge.cast(this, System.Collections.IEnumerator).System$Collections$IEnumerator$reset(); // auto-reset for YieldInstruction reuse
                    return false;
                }

                return true;
            },
            /*Spine.Unity.WaitForSpineEvent.System$Collections$IEnumerator$moveNext end.*/

            /*Spine.Unity.WaitForSpineEvent.System$Collections$IEnumerator$reset start.*/
            System$Collections$IEnumerator$reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$reset", this ); }

                this.m_WasFired = false;
            },
            /*Spine.Unity.WaitForSpineEvent.System$Collections$IEnumerator$reset end.*/


        },
        overloads: {
            "NowWaitFor(Spine.AnimationState, string, bool)": "NowWaitFor$1"
        }
    });
    /*Spine.Unity.WaitForSpineEvent end.*/

    /*ViewportHandler start.*/
    Bridge.define("ViewportHandler", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                Instance: null
            }
        },
        fields: {
            wireColor: null,
            UnitsSize: 0,
            constraint: 0,
            camera: null,
            _width: 0,
            _height: 0,
            _bl: null,
            _bc: null,
            _br: null,
            _ml: null,
            _mc: null,
            _mr: null,
            _tl: null,
            _tc: null,
            _tr: null
        },
        props: {
            Width: {
                get: function () {
if ( TRACE ) { TRACE( "ViewportHandler#Width#get", this ); }

                    return this._width;
                }
            },
            Height: {
                get: function () {
if ( TRACE ) { TRACE( "ViewportHandler#Height#get", this ); }

                    return this._height;
                }
            },
            BottomLeft: {
                get: function () {
if ( TRACE ) { TRACE( "ViewportHandler#BottomLeft#get", this ); }

                    return this._bl.$clone();
                }
            },
            BottomCenter: {
                get: function () {
if ( TRACE ) { TRACE( "ViewportHandler#BottomCenter#get", this ); }

                    return this._bc.$clone();
                }
            },
            BottomRight: {
                get: function () {
if ( TRACE ) { TRACE( "ViewportHandler#BottomRight#get", this ); }

                    return this._br.$clone();
                }
            },
            MiddleLeft: {
                get: function () {
if ( TRACE ) { TRACE( "ViewportHandler#MiddleLeft#get", this ); }

                    return this._ml.$clone();
                }
            },
            MiddleCenter: {
                get: function () {
if ( TRACE ) { TRACE( "ViewportHandler#MiddleCenter#get", this ); }

                    return this._mc.$clone();
                }
            },
            MiddleRight: {
                get: function () {
if ( TRACE ) { TRACE( "ViewportHandler#MiddleRight#get", this ); }

                    return this._mr.$clone();
                }
            },
            TopLeft: {
                get: function () {
if ( TRACE ) { TRACE( "ViewportHandler#TopLeft#get", this ); }

                    return this._tl.$clone();
                }
            },
            TopCenter: {
                get: function () {
if ( TRACE ) { TRACE( "ViewportHandler#TopCenter#get", this ); }

                    return this._tc.$clone();
                }
            },
            TopRight: {
                get: function () {
if ( TRACE ) { TRACE( "ViewportHandler#TopRight#get", this ); }

                    return this._tr.$clone();
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "ViewportHandler#init", this ); }

                this.wireColor = new UnityEngine.Color();
                this._bl = new UnityEngine.Vector3();
                this._bc = new UnityEngine.Vector3();
                this._br = new UnityEngine.Vector3();
                this._ml = new UnityEngine.Vector3();
                this._mc = new UnityEngine.Vector3();
                this._mr = new UnityEngine.Vector3();
                this._tl = new UnityEngine.Vector3();
                this._tc = new UnityEngine.Vector3();
                this._tr = new UnityEngine.Vector3();
                this.wireColor = new pc.Color( 1, 1, 1, 1 );
                this.UnitsSize = 1;
                this.constraint = ViewportHandler.Constraint.Portrait;
            }
        },
        methods: {
            /*ViewportHandler.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "ViewportHandler#Awake", this ); }

                this.camera = this.GetComponent(UnityEngine.Camera);
                ViewportHandler.Instance = this;
                this.ComputeResolution();
            },
            /*ViewportHandler.Awake end.*/

            /*ViewportHandler.ComputeResolution start.*/
            ComputeResolution: function () {
if ( TRACE ) { TRACE( "ViewportHandler#ComputeResolution", this ); }

                var leftX, rightX, topY, bottomY;

                if (this.constraint === ViewportHandler.Constraint.Landscape) {
                    this.camera.orthographicSize = 1.0 / this.camera.aspect * this.UnitsSize / 2.0;
                } else {
                    this.camera.orthographicSize = this.UnitsSize / 2.0;
                }

                this._height = 2.0 * this.camera.orthographicSize;
                this._width = this._height * this.camera.aspect;

                var cameraX, cameraY;
                cameraX = this.camera.transform.position.x;
                cameraY = this.camera.transform.position.y;

                leftX = cameraX - this._width / 2;
                rightX = cameraX + this._width / 2;
                topY = cameraY + this._height / 2;
                bottomY = cameraY - this._height / 2;

                //*** bottom
                this._bl = new pc.Vec3( leftX, bottomY, 0 );
                this._bc = new pc.Vec3( cameraX, bottomY, 0 );
                this._br = new pc.Vec3( rightX, bottomY, 0 );
                //*** middle
                this._ml = new pc.Vec3( leftX, cameraY, 0 );
                this._mc = new pc.Vec3( cameraX, cameraY, 0 );
                this._mr = new pc.Vec3( rightX, cameraY, 0 );
                //*** top
                this._tl = new pc.Vec3( leftX, topY, 0 );
                this._tc = new pc.Vec3( cameraX, topY, 0 );
                this._tr = new pc.Vec3( rightX, topY, 0 );
            },
            /*ViewportHandler.ComputeResolution end.*/

            /*ViewportHandler.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "ViewportHandler#Update", this ); }
 },
            /*ViewportHandler.Update end.*/

            /*ViewportHandler.OnDrawGizmos start.*/
            OnDrawGizmos: function () {
if ( TRACE ) { TRACE( "ViewportHandler#OnDrawGizmos", this ); }

                pc.generateStubProxy( 'UnityEngine.Gizmos', true ).color = this.wireColor.$clone();

                var temp = pc.generateStubProxy( 'UnityEngine.Gizmos', true ).reportProperty( 'UnityEngine.Gizmos.matrix', null );
                pc.generateStubProxy( 'UnityEngine.Gizmos', true ).matrix = new pc.Mat4().setTRS( this.transform.position, this.transform.rotation, new pc.Vec3( 1, 1, 1 ) );
                if (this.camera.orthographic) {
                    var spread = this.camera.farClipPlane - this.camera.nearClipPlane;
                    var center = (this.camera.farClipPlane + this.camera.nearClipPlane) * 0.5;
                    pc.stubProxy.reportMethod( 'UnityEngine.Gizmos.DrawWireCube', null );
                } else {
                    pc.stubProxy.reportMethod( 'UnityEngine.Gizmos.DrawFrustum', null );
                }
                pc.generateStubProxy( 'UnityEngine.Gizmos', true ).matrix = temp.$clone();
            },
            /*ViewportHandler.OnDrawGizmos end.*/


        }
    });
    /*ViewportHandler end.*/

    /*ViewportHandler+Constraint start.*/
    Bridge.define("ViewportHandler.Constraint", {
        $kind: 1006,
        statics: {
            fields: {
                Landscape: 0,
                Portrait: 1
            }
        }
    });
    /*ViewportHandler+Constraint end.*/

    /*Spine.Unity.IHasSkeletonDataAsset start.*/
    /**
     * Holds a reference to a SkeletonDataAsset.
     *
     * @abstract
     * @public
     * @class Spine.Unity.IHasSkeletonDataAsset
     * @implements  Spine.Unity.ISpineComponent
     */
    Bridge.define("Spine.Unity.IHasSkeletonDataAsset", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.IHasSkeletonDataAsset end.*/

    /*Spine.Unity.BlendModeMaterialsAsset start.*/
    Bridge.define("Spine.Unity.BlendModeMaterialsAsset", {
        inherits: [Spine.Unity.SkeletonDataModifierAsset],
        statics: {
            methods: {
                /*Spine.Unity.BlendModeMaterialsAsset.ApplyMaterials:static start.*/
                ApplyMaterials: function (skeletonData, multiplyTemplate, screenTemplate, additiveTemplate, includeAdditiveSlots) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset#ApplyMaterials", this ); }

                    var $t, $t1;
                    if (skeletonData == null) {
                        throw new System.ArgumentNullException.$ctor1("skeletonData");
                    }

                    var materialCache = new Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache();
                    try {
                        var entryBuffer = new (System.Collections.Generic.List$1(spine.SkinEntry)).ctor();
                        var slotsItems = skeletonData.Slots.Items;
                        for (var slotIndex = 0, slotCount = skeletonData.Slots.Count; slotIndex < slotCount; slotIndex = (slotIndex + 1) | 0) {
                            var slot = slotsItems[slotIndex];
                            if (slot.blendMode === spine.BlendMode.Normal) {
                                continue;
                            }
                            if (!includeAdditiveSlots && slot.blendMode === spine.BlendMode.Additive) {
                                continue;
                            }

                            entryBuffer.clear();
                            $t = Bridge.getEnumerator(skeletonData.Skins);
                            try {
                                while ($t.moveNext()) {
                                    var skin = $t.Current;
                                    ( entryBuffer._items.length = 0, skin.getAttachmentsForSlot( slotIndex, entryBuffer._items ), entryBuffer._size = entryBuffer._items.length );
                                }
                            } finally {
                                if (Bridge.is($t, System.IDisposable)) {
                                    $t.System$IDisposable$Dispose();
                                }
                            }

                            var templateMaterial = null;
                            switch (slot.blendMode) {
                                case spine.BlendMode.Multiply: 
                                    templateMaterial = multiplyTemplate;
                                    break;
                                case spine.BlendMode.Screen: 
                                    templateMaterial = screenTemplate;
                                    break;
                                case spine.BlendMode.Additive: 
                                    templateMaterial = additiveTemplate;
                                    break;
                            }
                            if (templateMaterial == null) {
                                continue;
                            }

                            $t1 = Bridge.getEnumerator(entryBuffer);
                            try {
                                while ($t1.moveNext()) {
                                    var entry = $t1.Current;
                                    var renderableAttachment = Bridge.as(entry.attachment, Spine.IHasTextureRegion);
                                    if (renderableAttachment != null) {
                                        renderableAttachment.Spine$IHasTextureRegion$Region = materialCache.CloneAtlasRegionWithMaterial(Bridge.cast(renderableAttachment.Spine$IHasTextureRegion$Region, Spine.AtlasRegion), templateMaterial);
                                    }
                                }
                            } finally {
                                if (Bridge.is($t1, System.IDisposable)) {
                                    $t1.System$IDisposable$Dispose();
                                }
                            }
                        }

                    }
                    finally {
                        if (Bridge.hasValue(materialCache)) {
                            materialCache.System$IDisposable$Dispose();
                        }
                    }
                    //attachmentBuffer.Clear();
                },
                /*Spine.Unity.BlendModeMaterialsAsset.ApplyMaterials:static end.*/


            }
        },
        fields: {
            multiplyMaterialTemplate: null,
            screenMaterialTemplate: null,
            additiveMaterialTemplate: null,
            applyAdditiveMaterial: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset#init", this ); }

                this.applyAdditiveMaterial = true;
            }
        },
        methods: {
            /*Spine.Unity.BlendModeMaterialsAsset.Apply start.*/
            Apply: function (skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset#Apply", this ); }

                Spine.Unity.BlendModeMaterialsAsset.ApplyMaterials(skeletonData, this.multiplyMaterialTemplate, this.screenMaterialTemplate, this.additiveMaterialTemplate, this.applyAdditiveMaterial);
            },
            /*Spine.Unity.BlendModeMaterialsAsset.Apply end.*/


        }
    });
    /*Spine.Unity.BlendModeMaterialsAsset end.*/

    /*Spine.Unity.Examples.AnimationMatchModifierAsset start.*/
    Bridge.define("Spine.Unity.Examples.AnimationMatchModifierAsset", {
        inherits: [Spine.Unity.SkeletonDataModifierAsset],
        fields: {
            matchAllAnimations: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.AnimationMatchModifierAsset#init", this ); }

                this.matchAllAnimations = true;
            }
        },
        methods: {
            /*Spine.Unity.Examples.AnimationMatchModifierAsset.Apply start.*/
            Apply: function (skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.AnimationMatchModifierAsset#Apply", this ); }

                if (this.matchAllAnimations) {
                    Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools.MatchAnimationTimelines(skeletonData.Animations, skeletonData);
                }
            },
            /*Spine.Unity.Examples.AnimationMatchModifierAsset.Apply end.*/


        }
    });
    /*Spine.Unity.Examples.AnimationMatchModifierAsset end.*/

    /*Spine.Unity.Examples.SkeletonGraphicRenderTexture start.*/
    /**
     * When enabled, this component renders a skeleton to a RenderTexture and
     then draws this RenderTexture at a UI RawImage quad of the same size.
     This allows changing transparency at a single quad, which produces a more
     natural fadeout effect.
     Note: It is recommended to keep this component disabled as much as possible
     because of the additional rendering overhead. Only enable it when alpha blending is required.
     *
     * @public
     * @class Spine.Unity.Examples.SkeletonGraphicRenderTexture
     * @augments Spine.Unity.Examples.SkeletonRenderTextureBase
     */
    Bridge.define("Spine.Unity.Examples.SkeletonGraphicRenderTexture", {
        inherits: [Spine.Unity.Examples.SkeletonRenderTextureBase],
        fields: {
            customRenderRect: null,
            skeletonGraphic: null,
            meshRendererMaterialForTexture: null,
            quadCanvasRenderer: null,
            quadRawImage: null,
            worldCorners: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGraphicRenderTexture#init", this ); }

                this.meshRendererMaterialForTexture = new (System.Collections.Generic.List$1(Spine.Unity.Examples.SkeletonGraphicRenderTexture.TextureMaterialPair)).ctor();
                this.worldCorners = System.Array.init(4, function (){
                    return new UnityEngine.Vector3();
                }, UnityEngine.Vector3);
            }
        },
        methods: {
            /*Spine.Unity.Examples.SkeletonGraphicRenderTexture.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGraphicRenderTexture#Awake", this ); }

                Spine.Unity.Examples.SkeletonRenderTextureBase.prototype.Awake.call(this);
                this.skeletonGraphic = this.GetComponent(Spine.Unity.SkeletonGraphic);
                if (UnityEngine.Component.op_Equality(this.targetCamera, null)) {
                    this.targetCamera = this.skeletonGraphic.canvas.worldCamera;
                    if (UnityEngine.Component.op_Equality(this.targetCamera, null)) {
                        this.targetCamera = UnityEngine.Camera.main;
                    }
                }
                this.CreateQuadChild();
            },
            /*Spine.Unity.Examples.SkeletonGraphicRenderTexture.Awake end.*/

            /*Spine.Unity.Examples.SkeletonGraphicRenderTexture.CreateQuadChild start.*/
            CreateQuadChild: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGraphicRenderTexture#CreateQuadChild", this ); }

                this.quad = new UnityEngine.GameObject.$ctor4((this.name || "") + " RenderTexture", [UnityEngine.CanvasRenderer, UnityEngine.UI.RawImage]);
                this.quad.transform.SetParent(this.transform.parent, false);
                this.quadCanvasRenderer = this.quad.GetComponent(UnityEngine.CanvasRenderer);
                this.quadRawImage = this.quad.GetComponent(UnityEngine.UI.RawImage);

                this.quadMesh = new UnityEngine.Mesh.ctor();
                this.quadMesh.MarkDynamic();
                this.quadMesh.name = "RenderTexture Quad";
                this.quadMesh.hideFlags = 20;
            },
            /*Spine.Unity.Examples.SkeletonGraphicRenderTexture.CreateQuadChild end.*/

            /*Spine.Unity.Examples.SkeletonGraphicRenderTexture.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGraphicRenderTexture#Reset", this ); }

                var $t;
                this.skeletonGraphic = this.GetComponent(Spine.Unity.SkeletonGraphic);
                var atlasAssets = this.skeletonGraphic.SkeletonDataAsset.atlasAssets;
                for (var i = 0; i < atlasAssets.length; i = (i + 1) | 0) {
                    $t = Bridge.getEnumerator(atlasAssets[i].Materials, UnityEngine.Material);
                    try {
                        while ($t.moveNext()) {
                            var material = $t.Current;
                            if (material.mainTexture != null) {
                                this.meshRendererMaterialForTexture.add(new Spine.Unity.Examples.SkeletonGraphicRenderTexture.TextureMaterialPair.$ctor1(material.mainTexture, material));
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }
            },
            /*Spine.Unity.Examples.SkeletonGraphicRenderTexture.Reset end.*/

            /*Spine.Unity.Examples.SkeletonGraphicRenderTexture.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGraphicRenderTexture#OnEnable", this ); }

                this.skeletonGraphic.addOnInstructionsPrepared(Bridge.fn.cacheBind(this, this.PrepareQuad));
                this.skeletonGraphic.addAssignMeshOverrideSingleRenderer(Bridge.fn.cacheBind(this, this.RenderSingleMeshToRenderTexture));
                this.skeletonGraphic.addAssignMeshOverrideMultipleRenderers(Bridge.fn.cacheBind(this, this.RenderMultipleMeshesToRenderTexture));
                this.skeletonGraphic.disableMeshAssignmentOnOverride = true;
                this.skeletonGraphic.addOnMeshAndMaterialsUpdated(Bridge.fn.cacheBind(this, this.RenderOntoQuad));
                var canvasRenderers = this.skeletonGraphic.canvasRenderers;
                for (var i = 0; i < canvasRenderers.Count; i = (i + 1) | 0) {
                    canvasRenderers.getItem(i).cull = true;
                }

                if (UnityEngine.Object.op_Implicit(this.quadCanvasRenderer)) {
                    this.quadCanvasRenderer.gameObject.SetActive(true);
                }
            },
            /*Spine.Unity.Examples.SkeletonGraphicRenderTexture.OnEnable end.*/

            /*Spine.Unity.Examples.SkeletonGraphicRenderTexture.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGraphicRenderTexture#OnDisable", this ); }

                this.skeletonGraphic.removeOnInstructionsPrepared(Bridge.fn.cacheBind(this, this.PrepareQuad));
                this.skeletonGraphic.removeAssignMeshOverrideSingleRenderer(Bridge.fn.cacheBind(this, this.RenderSingleMeshToRenderTexture));
                this.skeletonGraphic.removeAssignMeshOverrideMultipleRenderers(Bridge.fn.cacheBind(this, this.RenderMultipleMeshesToRenderTexture));
                this.skeletonGraphic.disableMeshAssignmentOnOverride = false;
                this.skeletonGraphic.removeOnMeshAndMaterialsUpdated(Bridge.fn.cacheBind(this, this.RenderOntoQuad));
                var canvasRenderers = this.skeletonGraphic.canvasRenderers;
                for (var i = 0; i < canvasRenderers.Count; i = (i + 1) | 0) {
                    canvasRenderers.getItem(i).cull = false;
                }

                if (UnityEngine.Object.op_Implicit(this.quadCanvasRenderer)) {
                    this.quadCanvasRenderer.gameObject.SetActive(false);
                }
                if (UnityEngine.Object.op_Implicit(this.renderTexture)) {
                    UnityEngine.RenderTexture.ReleaseTemporary(this.renderTexture);
                }
                this.allocatedRenderTextureSize = UnityEngine.Vector2Int.zero.$clone();
            },
            /*Spine.Unity.Examples.SkeletonGraphicRenderTexture.OnDisable end.*/

            /*Spine.Unity.Examples.SkeletonGraphicRenderTexture.PrepareQuad start.*/
            PrepareQuad: function (instruction) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGraphicRenderTexture#PrepareQuad", this ); }

                this.PrepareForMesh();
                this.SetupQuad();
            },
            /*Spine.Unity.Examples.SkeletonGraphicRenderTexture.PrepareQuad end.*/

            /*Spine.Unity.Examples.SkeletonGraphicRenderTexture.RenderOntoQuad start.*/
            RenderOntoQuad: function (skeletonRenderer) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGraphicRenderTexture#RenderOntoQuad", this ); }

                this.AssignAtQuad();
            },
            /*Spine.Unity.Examples.SkeletonGraphicRenderTexture.RenderOntoQuad end.*/

            /*Spine.Unity.Examples.SkeletonGraphicRenderTexture.PrepareForMesh start.*/
            PrepareForMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGraphicRenderTexture#PrepareForMesh", this ); }

                // We need to get the min/max of all four corners, rotation of the skeleton
                // in combination with perspective projection otherwise might lead to incorrect
                // screen space min/max.
                var rectTransform = UnityEngine.Object.op_Implicit(this.customRenderRect) ? this.customRenderRect : this.skeletonGraphic.rectTransform;
                rectTransform.GetWorldCorners(this.worldCorners);

                var canvasRenderMode = this.skeletonGraphic.canvas.renderMode;
                var screenCorner0 = new UnityEngine.Vector3(), screenCorner1 = new UnityEngine.Vector3(), screenCorner2 = new UnityEngine.Vector3(), screenCorner3 = new UnityEngine.Vector3();
                // note: world corners are ordered bottom left, top left, top right, bottom right.
                // This corresponds to 0, 3, 1, 2 in our desired order.
                if (canvasRenderMode === UnityEngine.RenderMode.ScreenSpaceOverlay) {
                    screenCorner0 = this.worldCorners[0].$clone();
                    screenCorner1 = this.worldCorners[3].$clone();
                    screenCorner2 = this.worldCorners[1].$clone();
                    screenCorner3 = this.worldCorners[2].$clone();
                } else {
                    screenCorner0 = this.targetCamera.WorldToScreenPoint(this.worldCorners[0]);
                    screenCorner1 = this.targetCamera.WorldToScreenPoint(this.worldCorners[3]);
                    screenCorner2 = this.targetCamera.WorldToScreenPoint(this.worldCorners[1]);
                    screenCorner3 = this.targetCamera.WorldToScreenPoint(this.worldCorners[2]);
                }

                // To avoid perspective distortion when rotated, we project all vertices
                // onto a plane parallel to the view frustum near plane.
                // Avoids the requirement of 'noperspective' vertex attribute interpolation modifier in shaders.
                var averageScreenDepth = (screenCorner0.z + screenCorner1.z + screenCorner2.z + screenCorner3.z) / 4.0;
                screenCorner0.z = (screenCorner1.z = (screenCorner2.z = (screenCorner3.z = averageScreenDepth)));

                if (canvasRenderMode === UnityEngine.RenderMode.ScreenSpaceOverlay) {
                    this.worldCornerNoDistortion0 = screenCorner0.$clone();
                    this.worldCornerNoDistortion1 = screenCorner1.$clone();
                    this.worldCornerNoDistortion2 = screenCorner2.$clone();
                    this.worldCornerNoDistortion3 = screenCorner3.$clone();
                } else {
                    this.worldCornerNoDistortion0 = this.targetCamera.ScreenToWorldPoint(screenCorner0);
                    this.worldCornerNoDistortion1 = this.targetCamera.ScreenToWorldPoint(screenCorner1);
                    this.worldCornerNoDistortion2 = this.targetCamera.ScreenToWorldPoint(screenCorner2);
                    this.worldCornerNoDistortion3 = this.targetCamera.ScreenToWorldPoint(screenCorner3);
                }
                var screenSpaceMin = { v : new UnityEngine.Vector3() }, screenSpaceMax = { v : new UnityEngine.Vector3() };
                this.PrepareTextureMapping(screenSpaceMin, screenSpaceMax, screenCorner0.$clone(), screenCorner1.$clone(), screenCorner2.$clone(), screenCorner3.$clone());
                this.PrepareCommandBuffer(this.targetCamera, screenSpaceMin.v, screenSpaceMax.v);
            },
            /*Spine.Unity.Examples.SkeletonGraphicRenderTexture.PrepareForMesh end.*/

            /*Spine.Unity.Examples.SkeletonGraphicRenderTexture.MeshRendererMaterialForTexture start.*/
            MeshRendererMaterialForTexture: function (texture) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGraphicRenderTexture#MeshRendererMaterialForTexture", this ); }

                return this.meshRendererMaterialForTexture.Find(function (x) {
                    return Bridge.referenceEquals(x.texture, texture);
                }).material;
            },
            /*Spine.Unity.Examples.SkeletonGraphicRenderTexture.MeshRendererMaterialForTexture end.*/

            /*Spine.Unity.Examples.SkeletonGraphicRenderTexture.RenderSingleMeshToRenderTexture start.*/
            RenderSingleMeshToRenderTexture: function (mesh, graphicMaterial, texture) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGraphicRenderTexture#RenderSingleMeshToRenderTexture", this ); }

                var meshRendererMaterial = this.MeshRendererMaterialForTexture(texture);
                this.commandBuffer.DrawMesh$2(mesh, this.transform.localToWorldMatrix, meshRendererMaterial, 0, -1);
                UnityEngine.Graphics.ExecuteCommandBuffer(this.commandBuffer);
            },
            /*Spine.Unity.Examples.SkeletonGraphicRenderTexture.RenderSingleMeshToRenderTexture end.*/

            /*Spine.Unity.Examples.SkeletonGraphicRenderTexture.RenderMultipleMeshesToRenderTexture start.*/
            RenderMultipleMeshesToRenderTexture: function (meshCount, meshes, graphicMaterials, textures) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGraphicRenderTexture#RenderMultipleMeshesToRenderTexture", this ); }


                for (var i = 0; i < meshCount; i = (i + 1) | 0) {
                    var meshRendererMaterial = this.MeshRendererMaterialForTexture(textures[i]);
                    this.commandBuffer.DrawMesh$2(meshes[i], this.transform.localToWorldMatrix, meshRendererMaterial, 0, -1);
                }
                UnityEngine.Graphics.ExecuteCommandBuffer(this.commandBuffer);
            },
            /*Spine.Unity.Examples.SkeletonGraphicRenderTexture.RenderMultipleMeshesToRenderTexture end.*/

            /*Spine.Unity.Examples.SkeletonGraphicRenderTexture.SetupQuad start.*/
            SetupQuad: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGraphicRenderTexture#SetupQuad", this ); }

                this.quadRawImage.texture = this.renderTexture;
                this.quadRawImage.color = this.color.$clone();
                this.quadCanvasRenderer.SetColor(this.color);

                var srcRectTransform = this.skeletonGraphic.rectTransform;
                var dstRectTransform = this.quadRawImage.rectTransform;

                dstRectTransform.anchorMin = srcRectTransform.anchorMin.$clone();
                dstRectTransform.anchorMax = srcRectTransform.anchorMax.$clone();
                dstRectTransform.anchoredPosition = srcRectTransform.anchoredPosition.$clone();
                dstRectTransform.pivot = srcRectTransform.pivot.$clone();
                dstRectTransform.localScale = srcRectTransform.localScale.$clone();
                dstRectTransform.sizeDelta = srcRectTransform.sizeDelta.$clone();
                dstRectTransform.rotation = srcRectTransform.rotation.$clone();
            },
            /*Spine.Unity.Examples.SkeletonGraphicRenderTexture.SetupQuad end.*/

            /*Spine.Unity.Examples.SkeletonGraphicRenderTexture.PrepareCommandBuffer start.*/
            PrepareCommandBuffer: function (targetCamera, screenSpaceMin, screenSpaceMax) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGraphicRenderTexture#PrepareCommandBuffer", this ); }

                this.commandBuffer.Clear();
                this.commandBuffer.SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier.op_Implicit$3(this.renderTexture));
                this.commandBuffer.ClearRenderTarget(true, true, new pc.Color( 0, 0, 0, 0 ));

                var canvasRect = this.skeletonGraphic.canvas.pixelRect.$clone();

                var projectionMatrix = new pc.Mat4().setOrtho( canvasRect.x, canvasRect.x + canvasRect.width, canvasRect.y, canvasRect.y + canvasRect.height, -3.40282347E+38, 3.40282347E+38 );

                var canvasRenderMode = this.skeletonGraphic.canvas.renderMode;
                if (canvasRenderMode === UnityEngine.RenderMode.ScreenSpaceOverlay) {
                    this.commandBuffer.SetViewMatrix(pc.Mat4.IDENTITY.clone());
                    this.commandBuffer.SetProjectionMatrix(projectionMatrix);
                } else {
                    this.commandBuffer.SetViewMatrix(targetCamera.worldToCameraMatrix);
                    this.commandBuffer.SetProjectionMatrix(targetCamera.projectionMatrix);
                }

                var targetCameraViewportSize = targetCamera.pixelRect.size.$clone();
                var viewportRect = new UnityEngine.Rect.$ctor3(UnityEngine.Vector2.FromVector3(screenSpaceMin.$clone().scale( -1 )).mul( this.downScaleFactor ), targetCameraViewportSize.$clone().mul( this.downScaleFactor ));
                this.commandBuffer.SetViewport(viewportRect);
            },
            /*Spine.Unity.Examples.SkeletonGraphicRenderTexture.PrepareCommandBuffer end.*/

            /*Spine.Unity.Examples.SkeletonGraphicRenderTexture.AssignMeshAtRenderer start.*/
            AssignMeshAtRenderer: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonGraphicRenderTexture#AssignMeshAtRenderer", this ); }

                this.quadCanvasRenderer.SetMesh(this.quadMesh);
            },
            /*Spine.Unity.Examples.SkeletonGraphicRenderTexture.AssignMeshAtRenderer end.*/


        }
    });
    /*Spine.Unity.Examples.SkeletonGraphicRenderTexture end.*/

    /*Spine.Unity.Examples.SkeletonRenderTexture start.*/
    /**
     * When enabled, this component renders a skeleton to a RenderTexture and
     then draws this RenderTexture at a quad of the same size.
     This allows changing transparency at a single quad, which produces a more
     natural fadeout effect.
     Note: It is recommended to keep this component disabled as much as possible
     because of the additional rendering overhead. Only enable it when alpha blending is required.
     *
     * @public
     * @class Spine.Unity.Examples.SkeletonRenderTexture
     * @augments Spine.Unity.Examples.SkeletonRenderTextureBase
     */
    Bridge.define("Spine.Unity.Examples.SkeletonRenderTexture", {
        inherits: [Spine.Unity.Examples.SkeletonRenderTextureBase],
        fields: {
            quadMaterial: null,
            skeletonRenderer: null,
            meshRenderer: null,
            meshFilter: null,
            quadMeshRenderer: null,
            quadMeshFilter: null,
            propertyBlock: null,
            materials: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRenderTexture#init", this ); }

                this.materials = new (System.Collections.Generic.List$1(UnityEngine.Material)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.Examples.SkeletonRenderTexture.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRenderTexture#Awake", this ); }

                Spine.Unity.Examples.SkeletonRenderTextureBase.prototype.Awake.call(this);
                this.meshRenderer = this.GetComponent(UnityEngine.MeshRenderer);
                this.meshFilter = this.GetComponent(UnityEngine.MeshFilter);
                this.skeletonRenderer = this.GetComponent(Spine.Unity.SkeletonRenderer);
                if (UnityEngine.Component.op_Equality(this.targetCamera, null)) {
                    this.targetCamera = UnityEngine.Camera.main;
                }

                this.propertyBlock = new UnityEngine.MaterialPropertyBlock();
                this.CreateQuadChild();
            },
            /*Spine.Unity.Examples.SkeletonRenderTexture.Awake end.*/

            /*Spine.Unity.Examples.SkeletonRenderTexture.CreateQuadChild start.*/
            CreateQuadChild: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRenderTexture#CreateQuadChild", this ); }

                this.quad = new UnityEngine.GameObject.$ctor4((this.name || "") + " RenderTexture", [UnityEngine.MeshRenderer, UnityEngine.MeshFilter]);
                this.quad.transform.SetParent(this.transform.parent, false);
                this.quadMeshRenderer = this.quad.GetComponent(UnityEngine.MeshRenderer);
                this.quadMeshFilter = this.quad.GetComponent(UnityEngine.MeshFilter);

                this.quadMeshRenderer.sortingOrder = this.meshRenderer.sortingOrder;
                this.quadMeshRenderer.sortingLayerID = this.meshRenderer.sortingLayerID;

                this.quadMesh = new UnityEngine.Mesh.ctor();
                this.quadMesh.MarkDynamic();
                this.quadMesh.name = "RenderTexture Quad";
                this.quadMesh.hideFlags = 20;

                if (this.quadMaterial != null) {
                    this.quadMeshRenderer.material = new UnityEngine.Material.$ctor1(this.quadMaterial);
                } else {
                    this.quadMeshRenderer.material = new UnityEngine.Material.$ctor2(UnityEngine.Shader.Find("Spine/RenderQuad"));
                }
            },
            /*Spine.Unity.Examples.SkeletonRenderTexture.CreateQuadChild end.*/

            /*Spine.Unity.Examples.SkeletonRenderTexture.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRenderTexture#OnEnable", this ); }

                this.skeletonRenderer.addOnMeshAndMaterialsUpdated(Bridge.fn.cacheBind(this, this.RenderOntoQuad));
                this.meshRenderer.forceRenderingOff = true;
                if (UnityEngine.Object.op_Implicit(this.quadMeshRenderer)) {
                    this.quadMeshRenderer.gameObject.SetActive(true);
                }
            },
            /*Spine.Unity.Examples.SkeletonRenderTexture.OnEnable end.*/

            /*Spine.Unity.Examples.SkeletonRenderTexture.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRenderTexture#OnDisable", this ); }

                this.skeletonRenderer.removeOnMeshAndMaterialsUpdated(Bridge.fn.cacheBind(this, this.RenderOntoQuad));
                this.meshRenderer.forceRenderingOff = false;
                if (UnityEngine.Object.op_Implicit(this.quadMeshRenderer)) {
                    this.quadMeshRenderer.gameObject.SetActive(false);
                }
                if (UnityEngine.Object.op_Implicit(this.renderTexture)) {
                    UnityEngine.RenderTexture.ReleaseTemporary(this.renderTexture);
                }
                this.allocatedRenderTextureSize = UnityEngine.Vector2Int.zero.$clone();
            },
            /*Spine.Unity.Examples.SkeletonRenderTexture.OnDisable end.*/

            /*Spine.Unity.Examples.SkeletonRenderTexture.RenderOntoQuad start.*/
            RenderOntoQuad: function (skeletonRenderer) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRenderTexture#RenderOntoQuad", this ); }

                this.PrepareForMesh();
                this.RenderToRenderTexture();
                this.AssignAtQuad();
            },
            /*Spine.Unity.Examples.SkeletonRenderTexture.RenderOntoQuad end.*/

            /*Spine.Unity.Examples.SkeletonRenderTexture.PrepareForMesh start.*/
            PrepareForMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRenderTexture#PrepareForMesh", this ); }

                // We need to get the min/max of all four corners, rotation of the skeleton
                // in combination with perspective projection otherwise might lead to incorrect
                // screen space min/max.
                var boundsLocalSpace = this.meshFilter.sharedMesh.bounds;
                var localCorner0 = boundsLocalSpace.min.$clone();
                var localCorner3 = boundsLocalSpace.max.$clone();
                var localCorner1 = new pc.Vec3( localCorner0.x, localCorner3.y, localCorner0.z );
                var localCorner2 = new pc.Vec3( localCorner3.x, localCorner0.y, localCorner3.z );

                var worldCorner0 = this.transform.TransformPoint$1(localCorner0);
                var worldCorner1 = this.transform.TransformPoint$1(localCorner1);
                var worldCorner2 = this.transform.TransformPoint$1(localCorner2);
                var worldCorner3 = this.transform.TransformPoint$1(localCorner3);

                var screenCorner0 = this.targetCamera.WorldToScreenPoint(worldCorner0);
                var screenCorner1 = this.targetCamera.WorldToScreenPoint(worldCorner1);
                var screenCorner2 = this.targetCamera.WorldToScreenPoint(worldCorner2);
                var screenCorner3 = this.targetCamera.WorldToScreenPoint(worldCorner3);

                // To avoid perspective distortion when rotated, we project all vertices
                // onto a plane parallel to the view frustum near plane.
                // Avoids the requirement of 'noperspective' vertex attribute interpolation modifier in shaders.
                var averageScreenDepth = (screenCorner0.z + screenCorner1.z + screenCorner2.z + screenCorner3.z) / 4.0;
                screenCorner0.z = (screenCorner1.z = (screenCorner2.z = (screenCorner3.z = averageScreenDepth)));
                this.worldCornerNoDistortion0 = this.targetCamera.ScreenToWorldPoint(screenCorner0);
                this.worldCornerNoDistortion1 = this.targetCamera.ScreenToWorldPoint(screenCorner1);
                this.worldCornerNoDistortion2 = this.targetCamera.ScreenToWorldPoint(screenCorner2);
                this.worldCornerNoDistortion3 = this.targetCamera.ScreenToWorldPoint(screenCorner3);

                var screenSpaceMin = { v : new UnityEngine.Vector3() }, screenSpaceMax = { v : new UnityEngine.Vector3() };
                this.PrepareTextureMapping(screenSpaceMin, screenSpaceMax, screenCorner0.$clone(), screenCorner1.$clone(), screenCorner2.$clone(), screenCorner3.$clone());
                this.PrepareCommandBuffer(this.targetCamera, screenSpaceMin.v, screenSpaceMax.v);
            },
            /*Spine.Unity.Examples.SkeletonRenderTexture.PrepareForMesh end.*/

            /*Spine.Unity.Examples.SkeletonRenderTexture.PrepareCommandBuffer start.*/
            PrepareCommandBuffer: function (targetCamera, screenSpaceMin, screenSpaceMax) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRenderTexture#PrepareCommandBuffer", this ); }

                this.commandBuffer.Clear();
                this.commandBuffer.SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier.op_Implicit$3(this.renderTexture));
                this.commandBuffer.ClearRenderTarget(true, true, new pc.Color( 0, 0, 0, 0 ));

                this.commandBuffer.SetProjectionMatrix(targetCamera.projectionMatrix);
                this.commandBuffer.SetViewMatrix(targetCamera.worldToCameraMatrix);
                var targetCameraViewportSize = targetCamera.pixelRect.size.$clone();
                var viewportRect = new UnityEngine.Rect.$ctor3(UnityEngine.Vector2.FromVector3(screenSpaceMin.$clone().scale( -1 )).mul( this.downScaleFactor ), targetCameraViewportSize.$clone().mul( this.downScaleFactor ));
                this.commandBuffer.SetViewport(viewportRect);
            },
            /*Spine.Unity.Examples.SkeletonRenderTexture.PrepareCommandBuffer end.*/

            /*Spine.Unity.Examples.SkeletonRenderTexture.RenderToRenderTexture start.*/
            RenderToRenderTexture: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRenderTexture#RenderToRenderTexture", this ); }

                this.meshRenderer.GetPropertyBlock(this.propertyBlock);
                this.meshRenderer.GetSharedMaterials(this.materials);

                for (var i = 0; i < this.materials.Count; i = (i + 1) | 0) {
                    this.commandBuffer.DrawMesh$3(this.meshFilter.sharedMesh, this.transform.localToWorldMatrix, this.materials.getItem(i), ((this.meshRenderer.subMeshStartIndex + i) | 0), -1, this.propertyBlock);
                }
                UnityEngine.Graphics.ExecuteCommandBuffer(this.commandBuffer);
            },
            /*Spine.Unity.Examples.SkeletonRenderTexture.RenderToRenderTexture end.*/

            /*Spine.Unity.Examples.SkeletonRenderTexture.AssignMeshAtRenderer start.*/
            AssignMeshAtRenderer: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonRenderTexture#AssignMeshAtRenderer", this ); }

                this.quadMeshFilter.mesh = this.quadMesh;
                this.quadMeshRenderer.sharedMaterial.mainTexture = this.renderTexture;
                this.quadMeshRenderer.sharedMaterial.color = this.color.$clone();
            },
            /*Spine.Unity.Examples.SkeletonRenderTexture.AssignMeshAtRenderer end.*/


        }
    });
    /*Spine.Unity.Examples.SkeletonRenderTexture end.*/

    /*Spine.Unity.Examples.SkeletonUtilityEyeConstraint start.*/
    Bridge.define("Spine.Unity.Examples.SkeletonUtilityEyeConstraint", {
        inherits: [Spine.Unity.SkeletonUtilityConstraint],
        fields: {
            eyes: null,
            radius: 0,
            target: null,
            targetPosition: null,
            speed: 0,
            origins: null,
            centerPoint: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonUtilityEyeConstraint#init", this ); }

                this.targetPosition = new UnityEngine.Vector3();
                this.centerPoint = new UnityEngine.Vector3();
                this.radius = 0.5;
                this.speed = 10;
            }
        },
        methods: {
            /*Spine.Unity.Examples.SkeletonUtilityEyeConstraint.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonUtilityEyeConstraint#OnEnable", this ); }

                if (!UnityEngine.Application.isPlaying) {
                    return;
                }
                Spine.Unity.SkeletonUtilityConstraint.prototype.OnEnable.call(this);

                var centerBounds = new pc.BoundingBox( this.eyes[0].localPosition.$clone(), pc.Vec3.ZERO.clone().scale( 0.5 ) );
                this.origins = System.Array.init(this.eyes.length, function (){
                    return new UnityEngine.Vector3();
                }, UnityEngine.Vector3);
                for (var i = 0; i < this.eyes.length; i = (i + 1) | 0) {
                    this.origins[i] = this.eyes[i].localPosition.$clone();
                    centerBounds.expandToPoint( this.origins[i].$clone() );
                }

                this.centerPoint = centerBounds.center.$clone();
            },
            /*Spine.Unity.Examples.SkeletonUtilityEyeConstraint.OnEnable end.*/

            /*Spine.Unity.Examples.SkeletonUtilityEyeConstraint.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonUtilityEyeConstraint#OnDisable", this ); }

                if (!UnityEngine.Application.isPlaying) {
                    return;
                }

                for (var i = 0; i < this.eyes.length; i = (i + 1) | 0) {
                    this.eyes[i].localPosition = this.origins[i].$clone();
                }
                Spine.Unity.SkeletonUtilityConstraint.prototype.OnDisable.call(this);
            },
            /*Spine.Unity.Examples.SkeletonUtilityEyeConstraint.OnDisable end.*/

            /*Spine.Unity.Examples.SkeletonUtilityEyeConstraint.DoUpdate start.*/
            DoUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonUtilityEyeConstraint#DoUpdate", this ); }

                if (UnityEngine.Component.op_Inequality(this.target, null)) {
                    this.targetPosition = this.target.position.$clone();
                }

                var goal = this.targetPosition.$clone();
                var center = this.transform.TransformPoint$1(this.centerPoint);
                var dir = goal.$clone().sub( center );

                if (dir.length() > 1) {
                    dir.normalize();
                }

                for (var i = 0; i < this.eyes.length; i = (i + 1) | 0) {
                    center = this.transform.TransformPoint$1(this.origins[i]);
                    this.eyes[i].position = pc.Vec3.moveTowards( this.eyes[i].position, center.$clone().add( (dir.$clone().clone().scale( this.radius ).clone().scale( this.hierarchy.PositionScale )) ), this.speed * this.hierarchy.PositionScale * UnityEngine.Time.deltaTime );
                }

            },
            /*Spine.Unity.Examples.SkeletonUtilityEyeConstraint.DoUpdate end.*/


        }
    });
    /*Spine.Unity.Examples.SkeletonUtilityEyeConstraint end.*/

    /*Spine.Unity.Examples.SkeletonUtilityGroundConstraint start.*/
    Bridge.define("Spine.Unity.Examples.SkeletonUtilityGroundConstraint", {
        inherits: [Spine.Unity.SkeletonUtilityConstraint],
        fields: {
            groundMask: null,
            use2D: false,
            useRadius: false,
            castRadius: 0,
            castDistance: 0,
            castOffset: 0,
            groundOffset: 0,
            adjustSpeed: 0,
            rayOrigin: null,
            rayDir: null,
            hitY: 0,
            lastHitY: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonUtilityGroundConstraint#init", this ); }

                this.groundMask = new UnityEngine.LayerMask();
                this.rayOrigin = new UnityEngine.Vector3();
                this.rayDir = new UnityEngine.Vector3();
                this.use2D = false;
                this.useRadius = false;
                this.castRadius = 0.1;
                this.castDistance = 5.0;
                this.castOffset = 0;
                this.groundOffset = 0;
                this.adjustSpeed = 5;
                this.rayDir = new pc.Vec3( 0, -1, 0 );
            }
        },
        methods: {
            /*Spine.Unity.Examples.SkeletonUtilityGroundConstraint.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonUtilityGroundConstraint#OnEnable", this ); }

                Spine.Unity.SkeletonUtilityConstraint.prototype.OnEnable.call(this);
                this.lastHitY = this.transform.position.y;
            },
            /*Spine.Unity.Examples.SkeletonUtilityGroundConstraint.OnEnable end.*/

            /*Spine.Unity.Examples.SkeletonUtilityGroundConstraint.DoUpdate start.*/
            DoUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonUtilityGroundConstraint#DoUpdate", this ); }

                this.rayOrigin = this.transform.position.$clone().add( new pc.Vec3( this.castOffset, this.castDistance, 0 ) );

                var positionScale = this.hierarchy.PositionScale;
                var adjustDistanceThisFrame = this.adjustSpeed * positionScale * UnityEngine.Time.deltaTime;
                this.hitY = -3.40282347E+38;
                if (this.use2D) {
                    var hit = new UnityEngine.RaycastHit2D();

                    if (this.useRadius) {
                        hit = UnityEngine.Physics2D.CircleCast$2(UnityEngine.Vector2.FromVector3(this.rayOrigin), this.castRadius, UnityEngine.Vector2.FromVector3(this.rayDir), this.castDistance + this.groundOffset, UnityEngine.LayerMask.op_Implicit(this.groundMask.$clone()));
                    } else {
                        hit = UnityEngine.Physics2D.Raycast$2(UnityEngine.Vector2.FromVector3(this.rayOrigin), UnityEngine.Vector2.FromVector3(this.rayDir), this.castDistance + this.groundOffset, UnityEngine.LayerMask.op_Implicit(this.groundMask.$clone()));
                    }

                    if (UnityEngine.Component.op_Inequality(hit.collider, null)) {
                        this.hitY = hit.point.y + this.groundOffset;
                        if (UnityEngine.Application.isPlaying) {
                            this.hitY = UnityEngine.Mathf.MoveTowards(this.lastHitY, this.hitY, adjustDistanceThisFrame);
                        }
                    } else {
                        if (UnityEngine.Application.isPlaying) {
                            this.hitY = UnityEngine.Mathf.MoveTowards(this.lastHitY, this.transform.position.y, adjustDistanceThisFrame);
                        }
                    }
                } else {
                    var hit1 = { v : new UnityEngine.RaycastHit() };
                    var validHit = false;

                    if (this.useRadius) {
                        validHit = UnityEngine.Physics.SphereCast$2(this.rayOrigin, this.castRadius, this.rayDir, hit1, this.castDistance + this.groundOffset, UnityEngine.LayerMask.op_Implicit(this.groundMask.$clone()));
                    } else {
                        validHit = UnityEngine.Physics.Raycast$3(this.rayOrigin, this.rayDir, hit1, this.castDistance + this.groundOffset, UnityEngine.LayerMask.op_Implicit(this.groundMask.$clone()));
                    }

                    if (validHit) {
                        this.hitY = hit1.v.point.y + this.groundOffset;
                        if (UnityEngine.Application.isPlaying) {
                            this.hitY = UnityEngine.Mathf.MoveTowards(this.lastHitY, this.hitY, adjustDistanceThisFrame);
                        }

                    } else {
                        if (UnityEngine.Application.isPlaying) {
                            this.hitY = UnityEngine.Mathf.MoveTowards(this.lastHitY, this.transform.position.y, adjustDistanceThisFrame);
                        }
                    }
                }

                var v = this.transform.position.$clone();
                v.y = Math.max(UnityEngine.Mathf.Min(this.lastHitY, this.hitY), Math.min(v.y, 3.40282347E+38));
                this.transform.position = v.$clone();

                this.bone.bone.x = this.transform.localPosition.x / this.hierarchy.PositionScale;
                this.bone.bone.y = this.transform.localPosition.y / this.hierarchy.PositionScale;

                this.lastHitY = this.hitY;
            },
            /*Spine.Unity.Examples.SkeletonUtilityGroundConstraint.DoUpdate end.*/

            /*Spine.Unity.Examples.SkeletonUtilityGroundConstraint.OnDrawGizmos start.*/
            OnDrawGizmos: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SkeletonUtilityGroundConstraint#OnDrawGizmos", this ); }

                var hitEnd = this.rayOrigin.$clone().add( (this.rayDir.$clone().clone().scale( UnityEngine.Mathf.Min(this.castDistance, this.rayOrigin.y - this.hitY) )) );
                var clearEnd = this.rayOrigin.$clone().add( (this.rayDir.$clone().clone().scale( this.castDistance )) );
                pc.stubProxy.reportMethod( 'UnityEngine.Gizmos.DrawLine', null );

                if (this.useRadius) {
                    pc.stubProxy.reportMethod( 'UnityEngine.Gizmos.DrawLine', null );
                    pc.stubProxy.reportMethod( 'UnityEngine.Gizmos.DrawLine', null );
                }

                pc.generateStubProxy( 'UnityEngine.Gizmos', true ).color = new pc.Color( 1, 0, 0, 1 );
                pc.stubProxy.reportMethod( 'UnityEngine.Gizmos.DrawLine', null );
            },
            /*Spine.Unity.Examples.SkeletonUtilityGroundConstraint.OnDrawGizmos end.*/


        }
    });
    /*Spine.Unity.Examples.SkeletonUtilityGroundConstraint end.*/

    /*Spine.Unity.IHasSkeletonComponent start.*/
    /**
     * A Spine-Unity Component that holds a reference to an ISkeletonComponent.
     *
     * @abstract
     * @public
     * @class Spine.Unity.IHasSkeletonComponent
     * @implements  Spine.Unity.ISpineComponent
     */
    Bridge.define("Spine.Unity.IHasSkeletonComponent", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.IHasSkeletonComponent end.*/

    /*Spine.Unity.IAnimationStateComponent start.*/
    /**
     * A Spine-Unity Component that uses a Spine.AnimationState to animate its skeleton.
     *
     * @abstract
     * @public
     * @class Spine.Unity.IAnimationStateComponent
     * @implements  Spine.Unity.ISpineComponent
     */
    Bridge.define("Spine.Unity.IAnimationStateComponent", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.IAnimationStateComponent end.*/

    /*Spine.Unity.IHasSkeletonRenderer start.*/
    /**
     * A Spine-Unity Component that holds a reference to a SkeletonRenderer.
     *
     * @abstract
     * @public
     * @class Spine.Unity.IHasSkeletonRenderer
     * @implements  Spine.Unity.ISpineComponent
     */
    Bridge.define("Spine.Unity.IHasSkeletonRenderer", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.IHasSkeletonRenderer end.*/

    /*Spine.Unity.ISkeletonAnimation start.*/
    /**
     * A Spine-Unity Component that animates a Skeleton but not necessarily with a Spine.AnimationState.
     *
     * @abstract
     * @public
     * @class Spine.Unity.ISkeletonAnimation
     * @implements  Spine.Unity.ISpineComponent
     */
    Bridge.define("Spine.Unity.ISkeletonAnimation", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.ISkeletonAnimation end.*/

    /*Spine.Unity.ISkeletonComponent start.*/
    /**
     * A Spine-Unity Component that manages a Spine.Skeleton instance, instantiated from a SkeletonDataAsset.
     *
     * @abstract
     * @public
     * @class Spine.Unity.ISkeletonComponent
     * @implements  Spine.Unity.ISpineComponent
     */
    Bridge.define("Spine.Unity.ISkeletonComponent", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.ISkeletonComponent end.*/

    /*Spine.Unity.SkeletonMecanimRootMotion start.*/
    /**
     * Add this component to a SkeletonMecanim GameObject
     to turn motion of a selected root bone into Transform or RigidBody motion.
     Local bone translation movement is used as motion.
     All top-level bones of the skeleton are moved to compensate the root
     motion bone location, keeping the distance relationship between bones intact.
     *
     * @public
     * @class Spine.Unity.SkeletonMecanimRootMotion
     * @augments Spine.Unity.SkeletonRootMotionBase
     */
    Bridge.define("Spine.Unity.SkeletonMecanimRootMotion", {
        inherits: [Spine.Unity.SkeletonRootMotionBase],
        statics: {
            fields: {
                DefaultMecanimLayerFlags: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#init", this ); }

                    this.DefaultMecanimLayerFlags = -1;
                }
            }
        },
        fields: {
            mecanimLayerFlags: 0,
            movementDelta: null,
            rotationDelta: 0,
            skeletonMecanim: null
        },
        props: {
            SkeletonMecanim: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#SkeletonMecanim#get", this ); }

                    return UnityEngine.Object.op_Implicit(this.skeletonMecanim) ? this.skeletonMecanim : (this.skeletonMecanim = this.GetComponent(Spine.Unity.SkeletonMecanim));
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#init", this ); }

                this.movementDelta = new UnityEngine.Vector2();
                this.mecanimLayerFlags = -1;
            }
        },
        methods: {
            /*Spine.Unity.SkeletonMecanimRootMotion.GetRemainingRootMotion start.*/
            GetRemainingRootMotion: function (layerIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#GetRemainingRootMotion", this ); }

                var pair = this.skeletonMecanim.Translator.GetActiveAnimationAndTime(layerIndex);
                var animation = pair.key;
                var time = pair.value;
                if (animation == null) {
                    return pc.Vec2.ZERO.clone();
                }

                var start = time;
                var end = animation.duration;
                return this.GetAnimationRootMotion$1(start, end, animation);
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.GetRemainingRootMotion end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.GetRootMotionInfo start.*/
            GetRootMotionInfo: function (layerIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#GetRootMotionInfo", this ); }

                var pair = this.skeletonMecanim.Translator.GetActiveAnimationAndTime(layerIndex);
                var animation = pair.key;
                var time = pair.value;
                if (animation == null) {
                    return new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo();
                }
                return this.GetAnimationRootMotionInfo(animation, time);
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.GetRootMotionInfo end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#Reset", this ); }

                Spine.Unity.SkeletonRootMotionBase.prototype.Reset.call(this);
                this.mecanimLayerFlags = Spine.Unity.SkeletonMecanimRootMotion.DefaultMecanimLayerFlags;
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.Reset end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#Start", this ); }

                Spine.Unity.SkeletonRootMotionBase.prototype.Start.call(this);
                this.skeletonMecanim = this.GetComponent(Spine.Unity.SkeletonMecanim);
                if (UnityEngine.Object.op_Implicit(this.skeletonMecanim)) {
                    this.skeletonMecanim.Translator.removeOnClipApplied(Bridge.fn.cacheBind(this, this.OnClipApplied));
                    this.skeletonMecanim.Translator.addOnClipApplied(Bridge.fn.cacheBind(this, this.OnClipApplied));
                }
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.Start end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.OnClipApplied start.*/
            OnClipApplied: function (animation, layerIndex, weight, time, lastTime, playsBackward) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#OnClipApplied", this ); }


                if (((this.mecanimLayerFlags & 1 << layerIndex) === 0) || weight === 0) {
                    return;
                }

                if (!playsBackward) {
                    this.movementDelta = this.movementDelta.$clone().add( this.GetAnimationRootMotion$1(lastTime, time, animation).scale( weight ) );
                } else {
                    this.movementDelta = this.movementDelta.$clone().sub( this.GetAnimationRootMotion$1(time, lastTime, animation).scale( weight ) );
                }
                if (this.transformRotation) {
                    if (!playsBackward) {
                        this.rotationDelta += weight * this.GetAnimationRootMotionRotation$1(lastTime, time, animation);
                    } else {
                        this.rotationDelta -= weight * this.GetAnimationRootMotionRotation$1(time, lastTime, animation);
                    }
                }
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.OnClipApplied end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.CalculateAnimationsMovementDelta start.*/
            CalculateAnimationsMovementDelta: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#CalculateAnimationsMovementDelta", this ); }

                // Note: movement delta is not gathered after animation but
                // in OnClipApplied after every applied animation.
                var result = this.movementDelta.$clone();
                this.movementDelta = pc.Vec2.ZERO.clone();
                return result.$clone();
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.CalculateAnimationsMovementDelta end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.CalculateAnimationsRotationDelta start.*/
            CalculateAnimationsRotationDelta: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#CalculateAnimationsRotationDelta", this ); }

                // Note: movement delta is not gathered after animation but
                // in OnClipApplied after every applied animation.
                var result = this.rotationDelta;
                this.rotationDelta = 0;
                return result;
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.CalculateAnimationsRotationDelta end.*/


        }
    });
    /*Spine.Unity.SkeletonMecanimRootMotion end.*/

    /*Spine.Unity.SkeletonRootMotion start.*/
    /**
     * Add this component to a SkeletonAnimation or SkeletonGraphic GameObject
     to turn motion of a selected root bone into Transform or RigidBody motion.
     Local bone translation movement is used as motion.
     All top-level bones of the skeleton are moved to compensate the root
     motion bone location, keeping the distance relationship between bones intact.
     *
     * @public
     * @class Spine.Unity.SkeletonRootMotion
     * @augments Spine.Unity.SkeletonRootMotionBase
     */
    Bridge.define("Spine.Unity.SkeletonRootMotion", {
        inherits: [Spine.Unity.SkeletonRootMotionBase],
        statics: {
            fields: {
                DefaultAnimationTrackFlags: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#init", this ); }

                    this.DefaultAnimationTrackFlags = -1;
                }
            }
        },
        fields: {
            animationTrackFlags: 0,
            animationState: null,
            skeletonGraphic: null
        },
        props: {
            AdditionalScale: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#AdditionalScale#get", this ); }

                    return UnityEngine.Object.op_Implicit(this.skeletonGraphic) ? this.skeletonGraphic.MeshScale : 1.0;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#init", this ); }

                this.animationTrackFlags = -1;
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRootMotion.GetRemainingRootMotion start.*/
            GetRemainingRootMotion: function (trackIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#GetRemainingRootMotion", this ); }

                var track = this.animationState.getCurrent(trackIndex);
                if (track == null) {
                    return pc.Vec2.ZERO.clone();
                }

                var animation = track.animation;
                var start = track.getAnimationTime();
                var end = animation.duration;
                return this.GetAnimationRootMotion$1(start, end, animation);
            },
            /*Spine.Unity.SkeletonRootMotion.GetRemainingRootMotion end.*/

            /*Spine.Unity.SkeletonRootMotion.GetRootMotionInfo start.*/
            GetRootMotionInfo: function (trackIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#GetRootMotionInfo", this ); }

                var track = this.animationState.getCurrent(trackIndex);
                if (track == null) {
                    return new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo();
                }

                var animation = track.animation;
                var time = track.getAnimationTime();
                return this.GetAnimationRootMotionInfo(track.animation, time);
            },
            /*Spine.Unity.SkeletonRootMotion.GetRootMotionInfo end.*/

            /*Spine.Unity.SkeletonRootMotion.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#Reset", this ); }

                Spine.Unity.SkeletonRootMotionBase.prototype.Reset.call(this);
                this.animationTrackFlags = Spine.Unity.SkeletonRootMotion.DefaultAnimationTrackFlags;
            },
            /*Spine.Unity.SkeletonRootMotion.Reset end.*/

            /*Spine.Unity.SkeletonRootMotion.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#Start", this ); }

                Spine.Unity.SkeletonRootMotionBase.prototype.Start.call(this);
                var animstateComponent = Bridge.as(this.skeletonComponent, Spine.Unity.IAnimationStateComponent);
                this.animationState = (animstateComponent != null) ? animstateComponent.Spine$Unity$IAnimationStateComponent$AnimationState : null;

                this.skeletonGraphic = this.GetComponent(Spine.Unity.SkeletonGraphic);
            },
            /*Spine.Unity.SkeletonRootMotion.Start end.*/

            /*Spine.Unity.SkeletonRootMotion.CalculateAnimationsMovementDelta start.*/
            CalculateAnimationsMovementDelta: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#CalculateAnimationsMovementDelta", this ); }

                var localDelta = pc.Vec2.ZERO.clone();
                var trackCount = this.animationState.Tracks.Count;

                for (var trackIndex = 0; trackIndex < trackCount; trackIndex = (trackIndex + 1) | 0) {
                    // note: animationTrackFlags != -1 below covers trackIndex >= 32,
                    // with -1 corresponding to entry "everything" of the dropdown list.
                    if (this.animationTrackFlags !== -1 && (this.animationTrackFlags & 1 << trackIndex) === 0) {
                        continue;
                    }

                    var track = this.animationState.getCurrent(trackIndex);
                    var next = null;
                    while (track != null) {
                        var animation = track.animation;
                        var start = track.animationLast;
                        var end = track.getAnimationTime();
                        var currentDelta = { v : this.GetAnimationRootMotion$1(start, end, animation) };
                        if (!pc.Vec2.equals( currentDelta.v, pc.Vec2.ZERO.clone() )) {
                            this.ApplyMixAlphaToDelta$1(currentDelta, next, track);
                            localDelta = localDelta.$clone().add( currentDelta.v.$clone() );
                        }

                        // Traverse mixingFrom chain.
                        next = track;
                        track = track.mixingFrom;
                    }
                }
                return localDelta.$clone();
            },
            /*Spine.Unity.SkeletonRootMotion.CalculateAnimationsMovementDelta end.*/

            /*Spine.Unity.SkeletonRootMotion.CalculateAnimationsRotationDelta start.*/
            CalculateAnimationsRotationDelta: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#CalculateAnimationsRotationDelta", this ); }

                var localDelta = 0;
                var trackCount = this.animationState.Tracks.Count;

                for (var trackIndex = 0; trackIndex < trackCount; trackIndex = (trackIndex + 1) | 0) {
                    // note: animationTrackFlags != -1 below covers trackIndex >= 32,
                    // with -1 corresponding to entry "everything" of the dropdown list.
                    if (this.animationTrackFlags !== -1 && (this.animationTrackFlags & 1 << trackIndex) === 0) {
                        continue;
                    }

                    var track = this.animationState.getCurrent(trackIndex);
                    var next = null;
                    while (track != null) {
                        var animation = track.animation;
                        var start = track.animationLast;
                        var end = track.getAnimationTime();
                        var currentDelta = { v : this.GetAnimationRootMotionRotation$1(start, end, animation) };
                        if (currentDelta.v !== 0) {
                            this.ApplyMixAlphaToDelta(currentDelta, next, track);
                            localDelta += currentDelta.v;
                        }

                        // Traverse mixingFrom chain.
                        next = track;
                        track = track.mixingFrom;
                    }
                }
                return localDelta;
            },
            /*Spine.Unity.SkeletonRootMotion.CalculateAnimationsRotationDelta end.*/

            /*Spine.Unity.SkeletonRootMotion.ApplyMixAlphaToDelta$1 start.*/
            ApplyMixAlphaToDelta$1: function (currentDelta, next, track) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#ApplyMixAlphaToDelta$1", this ); }

                var mixAlpha = { v : 1 };
                this.GetMixAlpha(mixAlpha, next, track);
                currentDelta.v = currentDelta.v.$clone().scale( mixAlpha.v );
            },
            /*Spine.Unity.SkeletonRootMotion.ApplyMixAlphaToDelta$1 end.*/

            /*Spine.Unity.SkeletonRootMotion.ApplyMixAlphaToDelta start.*/
            ApplyMixAlphaToDelta: function (currentDelta, next, track) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#ApplyMixAlphaToDelta", this ); }

                var mixAlpha = { v : 1 };
                this.GetMixAlpha(mixAlpha, next, track);
                currentDelta.v *= mixAlpha.v;
            },
            /*Spine.Unity.SkeletonRootMotion.ApplyMixAlphaToDelta end.*/

            /*Spine.Unity.SkeletonRootMotion.GetMixAlpha start.*/
            GetMixAlpha: function (cumulatedMixAlpha, next, track) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#GetMixAlpha", this ); }

                // code below based on AnimationState.cs
                var mix;
                if (next != null) {
                    if (next.mixDuration === 0) { // Single frame mix to undo mixingFrom changes.
                        mix = 1;
                    } else {
                        mix = next.mixTime / next.mixDuration;
                        if (mix > 1) {
                            mix = 1;
                        }
                    }
                    var mixAndAlpha = track.alpha * next.interruptAlpha * (1 - mix);
                    cumulatedMixAlpha.v *= mixAndAlpha;
                } else {
                    if (track.mixDuration === 0) {
                        mix = 1;
                    } else {
                        mix = track.alpha * (track.mixTime / track.mixDuration);
                        if (mix > 1) {
                            mix = 1;
                        }
                    }
                    cumulatedMixAlpha.v *= mix;
                }
            },
            /*Spine.Unity.SkeletonRootMotion.GetMixAlpha end.*/


        },
        overloads: {
            "ApplyMixAlphaToDelta(Vector2, TrackEntry, TrackEntry)": "ApplyMixAlphaToDelta$1"
        }
    });
    /*Spine.Unity.SkeletonRootMotion end.*/

    /*Spine.Unity.SpineAnimation start.*/
    Bridge.define("Spine.Unity.SpineAnimation", {
        inherits: [Spine.Unity.SpineAttributeBase],
        ctors: {
            
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAnimation#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineAnimation end.*/
    /** @namespace System */

    /**
     * @memberof System
     * @callback System.Func
     * @param   {Spine.Unity.SpineAtlasAsset}    arg
     * @return  {Spine.TextureLoader}
     */


    /*Spine.Unity.SpineAtlasAsset start.*/
    /**
     * Loads and stores a Spine atlas and list of materials.
     *
     * @public
     * @class Spine.Unity.SpineAtlasAsset
     * @augments Spine.Unity.AtlasAssetBase
     */
    Bridge.define("Spine.Unity.SpineAtlasAsset", {
        inherits: [Spine.Unity.AtlasAssetBase],
        statics: {
            methods: {
                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance:static start.*/
                /**
                 * Creates a runtime AtlasAsset
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SpineAtlasAsset
                 * @memberof Spine.Unity.SpineAtlasAsset
                 * @param   {UnityEngine.TextAsset}           atlasText                 
                 * @param   {Array.<UnityEngine.Material>}    materials                 
                 * @param   {boolean}                         initialize                
                 * @param   {System.Func}                     newCustomTextureLoader    When not null, a function instantiating
                 a custom <pre><code>TextureLoader</code></pre> with the newly created <pre><code>SpineAtlasAsset</code></pre> as argument
                 is used instead of instantiating the default <pre><code>MaterialsTextureLoader</code></pre>.
                 A valid parameter is e.g. <pre><code>(a) =&gt; new CustomTextureLoader(a)</code></pre>
                 * @return  {Spine.Unity.SpineAtlasAsset}
                 */
                CreateRuntimeInstance: function (atlasText, materials, initialize, newCustomTextureLoader) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance", this ); }

                    if (newCustomTextureLoader === void 0) { newCustomTextureLoader = null; }

                    var atlasAsset = UnityEngine.ScriptableObject.CreateInstance(Spine.Unity.SpineAtlasAsset);
                    atlasAsset.Reset();
                    atlasAsset.atlasFile = atlasText;
                    atlasAsset.materials = materials;
                    if (!Bridge.staticEquals(newCustomTextureLoader, null)) {
                        atlasAsset.customTextureLoader = newCustomTextureLoader(atlasAsset);
                    }

                    if (initialize) {
                        atlasAsset.GetAtlas();
                    }

                    return atlasAsset;
                },
                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance:static end.*/

                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$1:static start.*/
                /**
                 * Creates a runtime AtlasAsset. Only providing the textures is slower
                 because it has to search for atlas page matches.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SpineAtlasAsset
                 * @memberof Spine.Unity.SpineAtlasAsset
                 * @param   {UnityEngine.TextAsset}            atlasText                 
                 * @param   {Array.<UnityEngine.Texture2D>}    textures                  An array of all textures referenced in the provided <pre><code>atlasText</code></pre>
                 atlas asset JSON file. When procedurally creating textures, each <pre><code>Texture.name</code></pre>
                 needs to be set to the atlas page texture filename without the .png extension,
                 e.g. 'my_skeleton' if the png filename listed in the atlas asset file is 'my_skeleton.png'.
                 * @param   {UnityEngine.Material}             materialPropertySource    
                 * @param   {boolean}                          initialize                
                 * @param   {System.Func}                      newCustomTextureLoader
                 * @return  {Spine.Unity.SpineAtlasAsset}
                 * @see {@link SpineAtlasAsset.CreateRuntimeInstance(TextAsset, Material[], bool, Func{SpineAtlasAsset, TextureLoader})}
                 */
                CreateRuntimeInstance$1: function (atlasText, textures, materialPropertySource, initialize, newCustomTextureLoader) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance$1", this ); }

                    if (newCustomTextureLoader === void 0) { newCustomTextureLoader = null; }

                    // Get atlas page names.
                    var atlasString = atlasText.text;
                    atlasString = System.String.replaceAll(atlasString, "\r", "");
                    var atlasLines = System.String.split(atlasString, [10].map(function (i) {{ return String.fromCharCode(i); }}));
                    var pages = new (System.Collections.Generic.List$1(System.String)).ctor();
                    for (var i = 0; i < ((atlasLines.length - 1) | 0); i = (i + 1) | 0) {
                        var line = atlasLines[i].trim();
                        if (System.String.endsWith(line, ".png")) {
                            pages.add(System.String.replaceAll(line, ".png", ""));
                        }
                    }

                    // Populate Materials[] by matching texture names with page names.
                    var materials = System.Array.init(pages.Count, null, UnityEngine.Material);
                    for (var i1 = 0, n = pages.Count; i1 < n; i1 = (i1 + 1) | 0) {
                        var mat = null;

                        // Search for a match.
                        var pageName = pages.getItem(i1);
                        for (var j = 0, m = textures.length; j < m; j = (j + 1) | 0) {
                            if (System.String.equals(pageName, textures[j].name, 5)) {
                                // Match found.
                                mat = new UnityEngine.Material.$ctor1(materialPropertySource);
                                mat.mainTexture = textures[j];
                                break;
                            }
                        }

                        if (mat != null) {
                            materials[i1] = mat;
                        } else {
                            throw new System.ArgumentException.$ctor1("Could not find matching atlas page in the texture array.");
                        }
                    }

                    // Create AtlasAsset normally
                    return Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance(atlasText, materials, initialize, newCustomTextureLoader);
                },
                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$1:static end.*/

                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$2:static start.*/
                
                CreateRuntimeInstance$2: function (atlasText, textures, shader, initialize, newCustomTextureLoader) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance$2", this ); }

                    if (newCustomTextureLoader === void 0) { newCustomTextureLoader = null; }

                    if (shader == null) {
                        shader = UnityEngine.Shader.Find("Spine/Skeleton");
                    }

                    var materialProperySource = new UnityEngine.Material.$ctor2(shader);
                    return Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$1(atlasText, textures, materialProperySource, initialize, newCustomTextureLoader);
                },
                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$2:static end.*/


            }
        },
        fields: {
            atlasFile: null,
            materials: null,
            customTextureLoader: null,
            atlas: null
        },
        props: {
            IsLoaded: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#IsLoaded#get", this ); }

                    return this.atlas != null;
                }
            },
            Materials: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#Materials#get", this ); }

                    return this.materials;
                }
            },
            MaterialCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#MaterialCount#get", this ); }

                    return this.materials == null ? 0 : this.materials.length;
                }
            },
            PrimaryMaterial: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#PrimaryMaterial#get", this ); }

                    return this.materials[0];
                }
            }
        },
        methods: {
            /*Spine.Unity.SpineAtlasAsset.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#Reset", this ); }

                this.Clear();
            },
            /*Spine.Unity.SpineAtlasAsset.Reset end.*/

            /*Spine.Unity.SpineAtlasAsset.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#Clear", this ); }

                this.atlas = null;
            },
            /*Spine.Unity.SpineAtlasAsset.Clear end.*/

            /*Spine.Unity.SpineAtlasAsset.GetAtlas start.*/
            /**
             * @instance
             * @public
             * @override
             * @this Spine.Unity.SpineAtlasAsset
             * @memberof Spine.Unity.SpineAtlasAsset
             * @param   {boolean}        onlyMetaData
             * @return  {Spine.Atlas}                    The atlas or null if it could not be loaded.
             */
            GetAtlas: function (onlyMetaData) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#GetAtlas", this ); }

                if (onlyMetaData === void 0) { onlyMetaData = false; }
                if (this.atlasFile == null) {
                    UnityEngine.Debug.LogError$2("Atlas file not set for atlas asset: " + (this.name || ""), this);
                    this.Clear();
                    return null;
                }

                if (!onlyMetaData && (this.materials == null || this.materials.length === 0)) {
                    UnityEngine.Debug.LogError$2("Materials not set for atlas asset: " + (this.name || ""), this);
                    this.Clear();
                    return null;
                }

                if (this.atlas != null) {
                    return this.atlas;
                }

                try {
                    var loader;
                    if (!onlyMetaData) {
                        loader = this.customTextureLoader == null ? new Spine.Unity.MaterialsTextureLoader(this) : this.customTextureLoader;
                    } else {
                        loader = new Spine.Unity.NoOpTextureLoader();
                    }
                    this.atlas = new Spine.Atlas.$ctor1(new System.IO.StringReader(this.atlasFile.text), "", loader);
                    this.atlas.FlipV();
                    return this.atlas;
                } catch (ex) {
                    ex = System.Exception.create(ex);
                    UnityEngine.Debug.LogError$2("Error reading atlas file for atlas asset: " + (this.name || "") + "\n" + (ex.Message || "") + "\n" + (ex.StackTrace || ""), this);
                    return null;
                }
            },
            /*Spine.Unity.SpineAtlasAsset.GetAtlas end.*/

            /*Spine.Unity.SpineAtlasAsset.GenerateMesh start.*/
            GenerateMesh: function (name, mesh, material, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#GenerateMesh", this ); }

                if (scale === void 0) { scale = 0.01; }
                var region = this.atlas.findRegion(name);
                material.v = null;
                if (region != null) {
                    if (mesh == null) {
                        mesh = new UnityEngine.Mesh.ctor();
                        mesh.name = name;
                    }

                    var verts = System.Array.init(4, function (){
                        return new UnityEngine.Vector3();
                    }, UnityEngine.Vector3);
                    var uvs = System.Array.init(4, function (){
                        return new UnityEngine.Vector2();
                    }, UnityEngine.Vector2);
                    var colors = System.Array.init([
                        new pc.Color( 1, 1, 1, 1 ), 
                        new pc.Color( 1, 1, 1, 1 ), 
                        new pc.Color( 1, 1, 1, 1 ), 
                        new pc.Color( 1, 1, 1, 1 )
                    ], UnityEngine.Color);
                    var triangles = System.Array.init([
                        0, 
                        1, 
                        2, 
                        2, 
                        3, 
                        0
                    ], System.Int32);

                    var left, right, top, bottom;
                    left = region.width / -2.0;
                    right = left * -1.0;
                    top = region.height / 2.0;
                    bottom = top * -1;

                    verts[0] = new pc.Vec3( left, bottom, 0 ).clone().scale( scale );
                    verts[1] = new pc.Vec3( left, top, 0 ).clone().scale( scale );
                    verts[2] = new pc.Vec3( right, top, 0 ).clone().scale( scale );
                    verts[3] = new pc.Vec3( right, bottom, 0 ).clone().scale( scale );
                    var u, v, u2, v2;
                    u = region.u;
                    v = region.v;
                    u2 = region.u2;
                    v2 = region.v2;

                    if (region.degrees === 90) {
                        uvs[0] = new pc.Vec2( u2, v2 );
                        uvs[1] = new pc.Vec2( u, v2 );
                        uvs[2] = new pc.Vec2( u, v );
                        uvs[3] = new pc.Vec2( u2, v );
                    } else {
                        uvs[0] = new pc.Vec2( u, v2 );
                        uvs[1] = new pc.Vec2( u, v );
                        uvs[2] = new pc.Vec2( u2, v );
                        uvs[3] = new pc.Vec2( u2, v2 );
                    }

                    mesh.triangles = System.Array.init(0, 0, System.Int32);
                    mesh.vertices = verts;
                    mesh.uv = uvs;
                    mesh.colors = colors;
                    mesh.triangles = triangles;
                    mesh.RecalculateNormals();
                    mesh.RecalculateBounds();

                    material.v = Bridge.cast(region.page.rendererObject, UnityEngine.Material);
                } else {
                    mesh = null;
                }

                return mesh;
            },
            /*Spine.Unity.SpineAtlasAsset.GenerateMesh end.*/


        }
    });
    /*Spine.Unity.SpineAtlasAsset end.*/

    /*Spine.Unity.SpineAttachment start.*/
    Bridge.define("Spine.Unity.SpineAttachment", {
        inherits: [Spine.Unity.SpineAttributeBase],
        statics: {
            methods: {
                /*Spine.Unity.SpineAttachment.getHierarchy:static start.*/
                getHierarchy: function (fullPath) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment#getHierarchy", this ); }

                    return new Spine.Unity.SpineAttachment.Hierarchy.$ctor1(fullPath);
                },
                /*Spine.Unity.SpineAttachment.getHierarchy:static end.*/

                /*Spine.Unity.SpineAttachment.getAttachment:static start.*/
                getAttachment: function (attachmentPath, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment#getAttachment", this ); }

                    var hierarchy = Spine.Unity.SpineAttachment.getHierarchy(attachmentPath);
                    if (System.String.isNullOrEmpty(hierarchy.name)) {
                        return null;
                    }

                    var slot = skeletonData.findSlot(hierarchy.slot);
                    if (slot == null) {
                        return null;
                    }
                    return skeletonData.findSkin(hierarchy.skin).getAttachment(slot.index, hierarchy.name);
                },
                /*Spine.Unity.SpineAttachment.getAttachment:static end.*/

                /*Spine.Unity.SpineAttachment.getAttachment$1:static start.*/
                getAttachment$1: function (attachmentPath, skeletonDataAsset) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment#getAttachment$1", this ); }

                    return Spine.Unity.SpineAttachment.getAttachment(attachmentPath, skeletonDataAsset.GetSkeletonData(true));
                },
                /*Spine.Unity.SpineAttachment.getAttachment$1:static end.*/


            }
        },
        fields: {
            returnAttachmentPath: false,
            currentSkinOnly: false,
            placeholdersOnly: false,
            skinField: null,
            slotField: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment#init", this ); }

                this.returnAttachmentPath = false;
                this.currentSkinOnly = false;
                this.placeholdersOnly = false;
                this.skinField = "";
                this.slotField = "";
            },
            
            ctor: function (currentSkinOnly, returnAttachmentPath, placeholdersOnly, slotField, dataField, skinField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment#ctor", this ); }

                if (currentSkinOnly === void 0) { currentSkinOnly = true; }
                if (returnAttachmentPath === void 0) { returnAttachmentPath = false; }
                if (placeholdersOnly === void 0) { placeholdersOnly = false; }
                if (slotField === void 0) { slotField = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (skinField === void 0) { skinField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.currentSkinOnly = currentSkinOnly;
                this.returnAttachmentPath = returnAttachmentPath;
                this.placeholdersOnly = placeholdersOnly;
                this.slotField = slotField;
                this.dataField = dataField;
                this.skinField = skinField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineAttachment end.*/

    /*Spine.Unity.SpineBone start.*/
    Bridge.define("Spine.Unity.SpineBone", {
        inherits: [Spine.Unity.SpineAttributeBase],
        statics: {
            methods: {
                /*Spine.Unity.SpineBone.getBone:static start.*/
                getBone: function (boneName, renderer) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineBone#getBone", this ); }

                    return renderer.skeleton == null ? null : renderer.skeleton.findBone(boneName);
                },
                /*Spine.Unity.SpineBone.getBone:static end.*/

                /*Spine.Unity.SpineBone.getBoneData:static start.*/
                getBoneData: function (boneName, skeletonDataAsset) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineBone#getBoneData", this ); }

                    var data = skeletonDataAsset.GetSkeletonData(true);
                    return data.findBone(boneName);
                },
                /*Spine.Unity.SpineBone.getBoneData:static end.*/


            }
        },
        ctors: {
            
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineBone#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineBone end.*/

    /*Spine.Unity.SpineEvent start.*/
    Bridge.define("Spine.Unity.SpineEvent", {
        inherits: [Spine.Unity.SpineAttributeBase],
        fields: {
            /**
             * Smart popup menu for Spine Events (Spine.EventData)
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SpineEvent
             * @default false
             * @type boolean
             */
            audioOnly: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineEvent#init", this ); }

                this.audioOnly = false;
            },
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField, audioOnly) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineEvent#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }
                if (audioOnly === void 0) { audioOnly = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
                this.audioOnly = audioOnly;
            }
        }
    });
    /*Spine.Unity.SpineEvent end.*/

    /*Spine.Unity.SpineIkConstraint start.*/
    Bridge.define("Spine.Unity.SpineIkConstraint", {
        inherits: [Spine.Unity.SpineAttributeBase],
        ctors: {
            /**
             * Smart popup menu for Spine IK Constraints (Spine.IkConstraint)
             *
             * @instance
             * @public
             * @this Spine.Unity.SpineIkConstraint
             * @memberof Spine.Unity.SpineIkConstraint
             * @param   {string}     startsWith             Filters popup results to elements that begin with supplied string.
             * @param   {string}     dataField              If specified, a locally scoped field with the name supplied by in dataField will be used to fill the popup results.
             Valid types are SkeletonDataAsset and SkeletonRenderer (and derivatives).
             If left empty and the script the attribute is applied to is derived from Component, GetComponent(SkeletonRenderer)() will be called as a fallback.
             * @param   {boolean}    includeNone            If true, the dropdown list will include a "none" option which stored as an empty string.
             * @param   {boolean}    fallbackToTextField    If true, and an animation list source can't be found, the field will fall back to a normal text field. If false, it will show an error.
             * @return  {void}
             */
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineIkConstraint#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineIkConstraint end.*/

    /*Spine.Unity.SpinePathConstraint start.*/
    Bridge.define("Spine.Unity.SpinePathConstraint", {
        inherits: [Spine.Unity.SpineAttributeBase],
        ctors: {
            /**
             * Smart popup menu for Spine Events (Spine.PathConstraint)
             *
             * @instance
             * @public
             * @this Spine.Unity.SpinePathConstraint
             * @memberof Spine.Unity.SpinePathConstraint
             * @param   {string}     startsWith             Filters popup results to elements that begin with supplied string.
             * @param   {string}     dataField              If specified, a locally scoped field with the name supplied by in dataField will be used to fill the popup results.
             Valid types are SkeletonDataAsset and SkeletonRenderer (and derivatives).
             If left empty and the script the attribute is applied to is derived from Component, GetComponent(SkeletonRenderer)() will be called as a fallback.
             * @param   {boolean}    includeNone            If true, the dropdown list will include a "none" option which stored as an empty string.
             * @param   {boolean}    fallbackToTextField
             * @return  {void}
             */
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpinePathConstraint#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpinePathConstraint end.*/

    /*Spine.Unity.SpineSkin start.*/
    Bridge.define("Spine.Unity.SpineSkin", {
        inherits: [Spine.Unity.SpineAttributeBase],
        fields: {
            
            defaultAsEmptyString: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSkin#init", this ); }

                this.defaultAsEmptyString = false;
            },
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField, defaultAsEmptyString) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSkin#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }
                if (defaultAsEmptyString === void 0) { defaultAsEmptyString = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
                this.defaultAsEmptyString = defaultAsEmptyString;
            }
        }
    });
    /*Spine.Unity.SpineSkin end.*/

    /*Spine.Unity.SpineSlot start.*/
    Bridge.define("Spine.Unity.SpineSlot", {
        inherits: [Spine.Unity.SpineAttributeBase],
        fields: {
            containsBoundingBoxes: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSlot#init", this ); }

                this.containsBoundingBoxes = false;
            },
            
            ctor: function (startsWith, dataField, containsBoundingBoxes, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSlot#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (containsBoundingBoxes === void 0) { containsBoundingBoxes = false; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.containsBoundingBoxes = containsBoundingBoxes;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineSlot end.*/

    /*Spine.Unity.SpineSpriteAtlasAsset start.*/
    /**
     * Loads and stores a Spine atlas and list of materials.
     *
     * @public
     * @class Spine.Unity.SpineSpriteAtlasAsset
     * @augments Spine.Unity.AtlasAssetBase
     */
    Bridge.define("Spine.Unity.SpineSpriteAtlasAsset", {
        inherits: [Spine.Unity.AtlasAssetBase],
        statics: {
            methods: {
                /*Spine.Unity.SpineSpriteAtlasAsset.CreateRuntimeInstance:static start.*/
                /**
                 * Creates a runtime AtlasAsset
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SpineSpriteAtlasAsset
                 * @memberof Spine.Unity.SpineSpriteAtlasAsset
                 * @param   {UnityEngine.U2D.SpriteAtlas}          spriteAtlasFile    
                 * @param   {Array.<UnityEngine.Material>}         materials          
                 * @param   {boolean}                              initialize
                 * @return  {Spine.Unity.SpineSpriteAtlasAsset}
                 */
                CreateRuntimeInstance: function (spriteAtlasFile, materials, initialize) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#CreateRuntimeInstance", this ); }

                    var atlasAsset = UnityEngine.ScriptableObject.CreateInstance(Spine.Unity.SpineSpriteAtlasAsset);
                    atlasAsset.Reset();
                    atlasAsset.spriteAtlasFile = spriteAtlasFile;
                    atlasAsset.materials = materials;

                    if (initialize) {
                        atlasAsset.GetAtlas();
                    }

                    return atlasAsset;
                },
                /*Spine.Unity.SpineSpriteAtlasAsset.CreateRuntimeInstance:static end.*/

                /*Spine.Unity.SpineSpriteAtlasAsset.AccessPackedTexture:static start.*/
                AccessPackedTexture: function (sprites) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#AccessPackedTexture", this ); }

                    return sprites[0].texture;
                },
                /*Spine.Unity.SpineSpriteAtlasAsset.AccessPackedTexture:static end.*/

                /*Spine.Unity.SpineSpriteAtlasAsset.AccessPackedSprites:static start.*/
                AccessPackedSprites: function (spriteAtlas) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#AccessPackedSprites", this ); }

                    var sprites = null;
                    if (sprites == null) {
                        sprites = System.Array.init(spriteAtlas.spriteCount, null, UnityEngine.Sprite);
                        spriteAtlas.GetSprites(sprites);
                        if (sprites.length === 0) {
                            return null;
                        }
                    }
                    return sprites;
                },
                /*Spine.Unity.SpineSpriteAtlasAsset.AccessPackedSprites:static end.*/


            }
        },
        fields: {
            spriteAtlasFile: null,
            materials: null,
            atlas: null,
            updateRegionsInPlayMode: false,
            savedRegions: null
        },
        props: {
            IsLoaded: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#IsLoaded#get", this ); }

                    return this.atlas != null;
                }
            },
            Materials: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#Materials#get", this ); }

                    return this.materials;
                }
            },
            MaterialCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#MaterialCount#get", this ); }

                    return this.materials == null ? 0 : this.materials.length;
                }
            },
            PrimaryMaterial: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#PrimaryMaterial#get", this ); }

                    return this.materials[0];
                }
            }
        },
        methods: {
            /*Spine.Unity.SpineSpriteAtlasAsset.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#Reset", this ); }

                this.Clear();
            },
            /*Spine.Unity.SpineSpriteAtlasAsset.Reset end.*/

            /*Spine.Unity.SpineSpriteAtlasAsset.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#Clear", this ); }

                this.atlas = null;
            },
            /*Spine.Unity.SpineSpriteAtlasAsset.Clear end.*/

            /*Spine.Unity.SpineSpriteAtlasAsset.GetAtlas start.*/
            /**
             * @instance
             * @public
             * @override
             * @this Spine.Unity.SpineSpriteAtlasAsset
             * @memberof Spine.Unity.SpineSpriteAtlasAsset
             * @param   {boolean}        onlyMetaData
             * @return  {Spine.Atlas}                    The atlas or null if it could not be loaded.
             */
            GetAtlas: function (onlyMetaData) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#GetAtlas", this ); }

                if (onlyMetaData === void 0) { onlyMetaData = false; }
                if (this.spriteAtlasFile == null) {
                    UnityEngine.Debug.LogError$2("SpriteAtlas file not set for SpineSpriteAtlasAsset: " + (this.name || ""), this);
                    this.Clear();
                    return null;
                }

                if (!onlyMetaData && (this.materials == null || this.materials.length === 0)) {
                    UnityEngine.Debug.LogError$2("Materials not set for SpineSpriteAtlasAsset: " + (this.name || ""), this);
                    this.Clear();
                    return null;
                }

                if (this.atlas != null) {
                    return this.atlas;
                }

                try {
                    this.atlas = this.LoadAtlas(this.spriteAtlasFile);
                    return this.atlas;
                } catch (ex) {
                    ex = System.Exception.create(ex);
                    UnityEngine.Debug.LogError$2("Error analyzing SpriteAtlas for SpineSpriteAtlasAsset: " + (this.name || "") + "\n" + (ex.Message || "") + "\n" + (ex.StackTrace || ""), this);
                    return null;
                }
            },
            /*Spine.Unity.SpineSpriteAtlasAsset.GetAtlas end.*/

            /*Spine.Unity.SpineSpriteAtlasAsset.AssignRegionsFromSavedRegions start.*/
            AssignRegionsFromSavedRegions: function (sprites, usedAtlas) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#AssignRegionsFromSavedRegions", this ); }

                var $t;

                if (this.savedRegions == null || this.savedRegions.length !== sprites.length) {
                    return;
                }

                var i = 0;
                $t = Bridge.getEnumerator(usedAtlas);
                try {
                    while ($t.moveNext()) {
                        var region = $t.Current;
                        var savedRegion = this.savedRegions[i];
                        var page = region.page;

                        region.degrees = savedRegion.packingRotation === UnityEngine.SpritePackingRotation.None ? 0 : 90;

                        var x = savedRegion.x;
                        var y = savedRegion.y;
                        var width = savedRegion.width;
                        var height = savedRegion.height;

                        region.u = x / page.width;
                        region.v = y / page.height;
                        if (region.degrees === 90) {
                            region.u2 = (x + height) / page.width;
                            region.v2 = (y + width) / page.height;
                        } else {
                            region.u2 = (x + width) / page.width;
                            region.v2 = (y + height) / page.height;
                        }
                        region.x = Bridge.Int.clip32(x);
                        region.y = Bridge.Int.clip32(y);
                        region.width = Math.abs(Bridge.Int.clip32(width));
                        region.height = Math.abs(Bridge.Int.clip32(height));

                        // flip upside down
                        var temp = region.v;
                        region.v = region.v2;
                        region.v2 = temp;

                        region.originalWidth = Bridge.Int.clip32(width);
                        region.originalHeight = Bridge.Int.clip32(height);

                        // note: currently sprite pivot offsets are ignored.
                        // Sprite sprite = sprites[i];
                        region.offsetX = 0; //sprite.pivot.x;
                        region.offsetY = 0; //sprite.pivot.y;

                        i = (i + 1) | 0;
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SpineSpriteAtlasAsset.AssignRegionsFromSavedRegions end.*/

            /*Spine.Unity.SpineSpriteAtlasAsset.LoadAtlas start.*/
            LoadAtlas: function (spriteAtlas) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#LoadAtlas", this ); }


                var pages = new (System.Collections.Generic.List$1(Spine.AtlasPage)).ctor();
                var regions = new (System.Collections.Generic.List$1(Spine.AtlasRegion)).ctor();

                var sprites = System.Array.init(spriteAtlas.spriteCount, null, UnityEngine.Sprite);
                spriteAtlas.GetSprites(sprites);
                if (sprites.length === 0) {
                    return new Spine.Atlas.ctor(pages, regions);
                }

                var texture = null;
                texture = Spine.Unity.SpineSpriteAtlasAsset.AccessPackedTexture(sprites);

                var material = this.materials[0];
                material.mainTexture = texture;

                var page = new Spine.AtlasPage();
                page.name = spriteAtlas.name;
                page.width = texture.width;
                page.height = texture.height;
                page.format = Spine.Format.RGBA8888;

                page.minFilter = spine.TextureFilter.Linear;
                page.magFilter = spine.TextureFilter.Linear;
                page.uWrap = spine.TextureWrap.ClampToEdge;
                page.vWrap = spine.TextureWrap.ClampToEdge;
                page.rendererObject = material;
                pages.add(page);

                sprites = Spine.Unity.SpineSpriteAtlasAsset.AccessPackedSprites(spriteAtlas);

                var i = 0;
                for (; i < sprites.length; i = (i + 1) | 0) {
                    var sprite = sprites[i];
                    var region = new Spine.AtlasRegion();
                    region.name = System.String.replaceAll(sprite.name, "(Clone)", "");
                    region.page = page;
                    region.degrees = sprite.packingRotation === UnityEngine.SpritePackingRotation.None ? 0 : 90;

                    region.u2 = 1;
                    region.v2 = 1;
                    region.width = page.width;
                    region.height = page.height;
                    region.originalWidth = page.width;
                    region.originalHeight = page.height;

                    region.index = i;
                    regions.add(region);
                }

                var atlas = new Spine.Atlas.ctor(pages, regions);
                this.AssignRegionsFromSavedRegions(sprites, atlas);

                return atlas;
            },
            /*Spine.Unity.SpineSpriteAtlasAsset.LoadAtlas end.*/


        }
    });
    /*Spine.Unity.SpineSpriteAtlasAsset end.*/

    /*Spine.Unity.SpineTransformConstraint start.*/
    Bridge.define("Spine.Unity.SpineTransformConstraint", {
        inherits: [Spine.Unity.SpineAttributeBase],
        ctors: {
            
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineTransformConstraint#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineTransformConstraint end.*/

    /*Spine.Unity.WaitForSpineAnimationComplete start.*/
    /**
     * Use this as a condition-blocking yield instruction for Unity Coroutines.
     The routine will pause until the AnimationState.TrackEntry fires its Complete event.
     It can be configured to trigger on the End event as well to cover interruption.
     <p />
     See the {@link }
     and {@link }
     for more information on when track events will be triggered.
     *
     * @public
     * @class Spine.Unity.WaitForSpineAnimationComplete
     * @augments Spine.Unity.WaitForSpineAnimation
     * @implements  System.Collections.IEnumerator
     */
    Bridge.define("Spine.Unity.WaitForSpineAnimationComplete", {
        inherits: [Spine.Unity.WaitForSpineAnimation,System.Collections.IEnumerator],
        ctors: {
            ctor: function (trackEntry, includeEndEvent) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimationComplete#ctor", this ); }

                if (includeEndEvent === void 0) { includeEndEvent = false; }

                this.$initialize();
                Spine.Unity.WaitForSpineAnimation.ctor.call(this, trackEntry, includeEndEvent ? (20) : Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Complete);
            }
        },
        methods: {
            /*Spine.Unity.WaitForSpineAnimationComplete.NowWaitFor$1 start.*/
            /**
             * One optimization high-frequency YieldInstruction returns is to cache instances to minimize GC pressure.
             Use NowWaitFor to reuse the same instance of WaitForSpineAnimationComplete.
             *
             * @instance
             * @public
             * @this Spine.Unity.WaitForSpineAnimationComplete
             * @memberof Spine.Unity.WaitForSpineAnimationComplete
             * @param   {Spine.TrackEntry}                             trackEntry         
             * @param   {boolean}                                      includeEndEvent
             * @return  {Spine.Unity.WaitForSpineAnimationComplete}
             */
            NowWaitFor$1: function (trackEntry, includeEndEvent) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimationComplete#NowWaitFor$1", this ); }

                if (includeEndEvent === void 0) { includeEndEvent = false; }
                this.SafeSubscribe(trackEntry, includeEndEvent ? (20) : Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Complete);
                return this;
            },
            /*Spine.Unity.WaitForSpineAnimationComplete.NowWaitFor$1 end.*/


        },
        overloads: {
            "NowWaitFor(Spine.TrackEntry, bool)": "NowWaitFor$1"
        }
    });
    /*Spine.Unity.WaitForSpineAnimationComplete end.*/

    /*Spine.Unity.WaitForSpineAnimationEnd start.*/
    /**
     * Use this as a condition-blocking yield instruction for Unity Coroutines.
     The routine will pause until the AnimationState.TrackEntry fires its End event.
     <p />
     See the {@link }
     and {@link }
     for more information on when track events will be triggered.
     *
     * @public
     * @class Spine.Unity.WaitForSpineAnimationEnd
     * @augments Spine.Unity.WaitForSpineAnimation
     * @implements  System.Collections.IEnumerator
     */
    Bridge.define("Spine.Unity.WaitForSpineAnimationEnd", {
        inherits: [Spine.Unity.WaitForSpineAnimation,System.Collections.IEnumerator],
        ctors: {
            ctor: function (trackEntry) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimationEnd#ctor", this ); }

                this.$initialize();
                Spine.Unity.WaitForSpineAnimation.ctor.call(this, trackEntry, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.End);
            }
        },
        methods: {
            /*Spine.Unity.WaitForSpineAnimationEnd.NowWaitFor$1 start.*/
            /**
             * One optimization high-frequency YieldInstruction returns is to cache instances to minimize GC pressure.
             Use NowWaitFor to reuse the same instance of WaitForSpineAnimationComplete.
             *
             * @instance
             * @public
             * @this Spine.Unity.WaitForSpineAnimationEnd
             * @memberof Spine.Unity.WaitForSpineAnimationEnd
             * @param   {Spine.TrackEntry}                        trackEntry
             * @return  {Spine.Unity.WaitForSpineAnimationEnd}
             */
            NowWaitFor$1: function (trackEntry) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimationEnd#NowWaitFor$1", this ); }

                this.SafeSubscribe(trackEntry, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.End);
                return this;
            },
            /*Spine.Unity.WaitForSpineAnimationEnd.NowWaitFor$1 end.*/


        },
        overloads: {
            "NowWaitFor(Spine.TrackEntry)": "NowWaitFor$1"
        }
    });
    /*Spine.Unity.WaitForSpineAnimationEnd end.*/

    /*Spine.Unity.AnimationReferenceAsset start.*/
    Bridge.define("Spine.Unity.AnimationReferenceAsset", {
        inherits: [UnityEngine.ScriptableObject,Spine.Unity.IHasSkeletonDataAsset],
        statics: {
            fields: {
                QuietSkeletonData: false
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#init", this ); }

                    this.QuietSkeletonData = true;
                }
            },
            methods: {
                op_Implicit: function (asset) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#op_Implicit", this ); }

                    return asset.Animation;
                }
            }
        },
        fields: {
            skeletonDataAsset: null,
            animationName: null,
            animation: null
        },
        props: {
            SkeletonDataAsset: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#SkeletonDataAsset#get", this ); }

                    return this.skeletonDataAsset;
                }
            },
            Animation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#Animation#get", this ); }

                    if (this.animation == null) {
                        this.Initialize();
                    }
                    return this.animation;
                }
            }
        },
        alias: ["SkeletonDataAsset", "Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset"],
        methods: {
            /*Spine.Unity.AnimationReferenceAsset.Clear start.*/
            /**
             * Clears the cached animation corresponding to a loaded SkeletonData object.
             Use this to force a reload for the next time Animation is called.
             *
             * @instance
             * @public
             * @this Spine.Unity.AnimationReferenceAsset
             * @memberof Spine.Unity.AnimationReferenceAsset
             * @return  {void}
             */
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#Clear", this ); }

                this.animation = null;
            },
            /*Spine.Unity.AnimationReferenceAsset.Clear end.*/

            /*Spine.Unity.AnimationReferenceAsset.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#Initialize", this ); }

                if (this.skeletonDataAsset == null) {
                    return;
                }
                var skeletonData = this.skeletonDataAsset.GetSkeletonData(Spine.Unity.AnimationReferenceAsset.QuietSkeletonData);
                this.animation = skeletonData != null ? skeletonData.findAnimation(this.animationName) : null;
                if (this.animation == null) {
                    UnityEngine.Debug.LogWarningFormat("Animation '{0}' not found in SkeletonData : {1}.", [this.animationName, this.skeletonDataAsset.name]);
                }
            },
            /*Spine.Unity.AnimationReferenceAsset.Initialize end.*/


        }
    });
    /*Spine.Unity.AnimationReferenceAsset end.*/

    /*Spine.Unity.Examples.EquipSystemExample start.*/
    Bridge.define("Spine.Unity.Examples.EquipSystemExample", {
        inherits: [UnityEngine.MonoBehaviour,Spine.Unity.IHasSkeletonDataAsset],
        fields: {
            skeletonDataAsset: null,
            sourceMaterial: null,
            applyPMA: false,
            equippables: null,
            target: null,
            cachedAttachments: null
        },
        props: {
            Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.EquipSystemExample#Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset#get", this ); }

                    return this.skeletonDataAsset;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.EquipSystemExample#init", this ); }

                this.applyPMA = true;
                this.equippables = new (System.Collections.Generic.List$1(Spine.Unity.Examples.EquipSystemExample.EquipHook)).ctor();
                this.cachedAttachments = new (System.Collections.Generic.Dictionary$2(Spine.Unity.Examples.EquipAssetExample,spine.Attachment)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.Examples.EquipSystemExample.Equip start.*/
            Equip: function (asset) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.EquipSystemExample#Equip", this ); }

                var equipType = asset.equipType;
                var howToEquip = this.equippables.Find(function (x) {
                    return x.type === equipType;
                });

                var skeletonData = this.skeletonDataAsset.GetSkeletonData(true);
                var slotIndex = skeletonData.findSlot(howToEquip.slot).index;
                var attachment = this.GenerateAttachmentFromEquipAsset(asset, slotIndex, howToEquip.templateSkin, howToEquip.templateAttachment);
                this.target.Equip(slotIndex, howToEquip.templateAttachment, attachment);
            },
            /*Spine.Unity.Examples.EquipSystemExample.Equip end.*/

            /*Spine.Unity.Examples.EquipSystemExample.GenerateAttachmentFromEquipAsset start.*/
            GenerateAttachmentFromEquipAsset: function (asset, slotIndex, templateSkinName, templateAttachmentName) {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.EquipSystemExample#GenerateAttachmentFromEquipAsset", this ); }

                var attachment = { };
                this.cachedAttachments.tryGetValue(asset, attachment);

                if (attachment.v == null) {
                    var skeletonData = this.skeletonDataAsset.GetSkeletonData(true);
                    var templateSkin = skeletonData.findSkin(templateSkinName);
                    var templateAttachment = templateSkin.getAttachment(slotIndex, templateAttachmentName);
                    attachment.v = Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone$1(templateAttachment, asset.sprite, this.sourceMaterial, this.applyPMA, true, false, true, false, 4, false);
                    // Note: Each call to `GetRemappedClone()` with parameter `premultiplyAlpha` set to `true` creates
                    // a cached Texture copy which can be cleared by calling AtlasUtilities.ClearCache() as shown in the method below.

                    this.cachedAttachments.add(asset, attachment.v); // Cache this value for next time this asset is used.
                }

                return attachment.v;
            },
            /*Spine.Unity.Examples.EquipSystemExample.GenerateAttachmentFromEquipAsset end.*/

            /*Spine.Unity.Examples.EquipSystemExample.Done start.*/
            Done: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.EquipSystemExample#Done", this ); }

                this.target.OptimizeSkin();
                // `GetRepackedSkin()` and each call to `GetRemappedClone()` with parameter `premultiplyAlpha` set to `true`
                // creates cached Texture copies which can be cleared by calling AtlasUtilities.ClearCache().
                // You can optionally clear the textures cache after multiple repack operations.
                // Just be aware that while this cleanup frees up memory, it is also a costly operation
                // and will likely cause a spike in the framerate.

                //AtlasUtilities.ClearCache();
                //Resources.UnloadUnusedAssets();
            },
            /*Spine.Unity.Examples.EquipSystemExample.Done end.*/


        }
    });
    /*Spine.Unity.Examples.EquipSystemExample end.*/

    /*Spine.Unity.Examples.SpineAnimationTesterTool start.*/
    Bridge.define("Spine.Unity.Examples.SpineAnimationTesterTool", {
        inherits: [UnityEngine.MonoBehaviour,Spine.Unity.IHasSkeletonDataAsset,Spine.Unity.IHasSkeletonComponent],
        fields: {
            skeletonAnimation: null,
            useOverrideMixDuration: false,
            overrideMixDuration: 0,
            useOverrideAttachmentThreshold: false,
            attachmentThreshold: 0,
            useOverrideDrawOrderThreshold: false,
            drawOrderThreshold: 0,
            trackControls: null,
            boundAnimationsText: null,
            skeletonNameText: null
        },
        props: {
            SkeletonDataAsset: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineAnimationTesterTool#SkeletonDataAsset#get", this ); }

                    return this.skeletonAnimation.SkeletonDataAsset;
                }
            },
            SkeletonComponent: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineAnimationTesterTool#SkeletonComponent#get", this ); }

                    return this.skeletonAnimation;
                }
            }
        },
        alias: [
            "SkeletonDataAsset", "Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset",
            "SkeletonComponent", "Spine$Unity$IHasSkeletonComponent$SkeletonComponent"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineAnimationTesterTool#init", this ); }

                this.overrideMixDuration = 0.2;
                this.useOverrideAttachmentThreshold = true;
                this.attachmentThreshold = 0.5;
                this.drawOrderThreshold = 0.5;
                this.trackControls = new (System.Collections.Generic.List$1(Spine.Unity.Examples.SpineAnimationTesterTool.ControlledTrack)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.Examples.SpineAnimationTesterTool.OnValidate start.*/
            OnValidate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineAnimationTesterTool#OnValidate", this ); }

                var $t;
                // Fill in the SkeletonData asset name
                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonNameText, null)) {
                    if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonAnimation, null) && this.skeletonAnimation.skeletonDataAsset != null) {
                        this.skeletonNameText.text = System.String.replaceAll(this.SkeletonDataAsset.name, "_SkeletonData", "");
                    }
                }

                // Fill in the control list.
                if (UnityEngine.MonoBehaviour.op_Inequality(this.boundAnimationsText, null)) {
                    var boundAnimationsStringBuilder = new System.Text.StringBuilder();
                    boundAnimationsStringBuilder.appendLine("Animation Controls:");

                    for (var trackIndex = 0; trackIndex < this.trackControls.Count; trackIndex = (trackIndex + 1) | 0) {

                        if (trackIndex > 0) {
                            boundAnimationsStringBuilder.appendLine();
                        }

                        boundAnimationsStringBuilder.appendFormat("---- Track {0} ---- \n", Bridge.box(trackIndex, System.Int32));
                        $t = Bridge.getEnumerator(this.trackControls.getItem(trackIndex).controls);
                        try {
                            while ($t.moveNext()) {
                                var ba = $t.Current.$clone();
                                var animationName = ba.animationName;
                                if (System.String.isNullOrEmpty(animationName)) {
                                    animationName = "SetEmptyAnimation";
                                }

                                boundAnimationsStringBuilder.appendFormat("[{0}]  {1}\n", System.Enum.toString(UnityEngine.KeyCode, ba.key), animationName);
                            }
                        } finally {
                            if (Bridge.is($t, System.IDisposable)) {
                                $t.System$IDisposable$Dispose();
                            }
                        }

                    }

                    this.boundAnimationsText.text = boundAnimationsStringBuilder.toString();

                }

            },
            /*Spine.Unity.Examples.SpineAnimationTesterTool.OnValidate end.*/

            /*Spine.Unity.Examples.SpineAnimationTesterTool.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineAnimationTesterTool#Start", this ); }

                if (this.useOverrideMixDuration) {
                    this.skeletonAnimation.AnimationState.data.defaultMix = this.overrideMixDuration;
                }
            },
            /*Spine.Unity.Examples.SpineAnimationTesterTool.Start end.*/

            /*Spine.Unity.Examples.SpineAnimationTesterTool.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.Examples.SpineAnimationTesterTool#Update", this ); }

                var $t;
                var animationState = this.skeletonAnimation.AnimationState;

                // For each track
                for (var trackIndex = 0; trackIndex < this.trackControls.Count; trackIndex = (trackIndex + 1) | 0) {

                    // For each control in the track
                    $t = Bridge.getEnumerator(this.trackControls.getItem(trackIndex).controls);
                    try {
                        while ($t.moveNext()) {
                            var control = $t.Current.$clone();

                            // Check each control, and play the appropriate animation.
                            if (UnityEngine.Input.GetKeyDown(control.key)) {
                                var trackEntry;
                                if (!System.String.isNullOrEmpty(control.animationName)) {
                                    trackEntry = animationState.setAnimation(trackIndex, control.animationName, control.loop);

                                } else {
                                    var mix = control.useCustomMixDuration ? control.mixDuration : animationState.data.defaultMix;
                                    trackEntry = animationState.setEmptyAnimation(trackIndex, mix);
                                }

                                if (trackEntry != null) {
                                    if (control.useCustomMixDuration) {
                                        trackEntry.mixDuration = control.mixDuration;
                                    }

                                    if (this.useOverrideAttachmentThreshold) {
                                        trackEntry.attachmentThreshold = this.attachmentThreshold;
                                    }

                                    if (this.useOverrideDrawOrderThreshold) {
                                        trackEntry.drawOrderThreshold = this.drawOrderThreshold;
                                    }
                                }

                                // Don't parse more than one animation per track.
                                break;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }

            },
            /*Spine.Unity.Examples.SpineAnimationTesterTool.Update end.*/


        }
    });
    /*Spine.Unity.Examples.SpineAnimationTesterTool end.*/

    /*Spine.Unity.PointFollower start.*/
    Bridge.define("Spine.Unity.PointFollower", {
        inherits: [UnityEngine.MonoBehaviour,Spine.Unity.IHasSkeletonRenderer,Spine.Unity.IHasSkeletonComponent],
        fields: {
            skeletonRenderer: null,
            slotName: null,
            pointAttachmentName: null,
            followRotation: false,
            followSkeletonFlip: false,
            followSkeletonZPosition: false,
            skeletonTransform: null,
            skeletonTransformIsParent: false,
            point: null,
            bone: null,
            valid: false
        },
        props: {
            SkeletonRenderer: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#SkeletonRenderer#get", this ); }

                    return this.skeletonRenderer;
                }
            },
            SkeletonComponent: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#SkeletonComponent#get", this ); }

                    return Bridge.as(this.skeletonRenderer, Spine.Unity.ISkeletonComponent);
                }
            },
            IsValid: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#IsValid#get", this ); }

                    return this.valid;
                }
            }
        },
        alias: [
            "SkeletonRenderer", "Spine$Unity$IHasSkeletonRenderer$SkeletonRenderer",
            "SkeletonComponent", "Spine$Unity$IHasSkeletonComponent$SkeletonComponent"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#init", this ); }

                this.followRotation = true;
                this.followSkeletonFlip = true;
                this.followSkeletonZPosition = false;
            }
        },
        methods: {
            /*Spine.Unity.PointFollower.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#Initialize", this ); }

                this.valid = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) && this.skeletonRenderer.valid;
                if (!this.valid) {
                    return;
                }

                this.UpdateReferences();

            },
            /*Spine.Unity.PointFollower.Initialize end.*/

            /*Spine.Unity.PointFollower.HandleRebuildRenderer start.*/
            HandleRebuildRenderer: function (skeletonRenderer) {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#HandleRebuildRenderer", this ); }

                this.Initialize();
            },
            /*Spine.Unity.PointFollower.HandleRebuildRenderer end.*/

            /*Spine.Unity.PointFollower.UpdateReferences start.*/
            UpdateReferences: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#UpdateReferences", this ); }

                this.skeletonTransform = this.skeletonRenderer.transform;
                this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                this.skeletonRenderer.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                this.skeletonTransformIsParent = Bridge.referenceEquals(this.skeletonTransform, this.transform.parent);

                this.bone = null;
                this.point = null;
                if (!System.String.isNullOrEmpty(this.pointAttachmentName)) {
                    var skeleton = this.skeletonRenderer.Skeleton;

                    var slot = skeleton.findSlot(this.slotName);
                    if (slot != null) {
                        var slotIndex = slot.data.index;
                        this.bone = slot.bone;
                        this.point = Bridge.as(skeleton.getAttachment(slotIndex, this.pointAttachmentName), Spine.PointAttachment);
                    }
                }
            },
            /*Spine.Unity.PointFollower.UpdateReferences end.*/

            /*Spine.Unity.PointFollower.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#OnDestroy", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                }
            },
            /*Spine.Unity.PointFollower.OnDestroy end.*/

            /*Spine.Unity.PointFollower.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#LateUpdate", this ); }

                var $t;

                if (this.point == null) {
                    if (System.String.isNullOrEmpty(this.pointAttachmentName)) {
                        return;
                    }
                    this.UpdateReferences();
                    if (this.point == null) {
                        return;
                    }
                }

                var worldPos = new UnityEngine.Vector2();
                this.point.ComputeWorldPosition(this.bone, Bridge.ref(worldPos, "x"), Bridge.ref(worldPos, "y"));
                var rotation = this.point.computeWorldRotation(this.bone);

                var thisTransform = this.transform;
                if (this.skeletonTransformIsParent) {
                    // Recommended setup: Use local transform properties if Spine GameObject is the immediate parent
                    thisTransform.localPosition = new pc.Vec3( worldPos.x, worldPos.y, this.followSkeletonZPosition ? 0.0 : thisTransform.localPosition.z );
                    if (this.followRotation) {
                        var halfRotation = rotation * 0.5 * UnityEngine.Mathf.Deg2Rad;

                        var q = Bridge.getDefaultValue(UnityEngine.Quaternion);
                        q.z = Math.sin(halfRotation);
                        q.w = Math.cos(halfRotation);
                        thisTransform.localRotation = q.$clone();
                    }
                } else {
                    // For special cases: Use transform world properties if transform relationship is complicated
                    var targetWorldPosition = this.skeletonTransform.TransformPoint$1(new pc.Vec3( worldPos.x, worldPos.y, 0.0 ));
                    if (!this.followSkeletonZPosition) {
                        targetWorldPosition.z = thisTransform.position.z;
                    }

                    var transformParent = thisTransform.parent;
                    if (UnityEngine.Component.op_Inequality(transformParent, null)) {
                        var m = transformParent.localToWorldMatrix.$clone();
                        if (m.e00 * m.e11 - m.e01 * m.e10 < 0) {
                            rotation = -rotation;
                        }
                    }

                    if (this.followRotation) {
                        var transformWorldRotation = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                        thisTransform.SetPositionAndRotation(targetWorldPosition, new pc.Quat().setFromEulerAngles_Unity( transformWorldRotation.x, transformWorldRotation.y, transformWorldRotation.z + rotation ));
                    } else {
                        thisTransform.position = targetWorldPosition.$clone();
                    }
                }

                if (this.followSkeletonFlip) {
                    var localScale = thisTransform.localScale.$clone();
                    localScale.y = Math.abs(localScale.y) * ($t = this.bone.skeleton.scaleX * this.bone.skeleton.scaleY, ($t === 0 ? 1 : Math.sign($t)));
                    thisTransform.localScale = localScale.$clone();
                }
            },
            /*Spine.Unity.PointFollower.LateUpdate end.*/


        }
    });
    /*Spine.Unity.PointFollower end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonRenderer.InstructionDelegate
     * @param   {Spine.Unity.SkeletonRendererInstruction}    instruction
     * @return  {void}
     */

    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.MeshGeneratorDelegate
     * @param   {Spine.Unity.MeshGeneratorBuffers}    buffers
     * @return  {void}
     */


    /*Spine.Unity.SkeletonRenderer start.*/
    /**
     * Base class of animated Spine skeleton components. This component manages and renders a skeleton.
     *
     * @public
     * @class Spine.Unity.SkeletonRenderer
     * @augments UnityEngine.MonoBehaviour
     * @implements  Spine.Unity.ISkeletonComponent
     * @implements  Spine.Unity.IHasSkeletonDataAsset
     */
    Bridge.define("Spine.Unity.SkeletonRenderer", {
        inherits: [UnityEngine.MonoBehaviour,Spine.Unity.ISkeletonComponent,Spine.Unity.IHasSkeletonDataAsset],
        statics: {
            fields: {
                /**
                 * Shader property value used as Stencil comparison function for {@link }.
                 *
                 * @static
                 * @public
                 * @memberof Spine.Unity.SkeletonRenderer
                 * @constant
                 * @default 8
                 * @type UnityEngine.Rendering.CompareFunction
                 */
                STENCIL_COMP_MASKINTERACTION_NONE: 0,
                /**
                 * Shader property value used as Stencil comparison function for {@link }.
                 *
                 * @static
                 * @public
                 * @memberof Spine.Unity.SkeletonRenderer
                 * @constant
                 * @default 4
                 * @type UnityEngine.Rendering.CompareFunction
                 */
                STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE: 0,
                /**
                 * Shader property value used as Stencil comparison function for {@link }.
                 *
                 * @static
                 * @public
                 * @memberof Spine.Unity.SkeletonRenderer
                 * @constant
                 * @default 5
                 * @type UnityEngine.Rendering.CompareFunction
                 */
                STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE: 0,
                /**
                 * Shader property ID used for the Stencil comparison function.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof Spine.Unity.SkeletonRenderer
                 * @type number
                 */
                STENCIL_COMP_PARAM_ID: 0,
                SUBMESH_DUMMY_PARAM_ID: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#init", this ); }

                    this.STENCIL_COMP_MASKINTERACTION_NONE = UnityEngine.Rendering.CompareFunction.Always;
                    this.STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE = UnityEngine.Rendering.CompareFunction.LessEqual;
                    this.STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE = UnityEngine.Rendering.CompareFunction.Greater;
                    this.STENCIL_COMP_PARAM_ID = UnityEngine.Shader.PropertyToID("_StencilComp");
                    this.SUBMESH_DUMMY_PARAM_ID = UnityEngine.Shader.PropertyToID("_Submesh");
                }
            },
            methods: {
                /*Spine.Unity.SkeletonRenderer.NewSpineGameObject:static start.*/
                NewSpineGameObject: function (T, skeletonDataAsset, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#NewSpineGameObject", this ); }

                    if (quiet === void 0) { quiet = false; }
                    return Spine.Unity.SkeletonRenderer.AddSpineComponent(T, new UnityEngine.GameObject.$ctor2("New Spine GameObject"), skeletonDataAsset, quiet);
                },
                /*Spine.Unity.SkeletonRenderer.NewSpineGameObject:static end.*/

                /*Spine.Unity.SkeletonRenderer.AddSpineComponent:static start.*/
                /**
                 * Add and prepare a Spine component that derives from SkeletonRenderer to a GameObject at runtime.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonRenderer
                 * @memberof Spine.Unity.SkeletonRenderer
                 * @param   {Function}                         T                    T should be SkeletonRenderer or any of its derived classes.
                 * @param   {UnityEngine.GameObject}           gameObject           
                 * @param   {Spine.Unity.SkeletonDataAsset}    skeletonDataAsset    
                 * @param   {boolean}                          quiet
                 * @return  {T}
                 */
                AddSpineComponent: function (T, gameObject, skeletonDataAsset, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#AddSpineComponent", this ); }

                    if (quiet === void 0) { quiet = false; }
                    var c = Bridge.rValue(gameObject.AddComponent(T));
                    if (skeletonDataAsset != null) {
Bridge.rValue(                        c).skeletonDataAsset = skeletonDataAsset;
Bridge.rValue(                        c).Initialize(false, quiet);
                    }
                    return Bridge.rValue(c);
                },
                /*Spine.Unity.SkeletonRenderer.AddSpineComponent:static end.*/


            }
        },
        fields: {
            skeletonDataAsset: null,
            /**
             * Skin name to use when the Skeleton is initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type string
             */
            initialSkinName: null,
            /**
             * Enable this parameter when overwriting the Skeleton's skin from an editor script.
             Otherwise any changes will be overwritten by the next inspector update.
             * Flip X and Y to use when the Skeleton is initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type boolean
             */
            initialFlipX: false,
            /**
             * Enable this parameter when overwriting the Skeleton's skin from an editor script.
             Otherwise any changes will be overwritten by the next inspector update.
             * Flip X and Y to use when the Skeleton is initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type boolean
             */
            initialFlipY: false,
            updateMode: 0,
            /**
             * Update mode used when the MeshRenderer becomes invisible
             (when <pre><code>OnBecameInvisible()</code></pre> is called). Update mode is automatically
             reset to <pre><code>UpdateMode.FullUpdate</code></pre> when the mesh becomes visible again.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type Spine.Unity.UpdateMode
             */
            updateWhenInvisible: 0,
            /**
             * Slot names used to populate separatorSlots list when the Skeleton is initialized. Changing this after initialization does nothing.
             *
             * @instance
             * @protected
             * @memberof Spine.Unity.SkeletonRenderer
             * @type Array.<string>
             */
            separatorSlotNames: null,
            /**
             * Slots that determine where the render is split. This is used by components such as SkeletonRenderSeparator so that the skeleton can be rendered by two separate renderers on different GameObjects.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonRenderer
             * @type System.Collections.Generic.List$1
             */
            separatorSlots: null,
            zSpacing: 0,
            /**
             * Use Spine's clipping feature. If false, ClippingAttachments will be ignored.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default true
             * @type boolean
             */
            useClipping: false,
            /**
             * If true, triangles will not be updated. Enable this as an optimization if the skeleton does not make use of attachment swapping or hiding, or draw order keys. Otherwise, setting this to false may cause errors in rendering.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            immutableTriangles: false,
            /**
             * Multiply vertex color RGB with vertex color alpha. Set this to true if the shader used for rendering is a premultiplied alpha shader. Setting this to false disables single-batch additive slots.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default true
             * @type boolean
             */
            pmaVertexColors: false,
            /**
             * Clears the state of the render and skeleton when this component or its GameObject is disabled. This prevents previous state from being retained when it is enabled again. When pooling your skeleton, setting this to true can be helpful.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            clearStateOnDisable: false,
            /**
             * If true, second colors on slots will be added to the output Mesh as UV2 and UV3. A special "tint black" shader that interprets UV2 and UV3 as black point colors is required to render this properly.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            tintBlack: false,
            /**
             * If true, the renderer assumes the skeleton only requires one Material and one submesh to render. This allows the MeshGenerator to skip checking for changes in Materials. Enable this as an optimization if the skeleton only uses one Material.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            singleSubmesh: false,
            /**
             * Applies only when 3+ submeshes are used (2+ materials with alternating order, e.g. "A B A").
             If true, GPU instancing is disabled at all materials and MaterialPropertyBlocks are assigned at each
             material to prevent aggressive batching of submeshes by e.g. the LWRP renderer, leading to incorrect
             draw order (e.g. "A1 B A2" changed to "A1A2 B").
             You can disable this parameter when everything is drawn correctly to save the additional performance cost.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            fixDrawOrder: false,
            /**
             * If true, the mesh generator adds normals to the output mesh. For better performance and reduced memory requirements, use a shader that assumes the desired normal.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            addNormals: false,
            /**
             * If true, tangents are calculated every frame and added to the Mesh. Enable this when using a shader that uses lighting that requires tangents.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            calculateTangents: false,
            /**
             * This enum controls the mode under which the sprite will interact with the masking system.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type UnityEngine.SpriteMaskInteraction
             */
            maskInteraction: 0,
            /**
             * Material references for switching material sets at runtime when {@link } changes.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials
             */
            maskMaterials: null,
            disableRenderingOnOverride: false,
            customMaterialOverride: null,
            customSlotMaterials: null,
            currentInstructions: null,
            meshGenerator: null,
            rendererBuffers: null,
            meshRenderer: null,
            meshFilter: null,
            valid: false,
            skeleton: null,
            reusedPropertyBlock: null
        },
        events: {
            generateMeshOverride: null,
            /**
             * Occurs after the vertex data is populated every frame, before the vertices are pushed into the mesh.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function addOnPostProcessVertices
             * @param   {Spine.Unity.MeshGeneratorDelegate}    value
             * @return  {void}
             */
            /**
             * Occurs after the vertex data is populated every frame, before the vertices are pushed into the mesh.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function removeOnPostProcessVertices
             * @param   {Spine.Unity.MeshGeneratorDelegate}    value
             * @return  {void}
             */
            OnPostProcessVertices: null,
            /**
             * OnRebuild is raised after the Skeleton is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function addOnRebuild
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnRebuild is raised after the Skeleton is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function removeOnRebuild
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            OnRebuild: null,
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function addOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function removeOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            OnMeshAndMaterialsUpdated: null
        },
        props: {
            /**
             * Update mode to optionally limit updates to e.g. only apply animations but not update the mesh.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @function UpdateMode
             * @type Spine.Unity.UpdateMode
             */
            UpdateMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#UpdateMode#get", this ); }

                    return this.updateMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#UpdateMode#set", this ); }

                    this.updateMode = value;
                }
            },
            /**
             * Use this Dictionary to override a Material with a different Material.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonRenderer
             * @function CustomMaterialOverride
             * @type System.Collections.Generic.Dictionary$2
             */
            CustomMaterialOverride: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#CustomMaterialOverride#get", this ); }

                    return this.customMaterialOverride;
                }
            },
            /**
             * Use this Dictionary to use a different Material to render specific Slots.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonRenderer
             * @function CustomSlotMaterials
             * @type System.Collections.Generic.Dictionary$2
             */
            CustomSlotMaterials: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#CustomSlotMaterials#get", this ); }

                    return this.customSlotMaterials;
                }
            },
            Skeleton: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#Skeleton#get", this ); }

                    this.Initialize(false);
                    return this.skeleton;
                }
            },
            SkeletonDataAsset: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#SkeletonDataAsset#get", this ); }

                    return this.skeletonDataAsset;
                }
            }
        },
        alias: [
            "Skeleton", "Spine$Unity$ISkeletonComponent$Skeleton",
            "SkeletonDataAsset", "Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset",
            "SkeletonDataAsset", "Spine$Unity$ISkeletonComponent$SkeletonDataAsset"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#init", this ); }

                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
                this.updateWhenInvisible = Spine.Unity.UpdateMode.FullUpdate;
                this.separatorSlotNames = System.Array.init(0, null, System.String);
                this.separatorSlots = new (System.Collections.Generic.List$1(Spine.Slot)).ctor();
                this.useClipping = true;
                this.immutableTriangles = false;
                this.pmaVertexColors = true;
                this.clearStateOnDisable = false;
                this.tintBlack = false;
                this.singleSubmesh = false;
                this.fixDrawOrder = false;
                this.addNormals = false;
                this.calculateTangents = false;
                this.maskInteraction = UnityEngine.SpriteMaskInteraction.None;
                this.maskMaterials = new Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials();
                this.disableRenderingOnOverride = true;
                this.customMaterialOverride = new (System.Collections.Generic.Dictionary$2(UnityEngine.Material,UnityEngine.Material)).ctor();
                this.customSlotMaterials = new (System.Collections.Generic.Dictionary$2(Spine.Slot,UnityEngine.Material)).ctor();
                this.currentInstructions = new Spine.Unity.SkeletonRendererInstruction();
                this.meshGenerator = new Spine.Unity.MeshGenerator();
                this.rendererBuffers = new Spine.Unity.MeshRendererBuffers();
            }
        },
        methods: {
            /**
             * Allows separate code to take over rendering for this SkeletonRenderer component. The subscriber is passed a SkeletonRendererInstruction argument to determine how to render a skeleton.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @event Spine.Unity.SkeletonRenderer#GenerateMeshOverride
             * @return  {Spine.Unity.SkeletonRenderer.InstructionDelegate}
             */
            addGenerateMeshOverride: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#addGenerateMeshOverride", this ); }

                this.addgenerateMeshOverride(value);
                if (this.disableRenderingOnOverride && !Bridge.staticEquals(this.generateMeshOverride, null)) {
                    this.Initialize(false);
                    if (UnityEngine.Object.op_Implicit(this.meshRenderer)) {
                        this.meshRenderer.enabled = false;
                    }
                    this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
                }
            },
            /**
             * Allows separate code to take over rendering for this SkeletonRenderer component. The subscriber is passed a SkeletonRendererInstruction argument to determine how to render a skeleton.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @event Spine.Unity.SkeletonRenderer#GenerateMeshOverride
             * @return  {Spine.Unity.SkeletonRenderer.InstructionDelegate}
             */
            removeGenerateMeshOverride: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#removeGenerateMeshOverride", this ); }

                this.removegenerateMeshOverride(value);
                if (this.disableRenderingOnOverride && Bridge.staticEquals(this.generateMeshOverride, null)) {
                    this.Initialize(false);
                    if (UnityEngine.Object.op_Implicit(this.meshRenderer)) {
                        this.meshRenderer.enabled = true;
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderer.SetMeshSettings start.*/
            /**
             * Applies MeshGenerator settings to the SkeletonRenderer and its internal MeshGenerator.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @param   {Spine.Unity.MeshGenerator.Settings}    settings
             * @return  {void}
             */
            SetMeshSettings: function (settings) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#SetMeshSettings", this ); }

                this.calculateTangents = settings.calculateTangents;
                this.immutableTriangles = settings.immutableTriangles;
                this.pmaVertexColors = settings.pmaVertexColors;
                this.tintBlack = settings.tintBlack;
                this.useClipping = settings.useClipping;
                this.zSpacing = settings.zSpacing;

                this.meshGenerator.settings = settings.$clone();
            },
            /*Spine.Unity.SkeletonRenderer.SetMeshSettings end.*/

            /*Spine.Unity.SkeletonRenderer.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#Awake", this ); }

                this.Initialize(false);
                if (Bridge.staticEquals(this.generateMeshOverride, null) || !this.disableRenderingOnOverride) {
                    this.updateMode = this.updateWhenInvisible;
                }
            },
            /*Spine.Unity.SkeletonRenderer.Awake end.*/

            /*Spine.Unity.SkeletonRenderer.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#OnDisable", this ); }

                if (this.clearStateOnDisable && this.valid) {
                    this.ClearState();
                }
            },
            /*Spine.Unity.SkeletonRenderer.OnDisable end.*/

            /*Spine.Unity.SkeletonRenderer.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#OnDestroy", this ); }

                this.rendererBuffers.Dispose();
                this.valid = false;
            },
            /*Spine.Unity.SkeletonRenderer.OnDestroy end.*/

            /*Spine.Unity.SkeletonRenderer.ClearState start.*/
            /**
             * Clears the previously generated mesh and resets the skeleton's pose.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @return  {void}
             */
            ClearState: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#ClearState", this ); }

                var meshFilter = this.GetComponent(UnityEngine.MeshFilter);
                if (UnityEngine.Component.op_Inequality(meshFilter, null)) {
                    meshFilter.sharedMesh = null;
                }
                this.currentInstructions.Clear();
                if (this.skeleton != null) {
                    this.skeleton.setToSetupPose();
                }
            },
            /*Spine.Unity.SkeletonRenderer.ClearState end.*/

            /*Spine.Unity.SkeletonRenderer.EnsureMeshGeneratorCapacity start.*/
            /**
             * Sets a minimum buffer size for the internal MeshGenerator to prevent excess allocations during animation.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @param   {number}    minimumVertexCount
             * @return  {void}
             */
            EnsureMeshGeneratorCapacity: function (minimumVertexCount) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#EnsureMeshGeneratorCapacity", this ); }

                this.meshGenerator.EnsureVertexCapacity(minimumVertexCount);
            },
            /*Spine.Unity.SkeletonRenderer.EnsureMeshGeneratorCapacity end.*/

            /*Spine.Unity.SkeletonRenderer.Initialize start.*/
            /**
             * Initialize this component. Attempts to load the SkeletonData and creates the internal Skeleton object and buffers.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @param   {boolean}    overwrite    If set to <pre><code>true</code></pre>, it will overwrite internal objects if they were already generated. Otherwise, the initialized component will ignore subsequent calls to initialize.
             * @param   {boolean}    quiet
             * @return  {void}
             */
            Initialize: function (overwrite, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#Initialize", this ); }

                var $t;
                if (quiet === void 0) { quiet = false; }
                if (this.valid && !overwrite) {
                    return;
                }
                // Clear
                {
                    // Note: do not reset meshFilter.sharedMesh or meshRenderer.sharedMaterial to null,
                    // otherwise constant reloading will be triggered at prefabs.
                    this.currentInstructions.Clear();
                    this.rendererBuffers.Clear();
                    this.meshGenerator.Begin();
                    this.skeleton = null;
                    this.valid = false;
                }

                if (this.skeletonDataAsset == null) {
                    return;
                }

                var skeletonData = this.skeletonDataAsset.GetSkeletonData(false);
                if (skeletonData == null) {
                    return;
                }
                this.valid = true;

                this.meshFilter = this.GetComponent(UnityEngine.MeshFilter);
                if (UnityEngine.Component.op_Equality(this.meshFilter, null)) {
                    this.meshFilter = this.gameObject.AddComponent(UnityEngine.MeshFilter);
                }

                this.meshRenderer = this.GetComponent(UnityEngine.MeshRenderer);
                this.rendererBuffers.Initialize();

                this.skeleton = ($t = new Spine.Skeleton.$ctor1(skeletonData), $t.scaleX = this.initialFlipX ? -1 : 1, $t.scaleY = this.initialFlipY ? -1 : 1, $t);

                if (!System.String.isNullOrEmpty(this.initialSkinName) && !System.String.equals(this.initialSkinName, "default", 4)) {
                    this.skeleton.setSkinByName(this.initialSkinName);
                }

                this.separatorSlots.clear();
                for (var i = 0; i < this.separatorSlotNames.length; i = (i + 1) | 0) {
                    this.separatorSlots.add(this.skeleton.findSlot(this.separatorSlotNames[i]));
                }

                // Generate mesh once, required to update mesh bounds for visibility
                var updateModeSaved = this.updateMode;
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
                this.skeleton.updateWorldTransform();
                this.LateUpdate();
                this.updateMode = updateModeSaved;

                if (!Bridge.staticEquals(this.OnRebuild, null)) {
                    this.OnRebuild(this);
                }

            },
            /*Spine.Unity.SkeletonRenderer.Initialize end.*/

            /*Spine.Unity.SkeletonRenderer.LateUpdate start.*/
            /**
             * Generates a new UnityEngine.Mesh from the internal Skeleton.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @return  {void}
             */
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#LateUpdate", this ); }

                if (!this.valid) {
                    return;
                }


                if (this.updateMode !== Spine.Unity.UpdateMode.FullUpdate) {
                    return;
                }

                this.LateUpdateMesh();
            },
            /*Spine.Unity.SkeletonRenderer.LateUpdate end.*/

            /*Spine.Unity.SkeletonRenderer.LateUpdateMesh start.*/
            LateUpdateMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#LateUpdateMesh", this ); }

                var $t, $t1;
                var doMeshOverride = !Bridge.staticEquals(this.generateMeshOverride, null);
                if ((!UnityEngine.Object.op_Implicit(this.meshRenderer) || !this.meshRenderer.enabled) && !doMeshOverride) {
                    return;
                }
                var currentInstructions = this.currentInstructions;
                var workingSubmeshInstructions = currentInstructions.submeshInstructions;
                var currentSmartMesh = this.rendererBuffers.GetNextMesh(); // Double-buffer for performance.

                var updateTriangles;

                if (this.singleSubmesh) {
                    // STEP 1. Determine a SmartMesh.Instruction. Split up instructions into submeshes. =============================================
                    Spine.Unity.MeshGenerator.GenerateSingleSubmeshInstruction(currentInstructions, this.skeleton, ($t = this.skeletonDataAsset.atlasAssets)[0].PrimaryMaterial);

                    // STEP 1.9. Post-process workingInstructions. ==================================================================================
                    if (this.customMaterialOverride.Count > 0) {
                        Spine.Unity.MeshGenerator.TryReplaceMaterials(workingSubmeshInstructions, this.customMaterialOverride);
                    }

                    // STEP 2. Update vertex buffer based on verts from the attachments. ===========================================================
                    this.meshGenerator.settings = ($t1 = new Spine.Unity.MeshGenerator.Settings(), $t1.pmaVertexColors = this.pmaVertexColors, $t1.zSpacing = this.zSpacing, $t1.useClipping = this.useClipping, $t1.tintBlack = this.tintBlack, $t1.calculateTangents = this.calculateTangents, $t1.addNormals = this.addNormals, $t1);
                    this.meshGenerator.Begin();
                    updateTriangles = Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual(currentInstructions, currentSmartMesh.instructionUsed);
                    if (currentInstructions.hasActiveClipping) {
                        this.meshGenerator.AddSubmesh(workingSubmeshInstructions.Items[0], updateTriangles);
                    } else {
                        this.meshGenerator.BuildMeshWithArrays(currentInstructions, updateTriangles);
                    }

                } else {
                    // STEP 1. Determine a SmartMesh.Instruction. Split up instructions into submeshes. =============================================
                    Spine.Unity.MeshGenerator.GenerateSkeletonRendererInstruction(currentInstructions, this.skeleton, this.customSlotMaterials, this.separatorSlots, doMeshOverride, this.immutableTriangles);

                    // STEP 1.9. Post-process workingInstructions. ==================================================================================
                    if (this.customMaterialOverride.Count > 0) {
                        Spine.Unity.MeshGenerator.TryReplaceMaterials(workingSubmeshInstructions, this.customMaterialOverride);
                    }

                    if (doMeshOverride) {
                        this.generateMeshOverride(currentInstructions);
                        if (this.disableRenderingOnOverride) {
                            return;
                        }
                    }

                    updateTriangles = Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual(currentInstructions, currentSmartMesh.instructionUsed);

                    // STEP 2. Update vertex buffer based on verts from the attachments. ===========================================================
                    this.meshGenerator.settings = ($t1 = new Spine.Unity.MeshGenerator.Settings(), $t1.pmaVertexColors = this.pmaVertexColors, $t1.zSpacing = this.zSpacing, $t1.useClipping = this.useClipping, $t1.tintBlack = this.tintBlack, $t1.calculateTangents = this.calculateTangents, $t1.addNormals = this.addNormals, $t1);
                    this.meshGenerator.Begin();
                    if (currentInstructions.hasActiveClipping) {
                        this.meshGenerator.BuildMesh(currentInstructions, updateTriangles);
                    } else {
                        this.meshGenerator.BuildMeshWithArrays(currentInstructions, updateTriangles);
                    }
                }

                if (!Bridge.staticEquals(this.OnPostProcessVertices, null)) {
                    this.OnPostProcessVertices(this.meshGenerator.Buffers.$clone());
                }

                // STEP 3. Move the mesh data into a UnityEngine.Mesh ===========================================================================
                var currentMesh = currentSmartMesh.mesh;
                this.meshGenerator.FillVertexData(currentMesh);

                this.rendererBuffers.UpdateSharedMaterials(workingSubmeshInstructions);

                var materialsChanged = this.rendererBuffers.MaterialsChangedInLastUpdate();
                if (updateTriangles) { // Check if the triangles should also be updated.
                    this.meshGenerator.FillTriangles(currentMesh);
                    this.meshRenderer.sharedMaterials = this.rendererBuffers.GetUpdatedSharedMaterialsArray();
                } else if (materialsChanged) {
                    this.meshRenderer.sharedMaterials = this.rendererBuffers.GetUpdatedSharedMaterialsArray();
                }
                if (materialsChanged && (this.maskMaterials.AnyMaterialCreated)) {
                    this.maskMaterials = new Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials();
                }

                this.meshGenerator.FillLateVertexData(currentMesh);

                // STEP 4. The UnityEngine.Mesh is ready. Set it as the MeshFilter's mesh. Store the instructions used for that mesh. ===========
                if (UnityEngine.Object.op_Implicit(this.meshFilter)) {
                    this.meshFilter.sharedMesh = currentMesh;
                }
                currentSmartMesh.instructionUsed.Set(currentInstructions);

                if (UnityEngine.Component.op_Inequality(this.meshRenderer, null)) {
                    this.AssignSpriteMaskMaterials();
                }
                if (UnityEngine.Application.isPlaying) {
                    this.HandleOnDemandLoading();
                }

                if (this.fixDrawOrder && this.meshRenderer.sharedMaterials.length > 2) {
                    this.SetMaterialSettingsToFixDrawOrder();
                }

                if (!Bridge.staticEquals(this.OnMeshAndMaterialsUpdated, null)) {
                    this.OnMeshAndMaterialsUpdated(this);
                }
            },
            /*Spine.Unity.SkeletonRenderer.LateUpdateMesh end.*/

            /*Spine.Unity.SkeletonRenderer.OnBecameVisible start.*/
            OnBecameVisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#OnBecameVisible", this ); }

                var previousUpdateMode = this.updateMode;
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;

                // OnBecameVisible is called after LateUpdate()
                if (previousUpdateMode !== Spine.Unity.UpdateMode.FullUpdate) {
                    this.LateUpdate();
                }
            },
            /*Spine.Unity.SkeletonRenderer.OnBecameVisible end.*/

            /*Spine.Unity.SkeletonRenderer.OnBecameInvisible start.*/
            OnBecameInvisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#OnBecameInvisible", this ); }

                this.updateMode = this.updateWhenInvisible;
            },
            /*Spine.Unity.SkeletonRenderer.OnBecameInvisible end.*/

            /*Spine.Unity.SkeletonRenderer.FindAndApplySeparatorSlots$1 start.*/
            FindAndApplySeparatorSlots$1: function (startsWith, clearExistingSeparators, updateStringArray) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#FindAndApplySeparatorSlots$1", this ); }

                if (clearExistingSeparators === void 0) { clearExistingSeparators = true; }
                if (updateStringArray === void 0) { updateStringArray = false; }
                if (System.String.isNullOrEmpty(startsWith)) {
                    return;
                }

                this.FindAndApplySeparatorSlots(function (slotName) {
                    return System.String.startsWith(slotName, startsWith);
                }, clearExistingSeparators, updateStringArray);
            },
            /*Spine.Unity.SkeletonRenderer.FindAndApplySeparatorSlots$1 end.*/

            /*Spine.Unity.SkeletonRenderer.FindAndApplySeparatorSlots start.*/
            FindAndApplySeparatorSlots: function (slotNamePredicate, clearExistingSeparators, updateStringArray) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#FindAndApplySeparatorSlots", this ); }

                var $t, $t1, $t2;
                if (clearExistingSeparators === void 0) { clearExistingSeparators = true; }
                if (updateStringArray === void 0) { updateStringArray = false; }
                if (Bridge.staticEquals(slotNamePredicate, null)) {
                    return;
                }
                if (!this.valid) {
                    return;
                }

                if (clearExistingSeparators) {
                    this.separatorSlots.clear();
                }

                var slots = this.skeleton.Slots;
                $t = Bridge.getEnumerator(slots);
                try {
                    while ($t.moveNext()) {
                        var slot = $t.Current;
                        if (slotNamePredicate(slot.data.name)) {
                            this.separatorSlots.add(slot);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                if (updateStringArray) {
                    var detectedSeparatorNames = new (System.Collections.Generic.List$1(System.String)).ctor();
                    $t1 = Bridge.getEnumerator(this.skeleton.Slots);
                    try {
                        while ($t1.moveNext()) {
                            var slot1 = $t1.Current;
                            var slotName = slot1.data.name;
                            if (slotNamePredicate(slotName)) {
                                detectedSeparatorNames.add(slotName);
                            }
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                    if (!clearExistingSeparators) {
                        var originalNames = this.separatorSlotNames;
                        $t2 = Bridge.getEnumerator(originalNames);
                        try {
                            while ($t2.moveNext()) {
                                var originalName = $t2.Current;
                                detectedSeparatorNames.add(originalName);
                            }
                        } finally {
                            if (Bridge.is($t2, System.IDisposable)) {
                                $t2.System$IDisposable$Dispose();
                            }
                        }
                    }

                    this.separatorSlotNames = detectedSeparatorNames.ToArray();
                }

            },
            /*Spine.Unity.SkeletonRenderer.FindAndApplySeparatorSlots end.*/

            /*Spine.Unity.SkeletonRenderer.ReapplySeparatorSlotNames start.*/
            ReapplySeparatorSlotNames: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#ReapplySeparatorSlotNames", this ); }

                if (!this.valid) {
                    return;
                }

                this.separatorSlots.clear();
                for (var i = 0, n = this.separatorSlotNames.length; i < n; i = (i + 1) | 0) {
                    var slot = this.skeleton.findSlot(this.separatorSlotNames[i]);
                    if (slot != null) {
                        this.separatorSlots.add(slot);
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderer.ReapplySeparatorSlotNames end.*/

            /*Spine.Unity.SkeletonRenderer.AssignSpriteMaskMaterials start.*/
            AssignSpriteMaskMaterials: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#AssignSpriteMaskMaterials", this ); }

                var $t, $t1, $t2;

                if (UnityEngine.Application.isPlaying) {
                    if (this.maskInteraction !== UnityEngine.SpriteMaskInteraction.None && this.maskMaterials.materialsMaskDisabled.length === 0) {
                        this.maskMaterials.materialsMaskDisabled = this.meshRenderer.sharedMaterials;
                    }
                }

                if (this.maskMaterials.materialsMaskDisabled.length > 0 && ($t = this.maskMaterials.materialsMaskDisabled)[0] != null && this.maskInteraction === UnityEngine.SpriteMaskInteraction.None) {
                    this.meshRenderer.materials = this.maskMaterials.materialsMaskDisabled;
                } else if (this.maskInteraction === UnityEngine.SpriteMaskInteraction.VisibleInsideMask) {
                    if (this.maskMaterials.materialsInsideMask.length === 0 || ($t1 = this.maskMaterials.materialsInsideMask)[0] == null) {
                        if (!this.InitSpriteMaskMaterialsInsideMask()) {
                            return;
                        }
                    }
                    this.meshRenderer.materials = this.maskMaterials.materialsInsideMask;
                } else if (this.maskInteraction === UnityEngine.SpriteMaskInteraction.VisibleOutsideMask) {
                    if (this.maskMaterials.materialsOutsideMask.length === 0 || ($t2 = this.maskMaterials.materialsOutsideMask)[0] == null) {
                        if (!this.InitSpriteMaskMaterialsOutsideMask()) {
                            return;
                        }
                    }
                    this.meshRenderer.materials = this.maskMaterials.materialsOutsideMask;
                }
            },
            /*Spine.Unity.SkeletonRenderer.AssignSpriteMaskMaterials end.*/

            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsInsideMask start.*/
            InitSpriteMaskMaterialsInsideMask: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsInsideMask", this ); }

                return this.InitSpriteMaskMaterialsForMaskType(Spine.Unity.SkeletonRenderer.STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE, Bridge.ref(this.maskMaterials, "materialsInsideMask"));
            },
            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsInsideMask end.*/

            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsOutsideMask start.*/
            InitSpriteMaskMaterialsOutsideMask: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsOutsideMask", this ); }

                return this.InitSpriteMaskMaterialsForMaskType(Spine.Unity.SkeletonRenderer.STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE, Bridge.ref(this.maskMaterials, "materialsOutsideMask"));
            },
            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsOutsideMask end.*/

            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsForMaskType start.*/
            InitSpriteMaskMaterialsForMaskType: function (maskFunction, materialsToFill) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsForMaskType", this ); }

                var originalMaterials = this.maskMaterials.materialsMaskDisabled;
                materialsToFill.v = System.Array.init(originalMaterials.length, null, UnityEngine.Material);
                for (var i = 0; i < originalMaterials.length; i = (i + 1) | 0) {
                    var originalMaterial = originalMaterials[i];
                    if (originalMaterial == null) {
                        materialsToFill.v[i] = null;
                        continue;
                    }
                    var newMaterial = new UnityEngine.Material.$ctor1(originalMaterial);
                    newMaterial.SetFloat(Spine.Unity.SkeletonRenderer.STENCIL_COMP_PARAM_ID, maskFunction);
                    materialsToFill.v[i] = newMaterial;
                }
                return true;
            },
            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsForMaskType end.*/

            /*Spine.Unity.SkeletonRenderer.HandleOnDemandLoading start.*/
            HandleOnDemandLoading: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#HandleOnDemandLoading", this ); }

                var $t, $t1, $t2;
                $t = Bridge.getEnumerator(this.skeletonDataAsset.atlasAssets);
                try {
                    while ($t.moveNext()) {
                        var atlasAsset = $t.Current;
                        if (atlasAsset.TextureLoadingMode !== Spine.Unity.AtlasAssetBase.LoadingMode.Normal) {
                            atlasAsset.BeginCustomTextureLoading();
                            for (var i = 0, count = this.meshRenderer.sharedMaterials.length; i < count; i = (i + 1) | 0) {
                                var overrideMaterial = { v : null };
                                atlasAsset.RequireTexturesLoaded(($t1 = this.meshRenderer.sharedMaterials)[i], overrideMaterial);
                                if (overrideMaterial.v != null) {
                                    ($t2 = this.meshRenderer.sharedMaterials)[i] = overrideMaterial.v;
                                }
                            }
                            atlasAsset.EndCustomTextureLoading();
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderer.HandleOnDemandLoading end.*/

            /*Spine.Unity.SkeletonRenderer.SetMaterialSettingsToFixDrawOrder start.*/
            /**
             * This method was introduced as a workaround for too aggressive submesh draw call batching,
             leading to incorrect draw order when 3+ materials are used at submeshes in alternating order.
             Otherwise, e.g. when using Lightweight Render Pipeline, deliberately separated draw calls
             "A1 B A2" are reordered to "A1A2 B", regardless of batching-related project settings.
             *
             * @instance
             * @private
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @return  {void}
             */
            SetMaterialSettingsToFixDrawOrder: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#SetMaterialSettingsToFixDrawOrder", this ); }

                var $t, $t1;
                if (this.reusedPropertyBlock == null) {
                    this.reusedPropertyBlock = new UnityEngine.MaterialPropertyBlock();
                }

                var hasPerRendererBlock = this.meshRenderer.HasPropertyBlock();
                if (hasPerRendererBlock) {
                    this.meshRenderer.GetPropertyBlock(this.reusedPropertyBlock);
                }

                for (var i = 0; i < this.meshRenderer.sharedMaterials.length; i = (i + 1) | 0) {
                    if (!UnityEngine.Object.op_Implicit(($t = this.meshRenderer.sharedMaterials)[i])) {
                        continue;
                    }

                    if (!hasPerRendererBlock) {
                        this.meshRenderer.GetPropertyBlock$1(this.reusedPropertyBlock, i);
                    }
                    // Note: this parameter shall not exist at any shader, then Unity will create separate
                    // material instances (not in terms of memory cost or leakage).
                    this.reusedPropertyBlock.SetFloat(Spine.Unity.SkeletonRenderer.SUBMESH_DUMMY_PARAM_ID, i);
                    this.meshRenderer.SetPropertyBlock$1(this.reusedPropertyBlock, i);

                    ($t1 = this.meshRenderer.sharedMaterials)[i].enableInstancing = false;
                }
            },
            /*Spine.Unity.SkeletonRenderer.SetMaterialSettingsToFixDrawOrder end.*/


        },
        overloads: {
            "FindAndApplySeparatorSlots(string, bool, bool)": "FindAndApplySeparatorSlots$1"
        }
    });
    /*Spine.Unity.SkeletonRenderer end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonGraphic.MeshAssignmentDelegateMultiple
     * @param   {number}                          meshCount           
     * @param   {Array.<UnityEngine.Mesh>}        meshes              
     * @param   {Array.<UnityEngine.Material>}    graphicMaterials    
     * @param   {Array.<UnityEngine.Texture>}     textures
     * @return  {void}
     */

    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonGraphic.MeshAssignmentDelegateSingle
     * @param   {UnityEngine.Mesh}        mesh               
     * @param   {UnityEngine.Material}    graphicMaterial    
     * @param   {UnityEngine.Texture}     texture
     * @return  {void}
     */

    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.ISkeletonAnimationDelegate
     * @param   {Spine.Unity.ISkeletonAnimation}    animated
     * @return  {void}
     */

    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonGraphic.InstructionDelegate
     * @param   {Spine.Unity.SkeletonRendererInstruction}    instruction
     * @return  {void}
     */

    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonGraphic.SkeletonRendererDelegate
     * @param   {Spine.Unity.SkeletonGraphic}    skeletonGraphic
     * @return  {void}
     */


    /*Spine.Unity.SkeletonGraphic start.*/
    Bridge.define("Spine.Unity.SkeletonGraphic", {
        inherits: [UnityEngine.UI.MaskableGraphic,Spine.Unity.ISkeletonComponent,Spine.Unity.IAnimationStateComponent,Spine.Unity.ISkeletonAnimation,Spine.Unity.IHasSkeletonDataAsset],
        statics: {
            fields: {
                EditReferenceRect: false,
                SeparatorPartGameObjectName: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#init", this ); }

                    this.EditReferenceRect = false;
                    this.SeparatorPartGameObjectName = "Part";
                }
            },
            methods: {
                /*Spine.Unity.SkeletonGraphic.NewSkeletonGraphicGameObject:static start.*/
                /**
                 * Create a new GameObject with a SkeletonGraphic component.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonGraphic
                 * @memberof Spine.Unity.SkeletonGraphic
                 * @param   {Spine.Unity.SkeletonDataAsset}    skeletonDataAsset    
                 * @param   {UnityEngine.Transform}            parent               
                 * @param   {UnityEngine.Material}             material             Material for the canvas renderer to use. Usually, the default SkeletonGraphic material will work.
                 * @return  {Spine.Unity.SkeletonGraphic}
                 */
                NewSkeletonGraphicGameObject: function (skeletonDataAsset, parent, material) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#NewSkeletonGraphicGameObject", this ); }

                    var sg = Spine.Unity.SkeletonGraphic.AddSkeletonGraphicComponent(new UnityEngine.GameObject.$ctor2("New Spine GameObject"), skeletonDataAsset, material);
                    if (UnityEngine.Component.op_Inequality(parent, null)) {
                        sg.transform.SetParent(parent, false);
                    }
                    return sg;
                },
                /*Spine.Unity.SkeletonGraphic.NewSkeletonGraphicGameObject:static end.*/

                /*Spine.Unity.SkeletonGraphic.AddSkeletonGraphicComponent:static start.*/
                /**
                 * Add a SkeletonGraphic component to a GameObject.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonGraphic
                 * @memberof Spine.Unity.SkeletonGraphic
                 * @param   {UnityEngine.GameObject}           gameObject           
                 * @param   {Spine.Unity.SkeletonDataAsset}    skeletonDataAsset    
                 * @param   {UnityEngine.Material}             material             Material for the canvas renderer to use. Usually, the default SkeletonGraphic material will work.
                 * @return  {Spine.Unity.SkeletonGraphic}
                 */
                AddSkeletonGraphicComponent: function (gameObject, skeletonDataAsset, material) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#AddSkeletonGraphicComponent", this ); }

                    var skeletonGraphic = gameObject.AddComponent(Spine.Unity.SkeletonGraphic);
                    if (skeletonDataAsset != null) {
                        skeletonGraphic.material = material;
                        skeletonGraphic.skeletonDataAsset = skeletonDataAsset;
                        skeletonGraphic.Initialize(false);
                    }
                    var canvasRenderer = gameObject.GetComponent(UnityEngine.CanvasRenderer);
                    if (UnityEngine.Object.op_Implicit(canvasRenderer)) {
                        canvasRenderer.cullTransparentMesh = false;
                    }
                    return skeletonGraphic;
                },
                /*Spine.Unity.SkeletonGraphic.AddSkeletonGraphicComponent:static end.*/

                /*Spine.Unity.SkeletonGraphic.SetRectTransformSize$1:static start.*/
                SetRectTransformSize$1: function (target, size) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SetRectTransformSize$1", this ); }

                    Spine.Unity.SkeletonGraphic.SetRectTransformSize(target.rectTransform, size);
                },
                /*Spine.Unity.SkeletonGraphic.SetRectTransformSize$1:static end.*/

                /*Spine.Unity.SkeletonGraphic.SetRectTransformSize:static start.*/
                SetRectTransformSize: function (targetRectTransform, size) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SetRectTransformSize", this ); }

                    var $t;
                    var parentSize = pc.Vec2.ZERO.clone();
                    if (UnityEngine.Component.op_Inequality(targetRectTransform.parent, null)) {
                        var parentTransform = targetRectTransform.parent.GetComponent(UnityEngine.RectTransform);
                        if (UnityEngine.Object.op_Implicit(parentTransform)) {
                            parentSize = parentTransform.rect.size.$clone();
                        }
                    }
                    var anchorAreaSize = ($t = targetRectTransform.anchorMax.$clone().sub( targetRectTransform.anchorMin ), new pc.Vec2( $t.x * parentSize.x, $t.y * parentSize.y ));
                    targetRectTransform.sizeDelta = size.$clone().sub( anchorAreaSize );
                },
                /*Spine.Unity.SkeletonGraphic.SetRectTransformSize:static end.*/


            }
        },
        fields: {
            skeletonDataAsset: null,
            additiveMaterial: null,
            multiplyMaterial: null,
            screenMaterial: null,
            initialSkinName: null,
            initialFlipX: false,
            initialFlipY: false,
            startingAnimation: null,
            startingLoop: false,
            timeScale: 0,
            freeze: false,
            meshScale: 0,
            layoutScaleMode: 0,
            referenceSize: null,
            referenceScale: 0,
            updateMode: 0,
            /**
             * Update mode used when the MeshRenderer becomes invisible
             (when <pre><code>OnBecameInvisible()</code></pre> is called). Update mode is automatically
             reset to <pre><code>UpdateMode.FullUpdate</code></pre> when the mesh becomes visible again.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @type Spine.Unity.UpdateMode
             */
            updateWhenInvisible: 0,
            allowMultipleCanvasRenderers: false,
            canvasRenderers: null,
            submeshGraphics: null,
            usedRenderersCount: 0,
            /**
             * Slot names used to populate separatorSlots list when the Skeleton is initialized. Changing this after initialization does nothing.
             *
             * @instance
             * @protected
             * @memberof Spine.Unity.SkeletonGraphic
             * @type Array.<string>
             */
            separatorSlotNames: null,
            /**
             * Slots that determine where the render is split. This is used by components such as SkeletonRenderSeparator so that the skeleton can be rendered by two separate renderers on different GameObjects.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonGraphic
             * @type System.Collections.Generic.List$1
             */
            separatorSlots: null,
            enableSeparatorSlots: false,
            separatorParts: null,
            updateSeparatorPartLocation: false,
            updateSeparatorPartScale: false,
            wasUpdatedAfterInit: false,
            baseTexture: null,
            /**
             * When true, no meshes and materials are assigned at CanvasRenderers if the used override
             AssignMeshOverrideSingleRenderer or AssignMeshOverrideMultipleRenderers is non-null.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @default true
             * @type boolean
             */
            disableMeshAssignmentOnOverride: false,
            customTextureOverride: null,
            customMaterialOverride: null,
            overrideTexture: null,
            skeleton: null,
            state: null,
            meshGenerator: null,
            meshBuffers: null,
            currentInstructions: null,
            meshes: null,
            usedMaterials: null,
            usedTextures: null,
            updateTiming: 0,
            unscaledTime: false
        },
        events: {
            assignMeshOverrideSingle: null,
            assignMeshOverrideMultiple: null,
            /**
             * OnRebuild is raised after the Skeleton is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function addOnRebuild
             * @param   {Spine.Unity.SkeletonGraphic.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnRebuild is raised after the Skeleton is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function removeOnRebuild
             * @param   {Spine.Unity.SkeletonGraphic.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            OnRebuild: null,
            /**
             * OnInstructionsPrepared is raised at the end of <pre><code>LateUpdate</code></pre> after render instructions
             are done, target renderers are prepared, and the mesh is ready to be generated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function addOnInstructionsPrepared
             * @param   {Spine.Unity.SkeletonGraphic.InstructionDelegate}    value
             * @return  {void}
             */
            /**
             * OnInstructionsPrepared is raised at the end of <pre><code>LateUpdate</code></pre> after render instructions
             are done, target renderers are prepared, and the mesh is ready to be generated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function removeOnInstructionsPrepared
             * @param   {Spine.Unity.SkeletonGraphic.InstructionDelegate}    value
             * @return  {void}
             */
            OnInstructionsPrepared: null,
            /**
             * OnMeshAndMaterialsUpdated is raised at the end of <pre><code>Rebuild</code></pre> after the Mesh and
             all materials have been updated. Note that some Unity API calls are not permitted to be issued from
             <pre><code>Rebuild</code></pre>, so you may want to subscribe to {@link } instead
             from where you can issue such preparation calls.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function addOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonGraphic.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnMeshAndMaterialsUpdated is raised at the end of <pre><code>Rebuild</code></pre> after the Mesh and
             all materials have been updated. Note that some Unity API calls are not permitted to be issued from
             <pre><code>Rebuild</code></pre>, so you may want to subscribe to {@link } instead
             from where you can issue such preparation calls.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function removeOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonGraphic.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            OnMeshAndMaterialsUpdated: null,
            /**
             * OnAnimationRebuild is raised after the SkeletonAnimation component is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function addOnAnimationRebuild
             * @param   {Spine.Unity.ISkeletonAnimationDelegate}    value
             * @return  {void}
             */
            /**
             * OnAnimationRebuild is raised after the SkeletonAnimation component is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function removeOnAnimationRebuild
             * @param   {Spine.Unity.ISkeletonAnimationDelegate}    value
             * @return  {void}
             */
            OnAnimationRebuild: null,
            BeforeApply: null,
            UpdateLocal: null,
            UpdateWorld: null,
            UpdateComplete: null,
            /**
             * Occurs after the vertex data populated every frame, before the vertices are pushed into the mesh.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function addOnPostProcessVertices
             * @param   {Spine.Unity.MeshGeneratorDelegate}    value
             * @return  {void}
             */
            /**
             * Occurs after the vertex data populated every frame, before the vertices are pushed into the mesh.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function removeOnPostProcessVertices
             * @param   {Spine.Unity.MeshGeneratorDelegate}    value
             * @return  {void}
             */
            OnPostProcessVertices: null
        },
        props: {
            SkeletonDataAsset: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SkeletonDataAsset#get", this ); }

                    return this.skeletonDataAsset;
                }
            },
            MeshScale: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MeshScale#get", this ); }

                    return this.meshScale;
                }
            },
            /**
             * Update mode to optionally limit updates to e.g. only apply animations but not update the mesh.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @function UpdateMode
             * @type Spine.Unity.UpdateMode
             */
            UpdateMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMode#get", this ); }

                    return this.updateMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMode#set", this ); }

                    this.updateMode = value;
                }
            },
            SeparatorParts: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SeparatorParts#get", this ); }

                    return this.separatorParts;
                }
            },
            /**
             * Use this Dictionary to override a Texture with a different Texture.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonGraphic
             * @function CustomTextureOverride
             * @type System.Collections.Generic.Dictionary$2
             */
            CustomTextureOverride: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#CustomTextureOverride#get", this ); }

                    return this.customTextureOverride;
                }
            },
            /**
             * Use this Dictionary to override the Material where the Texture was used at the original atlas.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonGraphic
             * @function CustomMaterialOverride
             * @type System.Collections.Generic.Dictionary$2
             */
            CustomMaterialOverride: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#CustomMaterialOverride#get", this ); }

                    return this.customMaterialOverride;
                }
            },
            OverrideTexture: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OverrideTexture#get", this ); }

                    return this.overrideTexture;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OverrideTexture#set", this ); }

                    this.overrideTexture = value;
                    this.canvasRenderer.SetTexture(this.mainTexture); // Refresh canvasRenderer's texture. Make sure it handles null.
                }
            },
            mainTexture: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#mainTexture#get", this ); }

                    if (this.overrideTexture != null) {
                        return this.overrideTexture;
                    }
                    return this.baseTexture;
                }
            },
            Skeleton: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Skeleton#get", this ); }

                    this.Initialize(false);
                    return this.skeleton;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Skeleton#set", this ); }

                    this.skeleton = value;
                }
            },
            SkeletonData: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SkeletonData#get", this ); }

                    this.Initialize(false);
                    return this.skeleton == null ? null : this.skeleton.data;
                }
            },
            IsValid: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#IsValid#get", this ); }

                    return this.skeleton != null;
                }
            },
            AnimationState: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#AnimationState#get", this ); }

                    this.Initialize(false);
                    return this.state;
                }
            },
            MeshGenerator: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MeshGenerator#get", this ); }

                    return this.meshGenerator;
                }
            },
            MeshesMultipleCanvasRenderers: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MeshesMultipleCanvasRenderers#get", this ); }

                    return this.meshes;
                }
            },
            MaterialsMultipleCanvasRenderers: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MaterialsMultipleCanvasRenderers#get", this ); }

                    return this.usedMaterials;
                }
            },
            TexturesMultipleCanvasRenderers: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#TexturesMultipleCanvasRenderers#get", this ); }

                    return this.usedTextures;
                }
            },
            UpdateTiming: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateTiming#get", this ); }

                    return this.updateTiming;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateTiming#set", this ); }

                    this.updateTiming = value;
                }
            },
            UnscaledTime: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UnscaledTime#get", this ); }

                    return this.unscaledTime;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UnscaledTime#set", this ); }

                    this.unscaledTime = value;
                }
            }
        },
        alias: [
            "SkeletonDataAsset", "Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset",
            "SkeletonDataAsset", "Spine$Unity$ISkeletonComponent$SkeletonDataAsset",
            "Rebuild", "UnityEngine$UI$ICanvasElement$Rebuild",
            "Skeleton", "Spine$Unity$ISkeletonAnimation$Skeleton",
            "Skeleton", "Spine$Unity$ISkeletonComponent$Skeleton",
            "AnimationState", "Spine$Unity$IAnimationStateComponent$AnimationState",
            "addOnAnimationRebuild", "Spine$Unity$ISkeletonAnimation$addOnAnimationRebuild",
            "removeOnAnimationRebuild", "Spine$Unity$ISkeletonAnimation$removeOnAnimationRebuild",
            "addUpdateLocal", "Spine$Unity$ISkeletonAnimation$addUpdateLocal",
            "removeUpdateLocal", "Spine$Unity$ISkeletonAnimation$removeUpdateLocal",
            "addUpdateWorld", "Spine$Unity$ISkeletonAnimation$addUpdateWorld",
            "removeUpdateWorld", "Spine$Unity$ISkeletonAnimation$removeUpdateWorld",
            "addUpdateComplete", "Spine$Unity$ISkeletonAnimation$addUpdateComplete",
            "removeUpdateComplete", "Spine$Unity$ISkeletonAnimation$removeUpdateComplete",
            "UpdateTiming", "Spine$Unity$ISkeletonAnimation$UpdateTiming",
            "UnscaledTime", "Spine$Unity$IAnimationStateComponent$UnscaledTime"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#init", this ); }

                this.referenceSize = new UnityEngine.Vector2();
                this.timeScale = 1.0;
                this.meshScale = 1.0;
                this.layoutScaleMode = Spine.Unity.SkeletonGraphic.LayoutMode.None;
                this.referenceSize = pc.Vec2.ONE.clone();
                this.referenceScale = 1.0;
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
                this.updateWhenInvisible = Spine.Unity.UpdateMode.FullUpdate;
                this.allowMultipleCanvasRenderers = false;
                this.canvasRenderers = new (System.Collections.Generic.List$1(UnityEngine.CanvasRenderer)).ctor();
                this.submeshGraphics = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonSubmeshGraphic)).ctor();
                this.usedRenderersCount = 0;
                this.separatorSlotNames = System.Array.init(0, null, System.String);
                this.separatorSlots = new (System.Collections.Generic.List$1(Spine.Slot)).ctor();
                this.enableSeparatorSlots = false;
                this.separatorParts = new (System.Collections.Generic.List$1(UnityEngine.Transform)).ctor();
                this.updateSeparatorPartLocation = true;
                this.updateSeparatorPartScale = false;
                this.wasUpdatedAfterInit = true;
                this.disableMeshAssignmentOnOverride = true;
                this.customTextureOverride = new (System.Collections.Generic.Dictionary$2(UnityEngine.Texture,UnityEngine.Texture)).ctor();
                this.customMaterialOverride = new (System.Collections.Generic.Dictionary$2(UnityEngine.Texture,UnityEngine.Material)).ctor();
                this.meshGenerator = new Spine.Unity.MeshGenerator();
                this.currentInstructions = new Spine.Unity.SkeletonRendererInstruction();
                this.meshes = new (Spine.ExposedList$1(UnityEngine.Mesh)).ctor();
                this.usedMaterials = new (Spine.ExposedList$1(UnityEngine.Material)).ctor();
                this.usedTextures = new (Spine.ExposedList$1(UnityEngine.Texture)).ctor();
                this.updateTiming = Spine.Unity.UpdateTiming.InUpdate;
            }
        },
        methods: {
            /**
             * Allows separate code to take over mesh and material assignment for this SkeletonGraphic component.
             Used when <pre><code>allowMultipleCanvasRenderers</code></pre> is false.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @event Spine.Unity.SkeletonGraphic#AssignMeshOverrideSingleRenderer
             * @return  {Spine.Unity.SkeletonGraphic.MeshAssignmentDelegateSingle}
             */
            addAssignMeshOverrideSingleRenderer: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#addAssignMeshOverrideSingleRenderer", this ); }

                this.addassignMeshOverrideSingle(value);
                if (this.disableMeshAssignmentOnOverride && !Bridge.staticEquals(this.assignMeshOverrideSingle, null)) {
                    this.Initialize(false);
                }
            },
            /**
             * Allows separate code to take over mesh and material assignment for this SkeletonGraphic component.
             Used when <pre><code>allowMultipleCanvasRenderers</code></pre> is false.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @event Spine.Unity.SkeletonGraphic#AssignMeshOverrideSingleRenderer
             * @return  {Spine.Unity.SkeletonGraphic.MeshAssignmentDelegateSingle}
             */
            removeAssignMeshOverrideSingleRenderer: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#removeAssignMeshOverrideSingleRenderer", this ); }

                this.removeassignMeshOverrideSingle(value);
                if (this.disableMeshAssignmentOnOverride && Bridge.staticEquals(this.assignMeshOverrideSingle, null)) {
                    this.Initialize(false);
                }
            },
            /**
             * Allows separate code to take over mesh and material assignment for this SkeletonGraphic component.
             Used when <pre><code>allowMultipleCanvasRenderers</code></pre> is true.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @event Spine.Unity.SkeletonGraphic#AssignMeshOverrideMultipleRenderers
             * @return  {Spine.Unity.SkeletonGraphic.MeshAssignmentDelegateMultiple}
             */
            addAssignMeshOverrideMultipleRenderers: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#addAssignMeshOverrideMultipleRenderers", this ); }

                this.addassignMeshOverrideMultiple(value);
                if (this.disableMeshAssignmentOnOverride && !Bridge.staticEquals(this.assignMeshOverrideMultiple, null)) {
                    this.Initialize(false);
                }
            },
            /**
             * Allows separate code to take over mesh and material assignment for this SkeletonGraphic component.
             Used when <pre><code>allowMultipleCanvasRenderers</code></pre> is true.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @event Spine.Unity.SkeletonGraphic#AssignMeshOverrideMultipleRenderers
             * @return  {Spine.Unity.SkeletonGraphic.MeshAssignmentDelegateMultiple}
             */
            removeAssignMeshOverrideMultipleRenderers: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#removeAssignMeshOverrideMultipleRenderers", this ); }

                this.removeassignMeshOverrideMultiple(value);
                if (this.disableMeshAssignmentOnOverride && Bridge.staticEquals(this.assignMeshOverrideMultiple, null)) {
                    this.Initialize(false);
                }
            },
            /*Spine.Unity.SkeletonGraphic.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Awake", this ); }

                UnityEngine.UI.MaskableGraphic.prototype.Awake.call(this);
                this.onCullStateChanged.AddListener(Bridge.fn.cacheBind(this, this.OnCullStateChanged));

                this.SyncSubmeshGraphicsWithCanvasRenderers();
                if (!this.IsValid) {
                    this.Initialize(false);
                    if (this.IsValid) {
                        this.Rebuild(UnityEngine.UI.CanvasUpdate.PreRender);
                    }
                }

            },
            /*Spine.Unity.SkeletonGraphic.Awake end.*/

            /*Spine.Unity.SkeletonGraphic.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OnDestroy", this ); }

                this.Clear();
                UnityEngine.UI.MaskableGraphic.prototype.OnDestroy.call(this);
            },
            /*Spine.Unity.SkeletonGraphic.OnDestroy end.*/

            /*Spine.Unity.SkeletonGraphic.Rebuild start.*/
            Rebuild: function (update) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Rebuild", this ); }

                UnityEngine.UI.MaskableGraphic.prototype.Rebuild.call(this, update);
                if (!this.IsValid) {
                    return;
                }
                if (this.canvasRenderer.cull) {
                    return;
                }
                if (update === UnityEngine.UI.CanvasUpdate.PreRender) {
                    this.PrepareInstructionsAndRenderers(true);
                    this.UpdateMeshToInstructions();
                }
                if (this.allowMultipleCanvasRenderers) {
                    this.canvasRenderer.Clear();
                }
            },
            /*Spine.Unity.SkeletonGraphic.Rebuild end.*/

            /*Spine.Unity.SkeletonGraphic.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OnDisable", this ); }

                var $t;
                UnityEngine.UI.MaskableGraphic.prototype.OnDisable.call(this);
                $t = Bridge.getEnumerator(this.canvasRenderers);
                try {
                    while ($t.moveNext()) {
                        var canvasRenderer = $t.Current;
                        canvasRenderer.Clear();
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.OnDisable end.*/

            /*Spine.Unity.SkeletonGraphic.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Update", this ); }

                if (this.freeze || this.updateTiming !== Spine.Unity.UpdateTiming.InUpdate) {
                    return;
                }
                this.Update$1(this.unscaledTime ? UnityEngine.Time.unscaledDeltaTime : UnityEngine.Time.deltaTime);
            },
            /*Spine.Unity.SkeletonGraphic.Update end.*/

            /*Spine.Unity.SkeletonGraphic.Update$1 start.*/
            Update$1: function (deltaTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Update$1", this ); }

                if (!this.IsValid) {
                    return;
                }

                this.wasUpdatedAfterInit = true;
                if (this.updateMode < Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    return;
                }
                this.UpdateAnimationStatus(deltaTime);

                if (this.updateMode === Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    this.state.ApplyEventTimelinesOnly(this.skeleton, false);
                    return;
                }
                this.ApplyAnimation();
            },
            /*Spine.Unity.SkeletonGraphic.Update$1 end.*/

            /*Spine.Unity.SkeletonGraphic.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#FixedUpdate", this ); }

                if (this.freeze || this.updateTiming !== Spine.Unity.UpdateTiming.InFixedUpdate) {
                    return;
                }
                this.Update$1(this.unscaledTime ? UnityEngine.Time.unscaledDeltaTime : UnityEngine.Time.deltaTime);
            },
            /*Spine.Unity.SkeletonGraphic.FixedUpdate end.*/

            /*Spine.Unity.SkeletonGraphic.SyncSubmeshGraphicsWithCanvasRenderers start.*/
            SyncSubmeshGraphicsWithCanvasRenderers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SyncSubmeshGraphicsWithCanvasRenderers", this ); }

                var $t;
                this.submeshGraphics.clear();

                $t = Bridge.getEnumerator(this.canvasRenderers);
                try {
                    while ($t.moveNext()) {
                        var canvasRenderer = $t.Current;
                        var submeshGraphic = canvasRenderer.GetComponent(Spine.Unity.SkeletonSubmeshGraphic);
                        if (UnityEngine.MonoBehaviour.op_Equality(submeshGraphic, null)) {
                            submeshGraphic = canvasRenderer.gameObject.AddComponent(Spine.Unity.SkeletonSubmeshGraphic);
                            submeshGraphic.maskable = this.maskable;
                            submeshGraphic.raycastTarget = false;
                        }
                        this.submeshGraphics.add(submeshGraphic);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.SyncSubmeshGraphicsWithCanvasRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateAnimationStatus start.*/
            UpdateAnimationStatus: function (deltaTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateAnimationStatus", this ); }

                deltaTime *= this.timeScale;
                this.state.update(deltaTime);
            },
            /*Spine.Unity.SkeletonGraphic.UpdateAnimationStatus end.*/

            /*Spine.Unity.SkeletonGraphic.ApplyAnimation start.*/
            ApplyAnimation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#ApplyAnimation", this ); }

                if (!Bridge.staticEquals(this.BeforeApply, null)) {
                    this.BeforeApply(this);
                }

                if (this.updateMode !== Spine.Unity.UpdateMode.OnlyEventTimelines) {
                    this.state.apply(this.skeleton);
                } else {
                    this.state.ApplyEventTimelinesOnly(this.skeleton, true);
                }

                this.AfterAnimationApplied();
            },
            /*Spine.Unity.SkeletonGraphic.ApplyAnimation end.*/

            /*Spine.Unity.SkeletonGraphic.AfterAnimationApplied start.*/
            AfterAnimationApplied: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#AfterAnimationApplied", this ); }

                if (!Bridge.staticEquals(this.UpdateLocal, null)) {
                    this.UpdateLocal(this);
                }

                this.skeleton.updateWorldTransform();

                if (!Bridge.staticEquals(this.UpdateWorld, null)) {
                    this.UpdateWorld(this);
                    this.skeleton.updateWorldTransform();
                }

                if (!Bridge.staticEquals(this.UpdateComplete, null)) {
                    this.UpdateComplete(this);
                }
            },
            /*Spine.Unity.SkeletonGraphic.AfterAnimationApplied end.*/

            /*Spine.Unity.SkeletonGraphic.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#LateUpdate", this ); }

                if (!this.IsValid) {
                    return;
                }
                // instantiation can happen from Update() after this component, leading to a missing Update() call.
                if (!this.wasUpdatedAfterInit) {
                    this.Update$1(0);
                }
                if (this.freeze) {
                    return;
                }
                if (this.updateMode !== Spine.Unity.UpdateMode.FullUpdate) {
                    return;
                }

                if (this.updateTiming === Spine.Unity.UpdateTiming.InLateUpdate) {
                    this.Update$1(this.unscaledTime ? UnityEngine.Time.unscaledDeltaTime : UnityEngine.Time.deltaTime);
                }

                this.UpdateMesh();
            },
            /*Spine.Unity.SkeletonGraphic.LateUpdate end.*/

            /*Spine.Unity.SkeletonGraphic.OnCullStateChanged start.*/
            OnCullStateChanged: function (culled) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OnCullStateChanged", this ); }

                if (culled) {
                    this.OnBecameInvisible();
                } else {
                    this.OnBecameVisible();
                }
            },
            /*Spine.Unity.SkeletonGraphic.OnCullStateChanged end.*/

            /*Spine.Unity.SkeletonGraphic.OnBecameVisible start.*/
            OnBecameVisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OnBecameVisible", this ); }

                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
            },
            /*Spine.Unity.SkeletonGraphic.OnBecameVisible end.*/

            /*Spine.Unity.SkeletonGraphic.OnBecameInvisible start.*/
            OnBecameInvisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OnBecameInvisible", this ); }

                this.updateMode = this.updateWhenInvisible;
            },
            /*Spine.Unity.SkeletonGraphic.OnBecameInvisible end.*/

            /*Spine.Unity.SkeletonGraphic.ReapplySeparatorSlotNames start.*/
            ReapplySeparatorSlotNames: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#ReapplySeparatorSlotNames", this ); }

                if (!this.IsValid) {
                    return;
                }

                this.separatorSlots.clear();
                for (var i = 0, n = this.separatorSlotNames.length; i < n; i = (i + 1) | 0) {
                    var slotName = this.separatorSlotNames[i];
                    if (Bridge.referenceEquals(slotName, "")) {
                        continue;
                    }
                    var slot = this.skeleton.findSlot(slotName);
                    if (slot != null) {
                        this.separatorSlots.add(slot);
                    }
                }
                this.UpdateSeparatorPartParents();
            },
            /*Spine.Unity.SkeletonGraphic.ReapplySeparatorSlotNames end.*/

            /*Spine.Unity.SkeletonGraphic.GetLastMesh start.*/
            GetLastMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#GetLastMesh", this ); }

                return this.meshBuffers.GetCurrent().mesh;
            },
            /*Spine.Unity.SkeletonGraphic.GetLastMesh end.*/

            /*Spine.Unity.SkeletonGraphic.MatchRectTransformWithBounds start.*/
            MatchRectTransformWithBounds: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MatchRectTransformWithBounds", this ); }

                if (!this.wasUpdatedAfterInit) {
                    this.Update$1(0);
                }
                this.UpdateMesh();

                if (!this.allowMultipleCanvasRenderers) {
                    return this.MatchRectTransformSingleRenderer();
                } else {
                    return this.MatchRectTransformMultipleRenderers();
                }
            },
            /*Spine.Unity.SkeletonGraphic.MatchRectTransformWithBounds end.*/

            /*Spine.Unity.SkeletonGraphic.MatchRectTransformSingleRenderer start.*/
            MatchRectTransformSingleRenderer: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MatchRectTransformSingleRenderer", this ); }

                var mesh = this.GetLastMesh();
                if (mesh == null) {
                    return false;
                }
                if (mesh.vertexCount === 0 || pc.Vec3.equals( mesh.bounds.halfExtents.$clone().scale( 2 ), pc.Vec3.ZERO.clone() )) {
                    this.rectTransform.sizeDelta = new pc.Vec2( 50.0, 50.0 );
                    this.rectTransform.pivot = new pc.Vec2( 0.5, 0.5 );
                    return false;
                }
                mesh.RecalculateBounds();
                this.SetRectTransformBounds(mesh.bounds);
                return true;
            },
            /*Spine.Unity.SkeletonGraphic.MatchRectTransformSingleRenderer end.*/

            /*Spine.Unity.SkeletonGraphic.MatchRectTransformMultipleRenderers start.*/
            MatchRectTransformMultipleRenderers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MatchRectTransformMultipleRenderers", this ); }

                var $t;
                var anyBoundsAdded = false;
                var combinedBounds = new pc.BoundingBox.ctor();
                for (var i = 0; i < this.canvasRenderers.Count; i = (i + 1) | 0) {
                    var canvasRenderer = this.canvasRenderers.getItem(i);
                    if (!canvasRenderer.gameObject.activeSelf) {
                        continue;
                    }

                    var mesh = ($t = this.meshes.Items)[i];
                    if (mesh == null || mesh.vertexCount === 0) {
                        continue;
                    }

                    mesh.RecalculateBounds();
                    var bounds = mesh.bounds;
                    if (anyBoundsAdded) {
                        combinedBounds.add( bounds );
                    } else {
                        anyBoundsAdded = true;
                        combinedBounds = bounds;
                    }
                }

                if (!anyBoundsAdded || pc.Vec3.equals( combinedBounds.halfExtents.$clone().scale( 2 ), pc.Vec3.ZERO.clone() )) {
                    this.rectTransform.sizeDelta = new pc.Vec2( 50.0, 50.0 );
                    this.rectTransform.pivot = new pc.Vec2( 0.5, 0.5 );
                    return false;
                }

                this.SetRectTransformBounds(combinedBounds);
                return true;
            },
            /*Spine.Unity.SkeletonGraphic.MatchRectTransformMultipleRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.SetRectTransformBounds start.*/
            SetRectTransformBounds: function (combinedBounds) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SetRectTransformBounds", this ); }

                var $t, $t1;
                var size = combinedBounds.halfExtents.$clone().scale( 2 ).$clone();
                var center = combinedBounds.center.$clone();
                var p = new pc.Vec2( 0.5 - (center.x / size.x), 0.5 - (center.y / size.y) );

                Spine.Unity.SkeletonGraphic.SetRectTransformSize$1(this, UnityEngine.Vector2.FromVector3(size));
                this.rectTransform.pivot = p.$clone();

                $t = Bridge.getEnumerator(this.separatorParts);
                try {
                    while ($t.moveNext()) {
                        var separatorPart = $t.Current;
                        var separatorTransform = separatorPart.GetComponent(UnityEngine.RectTransform);
                        if (UnityEngine.Object.op_Implicit(separatorTransform)) {
                            Spine.Unity.SkeletonGraphic.SetRectTransformSize(separatorTransform, UnityEngine.Vector2.FromVector3(size));
                            separatorTransform.pivot = p.$clone();
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                $t1 = Bridge.getEnumerator(this.submeshGraphics);
                try {
                    while ($t1.moveNext()) {
                        var submeshGraphic = $t1.Current;
                        Spine.Unity.SkeletonGraphic.SetRectTransformSize$1(submeshGraphic, UnityEngine.Vector2.FromVector3(size));
                        submeshGraphic.rectTransform.pivot = p.$clone();
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }

                this.referenceSize = UnityEngine.Vector2.FromVector3(size.$clone());
            },
            /*Spine.Unity.SkeletonGraphic.SetRectTransformBounds end.*/

            /*Spine.Unity.SkeletonGraphic.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Clear", this ); }

                this.skeleton = null;
                this.canvasRenderer.Clear();

                for (var i = 0; i < this.canvasRenderers.Count; i = (i + 1) | 0) {
                    this.canvasRenderers.getItem(i).Clear();
                }
                this.DestroyMeshes();
                this.usedMaterials.Clear();
                this.usedTextures.Clear();
                this.DisposeMeshBuffers();
            },
            /*Spine.Unity.SkeletonGraphic.Clear end.*/

            /*Spine.Unity.SkeletonGraphic.TrimRenderers start.*/
            TrimRenderers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#TrimRenderers", this ); }

                var $t;
                var newList = new (System.Collections.Generic.List$1(UnityEngine.CanvasRenderer)).ctor();
                $t = Bridge.getEnumerator(this.canvasRenderers);
                try {
                    while ($t.moveNext()) {
                        var canvasRenderer = $t.Current;
                        if (canvasRenderer.gameObject.activeSelf) {
                            newList.add(canvasRenderer);
                        } else {
                            if (UnityEngine.Application.isEditor && !UnityEngine.Application.isPlaying) {
                                UnityEngine.Object.DestroyImmediate(canvasRenderer.gameObject);
                            } else {
                                UnityEngine.MonoBehaviour.Destroy(canvasRenderer.gameObject);
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.canvasRenderers = newList;
                this.SyncSubmeshGraphicsWithCanvasRenderers();
            },
            /*Spine.Unity.SkeletonGraphic.TrimRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.Initialize start.*/
            Initialize: function (overwrite) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Initialize", this ); }

                var $t, $t1;
                if (this.IsValid && !overwrite) {
                    return;
                }
                if (this.skeletonDataAsset == null) {
                    return;
                }
                var skeletonData = this.skeletonDataAsset.GetSkeletonData(false);
                if (skeletonData == null) {
                    return;
                }

                if (this.skeletonDataAsset.atlasAssets.length <= 0 || ($t = this.skeletonDataAsset.atlasAssets)[0].MaterialCount <= 0) {
                    return;
                }

                this.skeleton = ($t1 = new Spine.Skeleton.$ctor1(skeletonData), $t1.scaleX = this.initialFlipX ? -1 : 1, $t1.scaleY = this.initialFlipY ? -1 : 1, $t1);

                this.InitMeshBuffers();
                this.baseTexture = ($t1 = this.skeletonDataAsset.atlasAssets)[0].PrimaryMaterial.mainTexture;
                this.canvasRenderer.SetTexture(this.mainTexture); // Needed for overwriting initializations.

                // Set the initial Skin and Animation
                if (!System.String.isNullOrEmpty(this.initialSkinName)) {
                    this.skeleton.setSkinByName(this.initialSkinName);
                }

                this.separatorSlots.clear();
                for (var i = 0; i < this.separatorSlotNames.length; i = (i + 1) | 0) {
                    this.separatorSlots.add(this.skeleton.findSlot(this.separatorSlotNames[i]));
                }

                if (!Bridge.staticEquals(this.OnRebuild, null)) {
                    this.OnRebuild(this);
                }

                this.wasUpdatedAfterInit = false;
                this.state = new Spine.AnimationState(this.skeletonDataAsset.GetAnimationStateData());
                if (this.state == null) {
                    this.Clear();
                    return;
                }

                if (!System.String.isNullOrEmpty(this.startingAnimation)) {
                    var animationObject = this.skeletonDataAsset.GetSkeletonData(false).findAnimation(this.startingAnimation);
                    if (animationObject != null) {
                        this.state.setAnimationWith( 0, animationObject, this.startingLoop );
                    }
                }

                if (!Bridge.staticEquals(this.OnAnimationRebuild, null)) {
                    this.OnAnimationRebuild(this);
                }
            },
            /*Spine.Unity.SkeletonGraphic.Initialize end.*/

            /*Spine.Unity.SkeletonGraphic.PrepareInstructionsAndRenderers start.*/
            PrepareInstructionsAndRenderers: function (isInRebuild) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#PrepareInstructionsAndRenderers", this ); }

                if (isInRebuild === void 0) { isInRebuild = false; }
                if (!this.allowMultipleCanvasRenderers) {
                    Spine.Unity.MeshGenerator.GenerateSingleSubmeshInstruction(this.currentInstructions, this.skeleton, null);
                    if (this.canvasRenderers.Count > 0) {
                        this.DisableUnusedCanvasRenderers(0, isInRebuild);
                    }
                    this.usedRenderersCount = 0;
                } else {
                    Spine.Unity.MeshGenerator.GenerateSkeletonRendererInstruction(this.currentInstructions, this.skeleton, null, this.enableSeparatorSlots ? this.separatorSlots : null, this.enableSeparatorSlots ? this.separatorSlots.Count > 0 : false, false);

                    var submeshCount = this.currentInstructions.submeshInstructions.Count;
                    this.EnsureCanvasRendererCount(submeshCount);
                    this.EnsureMeshesCount(submeshCount);
                    this.EnsureUsedTexturesAndMaterialsCount(submeshCount);
                    this.EnsureSeparatorPartCount();
                    this.PrepareRendererGameObjects(this.currentInstructions, isInRebuild);
                }
                if (!Bridge.staticEquals(this.OnInstructionsPrepared, null)) {
                    this.OnInstructionsPrepared(this.currentInstructions);
                }
            },
            /*Spine.Unity.SkeletonGraphic.PrepareInstructionsAndRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateMesh start.*/
            UpdateMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMesh", this ); }

                this.PrepareInstructionsAndRenderers();
                this.UpdateMeshToInstructions();
            },
            /*Spine.Unity.SkeletonGraphic.UpdateMesh end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateMeshToInstructions start.*/
            UpdateMeshToInstructions: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMeshToInstructions", this ); }

                if (!this.IsValid || this.currentInstructions.rawVertexCount < 0) {
                    return;
                }
                Spine.Unity.SkeletonExtensions.SetColor$4(this.skeleton, this.color.$clone());

                if (!this.allowMultipleCanvasRenderers) {
                    this.UpdateMeshSingleCanvasRenderer(this.currentInstructions);
                } else {
                    this.UpdateMaterialsMultipleCanvasRenderers(this.currentInstructions);
                    this.UpdateMeshMultipleCanvasRenderers(this.currentInstructions);
                }

                if (!Bridge.staticEquals(this.OnMeshAndMaterialsUpdated, null)) {
                    this.OnMeshAndMaterialsUpdated(this);
                }
            },
            /*Spine.Unity.SkeletonGraphic.UpdateMeshToInstructions end.*/

            /*Spine.Unity.SkeletonGraphic.HasMultipleSubmeshInstructions start.*/
            HasMultipleSubmeshInstructions: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#HasMultipleSubmeshInstructions", this ); }

                if (!this.IsValid) {
                    return false;
                }
                return Spine.Unity.MeshGenerator.RequiresMultipleSubmeshesByDrawOrder(this.skeleton);
            },
            /*Spine.Unity.SkeletonGraphic.HasMultipleSubmeshInstructions end.*/

            /*Spine.Unity.SkeletonGraphic.InitMeshBuffers start.*/
            InitMeshBuffers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#InitMeshBuffers", this ); }

                if (this.meshBuffers != null) {
                    this.meshBuffers.GetNext().Clear();
                    this.meshBuffers.GetNext().Clear();
                } else {
                    this.meshBuffers = new (Spine.Unity.DoubleBuffered$1(Spine.Unity.MeshRendererBuffers.SmartMesh))();
                }
            },
            /*Spine.Unity.SkeletonGraphic.InitMeshBuffers end.*/

            /*Spine.Unity.SkeletonGraphic.DisposeMeshBuffers start.*/
            DisposeMeshBuffers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#DisposeMeshBuffers", this ); }

                if (this.meshBuffers != null) {
                    this.meshBuffers.GetNext().Dispose();
                    this.meshBuffers.GetNext().Dispose();
                    this.meshBuffers = null;
                }
            },
            /*Spine.Unity.SkeletonGraphic.DisposeMeshBuffers end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateMeshSingleCanvasRenderer start.*/
            UpdateMeshSingleCanvasRenderer: function (currentInstructions) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMeshSingleCanvasRenderer", this ); }

                var $t, $t1;
                var smartMesh = this.meshBuffers.GetNext();
                var updateTriangles = Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual(currentInstructions, smartMesh.instructionUsed);
                this.meshGenerator.Begin();

                var useAddSubmesh = currentInstructions.hasActiveClipping && currentInstructions.submeshInstructions.Count > 0;
                if (useAddSubmesh) {
                    this.meshGenerator.AddSubmesh(($t = currentInstructions.submeshInstructions.Items)[0], updateTriangles);
                } else {
                    this.meshGenerator.BuildMeshWithArrays(currentInstructions, updateTriangles);
                }

                this.meshScale = (UnityEngine.Component.op_Equality(this.canvas, null)) ? 100 : this.canvas.referencePixelsPerUnit;
                if (this.layoutScaleMode !== Spine.Unity.SkeletonGraphic.LayoutMode.None) {
                    this.meshScale *= this.referenceScale;
                    if (true) {
                        this.meshScale *= this.GetLayoutScale(this.layoutScaleMode);
                    }
                }
                this.meshGenerator.ScaleVertexData(this.meshScale);
                if (!Bridge.staticEquals(this.OnPostProcessVertices, null)) {
                    this.OnPostProcessVertices(this.meshGenerator.Buffers.$clone());
                }

                var mesh = smartMesh.mesh;
                this.meshGenerator.FillVertexData(mesh);
                if (updateTriangles) {
                    this.meshGenerator.FillTriangles(mesh);
                }
                this.meshGenerator.FillLateVertexData(mesh);

                smartMesh.instructionUsed.Set(currentInstructions);
                if (!Bridge.staticEquals(this.assignMeshOverrideSingle, null)) {
                    this.assignMeshOverrideSingle(mesh, this.canvasRenderer.GetMaterial(), this.mainTexture);
                }

                var assignAtCanvasRenderer = (Bridge.staticEquals(this.assignMeshOverrideSingle, null) || !this.disableMeshAssignmentOnOverride);
                if (assignAtCanvasRenderer) {
                    this.canvasRenderer.SetMesh(mesh);
                } else {
                    this.canvasRenderer.SetMesh(null);
                }

                var assignTexture = false;
                if (currentInstructions.submeshInstructions.Count > 0) {
                    var material = ($t1 = currentInstructions.submeshInstructions.Items)[0].material;
                    if (material != null && !Bridge.referenceEquals(this.baseTexture, material.mainTexture)) {
                        this.baseTexture = material.mainTexture;
                        if (this.overrideTexture == null && assignAtCanvasRenderer) {
                            assignTexture = true;
                        }
                    }
                }

                if (UnityEngine.Application.isPlaying) {
                    this.HandleOnDemandLoading();
                }
                if (assignTexture) {
                    this.canvasRenderer.SetTexture(this.mainTexture);
                }
            },
            /*Spine.Unity.SkeletonGraphic.UpdateMeshSingleCanvasRenderer end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateMaterialsMultipleCanvasRenderers start.*/
            UpdateMaterialsMultipleCanvasRenderers: function (currentInstructions) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMaterialsMultipleCanvasRenderers", this ); }

                var $t;
                var submeshCount = currentInstructions.submeshInstructions.Count;
                var useOriginalTextureAndMaterial = (this.customMaterialOverride.Count === 0 && this.customTextureOverride.Count === 0);

                var blendModeMaterials = this.skeletonDataAsset.blendModeMaterials;
                var hasBlendModeMaterials = blendModeMaterials.RequiresBlendModeMaterials;

                var pmaVertexColors = this.meshGenerator.settings.pmaVertexColors;
                var usedMaterialItems = this.usedMaterials.Items;
                var usedTextureItems = this.usedTextures.Items;
                for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                    var submeshInstructionItem = ($t = currentInstructions.submeshInstructions.Items)[i].$clone();
                    var submeshMaterial = submeshInstructionItem.material;
                    if (useOriginalTextureAndMaterial) {
                        if (submeshMaterial == null) {
                            usedMaterialItems[i] = null;
                            usedTextureItems[i] = null;
                            continue;
                        }
                        usedTextureItems[i] = submeshMaterial.mainTexture;
                        if (!hasBlendModeMaterials) {
                            usedMaterialItems[i] = this.materialForRendering;
                        } else {
                            var blendMode = blendModeMaterials.BlendModeForMaterial(submeshMaterial);
                            var usedMaterial = this.materialForRendering;
                            if (blendMode === spine.BlendMode.Additive && !pmaVertexColors && UnityEngine.Object.op_Implicit(this.additiveMaterial)) {
                                usedMaterial = this.additiveMaterial;
                            } else if (blendMode === spine.BlendMode.Multiply && UnityEngine.Object.op_Implicit(this.multiplyMaterial)) {
                                usedMaterial = this.multiplyMaterial;
                            } else {
                                if (blendMode === spine.BlendMode.Screen && UnityEngine.Object.op_Implicit(this.screenMaterial)) {
                                    usedMaterial = this.screenMaterial;
                                }
                            }
                            usedMaterialItems[i] = this.submeshGraphics.getItem(i).GetModifiedMaterial(usedMaterial);
                        }
                    } else {
                        var originalTexture = submeshMaterial.mainTexture;
                        var usedMaterial1 = { };
                        var usedTexture = { };
                        if (!this.customMaterialOverride.tryGetValue(originalTexture, usedMaterial1)) {
                            usedMaterial1.v = this.material;
                        }
                        if (!this.customTextureOverride.tryGetValue(originalTexture, usedTexture)) {
                            usedTexture.v = originalTexture;
                        }

                        usedMaterialItems[i] = this.submeshGraphics.getItem(i).GetModifiedMaterial(usedMaterial1.v);
                        usedTextureItems[i] = usedTexture.v;
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.UpdateMaterialsMultipleCanvasRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateMeshMultipleCanvasRenderers start.*/
            UpdateMeshMultipleCanvasRenderers: function (currentInstructions) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMeshMultipleCanvasRenderers", this ); }

                var $t;
                this.meshScale = (UnityEngine.Component.op_Equality(this.canvas, null)) ? 100 : this.canvas.referencePixelsPerUnit;
                if (this.layoutScaleMode !== Spine.Unity.SkeletonGraphic.LayoutMode.None) {
                    this.meshScale *= this.referenceScale;
                    if (true) {
                        this.meshScale *= this.GetLayoutScale(this.layoutScaleMode);
                    }
                }
                // Generate meshes.
                var submeshCount = currentInstructions.submeshInstructions.Count;
                var meshesItems = this.meshes.Items;
                var useOriginalTextureAndMaterial = (this.customMaterialOverride.Count === 0 && this.customTextureOverride.Count === 0);

                var blendModeMaterials = this.skeletonDataAsset.blendModeMaterials;
                var hasBlendModeMaterials = blendModeMaterials.RequiresBlendModeMaterials;
                var mainCullTransparentMesh = this.canvasRenderer.cullTransparentMesh;
                var pmaVertexColors = this.meshGenerator.settings.pmaVertexColors;
                var usedMaterialItems = this.usedMaterials.Items;
                var usedTextureItems = this.usedTextures.Items;
                for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                    var submeshInstructionItem = ($t = currentInstructions.submeshInstructions.Items)[i].$clone();
                    this.meshGenerator.Begin();
                    this.meshGenerator.AddSubmesh(submeshInstructionItem);

                    var targetMesh = meshesItems[i];
                    this.meshGenerator.ScaleVertexData(this.meshScale);
                    if (!Bridge.staticEquals(this.OnPostProcessVertices, null)) {
                        this.OnPostProcessVertices(this.meshGenerator.Buffers.$clone());
                    }
                    this.meshGenerator.FillVertexData(targetMesh);
                    this.meshGenerator.FillTriangles(targetMesh);
                    this.meshGenerator.FillLateVertexData(targetMesh);

                    var canvasRenderer = this.canvasRenderers.getItem(i);
                    if (Bridge.staticEquals(this.assignMeshOverrideSingle, null) || !this.disableMeshAssignmentOnOverride) {
                        canvasRenderer.SetMesh(targetMesh);
                    } else {
                        canvasRenderer.SetMesh(null);
                    }

                    var submeshGraphic = this.submeshGraphics.getItem(i);
                    if (useOriginalTextureAndMaterial && hasBlendModeMaterials) {
                        var allowCullTransparentMesh = true;
                        var materialBlendMode = blendModeMaterials.BlendModeForMaterial(usedMaterialItems[i]);
                        if ((materialBlendMode === spine.BlendMode.Normal && submeshInstructionItem.hasPMAAdditiveSlot) || (materialBlendMode === spine.BlendMode.Additive && pmaVertexColors)) {
                            allowCullTransparentMesh = false;
                        }
                        canvasRenderer.cullTransparentMesh = allowCullTransparentMesh ? mainCullTransparentMesh : false;
                    }
                    canvasRenderer.materialCount = 1;
                }

                if (UnityEngine.Application.isPlaying) {
                    this.HandleOnDemandLoading();
                }
                var assignAtCanvasRenderer = (Bridge.staticEquals(this.assignMeshOverrideSingle, null) || !this.disableMeshAssignmentOnOverride);
                if (assignAtCanvasRenderer) {
                    for (var i1 = 0; i1 < submeshCount; i1 = (i1 + 1) | 0) {
                        var canvasRenderer1 = this.canvasRenderers.getItem(i1);
                        canvasRenderer1.SetMaterial$1(usedMaterialItems[i1], usedTextureItems[i1]);
                    }
                }

                if (!Bridge.staticEquals(this.assignMeshOverrideMultiple, null)) {
                    this.assignMeshOverrideMultiple(submeshCount, meshesItems, usedMaterialItems, usedTextureItems);
                }
            },
            /*Spine.Unity.SkeletonGraphic.UpdateMeshMultipleCanvasRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.HandleOnDemandLoading start.*/
            HandleOnDemandLoading: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#HandleOnDemandLoading", this ); }

                var $t, $t1;
                $t = Bridge.getEnumerator(this.skeletonDataAsset.atlasAssets);
                try {
                    while ($t.moveNext()) {
                        var atlasAsset = $t.Current;
                        if (atlasAsset.TextureLoadingMode !== Spine.Unity.AtlasAssetBase.LoadingMode.Normal) {
                            atlasAsset.BeginCustomTextureLoading();

                            if (!this.allowMultipleCanvasRenderers) {
                                var loadedTexture = { v : null };
                                atlasAsset.RequireTextureLoaded(this.mainTexture, loadedTexture, null);
                                if (UnityEngine.Object.op_Implicit(loadedTexture.v)) {
                                    this.baseTexture = loadedTexture.v;
                                }
                            } else {
                                var textureItems = this.usedTextures.Items;
                                for (var i = 0, count = this.usedTextures.Count; i < count; i = (i + 1) | 0) {
                                    var loadedTexture1 = { v : null };
                                    atlasAsset.RequireTextureLoaded(textureItems[i], loadedTexture1, null);
                                    if (UnityEngine.Object.op_Implicit(loadedTexture1.v)) {
                                        ($t1 = this.usedTextures.Items)[i] = loadedTexture1.v;
                                    }
                                }
                            }
                            atlasAsset.EndCustomTextureLoading();
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.HandleOnDemandLoading end.*/

            /*Spine.Unity.SkeletonGraphic.EnsureCanvasRendererCount start.*/
            EnsureCanvasRendererCount: function (targetCount) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#EnsureCanvasRendererCount", this ); }

                var currentCount = this.canvasRenderers.Count;
                for (var i = currentCount; i < targetCount; i = (i + 1) | 0) {
                    var go = new UnityEngine.GameObject.$ctor3(System.String.format("Renderer{0}", [Bridge.box(i, System.Int32)]), UnityEngine.RectTransform);
                    go.transform.SetParent(this.transform, false);
                    go.transform.localPosition = pc.Vec3.ZERO.clone();
                    var canvasRenderer = go.AddComponent(UnityEngine.CanvasRenderer);
                    this.canvasRenderers.add(canvasRenderer);
                    var submeshGraphic = go.AddComponent(Spine.Unity.SkeletonSubmeshGraphic);
                    submeshGraphic.maskable = this.maskable;
                    submeshGraphic.raycastTarget = false;
                    submeshGraphic.rectTransform.pivot = this.rectTransform.pivot.$clone();
                    submeshGraphic.rectTransform.anchorMin = pc.Vec2.ZERO.clone();
                    submeshGraphic.rectTransform.anchorMax = pc.Vec2.ONE.clone();
                    submeshGraphic.rectTransform.sizeDelta = pc.Vec2.ZERO.clone();
                    this.submeshGraphics.add(submeshGraphic);
                }
            },
            /*Spine.Unity.SkeletonGraphic.EnsureCanvasRendererCount end.*/

            /*Spine.Unity.SkeletonGraphic.PrepareRendererGameObjects start.*/
            PrepareRendererGameObjects: function (currentInstructions, isInRebuild) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#PrepareRendererGameObjects", this ); }

                var $t;
                if (isInRebuild === void 0) { isInRebuild = false; }

                var submeshCount = currentInstructions.submeshInstructions.Count;
                this.DisableUnusedCanvasRenderers(submeshCount, isInRebuild);

                var parent = this.separatorParts.Count === 0 ? this.transform : this.separatorParts.getItem(0);
                if (this.updateSeparatorPartLocation) {
                    for (var p = 0; p < this.separatorParts.Count; p = (p + 1) | 0) {
                        var separatorPart = this.separatorParts.getItem(p);
                        if (UnityEngine.Component.op_Equality(separatorPart, null)) {
                            continue;
                        }
                        separatorPart.position = this.transform.position.$clone();
                        separatorPart.rotation = this.transform.rotation.$clone();
                    }
                }
                if (this.updateSeparatorPartScale) {
                    var targetScale = this.transform.lossyScale.$clone();
                    for (var p1 = 0; p1 < this.separatorParts.Count; p1 = (p1 + 1) | 0) {
                        var separatorPart1 = this.separatorParts.getItem(p1);
                        if (UnityEngine.Component.op_Equality(separatorPart1, null)) {
                            continue;
                        }
                        var partParent = separatorPart1.parent;
                        var parentScale = UnityEngine.Component.op_Equality(partParent, null) ? new pc.Vec3( 1, 1, 1 ) : partParent.lossyScale.$clone();
                        separatorPart1.localScale = new pc.Vec3( parentScale.x === 0.0 ? 1.0 : targetScale.x / parentScale.x, parentScale.y === 0.0 ? 1.0 : targetScale.y / parentScale.y, parentScale.z === 0.0 ? 1.0 : targetScale.z / parentScale.z );
                    }
                }

                var separatorSlotGroupIndex = 0;
                var targetSiblingIndex = 0;
                for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                    var canvasRenderer = this.canvasRenderers.getItem(i);
                    if (UnityEngine.Component.op_Inequality(canvasRenderer, null)) {
                        if (i >= this.usedRenderersCount) {
                            canvasRenderer.gameObject.SetActive(true);
                        }

                        if (UnityEngine.Component.op_Inequality(canvasRenderer.transform.parent, parent.transform) && !isInRebuild) {
                            canvasRenderer.transform.SetParent(parent.transform, false);
                        }

                        canvasRenderer.transform.SetSiblingIndex(Bridge.identity(targetSiblingIndex, ((targetSiblingIndex = (targetSiblingIndex + 1) | 0))));
                    }

                    var submeshGraphic = this.submeshGraphics.getItem(i);
                    if (UnityEngine.MonoBehaviour.op_Inequality(submeshGraphic, null)) {
                        var dstTransform = submeshGraphic.rectTransform;
                        dstTransform.localPosition = pc.Vec3.ZERO.clone();
                        dstTransform.pivot = this.rectTransform.pivot.$clone();
                        dstTransform.anchorMin = pc.Vec2.ZERO.clone();
                        dstTransform.anchorMax = pc.Vec2.ONE.clone();
                        dstTransform.sizeDelta = pc.Vec2.ZERO.clone();
                    }

                    var submeshInstructionItem = ($t = currentInstructions.submeshInstructions.Items)[i].$clone();
                    if (submeshInstructionItem.forceSeparate) {
                        targetSiblingIndex = 0;
                        parent = this.separatorParts.getItem(((separatorSlotGroupIndex = (separatorSlotGroupIndex + 1) | 0)));
                    }
                }
                this.usedRenderersCount = submeshCount;
            },
            /*Spine.Unity.SkeletonGraphic.PrepareRendererGameObjects end.*/

            /*Spine.Unity.SkeletonGraphic.DisableUnusedCanvasRenderers start.*/
            DisableUnusedCanvasRenderers: function (usedCount, isInRebuild) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#DisableUnusedCanvasRenderers", this ); }

                if (isInRebuild === void 0) { isInRebuild = false; }
                for (var i = usedCount; i < this.canvasRenderers.Count; i = (i + 1) | 0) {
                    this.canvasRenderers.getItem(i).Clear();
                    if (!isInRebuild) {
                        this.canvasRenderers.getItem(i).gameObject.SetActive(false);
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.DisableUnusedCanvasRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.EnsureMeshesCount start.*/
            EnsureMeshesCount: function (targetCount) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#EnsureMeshesCount", this ); }

                var oldCount = this.meshes.Count;
                this.meshes.EnsureCapacity(targetCount);
                for (var i = oldCount; i < targetCount; i = (i + 1) | 0) {
                    this.meshes.Add(Spine.Unity.SpineMesh.NewSkeletonMesh());
                }
            },
            /*Spine.Unity.SkeletonGraphic.EnsureMeshesCount end.*/

            /*Spine.Unity.SkeletonGraphic.EnsureUsedTexturesAndMaterialsCount start.*/
            EnsureUsedTexturesAndMaterialsCount: function (targetCount) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#EnsureUsedTexturesAndMaterialsCount", this ); }

                var oldCount = this.usedMaterials.Count;
                this.usedMaterials.EnsureCapacity(targetCount);
                this.usedTextures.EnsureCapacity(targetCount);
                for (var i = oldCount; i < targetCount; i = (i + 1) | 0) {
                    this.usedMaterials.Add(null);
                    this.usedTextures.Add(null);
                }
            },
            /*Spine.Unity.SkeletonGraphic.EnsureUsedTexturesAndMaterialsCount end.*/

            /*Spine.Unity.SkeletonGraphic.DestroyMeshes start.*/
            DestroyMeshes: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#DestroyMeshes", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.meshes);
                try {
                    while ($t.moveNext()) {
                        var mesh = $t.Current;
                        UnityEngine.Object.Destroy(mesh);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.meshes.Clear();
            },
            /*Spine.Unity.SkeletonGraphic.DestroyMeshes end.*/

            /*Spine.Unity.SkeletonGraphic.EnsureSeparatorPartCount start.*/
            EnsureSeparatorPartCount: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#EnsureSeparatorPartCount", this ); }

                var targetCount = (this.separatorSlots.Count + 1) | 0;
                if (targetCount === 1) {
                    return;
                }

                var currentCount = this.separatorParts.Count;
                for (var i = currentCount; i < targetCount; i = (i + 1) | 0) {
                    var go = new UnityEngine.GameObject.$ctor3(System.String.format("{0}[{1}]", Spine.Unity.SkeletonGraphic.SeparatorPartGameObjectName, Bridge.box(i, System.Int32)), UnityEngine.RectTransform);
                    go.transform.SetParent(this.transform, false);

                    var dstTransform = go.transform.GetComponent(UnityEngine.RectTransform);
                    dstTransform.localPosition = pc.Vec3.ZERO.clone();
                    dstTransform.pivot = this.rectTransform.pivot.$clone();
                    dstTransform.anchorMin = pc.Vec2.ZERO.clone();
                    dstTransform.anchorMax = pc.Vec2.ONE.clone();
                    dstTransform.sizeDelta = pc.Vec2.ZERO.clone();

                    this.separatorParts.add(go.transform);
                }
            },
            /*Spine.Unity.SkeletonGraphic.EnsureSeparatorPartCount end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateSeparatorPartParents start.*/
            UpdateSeparatorPartParents: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateSeparatorPartParents", this ); }

                var usedCount = (this.separatorSlots.Count + 1) | 0;
                if (usedCount === 1) {
                    usedCount = 0; // placed directly at the SkeletonGraphic parent
                    for (var i = 0; i < this.canvasRenderers.Count; i = (i + 1) | 0) {
                        var canvasRenderer = this.canvasRenderers.getItem(i);
                        if (System.String.contains(canvasRenderer.transform.parent.name,Spine.Unity.SkeletonGraphic.SeparatorPartGameObjectName)) {
                            canvasRenderer.transform.SetParent(this.transform, false);
                            canvasRenderer.transform.localPosition = pc.Vec3.ZERO.clone();
                        }
                    }
                }
                for (var i1 = 0; i1 < this.separatorParts.Count; i1 = (i1 + 1) | 0) {
                    var isUsed = i1 < usedCount;
                    this.separatorParts.getItem(i1).gameObject.SetActive(isUsed);
                }
            },
            /*Spine.Unity.SkeletonGraphic.UpdateSeparatorPartParents end.*/

            /*Spine.Unity.SkeletonGraphic.GetLayoutScale start.*/
            GetLayoutScale: function (mode) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#GetLayoutScale", this ); }

                var currentSize = this.GetCurrentRectSize();
                var referenceAspect = this.referenceSize.x / this.referenceSize.y;
                var frameAspect = currentSize.x / currentSize.y;
                if (mode === Spine.Unity.SkeletonGraphic.LayoutMode.FitInParent) {
                    mode = frameAspect > referenceAspect ? Spine.Unity.SkeletonGraphic.LayoutMode.HeightControlsWidth : Spine.Unity.SkeletonGraphic.LayoutMode.WidthControlsHeight;
                } else {
                    if (mode === Spine.Unity.SkeletonGraphic.LayoutMode.EnvelopeParent) {
                        mode = frameAspect > referenceAspect ? Spine.Unity.SkeletonGraphic.LayoutMode.WidthControlsHeight : Spine.Unity.SkeletonGraphic.LayoutMode.HeightControlsWidth;
                    }
                }

                if (mode === Spine.Unity.SkeletonGraphic.LayoutMode.WidthControlsHeight) {
                    return currentSize.x / this.referenceSize.x;
                } else if (mode === Spine.Unity.SkeletonGraphic.LayoutMode.HeightControlsWidth) {
                    return currentSize.y / this.referenceSize.y;
                }
                return 1.0;
            },
            /*Spine.Unity.SkeletonGraphic.GetLayoutScale end.*/

            /*Spine.Unity.SkeletonGraphic.GetCurrentRectSize start.*/
            GetCurrentRectSize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#GetCurrentRectSize", this ); }

                return this.rectTransform.rect.size.$clone();
            },
            /*Spine.Unity.SkeletonGraphic.GetCurrentRectSize end.*/


        },
        overloads: {
            "Update(float)": "Update$1"
        }
    });
    /*Spine.Unity.SkeletonGraphic end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.UpdateBonesDelegate
     * @param   {Spine.Unity.ISkeletonAnimation}    animated
     * @return  {void}
     */


    /*Spine.Unity.SkeletonAnimation start.*/
    Bridge.define("Spine.Unity.SkeletonAnimation", {
        inherits: [Spine.Unity.SkeletonRenderer,Spine.Unity.ISkeletonAnimation,Spine.Unity.IAnimationStateComponent],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonAnimation.AddToGameObject:static start.*/
                /**
                 * Adds and prepares a SkeletonAnimation component to a GameObject at runtime.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonAnimation
                 * @memberof Spine.Unity.SkeletonAnimation
                 * @param   {UnityEngine.GameObject}           gameObject           
                 * @param   {Spine.Unity.SkeletonDataAsset}    skeletonDataAsset    
                 * @param   {boolean}                          quiet
                 * @return  {Spine.Unity.SkeletonAnimation}                         The newly instantiated SkeletonAnimation
                 */
                AddToGameObject: function (gameObject, skeletonDataAsset, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#AddToGameObject", this ); }

                    if (quiet === void 0) { quiet = false; }
                    return Spine.Unity.SkeletonRenderer.AddSpineComponent(Spine.Unity.SkeletonAnimation, gameObject, skeletonDataAsset, quiet);
                },
                /*Spine.Unity.SkeletonAnimation.AddToGameObject:static end.*/

                /*Spine.Unity.SkeletonAnimation.NewSkeletonAnimationGameObject:static start.*/
                /**
                 * Instantiates a new UnityEngine.GameObject and adds a prepared SkeletonAnimation component to it.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonAnimation
                 * @memberof Spine.Unity.SkeletonAnimation
                 * @param   {Spine.Unity.SkeletonDataAsset}    skeletonDataAsset    
                 * @param   {boolean}                          quiet
                 * @return  {Spine.Unity.SkeletonAnimation}                         The newly instantiated SkeletonAnimation component.
                 */
                NewSkeletonAnimationGameObject: function (skeletonDataAsset, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#NewSkeletonAnimationGameObject", this ); }

                    if (quiet === void 0) { quiet = false; }
                    return Spine.Unity.SkeletonRenderer.NewSpineGameObject(Spine.Unity.SkeletonAnimation, skeletonDataAsset, quiet);
                },
                /*Spine.Unity.SkeletonAnimation.NewSkeletonAnimationGameObject:static end.*/


            }
        },
        fields: {
            /**
             * This is the Spine.AnimationState object of this SkeletonAnimation. You can control animations through it.
             Note that this object, like .skeleton, is not guaranteed to exist in Awake. Do all accesses and caching to it in Start
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @type Spine.AnimationState
             */
            state: null,
            wasUpdatedAfterInit: false,
            updateTiming: 0,
            /**
             * If enabled, AnimationState uses unscaled game time
             (<pre><code>Time.unscaledDeltaTime</code></pre> instead of normal game time(<pre><code>Time.deltaTime</code></pre>),
             running animations independent of e.g. game pause (<pre><code>Time.timeScale</code></pre>).
             Instance SkeletonAnimation.timeScale will still be applied.
             *
             * @instance
             * @protected
             * @memberof Spine.Unity.SkeletonAnimation
             * @type boolean
             */
            unscaledTime: false,
            _animationName: null,
            /**
             * Whether or not {@link } should loop. This only applies to the initial animation specified in the inspector, or any subsequent Animations played through .AnimationName. Animations set through state.SetAnimation are unaffected.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @type boolean
             */
            loop: false,
            /**
             * The rate at which animations progress over time. 1 means 100%. 0.5 means 50%.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @default 1
             * @type number
             */
            timeScale: 0
        },
        events: {
            _OnAnimationRebuild: null,
            _BeforeApply: null,
            _UpdateLocal: null,
            _UpdateWorld: null,
            _UpdateComplete: null
        },
        props: {
            /**
             * This is the Spine.AnimationState object of this SkeletonAnimation. You can control animations through it.
             Note that this object, like .skeleton, is not guaranteed to exist in Awake. Do all accesses and caching to it in Start
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonAnimation
             * @function AnimationState
             * @type Spine.AnimationState
             */
            AnimationState: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#AnimationState#get", this ); }

                    this.Initialize(false);
                    return this.state;
                }
            },
            UpdateTiming: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#UpdateTiming#get", this ); }

                    return this.updateTiming;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#UpdateTiming#set", this ); }

                    this.updateTiming = value;
                }
            },
            UnscaledTime: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#UnscaledTime#get", this ); }

                    return this.unscaledTime;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#UnscaledTime#set", this ); }

                    this.unscaledTime = value;
                }
            },
            /**
             * Setting this property sets the animation of the skeleton. If invalid, it will store the animation name for the next time the skeleton is properly initialized.
             Getting this property gets the name of the currently playing animation. If invalid, it will return the last stored animation name set through this property.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @function AnimationName
             * @type string
             */
            AnimationName: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#AnimationName#get", this ); }

                    if (!this.valid) {
                        return this._animationName;
                    } else {
                        var entry = this.state.getCurrent(0);
                        return entry == null ? null : entry.animation.name;
                    }
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#AnimationName#set", this ); }

                    this.Initialize(false);
                    if (Bridge.referenceEquals(this._animationName, value)) {
                        var entry = this.state.getCurrent(0);
                        if (entry != null && entry.loop === this.loop) {
                            return;
                        }
                    }
                    this._animationName = value;

                    if (System.String.isNullOrEmpty(value)) {
                        this.state.clearTrack(0);
                    } else {
                        var animationObject = this.skeletonDataAsset.GetSkeletonData(false).findAnimation(value);
                        if (animationObject != null) {
                            this.state.setAnimationWith( 0, animationObject, this.loop );
                        }
                    }
                }
            }
        },
        alias: [
            "AnimationState", "Spine$Unity$IAnimationStateComponent$AnimationState",
            "addOnAnimationRebuild", "Spine$Unity$ISkeletonAnimation$addOnAnimationRebuild",
            "removeOnAnimationRebuild", "Spine$Unity$ISkeletonAnimation$removeOnAnimationRebuild",
            "addUpdateLocal", "Spine$Unity$ISkeletonAnimation$addUpdateLocal",
            "removeUpdateLocal", "Spine$Unity$ISkeletonAnimation$removeUpdateLocal",
            "addUpdateWorld", "Spine$Unity$ISkeletonAnimation$addUpdateWorld",
            "removeUpdateWorld", "Spine$Unity$ISkeletonAnimation$removeUpdateWorld",
            "addUpdateComplete", "Spine$Unity$ISkeletonAnimation$addUpdateComplete",
            "removeUpdateComplete", "Spine$Unity$ISkeletonAnimation$removeUpdateComplete",
            "UpdateTiming", "Spine$Unity$ISkeletonAnimation$UpdateTiming",
            "UnscaledTime", "Spine$Unity$IAnimationStateComponent$UnscaledTime",
            "Skeleton", "Spine$Unity$ISkeletonAnimation$Skeleton"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#init", this ); }

                this.wasUpdatedAfterInit = true;
                this.updateTiming = Spine.Unity.UpdateTiming.InUpdate;
                this.timeScale = 1;
            }
        },
        methods: {
            /**
             * OnAnimationRebuild is raised after the SkeletonAnimation component is successfully initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#OnAnimationRebuild
             * @return  {Spine.Unity.ISkeletonAnimationDelegate}
             */
            addOnAnimationRebuild: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#addOnAnimationRebuild", this ); }

                this.add_OnAnimationRebuild(value);
            },
            /**
             * OnAnimationRebuild is raised after the SkeletonAnimation component is successfully initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#OnAnimationRebuild
             * @return  {Spine.Unity.ISkeletonAnimationDelegate}
             */
            removeOnAnimationRebuild: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#removeOnAnimationRebuild", this ); }

                this.remove_OnAnimationRebuild(value);
            },
            /**
             * Occurs before the animations are applied.
             Use this callback when you want to change the skeleton state before animations are applied on top.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#BeforeApply
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addBeforeApply: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#addBeforeApply", this ); }

                this.add_BeforeApply(value);
            },
            /**
             * Occurs before the animations are applied.
             Use this callback when you want to change the skeleton state before animations are applied on top.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#BeforeApply
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeBeforeApply: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#removeBeforeApply", this ); }

                this.remove_BeforeApply(value);
            },
            /**
             * Occurs after the animations are applied and before world space values are resolved.
             Use this callback when you want to set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateLocal
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateLocal: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#addUpdateLocal", this ); }

                this.add_UpdateLocal(value);
            },
            /**
             * Occurs after the animations are applied and before world space values are resolved.
             Use this callback when you want to set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateLocal
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateLocal: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#removeUpdateLocal", this ); }

                this.remove_UpdateLocal(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Using this callback will cause the world space values to be solved an extra time.
             Use this callback if want to use bone world space values, and also set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateWorld
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateWorld: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#addUpdateWorld", this ); }

                this.add_UpdateWorld(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Using this callback will cause the world space values to be solved an extra time.
             Use this callback if want to use bone world space values, and also set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateWorld
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateWorld: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#removeUpdateWorld", this ); }

                this.remove_UpdateWorld(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Use this callback if you want to use bone world space values, but don't intend to modify bone local values.
             This callback can also be used when setting world position and the bone matrix.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateComplete
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateComplete: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#addUpdateComplete", this ); }

                this.add_UpdateComplete(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Use this callback if you want to use bone world space values, but don't intend to modify bone local values.
             This callback can also be used when setting world position and the bone matrix.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateComplete
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateComplete: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#removeUpdateComplete", this ); }

                this.remove_UpdateComplete(value);
            },
            /*Spine.Unity.SkeletonAnimation.ClearState start.*/
            /**
             * Clears the previously generated mesh, resets the skeleton's pose, and clears all previously active animations.
             *
             * @instance
             * @public
             * @override
             * @this Spine.Unity.SkeletonAnimation
             * @memberof Spine.Unity.SkeletonAnimation
             * @return  {void}
             */
            ClearState: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#ClearState", this ); }

                Spine.Unity.SkeletonRenderer.prototype.ClearState.call(this);
                if (this.state != null) {
                    this.state.clearTracks();
                }
            },
            /*Spine.Unity.SkeletonAnimation.ClearState end.*/

            /*Spine.Unity.SkeletonAnimation.Initialize start.*/
            /**
             * Initialize this component. Attempts to load the SkeletonData and creates the internal Spine objects and buffers.
             *
             * @instance
             * @public
             * @override
             * @this Spine.Unity.SkeletonAnimation
             * @memberof Spine.Unity.SkeletonAnimation
             * @param   {boolean}    overwrite    If set to <pre><code>true</code></pre>, force overwrite an already initialized object.
             * @param   {boolean}    quiet
             * @return  {void}
             */
            Initialize: function (overwrite, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#Initialize", this ); }

                if (quiet === void 0) { quiet = false; }
                if (this.valid && !overwrite) {
                    return;
                }
                this.state = null; // prevent applying leftover AnimationState
                Spine.Unity.SkeletonRenderer.prototype.Initialize.call(this, overwrite, quiet);

                if (!this.valid) {
                    return;
                }
                this.state = new Spine.AnimationState(this.skeletonDataAsset.GetAnimationStateData());
                this.wasUpdatedAfterInit = false;

                if (!System.String.isNullOrEmpty(this._animationName)) {
                    var animationObject = this.skeletonDataAsset.GetSkeletonData(false).findAnimation(this._animationName);
                    if (animationObject != null) {
                        this.state.setAnimationWith( 0, animationObject, this.loop );
                    }
                }

                if (!Bridge.staticEquals(this._OnAnimationRebuild, null)) {
                    this._OnAnimationRebuild(this);
                }
            },
            /*Spine.Unity.SkeletonAnimation.Initialize end.*/

            /*Spine.Unity.SkeletonAnimation.Update$1 start.*/
            Update$1: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#Update$1", this ); }

                if (this.updateTiming !== Spine.Unity.UpdateTiming.InUpdate) {
                    return;
                }
                this.Update(this.unscaledTime ? UnityEngine.Time.unscaledDeltaTime : UnityEngine.Time.deltaTime);
            },
            /*Spine.Unity.SkeletonAnimation.Update$1 end.*/

            /*Spine.Unity.SkeletonAnimation.Update start.*/
            /**
             * Progresses the AnimationState according to the given deltaTime, and applies it to the Skeleton. Use Time.deltaTime to update manually. Use deltaTime 0 to update without progressing the time.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonAnimation
             * @memberof Spine.Unity.SkeletonAnimation
             * @param   {number}    deltaTime
             * @return  {void}
             */
            Update: function (deltaTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#Update", this ); }

                if (!this.valid || this.state == null) {
                    return;
                }

                this.wasUpdatedAfterInit = true;
                if (this.updateMode < Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    return;
                }
                this.UpdateAnimationStatus(deltaTime);

                if (this.updateMode === Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    this.state.ApplyEventTimelinesOnly(this.skeleton, false);
                    return;
                }
                this.ApplyAnimation();
            },
            /*Spine.Unity.SkeletonAnimation.Update end.*/

            /*Spine.Unity.SkeletonAnimation.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#FixedUpdate", this ); }

                if (this.updateTiming !== Spine.Unity.UpdateTiming.InFixedUpdate) {
                    return;
                }
                this.Update(this.unscaledTime ? UnityEngine.Time.unscaledDeltaTime : UnityEngine.Time.deltaTime);
            },
            /*Spine.Unity.SkeletonAnimation.FixedUpdate end.*/

            /*Spine.Unity.SkeletonAnimation.UpdateAnimationStatus start.*/
            UpdateAnimationStatus: function (deltaTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#UpdateAnimationStatus", this ); }

                deltaTime *= this.timeScale;
                this.state.update(deltaTime);
            },
            /*Spine.Unity.SkeletonAnimation.UpdateAnimationStatus end.*/

            /*Spine.Unity.SkeletonAnimation.ApplyAnimation start.*/
            ApplyAnimation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#ApplyAnimation", this ); }

                if (!Bridge.staticEquals(this._BeforeApply, null)) {
                    this._BeforeApply(this);
                }

                if (this.updateMode !== Spine.Unity.UpdateMode.OnlyEventTimelines) {
                    this.state.apply(this.skeleton);
                } else {
                    this.state.ApplyEventTimelinesOnly(this.skeleton, true);
                }

                this.AfterAnimationApplied();
            },
            /*Spine.Unity.SkeletonAnimation.ApplyAnimation end.*/

            /*Spine.Unity.SkeletonAnimation.AfterAnimationApplied start.*/
            AfterAnimationApplied: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#AfterAnimationApplied", this ); }

                if (!Bridge.staticEquals(this._UpdateLocal, null)) {
                    this._UpdateLocal(this);
                }

                this.skeleton.updateWorldTransform();

                if (!Bridge.staticEquals(this._UpdateWorld, null)) {
                    this._UpdateWorld(this);
                    this.skeleton.updateWorldTransform();
                }

                if (!Bridge.staticEquals(this._UpdateComplete, null)) {
                    this._UpdateComplete(this);
                }
            },
            /*Spine.Unity.SkeletonAnimation.AfterAnimationApplied end.*/

            /*Spine.Unity.SkeletonAnimation.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#LateUpdate", this ); }

                if (this.updateTiming === Spine.Unity.UpdateTiming.InLateUpdate && this.valid) {
                    this.Update(this.unscaledTime ? UnityEngine.Time.unscaledDeltaTime : UnityEngine.Time.deltaTime);
                }

                // instantiation can happen from Update() after this component, leading to a missing Update() call.
                if (!this.wasUpdatedAfterInit) {
                    this.Update(0);
                }

                Spine.Unity.SkeletonRenderer.prototype.LateUpdate.call(this);
            },
            /*Spine.Unity.SkeletonAnimation.LateUpdate end.*/

            /*Spine.Unity.SkeletonAnimation.OnBecameVisible start.*/
            OnBecameVisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#OnBecameVisible", this ); }

                var previousUpdateMode = this.updateMode;
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;

                // OnBecameVisible is called after LateUpdate()
                if (previousUpdateMode !== Spine.Unity.UpdateMode.FullUpdate && previousUpdateMode !== Spine.Unity.UpdateMode.EverythingExceptMesh) {
                    this.Update(0);
                }
                if (previousUpdateMode !== Spine.Unity.UpdateMode.FullUpdate) {
                    this.LateUpdate();
                }
            },
            /*Spine.Unity.SkeletonAnimation.OnBecameVisible end.*/


        },
        overloads: {
            "Update()": "Update$1"
        }
    });
    /*Spine.Unity.SkeletonAnimation end.*/

    /*Spine.Unity.SkeletonMecanim start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim", {
        inherits: [Spine.Unity.SkeletonRenderer,Spine.Unity.ISkeletonAnimation],
        fields: {
            translator: null,
            wasUpdatedAfterInit: false,
            updateTiming: 0
        },
        events: {
            _OnAnimationRebuild: null,
            _BeforeApply: null,
            _UpdateLocal: null,
            _UpdateWorld: null,
            _UpdateComplete: null
        },
        props: {
            Translator: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#Translator#get", this ); }

                    return this.translator;
                }
            },
            UpdateTiming: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#UpdateTiming#get", this ); }

                    return this.updateTiming;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#UpdateTiming#set", this ); }

                    this.updateTiming = value;
                }
            }
        },
        alias: [
            "addOnAnimationRebuild", "Spine$Unity$ISkeletonAnimation$addOnAnimationRebuild",
            "removeOnAnimationRebuild", "Spine$Unity$ISkeletonAnimation$removeOnAnimationRebuild",
            "addUpdateLocal", "Spine$Unity$ISkeletonAnimation$addUpdateLocal",
            "removeUpdateLocal", "Spine$Unity$ISkeletonAnimation$removeUpdateLocal",
            "addUpdateWorld", "Spine$Unity$ISkeletonAnimation$addUpdateWorld",
            "removeUpdateWorld", "Spine$Unity$ISkeletonAnimation$removeUpdateWorld",
            "addUpdateComplete", "Spine$Unity$ISkeletonAnimation$addUpdateComplete",
            "removeUpdateComplete", "Spine$Unity$ISkeletonAnimation$removeUpdateComplete",
            "UpdateTiming", "Spine$Unity$ISkeletonAnimation$UpdateTiming",
            "Skeleton", "Spine$Unity$ISkeletonAnimation$Skeleton"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#init", this ); }

                this.wasUpdatedAfterInit = true;
                this.updateTiming = Spine.Unity.UpdateTiming.InUpdate;
            }
        },
        methods: {
            /**
             * OnAnimationRebuild is raised after the SkeletonAnimation component is successfully initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#OnAnimationRebuild
             * @return  {Spine.Unity.ISkeletonAnimationDelegate}
             */
            addOnAnimationRebuild: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#addOnAnimationRebuild", this ); }

                this.add_OnAnimationRebuild(value);
            },
            /**
             * OnAnimationRebuild is raised after the SkeletonAnimation component is successfully initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#OnAnimationRebuild
             * @return  {Spine.Unity.ISkeletonAnimationDelegate}
             */
            removeOnAnimationRebuild: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#removeOnAnimationRebuild", this ); }

                this.remove_OnAnimationRebuild(value);
            },
            /**
             * Occurs before the animations are applied.
             Use this callback when you want to change the skeleton state before animations are applied on top.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#BeforeApply
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addBeforeApply: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#addBeforeApply", this ); }

                this.add_BeforeApply(value);
            },
            /**
             * Occurs before the animations are applied.
             Use this callback when you want to change the skeleton state before animations are applied on top.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#BeforeApply
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeBeforeApply: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#removeBeforeApply", this ); }

                this.remove_BeforeApply(value);
            },
            /**
             * Occurs after the animations are applied and before world space values are resolved.
             Use this callback when you want to set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateLocal
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateLocal: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#addUpdateLocal", this ); }

                this.add_UpdateLocal(value);
            },
            /**
             * Occurs after the animations are applied and before world space values are resolved.
             Use this callback when you want to set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateLocal
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateLocal: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#removeUpdateLocal", this ); }

                this.remove_UpdateLocal(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Using this callback will cause the world space values to be solved an extra time.
             Use this callback if want to use bone world space values, and also set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateWorld
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateWorld: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#addUpdateWorld", this ); }

                this.add_UpdateWorld(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Using this callback will cause the world space values to be solved an extra time.
             Use this callback if want to use bone world space values, and also set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateWorld
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateWorld: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#removeUpdateWorld", this ); }

                this.remove_UpdateWorld(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Use this callback if you want to use bone world space values, but don't intend to modify bone local values.
             This callback can also be used when setting world position and the bone matrix.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateComplete
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateComplete: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#addUpdateComplete", this ); }

                this.add_UpdateComplete(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Use this callback if you want to use bone world space values, but don't intend to modify bone local values.
             This callback can also be used when setting world position and the bone matrix.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateComplete
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateComplete: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#removeUpdateComplete", this ); }

                this.remove_UpdateComplete(value);
            },
            /*Spine.Unity.SkeletonMecanim.Initialize start.*/
            Initialize: function (overwrite, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#Initialize", this ); }

                if (quiet === void 0) { quiet = false; }
                if (this.valid && !overwrite) {
                    return;
                }
                Spine.Unity.SkeletonRenderer.prototype.Initialize.call(this, overwrite, quiet);

                if (!this.valid) {
                    return;
                }

                if (this.translator == null) {
                    this.translator = new Spine.Unity.SkeletonMecanim.MecanimTranslator();
                }
                this.translator.Initialize(this.GetComponent(UnityEngine.Animator), this.skeletonDataAsset);
                this.wasUpdatedAfterInit = false;

                if (!Bridge.staticEquals(this._OnAnimationRebuild, null)) {
                    this._OnAnimationRebuild(this);
                }
            },
            /*Spine.Unity.SkeletonMecanim.Initialize end.*/

            /*Spine.Unity.SkeletonMecanim.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#Update", this ); }

                if (!this.valid || this.updateTiming !== Spine.Unity.UpdateTiming.InUpdate) {
                    return;
                }
                this.UpdateAnimation();
            },
            /*Spine.Unity.SkeletonMecanim.Update end.*/

            /*Spine.Unity.SkeletonMecanim.Update$1 start.*/
            /**
             * Manual animation update. Required when <pre><code>updateTiming</code></pre> is set to <pre><code>ManualUpdate</code></pre>.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonMecanim
             * @memberof Spine.Unity.SkeletonMecanim
             * @param   {number}    deltaTime    Ignored parameter.
             * @return  {void}
             */
            Update$1: function (deltaTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#Update$1", this ); }

                if (!this.valid) {
                    return;
                }
                this.UpdateAnimation();
            },
            /*Spine.Unity.SkeletonMecanim.Update$1 end.*/

            /*Spine.Unity.SkeletonMecanim.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#FixedUpdate", this ); }

                if (!this.valid || this.updateTiming !== Spine.Unity.UpdateTiming.InFixedUpdate) {
                    return;
                }
                this.UpdateAnimation();
            },
            /*Spine.Unity.SkeletonMecanim.FixedUpdate end.*/

            /*Spine.Unity.SkeletonMecanim.UpdateAnimation start.*/
            UpdateAnimation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#UpdateAnimation", this ); }

                this.wasUpdatedAfterInit = true;

                // animation status is kept by Mecanim Animator component
                if (this.updateMode <= Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    return;
                }

                this.ApplyAnimation();
            },
            /*Spine.Unity.SkeletonMecanim.UpdateAnimation end.*/

            /*Spine.Unity.SkeletonMecanim.ApplyAnimation start.*/
            ApplyAnimation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#ApplyAnimation", this ); }

                if (!Bridge.staticEquals(this._BeforeApply, null)) {
                    this._BeforeApply(this);
                }

                this.translator.Apply(this.skeleton);

                // UpdateWorldTransform and Bone Callbacks
                {
                    if (!Bridge.staticEquals(this._UpdateLocal, null)) {
                        this._UpdateLocal(this);
                    }

                    this.skeleton.updateWorldTransform();

                    if (!Bridge.staticEquals(this._UpdateWorld, null)) {
                        this._UpdateWorld(this);
                        this.skeleton.updateWorldTransform();
                    }

                    if (!Bridge.staticEquals(this._UpdateComplete, null)) {
                        this._UpdateComplete(this);
                    }
                }
            },
            /*Spine.Unity.SkeletonMecanim.ApplyAnimation end.*/

            /*Spine.Unity.SkeletonMecanim.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#LateUpdate", this ); }

                if (this.updateTiming === Spine.Unity.UpdateTiming.InLateUpdate && this.valid && this.translator != null && UnityEngine.Component.op_Inequality(this.translator.Animator, null)) {
                    this.UpdateAnimation();
                }
                // instantiation can happen from Update() after this component, leading to a missing Update() call.
                if (!this.wasUpdatedAfterInit) {
                    this.Update();
                }
                Spine.Unity.SkeletonRenderer.prototype.LateUpdate.call(this);
            },
            /*Spine.Unity.SkeletonMecanim.LateUpdate end.*/

            /*Spine.Unity.SkeletonMecanim.OnBecameVisible start.*/
            OnBecameVisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#OnBecameVisible", this ); }

                var previousUpdateMode = this.updateMode;
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;

                // OnBecameVisible is called after LateUpdate()
                if (previousUpdateMode !== Spine.Unity.UpdateMode.FullUpdate && previousUpdateMode !== Spine.Unity.UpdateMode.EverythingExceptMesh) {
                    this.Update();
                }
                if (previousUpdateMode !== Spine.Unity.UpdateMode.FullUpdate) {
                    this.LateUpdate();
                }
            },
            /*Spine.Unity.SkeletonMecanim.OnBecameVisible end.*/


        },
        overloads: {
            "Update(float)": "Update$1"
        }
    });
    /*Spine.Unity.SkeletonMecanim end.*/

    if ( MODULE_reflection ) {
    var $m = Bridge.setMetadata,
        $n = ["System","Spine.Unity","System.Collections.Generic","UnityEngine","System.Collections","Spine","UnityEngine.U2D","UnityEngine.UI","UnityEngine.Rendering","Spine.Unity.AttachmentTools","Spine.Unity.Prototyping","UnityEngine.Events","Spine.Unity.Examples","UnityEngine.Audio","DG.Tweening.Core","DG.Tweening","DG.Tweening.Plugins.Core.PathCore","System.Globalization","DG.Tweening.Plugins.Options"];

    /*AnimKing start.*/
    $m("AnimKing", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"SetAnim","t":8,"pi":[{"n":"animName","pt":$n[0].String,"ps":0},{"n":"loop","pt":$n[0].Boolean,"ps":1}],"sn":"SetAnim","rt":$n[0].Void,"p":[$n[0].String,$n[0].Boolean]},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"anim","t":4,"rt":$n[1].SkeletonAnimation,"sn":"anim"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"clips","t":4,"rt":$n[2].List$1(AnimClip),"sn":"clips"}]}; }, $n);
    /*AnimKing end.*/

    /*AnimClip start.*/
    $m("AnimClip", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Index","t":4,"rt":$n[0].Int32,"sn":"Index","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new Spine.Unity.SpineAnimation("", "", true, false)],"a":2,"n":"Name","t":4,"rt":$n[0].String,"sn":"Name"}]}; }, $n);
    /*AnimClip end.*/

    /*King start.*/
    $m("King", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"anim","t":4,"rt":AnimKing,"sn":"anim"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"bag","t":4,"rt":Bag,"sn":"bag"}]}; }, $n);
    /*King end.*/

    /*Bag start.*/
    $m("Bag", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"OnIdle","t":8,"sn":"OnIdle","rt":$n[0].Void},{"a":2,"n":"OnLose","t":8,"sn":"OnLose","rt":$n[0].Void},{"a":2,"n":"OnWin","t":8,"sn":"OnWin","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"idlePosition","t":4,"rt":$n[3].Transform,"sn":"idlePosition"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"losePosition","t":4,"rt":$n[3].Transform,"sn":"losePosition"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"model","t":4,"rt":$n[3].Transform,"sn":"model"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"winPosition","t":4,"rt":$n[3].Transform,"sn":"winPosition"}]}; }, $n);
    /*Bag end.*/

    /*Pin start.*/
    $m("Pin", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ActivePin","t":8,"sn":"ActivePin","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"end","t":4,"rt":$n[3].Transform,"sn":"end"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"head","t":4,"rt":$n[3].Transform,"sn":"head"}]}; }, $n);
    /*Pin end.*/

    /*SoundClick start.*/
    $m("SoundClick", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AudioReplay","t":8,"sn":"AudioReplay","rt":$n[4].IEnumerator},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"loopTime","t":4,"rt":$n[0].Single,"sn":"loopTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"sound","t":4,"rt":$n[3].AudioSource,"sn":"sound"}]}; }, $n);
    /*SoundClick end.*/

    /*CameraAnchor start.*/
    $m("CameraAnchor", function () { return {"nested":[CameraAnchor.AnchorType],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteInEditModeAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"SetAnchor","t":8,"pi":[{"n":"anchor","pt":$n[3].Vector3,"ps":0}],"sn":"SetAnchor","rt":$n[0].Void,"p":[$n[3].Vector3]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"UpdateAnchor","t":8,"sn":"UpdateAnchor","rt":$n[0].Void},{"a":1,"n":"UpdateAnchorAsync","t":8,"sn":"UpdateAnchorAsync","rt":$n[4].IEnumerator},{"a":2,"n":"anchorOffset","t":4,"rt":$n[3].Vector3,"sn":"anchorOffset"},{"a":2,"n":"anchorType","t":4,"rt":CameraAnchor.AnchorType,"sn":"anchorType","box":function ($v) { return Bridge.box($v, CameraAnchor.AnchorType, System.Enum.toStringFn(CameraAnchor.AnchorType));}},{"a":1,"n":"updateAnchorRoutine","t":4,"rt":$n[4].IEnumerator,"sn":"updateAnchorRoutine"}]}; }, $n);
    /*CameraAnchor end.*/

    /*CameraAnchor+AnchorType start.*/
    $m("CameraAnchor.AnchorType", function () { return {"td":CameraAnchor,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"BottomCenter","is":true,"t":4,"rt":CameraAnchor.AnchorType,"sn":"BottomCenter","box":function ($v) { return Bridge.box($v, CameraAnchor.AnchorType, System.Enum.toStringFn(CameraAnchor.AnchorType));}},{"a":2,"n":"BottomLeft","is":true,"t":4,"rt":CameraAnchor.AnchorType,"sn":"BottomLeft","box":function ($v) { return Bridge.box($v, CameraAnchor.AnchorType, System.Enum.toStringFn(CameraAnchor.AnchorType));}},{"a":2,"n":"BottomRight","is":true,"t":4,"rt":CameraAnchor.AnchorType,"sn":"BottomRight","box":function ($v) { return Bridge.box($v, CameraAnchor.AnchorType, System.Enum.toStringFn(CameraAnchor.AnchorType));}},{"a":2,"n":"MiddleCenter","is":true,"t":4,"rt":CameraAnchor.AnchorType,"sn":"MiddleCenter","box":function ($v) { return Bridge.box($v, CameraAnchor.AnchorType, System.Enum.toStringFn(CameraAnchor.AnchorType));}},{"a":2,"n":"MiddleLeft","is":true,"t":4,"rt":CameraAnchor.AnchorType,"sn":"MiddleLeft","box":function ($v) { return Bridge.box($v, CameraAnchor.AnchorType, System.Enum.toStringFn(CameraAnchor.AnchorType));}},{"a":2,"n":"MiddleRight","is":true,"t":4,"rt":CameraAnchor.AnchorType,"sn":"MiddleRight","box":function ($v) { return Bridge.box($v, CameraAnchor.AnchorType, System.Enum.toStringFn(CameraAnchor.AnchorType));}},{"a":2,"n":"TopCenter","is":true,"t":4,"rt":CameraAnchor.AnchorType,"sn":"TopCenter","box":function ($v) { return Bridge.box($v, CameraAnchor.AnchorType, System.Enum.toStringFn(CameraAnchor.AnchorType));}},{"a":2,"n":"TopLeft","is":true,"t":4,"rt":CameraAnchor.AnchorType,"sn":"TopLeft","box":function ($v) { return Bridge.box($v, CameraAnchor.AnchorType, System.Enum.toStringFn(CameraAnchor.AnchorType));}},{"a":2,"n":"TopRight","is":true,"t":4,"rt":CameraAnchor.AnchorType,"sn":"TopRight","box":function ($v) { return Bridge.box($v, CameraAnchor.AnchorType, System.Enum.toStringFn(CameraAnchor.AnchorType));}}]}; }, $n);
    /*CameraAnchor+AnchorType end.*/

    /*ViewportHandler start.*/
    $m("ViewportHandler", function () { return {"nested":[ViewportHandler.Constraint],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteInEditModeAttribute(),new UnityEngine.RequireComponent.ctor(UnityEngine.Camera)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"ComputeResolution","t":8,"sn":"ComputeResolution","rt":$n[0].Void},{"a":1,"n":"OnDrawGizmos","t":8,"sn":"OnDrawGizmos","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"BottomCenter","t":16,"rt":$n[3].Vector3,"g":{"a":2,"n":"get_BottomCenter","t":8,"rt":$n[3].Vector3,"fg":"BottomCenter"},"fn":"BottomCenter"},{"a":2,"n":"BottomLeft","t":16,"rt":$n[3].Vector3,"g":{"a":2,"n":"get_BottomLeft","t":8,"rt":$n[3].Vector3,"fg":"BottomLeft"},"fn":"BottomLeft"},{"a":2,"n":"BottomRight","t":16,"rt":$n[3].Vector3,"g":{"a":2,"n":"get_BottomRight","t":8,"rt":$n[3].Vector3,"fg":"BottomRight"},"fn":"BottomRight"},{"a":2,"n":"Height","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Height","t":8,"rt":$n[0].Single,"fg":"Height","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"Height"},{"a":2,"n":"MiddleCenter","t":16,"rt":$n[3].Vector3,"g":{"a":2,"n":"get_MiddleCenter","t":8,"rt":$n[3].Vector3,"fg":"MiddleCenter"},"fn":"MiddleCenter"},{"a":2,"n":"MiddleLeft","t":16,"rt":$n[3].Vector3,"g":{"a":2,"n":"get_MiddleLeft","t":8,"rt":$n[3].Vector3,"fg":"MiddleLeft"},"fn":"MiddleLeft"},{"a":2,"n":"MiddleRight","t":16,"rt":$n[3].Vector3,"g":{"a":2,"n":"get_MiddleRight","t":8,"rt":$n[3].Vector3,"fg":"MiddleRight"},"fn":"MiddleRight"},{"a":2,"n":"TopCenter","t":16,"rt":$n[3].Vector3,"g":{"a":2,"n":"get_TopCenter","t":8,"rt":$n[3].Vector3,"fg":"TopCenter"},"fn":"TopCenter"},{"a":2,"n":"TopLeft","t":16,"rt":$n[3].Vector3,"g":{"a":2,"n":"get_TopLeft","t":8,"rt":$n[3].Vector3,"fg":"TopLeft"},"fn":"TopLeft"},{"a":2,"n":"TopRight","t":16,"rt":$n[3].Vector3,"g":{"a":2,"n":"get_TopRight","t":8,"rt":$n[3].Vector3,"fg":"TopRight"},"fn":"TopRight"},{"a":2,"n":"Width","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Width","t":8,"rt":$n[0].Single,"fg":"Width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"Width"},{"a":2,"n":"Instance","is":true,"t":4,"rt":ViewportHandler,"sn":"Instance"},{"a":2,"n":"UnitsSize","t":4,"rt":$n[0].Single,"sn":"UnitsSize","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"_bc","t":4,"rt":$n[3].Vector3,"sn":"_bc"},{"a":1,"n":"_bl","t":4,"rt":$n[3].Vector3,"sn":"_bl"},{"a":1,"n":"_br","t":4,"rt":$n[3].Vector3,"sn":"_br"},{"a":1,"n":"_height","t":4,"rt":$n[0].Single,"sn":"_height","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"_mc","t":4,"rt":$n[3].Vector3,"sn":"_mc"},{"a":1,"n":"_ml","t":4,"rt":$n[3].Vector3,"sn":"_ml"},{"a":1,"n":"_mr","t":4,"rt":$n[3].Vector3,"sn":"_mr"},{"a":1,"n":"_tc","t":4,"rt":$n[3].Vector3,"sn":"_tc"},{"a":1,"n":"_tl","t":4,"rt":$n[3].Vector3,"sn":"_tl"},{"a":1,"n":"_tr","t":4,"rt":$n[3].Vector3,"sn":"_tr"},{"a":1,"n":"_width","t":4,"rt":$n[0].Single,"sn":"_width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"camera","t":4,"rt":$n[3].Camera,"sn":"camera"},{"a":2,"n":"constraint","t":4,"rt":ViewportHandler.Constraint,"sn":"constraint","box":function ($v) { return Bridge.box($v, ViewportHandler.Constraint, System.Enum.toStringFn(ViewportHandler.Constraint));}},{"a":2,"n":"wireColor","t":4,"rt":$n[3].Color,"sn":"wireColor"}]}; }, $n);
    /*ViewportHandler end.*/

    /*ViewportHandler+Constraint start.*/
    $m("ViewportHandler.Constraint", function () { return {"td":ViewportHandler,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Landscape","is":true,"t":4,"rt":ViewportHandler.Constraint,"sn":"Landscape","box":function ($v) { return Bridge.box($v, ViewportHandler.Constraint, System.Enum.toStringFn(ViewportHandler.Constraint));}},{"a":2,"n":"Portrait","is":true,"t":4,"rt":ViewportHandler.Constraint,"sn":"Portrait","box":function ($v) { return Bridge.box($v, ViewportHandler.Constraint, System.Enum.toStringFn(ViewportHandler.Constraint));}}]}; }, $n);
    /*ViewportHandler+Constraint end.*/

    /*Constant start.*/
    $m("Constant", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"animKingIdle","is":true,"t":4,"rt":$n[0].String,"sn":"animKingIdle"},{"a":2,"n":"animKingLose","is":true,"t":4,"rt":$n[0].String,"sn":"animKingLose"},{"a":2,"n":"animKingWin","is":true,"t":4,"rt":$n[0].String,"sn":"animKingWin"}]}; }, $n);
    /*Constant end.*/

    /*InputReceiver start.*/
    $m("InputReceiver", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"HandleTarget","t":8,"sn":"HandleTarget","rt":$n[0].Void},{"a":2,"n":"TriggerCTA","t":8,"sn":"TriggerCTA","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"FirstClick","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_FirstClick","t":8,"rt":$n[0].Boolean,"fg":"FirstClick","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_FirstClick","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"FirstClick"},"fn":"FirstClick"},{"a":1,"n":"firstClick","t":4,"rt":$n[0].Boolean,"sn":"firstClick","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*InputReceiver end.*/

    /*SkeletonGraphicPlayAnimationAtEvent start.*/
    $m("SkeletonGraphicPlayAnimationAtEvent", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ClearTrack","t":8,"sn":"ClearTrack","rt":$n[0].Void},{"a":2,"n":"PlayAnimationLooping","t":8,"pi":[{"n":"animation","pt":$n[0].String,"ps":0}],"sn":"PlayAnimationLooping","rt":$n[0].Void,"p":[$n[0].String]},{"a":2,"n":"PlayAnimationOnce","t":8,"pi":[{"n":"animation","pt":$n[0].String,"ps":0}],"sn":"PlayAnimationOnce","rt":$n[0].Void,"p":[$n[0].String]},{"a":2,"n":"playbackSpeed","t":4,"rt":$n[0].Single,"sn":"playbackSpeed","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[1].SkeletonGraphic,"sn":"skeletonGraphic"},{"a":2,"n":"trackIndex","t":4,"rt":$n[0].Int32,"sn":"trackIndex","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*SkeletonGraphicPlayAnimationAtEvent end.*/

    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty start.*/
    $m("IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty end.*/

    /*Spine.BoneMatrix start.*/
    $m("Spine.BoneMatrix", function () { return {"att":1048841,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[5].Bone],"pi":[{"n":"bone","pt":$n[5].Bone,"ps":0}],"sn":"$ctor1"},{"a":2,"n":".ctor","t":1,"p":[spine.BoneData],"pi":[{"n":"boneData","pt":spine.BoneData,"ps":0}],"sn":"$ctor2"},{"a":2,"n":"CalculateSetupWorld","is":true,"t":8,"pi":[{"n":"boneData","pt":spine.BoneData,"ps":0}],"sn":"CalculateSetupWorld","rt":$n[5].BoneMatrix,"p":[spine.BoneData]},{"a":1,"n":"GetInheritedInternal","is":true,"t":8,"pi":[{"n":"boneData","pt":spine.BoneData,"ps":0},{"n":"parentMatrix","pt":$n[5].BoneMatrix,"ps":1}],"sn":"GetInheritedInternal","rt":$n[5].BoneMatrix,"p":[spine.BoneData,$n[5].BoneMatrix]},{"a":2,"n":"TransformMatrix","t":8,"pi":[{"n":"local","pt":$n[5].BoneMatrix,"ps":0}],"sn":"TransformMatrix","rt":$n[5].BoneMatrix,"p":[$n[5].BoneMatrix]},{"a":2,"n":"a","t":4,"rt":$n[0].Single,"sn":"a","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"b","t":4,"rt":$n[0].Single,"sn":"b","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"c","t":4,"rt":$n[0].Single,"sn":"c","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"d","t":4,"rt":$n[0].Single,"sn":"d","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.BoneMatrix end.*/

    /*Spine.SpineSkeletonExtensions start.*/
    $m("Spine.SpineSkeletonExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"InheritsRotation","is":true,"t":8,"pi":[{"n":"mode","pt":spine.TransformMode,"ps":0}],"sn":"InheritsRotation","rt":$n[0].Boolean,"p":[spine.TransformMode],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"InheritsScale","is":true,"t":8,"pi":[{"n":"mode","pt":spine.TransformMode,"ps":0}],"sn":"InheritsScale","rt":$n[0].Boolean,"p":[spine.TransformMode],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"IsWeighted","is":true,"t":8,"pi":[{"n":"va","pt":spine.VertexAttachment,"ps":0}],"sn":"IsWeighted","rt":$n[0].Boolean,"p":[spine.VertexAttachment],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.SpineSkeletonExtensions end.*/

    /*Spine.Unity.SkeletonAnimationFixedTimestep start.*/
    $m("Spine.Unity.SkeletonAnimationFixedTimestep", function () { return {"att":1048833,"a":2,"at":[new UnityEngine.DisallowMultipleComponent()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"OnValidate","t":8,"sn":"OnValidate","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":1,"n":"accumulatedTime","t":4,"rt":$n[0].Single,"sn":"accumulatedTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("The duration of each frame in seconds. For 12 fps: enter '1/12' in the Unity inspector.")],"a":2,"n":"frameDeltaTime","t":4,"rt":$n[0].Single,"sn":"frameDeltaTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("If enabled, the Skeleton mesh will be updated only on the same frame when the animation and skeleton are updated. Disable this or call SkeletonAnimation.LateUpdate yourself if you are modifying the Skeleton using other components that don't run in the same fixed timestep.")],"a":2,"n":"frameskipMeshUpdate","t":4,"rt":$n[0].Boolean,"sn":"frameskipMeshUpdate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HeaderAttribute("Advanced"),new UnityEngine.TooltipAttribute("The maximum number of fixed timesteps. If the game framerate drops below the If the framerate is consistently faster than the limited frames, this does nothing.")],"a":2,"n":"maxFrameSkip","t":4,"rt":$n[0].Int32,"sn":"maxFrameSkip","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"requiresNewMesh","t":4,"rt":$n[0].Boolean,"sn":"requiresNewMesh","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"skeletonAnimation","t":4,"rt":$n[1].SkeletonAnimation,"sn":"skeletonAnimation"},{"at":[new UnityEngine.TooltipAttribute("This is the amount the internal accumulator starts with. Set it to some fraction of your frame delta time if you want to stagger updates between multiple skeletons.")],"a":2,"n":"timeOffset","t":4,"rt":$n[0].Single,"sn":"timeOffset","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Unity.SkeletonAnimationFixedTimestep end.*/

    /*Spine.Unity.SkeletonAnimationMulti start.*/
    $m("Spine.Unity.SkeletonAnimationMulti", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"ClearAnimation","t":8,"sn":"ClearAnimation","rt":$n[0].Void},{"a":2,"n":"FindAnimation","t":8,"pi":[{"n":"animationName","pt":$n[0].String,"ps":0}],"sn":"FindAnimation","rt":$n[5].Animation,"p":[$n[0].String]},{"a":2,"n":"GetCurrent","t":8,"sn":"GetCurrent","rt":$n[5].TrackEntry},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","pt":$n[0].Boolean,"ps":0}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"SetActiveSkeleton","t":8,"pi":[{"n":"skeletonAnimation","pt":$n[1].SkeletonAnimation,"ps":0}],"sn":"SetActiveSkeleton","rt":$n[0].Void,"p":[$n[1].SkeletonAnimation]},{"a":1,"n":"SetActiveSkeleton","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0}],"sn":"SetActiveSkeleton$1","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"SetAnimation","t":8,"pi":[{"n":"animation","pt":$n[5].Animation,"ps":0},{"n":"loop","pt":$n[0].Boolean,"ps":1}],"sn":"SetAnimation","rt":$n[5].TrackEntry,"p":[$n[5].Animation,$n[0].Boolean]},{"a":2,"n":"SetAnimation","t":8,"pi":[{"n":"animationName","pt":$n[0].String,"ps":0},{"n":"loop","pt":$n[0].Boolean,"ps":1}],"sn":"SetAnimation$1","rt":$n[5].TrackEntry,"p":[$n[0].String,$n[0].Boolean]},{"a":2,"n":"SetEmptyAnimation","t":8,"pi":[{"n":"mixDuration","pt":$n[0].Single,"ps":0}],"sn":"SetEmptyAnimation","rt":$n[0].Void,"p":[$n[0].Single]},{"a":2,"n":"AnimationNameTable","t":16,"rt":$n[2].Dictionary$2(System.String,Spine.Animation),"g":{"a":2,"n":"get_AnimationNameTable","t":8,"rt":$n[2].Dictionary$2(System.String,Spine.Animation),"fg":"AnimationNameTable"},"fn":"AnimationNameTable"},{"a":2,"n":"AnimationSkeletonTable","t":16,"rt":$n[2].Dictionary$2(Spine.Animation,Spine.Unity.SkeletonAnimation),"g":{"a":2,"n":"get_AnimationSkeletonTable","t":8,"rt":$n[2].Dictionary$2(Spine.Animation,Spine.Unity.SkeletonAnimation),"fg":"AnimationSkeletonTable"},"fn":"AnimationSkeletonTable"},{"a":2,"n":"CurrentSkeletonAnimation","t":16,"rt":$n[1].SkeletonAnimation,"g":{"a":2,"n":"get_CurrentSkeletonAnimation","t":8,"rt":$n[1].SkeletonAnimation,"fg":"CurrentSkeletonAnimation"},"fn":"CurrentSkeletonAnimation"},{"a":2,"n":"SkeletonAnimations","t":16,"rt":$n[2].List$1(Spine.Unity.SkeletonAnimation),"g":{"a":2,"n":"get_SkeletonAnimations","t":8,"rt":$n[2].List$1(Spine.Unity.SkeletonAnimation),"fg":"SkeletonAnimations"},"fn":"SkeletonAnimations"},{"a":1,"n":"MainTrackIndex","is":true,"t":4,"rt":$n[0].Int32,"sn":"MainTrackIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"animationNameTable","t":4,"rt":$n[2].Dictionary$2(System.String,Spine.Animation),"sn":"animationNameTable","ro":true},{"a":1,"n":"animationSkeletonTable","t":4,"rt":$n[2].Dictionary$2(Spine.Animation,Spine.Unity.SkeletonAnimation),"sn":"animationSkeletonTable","ro":true},{"a":1,"n":"currentSkeletonAnimation","t":4,"rt":$n[1].SkeletonAnimation,"sn":"currentSkeletonAnimation"},{"a":2,"n":"initialAnimation","t":4,"rt":$n[0].String,"sn":"initialAnimation"},{"a":2,"n":"initialFlipX","t":4,"rt":$n[0].Boolean,"sn":"initialFlipX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initialFlipY","t":4,"rt":$n[0].Boolean,"sn":"initialFlipY","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initialLoop","t":4,"rt":$n[0].Boolean,"sn":"initialLoop","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HeaderAttribute("Settings")],"a":2,"n":"meshGeneratorSettings","t":4,"rt":$n[1].MeshGenerator.Settings,"sn":"meshGeneratorSettings"},{"a":1,"n":"skeletonAnimations","t":4,"rt":$n[2].List$1(Spine.Unity.SkeletonAnimation),"sn":"skeletonAnimations","ro":true},{"at":[new UnityEngine.SpaceAttribute.ctor()],"a":2,"n":"skeletonDataAssets","t":4,"rt":$n[2].List$1(Spine.Unity.SkeletonDataAsset),"sn":"skeletonDataAssets"}]}; }, $n);
    /*Spine.Unity.SkeletonAnimationMulti end.*/

    /*Spine.Unity.AnimationReferenceAsset start.*/
    $m("Spine.Unity.AnimationReferenceAsset", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Spine/Animation Reference Asset", order: 100
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"op_Implicit","is":true,"t":8,"pi":[{"n":"asset","pt":$n[1].AnimationReferenceAsset,"ps":0}],"sn":"op_Implicit","rt":$n[5].Animation,"p":[$n[1].AnimationReferenceAsset]},{"a":2,"n":"Animation","t":16,"rt":$n[5].Animation,"g":{"a":2,"n":"get_Animation","t":8,"rt":$n[5].Animation,"fg":"Animation"},"fn":"Animation"},{"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[1].SkeletonDataAsset,"g":{"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[1].SkeletonDataAsset,"fg":"SkeletonDataAsset"},"fn":"SkeletonDataAsset"},{"a":1,"n":"QuietSkeletonData","is":true,"t":4,"rt":$n[0].Boolean,"sn":"QuietSkeletonData","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"animation","t":4,"rt":$n[5].Animation,"sn":"animation"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineAnimation("", "", true, false)],"a":3,"n":"animationName","t":4,"rt":$n[0].String,"sn":"animationName"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"skeletonDataAsset","t":4,"rt":$n[1].SkeletonDataAsset,"sn":"skeletonDataAsset"}]}; }, $n);
    /*Spine.Unity.AnimationReferenceAsset end.*/

    /*Spine.Unity.AtlasAssetBase start.*/
    $m("Spine.Unity.AtlasAssetBase", function () { return {"nested":[$n[1].AtlasAssetBase.LoadingMode],"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"v":true,"a":2,"n":"BeginCustomTextureLoading","t":8,"sn":"BeginCustomTextureLoading","rt":$n[0].Void},{"ab":true,"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"v":true,"a":2,"n":"EndCustomTextureLoading","t":8,"sn":"EndCustomTextureLoading","rt":$n[0].Void},{"ab":true,"a":2,"n":"GetAtlas","t":8,"pi":[{"n":"onlyMetaData","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"GetAtlas","rt":$n[5].Atlas,"p":[$n[0].Boolean]},{"v":true,"a":2,"n":"RequireTextureLoaded","t":8,"pi":[{"n":"placeholderTexture","pt":$n[3].Texture,"ps":0},{"n":"replacementTexture","ref":true,"pt":$n[3].Texture,"ps":1},{"n":"onTextureLoaded","pt":Function,"ps":2}],"sn":"RequireTextureLoaded","rt":$n[0].Void,"p":[$n[3].Texture,$n[3].Texture,Function]},{"v":true,"a":2,"n":"RequireTexturesLoaded","t":8,"pi":[{"n":"material","pt":$n[3].Material,"ps":0},{"n":"overrideMaterial","ref":true,"pt":$n[3].Material,"ps":1}],"sn":"RequireTexturesLoaded","rt":$n[0].Void,"p":[$n[3].Material,$n[3].Material]},{"ab":true,"a":2,"n":"IsLoaded","t":16,"rt":$n[0].Boolean,"g":{"ab":true,"a":2,"n":"get_IsLoaded","t":8,"rt":$n[0].Boolean,"fg":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsLoaded"},{"ab":true,"a":2,"n":"MaterialCount","t":16,"rt":$n[0].Int32,"g":{"ab":true,"a":2,"n":"get_MaterialCount","t":8,"rt":$n[0].Int32,"fg":"MaterialCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"MaterialCount"},{"ab":true,"a":2,"n":"Materials","t":16,"rt":$n[2].IEnumerable$1(UnityEngine.Material),"g":{"ab":true,"a":2,"n":"get_Materials","t":8,"rt":$n[2].IEnumerable$1(UnityEngine.Material),"fg":"Materials"},"fn":"Materials"},{"a":2,"n":"OnDemandTextureLoader","t":16,"rt":$n[1].OnDemandTextureLoader,"g":{"a":2,"n":"get_OnDemandTextureLoader","t":8,"rt":$n[1].OnDemandTextureLoader,"fg":"OnDemandTextureLoader"},"s":{"a":2,"n":"set_OnDemandTextureLoader","t":8,"p":[$n[1].OnDemandTextureLoader],"rt":$n[0].Void,"fs":"OnDemandTextureLoader"},"fn":"OnDemandTextureLoader"},{"ab":true,"a":2,"n":"PrimaryMaterial","t":16,"rt":$n[3].Material,"g":{"ab":true,"a":2,"n":"get_PrimaryMaterial","t":8,"rt":$n[3].Material,"fg":"PrimaryMaterial"},"fn":"PrimaryMaterial"},{"v":true,"a":2,"n":"TextureLoadingMode","t":16,"rt":$n[1].AtlasAssetBase.LoadingMode,"g":{"v":true,"a":2,"n":"get_TextureLoadingMode","t":8,"rt":$n[1].AtlasAssetBase.LoadingMode,"fg":"TextureLoadingMode","box":function ($v) { return Bridge.box($v, Spine.Unity.AtlasAssetBase.LoadingMode, System.Enum.toStringFn(Spine.Unity.AtlasAssetBase.LoadingMode));}},"s":{"v":true,"a":2,"n":"set_TextureLoadingMode","t":8,"p":[$n[1].AtlasAssetBase.LoadingMode],"rt":$n[0].Void,"fs":"TextureLoadingMode"},"fn":"TextureLoadingMode"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"onDemandTextureLoader","t":4,"rt":$n[1].OnDemandTextureLoader,"sn":"onDemandTextureLoader"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"textureLoadingMode","t":4,"rt":$n[1].AtlasAssetBase.LoadingMode,"sn":"textureLoadingMode","box":function ($v) { return Bridge.box($v, Spine.Unity.AtlasAssetBase.LoadingMode, System.Enum.toStringFn(Spine.Unity.AtlasAssetBase.LoadingMode));}},{"a":1,"backing":true,"n":"<IsLoaded>k__BackingField","t":4,"rt":$n[0].Boolean,"sn":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"backing":true,"n":"<MaterialCount>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"MaterialCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"backing":true,"n":"<Materials>k__BackingField","t":4,"rt":$n[2].IEnumerable$1(UnityEngine.Material),"sn":"Materials"},{"a":1,"backing":true,"n":"<PrimaryMaterial>k__BackingField","t":4,"rt":$n[3].Material,"sn":"PrimaryMaterial"}]}; }, $n);
    /*Spine.Unity.AtlasAssetBase end.*/

    /*Spine.Unity.AtlasAssetBase+LoadingMode start.*/
    $m("Spine.Unity.AtlasAssetBase.LoadingMode", function () { return {"td":$n[1].AtlasAssetBase,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Normal","is":true,"t":4,"rt":$n[1].AtlasAssetBase.LoadingMode,"sn":"Normal","box":function ($v) { return Bridge.box($v, Spine.Unity.AtlasAssetBase.LoadingMode, System.Enum.toStringFn(Spine.Unity.AtlasAssetBase.LoadingMode));}},{"a":2,"n":"OnDemand","is":true,"t":4,"rt":$n[1].AtlasAssetBase.LoadingMode,"sn":"OnDemand","box":function ($v) { return Bridge.box($v, Spine.Unity.AtlasAssetBase.LoadingMode, System.Enum.toStringFn(Spine.Unity.AtlasAssetBase.LoadingMode));}}]}; }, $n);
    /*Spine.Unity.AtlasAssetBase+LoadingMode end.*/

    /*Spine.Unity.BlendModeMaterials start.*/
    $m("Spine.Unity.BlendModeMaterials", function () { return {"nested":[$n[1].BlendModeMaterials.ReplacementMaterial],"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ApplyMaterials","t":8,"pi":[{"n":"skeletonData","pt":$n[5].SkeletonData,"ps":0}],"sn":"ApplyMaterials","rt":$n[0].Void,"p":[$n[5].SkeletonData]},{"a":2,"n":"BlendModeForMaterial","t":8,"pi":[{"n":"material","pt":$n[3].Material,"ps":0}],"sn":"BlendModeForMaterial","rt":spine.BlendMode,"p":[$n[3].Material],"box":function ($v) { return Bridge.box($v, spine.BlendMode, System.Enum.toStringFn(spine.BlendMode));}},{"a":3,"n":"CloneAtlasRegionWithMaterial","t":8,"pi":[{"n":"originalRegion","pt":$n[5].AtlasRegion,"ps":0},{"n":"replacementMaterials","pt":$n[2].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial),"ps":1}],"sn":"CloneAtlasRegionWithMaterial","rt":$n[5].AtlasRegion,"p":[$n[5].AtlasRegion,$n[2].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial)]},{"a":2,"n":"RequiresBlendModeMaterials","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_RequiresBlendModeMaterials","t":8,"rt":$n[0].Boolean,"fg":"RequiresBlendModeMaterials","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_RequiresBlendModeMaterials","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"RequiresBlendModeMaterials"},"fn":"RequiresBlendModeMaterials"},{"a":2,"n":"additiveMaterials","t":4,"rt":$n[2].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial),"sn":"additiveMaterials"},{"a":2,"n":"applyAdditiveMaterial","t":4,"rt":$n[0].Boolean,"sn":"applyAdditiveMaterial","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"multiplyMaterials","t":4,"rt":$n[2].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial),"sn":"multiplyMaterials"},{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.HideInInspector()],"a":3,"n":"requiresBlendModeMaterials","t":4,"rt":$n[0].Boolean,"sn":"requiresBlendModeMaterials","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"screenMaterials","t":4,"rt":$n[2].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial),"sn":"screenMaterials"}]}; }, $n);
    /*Spine.Unity.BlendModeMaterials end.*/

    /*Spine.Unity.BlendModeMaterials+ReplacementMaterial start.*/
    $m("Spine.Unity.BlendModeMaterials.ReplacementMaterial", function () { return {"td":$n[1].BlendModeMaterials,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"material","t":4,"rt":$n[3].Material,"sn":"material"},{"a":2,"n":"pageName","t":4,"rt":$n[0].String,"sn":"pageName"}]}; }, $n);
    /*Spine.Unity.BlendModeMaterials+ReplacementMaterial end.*/

    /*Spine.Unity.EventDataReferenceAsset start.*/
    $m("Spine.Unity.EventDataReferenceAsset", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Spine/EventData Reference Asset", order: 100
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"op_Implicit","is":true,"t":8,"pi":[{"n":"asset","pt":$n[1].EventDataReferenceAsset,"ps":0}],"sn":"op_Implicit","rt":spine.EventData,"p":[$n[1].EventDataReferenceAsset]},{"a":2,"n":"EventData","t":16,"rt":spine.EventData,"g":{"a":2,"n":"get_EventData","t":8,"rt":spine.EventData,"fg":"EventData"},"fn":"EventData"},{"a":1,"n":"QuietSkeletonData","is":true,"t":4,"rt":$n[0].Boolean,"sn":"QuietSkeletonData","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"eventData","t":4,"rt":spine.EventData,"sn":"eventData"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineEvent("", "skeletonDataAsset", true, false, false)],"a":3,"n":"eventName","t":4,"rt":$n[0].String,"sn":"eventName"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"skeletonDataAsset","t":4,"rt":$n[1].SkeletonDataAsset,"sn":"skeletonDataAsset"}]}; }, $n);
    /*Spine.Unity.EventDataReferenceAsset end.*/

    /*Spine.Unity.OnDemandTextureLoader start.*/
    $m("Spine.Unity.OnDemandTextureLoader", function () { return {"nested":[Function],"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ab":true,"a":2,"n":"AssignPlaceholderTextures","t":8,"pi":[{"n":"modifiedMaterials","out":true,"pt":$n[2].IEnumerable$1(UnityEngine.Material),"ps":0}],"sn":"AssignPlaceholderTextures","rt":$n[0].Boolean,"p":[$n[2].IEnumerable$1(UnityEngine.Material)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"ab":true,"a":2,"n":"AssignTargetTextures","t":8,"pi":[{"n":"modifiedMaterials","out":true,"pt":$n[2].IEnumerable$1(UnityEngine.Material),"ps":0}],"sn":"AssignTargetTextures","rt":$n[0].Boolean,"p":[$n[2].IEnumerable$1(UnityEngine.Material)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"ab":true,"a":2,"n":"BeginCustomTextureLoading","t":8,"sn":"BeginCustomTextureLoading","rt":$n[0].Void},{"ab":true,"a":2,"n":"Clear","t":8,"pi":[{"n":"clearAtlasAsset","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"Clear","rt":$n[0].Void,"p":[$n[0].Boolean]},{"ab":true,"a":2,"n":"EndCustomTextureLoading","t":8,"sn":"EndCustomTextureLoading","rt":$n[0].Void},{"ab":true,"a":2,"n":"GetPlaceholderTextureName","t":8,"pi":[{"n":"originalTextureName","pt":$n[0].String,"ps":0}],"sn":"GetPlaceholderTextureName","rt":$n[0].String,"p":[$n[0].String]},{"v":true,"a":2,"n":"HasNullMainTexturesAssigned","t":8,"pi":[{"n":"nullTextureMaterials","out":true,"pt":$n[2].List$1(UnityEngine.Material),"ps":0}],"sn":"HasNullMainTexturesAssigned","rt":$n[0].Boolean,"p":[$n[2].List$1(UnityEngine.Material)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"ab":true,"a":2,"n":"HasPlaceholderAssigned","t":8,"pi":[{"n":"material","pt":$n[3].Material,"ps":0}],"sn":"HasPlaceholderAssigned","rt":$n[0].Boolean,"p":[$n[3].Material],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"ab":true,"a":2,"n":"HasPlaceholderTexturesAssigned","t":8,"pi":[{"n":"placeholderMaterials","out":true,"pt":$n[2].List$1(UnityEngine.Material),"ps":0}],"sn":"HasPlaceholderTexturesAssigned","rt":$n[0].Boolean,"p":[$n[2].List$1(UnityEngine.Material)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"OnTextureLoaded","t":8,"pi":[{"n":"material","pt":$n[3].Material,"ps":0},{"n":"textureIndex","pt":$n[0].Int32,"ps":1}],"sn":"OnTextureLoaded","rt":$n[0].Void,"p":[$n[3].Material,$n[0].Int32]},{"a":3,"n":"OnTextureRequested","t":8,"pi":[{"n":"material","pt":$n[3].Material,"ps":0},{"n":"textureIndex","pt":$n[0].Int32,"ps":1}],"sn":"OnTextureRequested","rt":$n[0].Void,"p":[$n[3].Material,$n[0].Int32]},{"a":3,"n":"OnTextureUnloaded","t":8,"pi":[{"n":"material","pt":$n[3].Material,"ps":0},{"n":"textureIndex","pt":$n[0].Int32,"ps":1}],"sn":"OnTextureUnloaded","rt":$n[0].Void,"p":[$n[3].Material,$n[0].Int32]},{"ab":true,"a":2,"n":"RequestLoadMaterialTextures","t":8,"pi":[{"n":"material","pt":$n[3].Material,"ps":0},{"n":"overrideMaterial","ref":true,"pt":$n[3].Material,"ps":1}],"sn":"RequestLoadMaterialTextures","rt":$n[0].Void,"p":[$n[3].Material,$n[3].Material]},{"ab":true,"a":2,"n":"RequestLoadTexture","t":8,"pi":[{"n":"placeholderTexture","pt":$n[3].Texture,"ps":0},{"n":"replacementTexture","ref":true,"pt":$n[3].Texture,"ps":1},{"n":"onTextureLoaded","dv":null,"o":true,"pt":Function,"ps":2}],"sn":"RequestLoadTexture","rt":$n[0].Void,"p":[$n[3].Texture,$n[3].Texture,Function]},{"a":2,"n":"atlasAsset","t":4,"rt":$n[1].AtlasAssetBase,"sn":"atlasAsset"},{"a":2,"n":"TextureLoaded","t":2,"ad":{"a":2,"n":"add_TextureLoaded","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addTextureLoaded","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_TextureLoaded","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeTextureLoaded","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"TextureRequested","t":2,"ad":{"a":2,"n":"add_TextureRequested","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addTextureRequested","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_TextureRequested","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeTextureRequested","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"TextureUnloaded","t":2,"ad":{"a":2,"n":"add_TextureUnloaded","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addTextureUnloaded","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_TextureUnloaded","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeTextureUnloaded","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"onTextureLoaded","t":2,"ad":{"a":3,"n":"add_onTextureLoaded","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addonTextureLoaded","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove_onTextureLoaded","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeonTextureLoaded","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"onTextureRequested","t":2,"ad":{"a":3,"n":"add_onTextureRequested","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addonTextureRequested","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove_onTextureRequested","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeonTextureRequested","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"onTextureUnloaded","t":2,"ad":{"a":3,"n":"add_onTextureUnloaded","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addonTextureUnloaded","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove_onTextureUnloaded","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeonTextureUnloaded","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.OnDemandTextureLoader end.*/

    /*Spine.Unity.RegionlessAttachmentLoader start.*/
    $m("Spine.Unity.RegionlessAttachmentLoader", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"NewBoundingBoxAttachment","t":8,"pi":[{"n":"skin","pt":$n[5].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewBoundingBoxAttachment","rt":spine.BoundingBoxAttachment,"p":[$n[5].Skin,$n[0].String]},{"a":2,"n":"NewClippingAttachment","t":8,"pi":[{"n":"skin","pt":$n[5].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewClippingAttachment","rt":spine.ClippingAttachment,"p":[$n[5].Skin,$n[0].String]},{"a":2,"n":"NewMeshAttachment","t":8,"pi":[{"n":"skin","pt":$n[5].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"path","pt":$n[0].String,"ps":2},{"n":"sequence","pt":spine.Sequence,"ps":3}],"sn":"NewMeshAttachment","rt":$n[5].MeshAttachment,"p":[$n[5].Skin,$n[0].String,$n[0].String,spine.Sequence]},{"a":2,"n":"NewPathAttachment","t":8,"pi":[{"n":"skin","pt":$n[5].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewPathAttachment","rt":spine.PathAttachment,"p":[$n[5].Skin,$n[0].String]},{"a":2,"n":"NewPointAttachment","t":8,"pi":[{"n":"skin","pt":$n[5].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewPointAttachment","rt":$n[5].PointAttachment,"p":[$n[5].Skin,$n[0].String]},{"a":2,"n":"NewRegionAttachment","t":8,"pi":[{"n":"skin","pt":$n[5].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"path","pt":$n[0].String,"ps":2},{"n":"sequence","pt":spine.Sequence,"ps":3}],"sn":"NewRegionAttachment","rt":$n[5].RegionAttachment,"p":[$n[5].Skin,$n[0].String,$n[0].String,spine.Sequence]},{"a":1,"n":"EmptyRegion","is":true,"t":16,"rt":$n[5].AtlasRegion,"g":{"a":1,"n":"get_EmptyRegion","t":8,"rt":$n[5].AtlasRegion,"fg":"EmptyRegion","is":true},"fn":"EmptyRegion"},{"a":1,"n":"emptyRegion","is":true,"t":4,"rt":$n[5].AtlasRegion,"sn":"emptyRegion"}]}; }, $n);
    /*Spine.Unity.RegionlessAttachmentLoader end.*/

    /*Spine.Unity.SkeletonDataAsset start.*/
    $m("Spine.Unity.SkeletonDataAsset", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        fileName: "New SkeletonDataAsset", menuName: "Spine/SkeletonData Asset"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"skeletonDataFile","pt":$n[3].TextAsset,"ps":0},{"n":"atlasAsset","pt":$n[1].AtlasAssetBase,"ps":1},{"n":"initialize","pt":$n[0].Boolean,"ps":2},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"CreateRuntimeInstance","rt":$n[1].SkeletonDataAsset,"p":[$n[3].TextAsset,$n[1].AtlasAssetBase,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"skeletonDataFile","pt":$n[3].TextAsset,"ps":0},{"n":"atlasAssets","pt":System.Array.type(Spine.Unity.AtlasAssetBase),"ps":1},{"n":"initialize","pt":$n[0].Boolean,"ps":2},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"CreateRuntimeInstance$1","rt":$n[1].SkeletonDataAsset,"p":[$n[3].TextAsset,System.Array.type(Spine.Unity.AtlasAssetBase),$n[0].Boolean,$n[0].Single]},{"a":2,"n":"FillStateData","t":8,"pi":[{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"FillStateData","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"GetAnimationStateData","t":8,"sn":"GetAnimationStateData","rt":spine.AnimationStateData},{"a":4,"n":"GetAtlasArray","t":8,"sn":"GetAtlasArray","rt":System.Array.type(Spine.Atlas)},{"a":2,"n":"GetSkeletonData","t":8,"pi":[{"n":"quiet","pt":$n[0].Boolean,"ps":0}],"sn":"GetSkeletonData","rt":$n[5].SkeletonData,"p":[$n[0].Boolean]},{"a":4,"n":"InitializeWithData","t":8,"pi":[{"n":"sd","pt":$n[5].SkeletonData,"ps":0}],"sn":"InitializeWithData","rt":$n[0].Void,"p":[$n[5].SkeletonData]},{"a":4,"n":"ReadSkeletonData","is":true,"t":8,"pi":[{"n":"bytes","pt":$n[0].Array.type(System.Byte),"ps":0},{"n":"attachmentLoader","pt":$n[5].AttachmentLoader,"ps":1},{"n":"scale","pt":$n[0].Single,"ps":2}],"sn":"ReadSkeletonData","rt":$n[5].SkeletonData,"p":[$n[0].Array.type(System.Byte),$n[5].AttachmentLoader,$n[0].Single]},{"a":4,"n":"ReadSkeletonData","is":true,"t":8,"pi":[{"n":"text","pt":$n[0].String,"ps":0},{"n":"attachmentLoader","pt":$n[5].AttachmentLoader,"ps":1},{"n":"scale","pt":$n[0].Single,"ps":2}],"sn":"ReadSkeletonData$1","rt":$n[5].SkeletonData,"p":[$n[0].String,$n[5].AttachmentLoader,$n[0].Single]},{"a":1,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"a":2,"n":"IsLoaded","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsLoaded","t":8,"rt":$n[0].Boolean,"fg":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsLoaded"},{"a":2,"n":"atlasAssets","t":4,"rt":System.Array.type(Spine.Unity.AtlasAssetBase),"sn":"atlasAssets"},{"a":2,"n":"blendModeMaterials","t":4,"rt":$n[1].BlendModeMaterials,"sn":"blendModeMaterials"},{"a":2,"n":"controller","t":4,"rt":$n[3].RuntimeAnimatorController,"sn":"controller"},{"a":2,"n":"defaultMix","t":4,"rt":$n[0].Single,"sn":"defaultMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"duration","t":4,"rt":$n[0].Array.type(System.Single),"sn":"duration"},{"at":[new Spine.Unity.SpineAnimation("", "", false, false)],"a":2,"n":"fromAnimation","t":4,"rt":$n[0].Array.type(System.String),"sn":"fromAnimation"},{"a":2,"n":"isUpgradingBlendModeMaterials","t":4,"rt":$n[0].Boolean,"sn":"isUpgradingBlendModeMaterials","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"scale","t":4,"rt":$n[0].Single,"sn":"scale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"skeletonData","t":4,"rt":$n[5].SkeletonData,"sn":"skeletonData"},{"at":[new UnityEngine.TooltipAttribute("Use SkeletonDataModifierAssets to apply changes to the SkeletonData after being loaded, such as apply blend mode Materials to Attachments under slots with special blend modes.")],"a":2,"n":"skeletonDataModifiers","t":4,"rt":$n[2].List$1(Spine.Unity.SkeletonDataModifierAsset),"sn":"skeletonDataModifiers"},{"a":2,"n":"skeletonJSON","t":4,"rt":$n[3].TextAsset,"sn":"skeletonJSON"},{"a":1,"n":"stateData","t":4,"rt":spine.AnimationStateData,"sn":"stateData"},{"at":[new Spine.Unity.SpineAnimation("", "", false, false)],"a":2,"n":"toAnimation","t":4,"rt":$n[0].Array.type(System.String),"sn":"toAnimation"}]}; }, $n);
    /*Spine.Unity.SkeletonDataAsset end.*/

    /*Spine.Unity.SkeletonDataCompatibility start.*/
    $m("Spine.Unity.SkeletonDataCompatibility", function () { return {"nested":[$n[1].SkeletonDataCompatibility.SourceType,$n[1].SkeletonDataCompatibility.VersionInfo,$n[1].SkeletonDataCompatibility.CompatibilityProblemInfo],"att":1048961,"a":2,"s":true}; }, $n);
    /*Spine.Unity.SkeletonDataCompatibility end.*/

    /*Spine.Unity.SkeletonDataCompatibility+SourceType start.*/
    $m("Spine.Unity.SkeletonDataCompatibility.SourceType", function () { return {"td":$n[1].SkeletonDataCompatibility,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Binary","is":true,"t":4,"rt":$n[1].SkeletonDataCompatibility.SourceType,"sn":"Binary","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonDataCompatibility.SourceType, System.Enum.toStringFn(Spine.Unity.SkeletonDataCompatibility.SourceType));}},{"a":2,"n":"Json","is":true,"t":4,"rt":$n[1].SkeletonDataCompatibility.SourceType,"sn":"Json","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonDataCompatibility.SourceType, System.Enum.toStringFn(Spine.Unity.SkeletonDataCompatibility.SourceType));}}]}; }, $n);
    /*Spine.Unity.SkeletonDataCompatibility+SourceType end.*/

    /*Spine.Unity.SkeletonDataCompatibility+VersionInfo start.*/
    $m("Spine.Unity.SkeletonDataCompatibility.VersionInfo", function () { return {"td":$n[1].SkeletonDataCompatibility,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"rawVersion","t":4,"rt":$n[0].String,"sn":"rawVersion"},{"a":2,"n":"sourceType","t":4,"rt":$n[1].SkeletonDataCompatibility.SourceType,"sn":"sourceType","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonDataCompatibility.SourceType, System.Enum.toStringFn(Spine.Unity.SkeletonDataCompatibility.SourceType));}},{"a":2,"n":"version","t":4,"rt":$n[0].Array.type(System.Int32),"sn":"version"}]}; }, $n);
    /*Spine.Unity.SkeletonDataCompatibility+VersionInfo end.*/

    /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo start.*/
    $m("Spine.Unity.SkeletonDataCompatibility.CompatibilityProblemInfo", function () { return {"td":$n[1].SkeletonDataCompatibility,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"DescriptionString","t":8,"sn":"DescriptionString","rt":$n[0].String},{"a":2,"n":"actualVersion","t":4,"rt":$n[1].SkeletonDataCompatibility.VersionInfo,"sn":"actualVersion"},{"a":2,"n":"compatibleVersions","t":4,"rt":$n[0].Array.type(System.Array.type(System.Int32)),"sn":"compatibleVersions"},{"a":2,"n":"explicitProblemDescription","t":4,"rt":$n[0].String,"sn":"explicitProblemDescription"}]}; }, $n);
    /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo end.*/

    /*Spine.Unity.SkeletonDataModifierAsset start.*/
    $m("Spine.Unity.SkeletonDataModifierAsset", function () { return {"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ab":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeletonData","pt":$n[5].SkeletonData,"ps":0}],"sn":"Apply","rt":$n[0].Void,"p":[$n[5].SkeletonData]}]}; }, $n);
    /*Spine.Unity.SkeletonDataModifierAsset end.*/

    /*Spine.Unity.SpineAtlasAsset start.*/
    $m("Spine.Unity.SpineAtlasAsset", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        fileName: "New Spine Atlas Asset", menuName: "Spine/Spine Atlas Asset"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"atlasText","pt":$n[3].TextAsset,"ps":0},{"n":"materials","pt":System.Array.type(UnityEngine.Material),"ps":1},{"n":"initialize","pt":$n[0].Boolean,"ps":2},{"n":"newCustomTextureLoader","dv":null,"o":true,"pt":Function,"ps":3}],"sn":"CreateRuntimeInstance","rt":$n[1].SpineAtlasAsset,"p":[$n[3].TextAsset,System.Array.type(UnityEngine.Material),$n[0].Boolean,Function]},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"atlasText","pt":$n[3].TextAsset,"ps":0},{"n":"textures","pt":System.Array.type(UnityEngine.Texture2D),"ps":1},{"n":"materialPropertySource","pt":$n[3].Material,"ps":2},{"n":"initialize","pt":$n[0].Boolean,"ps":3},{"n":"newCustomTextureLoader","dv":null,"o":true,"pt":Function,"ps":4}],"sn":"CreateRuntimeInstance$1","rt":$n[1].SpineAtlasAsset,"p":[$n[3].TextAsset,System.Array.type(UnityEngine.Texture2D),$n[3].Material,$n[0].Boolean,Function]},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"atlasText","pt":$n[3].TextAsset,"ps":0},{"n":"textures","pt":System.Array.type(UnityEngine.Texture2D),"ps":1},{"n":"shader","pt":$n[3].Shader,"ps":2},{"n":"initialize","pt":$n[0].Boolean,"ps":3},{"n":"newCustomTextureLoader","dv":null,"o":true,"pt":Function,"ps":4}],"sn":"CreateRuntimeInstance$2","rt":$n[1].SpineAtlasAsset,"p":[$n[3].TextAsset,System.Array.type(UnityEngine.Texture2D),$n[3].Shader,$n[0].Boolean,Function]},{"a":2,"n":"GenerateMesh","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0},{"n":"mesh","pt":$n[3].Mesh,"ps":1},{"n":"material","out":true,"pt":$n[3].Material,"ps":2},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"GenerateMesh","rt":$n[3].Mesh,"p":[$n[0].String,$n[3].Mesh,$n[3].Material,$n[0].Single]},{"ov":true,"a":2,"n":"GetAtlas","t":8,"pi":[{"n":"onlyMetaData","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"GetAtlas","rt":$n[5].Atlas,"p":[$n[0].Boolean]},{"a":1,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"ov":true,"a":2,"n":"IsLoaded","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_IsLoaded","t":8,"rt":$n[0].Boolean,"fg":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsLoaded"},{"ov":true,"a":2,"n":"MaterialCount","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_MaterialCount","t":8,"rt":$n[0].Int32,"fg":"MaterialCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"MaterialCount"},{"ov":true,"a":2,"n":"Materials","t":16,"rt":$n[2].IEnumerable$1(UnityEngine.Material),"g":{"ov":true,"a":2,"n":"get_Materials","t":8,"rt":$n[2].IEnumerable$1(UnityEngine.Material),"fg":"Materials"},"fn":"Materials"},{"ov":true,"a":2,"n":"PrimaryMaterial","t":16,"rt":$n[3].Material,"g":{"ov":true,"a":2,"n":"get_PrimaryMaterial","t":8,"rt":$n[3].Material,"fg":"PrimaryMaterial"},"fn":"PrimaryMaterial"},{"a":3,"n":"atlas","t":4,"rt":$n[5].Atlas,"sn":"atlas"},{"a":2,"n":"atlasFile","t":4,"rt":$n[3].TextAsset,"sn":"atlasFile"},{"a":2,"n":"customTextureLoader","t":4,"rt":$n[5].TextureLoader,"sn":"customTextureLoader"},{"a":2,"n":"materials","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materials"}]}; }, $n);
    /*Spine.Unity.SpineAtlasAsset end.*/

    /*Spine.Unity.NoOpTextureLoader start.*/
    $m("Spine.Unity.NoOpTextureLoader", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Load","t":8,"pi":[{"n":"page","pt":$n[5].AtlasPage,"ps":0},{"n":"path","pt":$n[0].String,"ps":1}],"sn":"Load","rt":$n[0].Void,"p":[$n[5].AtlasPage,$n[0].String]},{"a":2,"n":"Unload","t":8,"pi":[{"n":"texture","pt":$n[0].Object,"ps":0}],"sn":"Unload","rt":$n[0].Void,"p":[$n[0].Object]}]}; }, $n);
    /*Spine.Unity.NoOpTextureLoader end.*/

    /*Spine.Unity.MaterialsTextureLoader start.*/
    $m("Spine.Unity.MaterialsTextureLoader", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[1].SpineAtlasAsset],"pi":[{"n":"atlasAsset","pt":$n[1].SpineAtlasAsset,"ps":0}],"sn":"ctor"},{"a":2,"n":"Load","t":8,"pi":[{"n":"page","pt":$n[5].AtlasPage,"ps":0},{"n":"path","pt":$n[0].String,"ps":1}],"sn":"Load","rt":$n[0].Void,"p":[$n[5].AtlasPage,$n[0].String]},{"a":2,"n":"Unload","t":8,"pi":[{"n":"texture","pt":$n[0].Object,"ps":0}],"sn":"Unload","rt":$n[0].Void,"p":[$n[0].Object]},{"a":1,"n":"atlasAsset","t":4,"rt":$n[1].SpineAtlasAsset,"sn":"atlasAsset"}]}; }, $n);
    /*Spine.Unity.MaterialsTextureLoader end.*/

    /*Spine.Unity.SpineSpriteAtlasAsset start.*/
    $m("Spine.Unity.SpineSpriteAtlasAsset", function () { return {"nested":[$n[1].SpineSpriteAtlasAsset.SavedRegionInfo],"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        fileName: "New Spine SpriteAtlas Asset", menuName: "Spine/Spine SpriteAtlas Asset"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AccessPackedSprites","is":true,"t":8,"pi":[{"n":"spriteAtlas","pt":$n[6].SpriteAtlas,"ps":0}],"sn":"AccessPackedSprites","rt":System.Array.type(UnityEngine.Sprite),"p":[$n[6].SpriteAtlas]},{"a":2,"n":"AccessPackedTexture","is":true,"t":8,"pi":[{"n":"sprites","pt":System.Array.type(UnityEngine.Sprite),"ps":0}],"sn":"AccessPackedTexture","rt":$n[3].Texture2D,"p":[System.Array.type(UnityEngine.Sprite)]},{"a":3,"n":"AssignRegionsFromSavedRegions","t":8,"pi":[{"n":"sprites","pt":System.Array.type(UnityEngine.Sprite),"ps":0},{"n":"usedAtlas","pt":$n[5].Atlas,"ps":1}],"sn":"AssignRegionsFromSavedRegions","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.Sprite),$n[5].Atlas]},{"ov":true,"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"spriteAtlasFile","pt":$n[6].SpriteAtlas,"ps":0},{"n":"materials","pt":System.Array.type(UnityEngine.Material),"ps":1},{"n":"initialize","pt":$n[0].Boolean,"ps":2}],"sn":"CreateRuntimeInstance","rt":$n[1].SpineSpriteAtlasAsset,"p":[$n[6].SpriteAtlas,System.Array.type(UnityEngine.Material),$n[0].Boolean]},{"ov":true,"a":2,"n":"GetAtlas","t":8,"pi":[{"n":"onlyMetaData","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"GetAtlas","rt":$n[5].Atlas,"p":[$n[0].Boolean]},{"a":1,"n":"LoadAtlas","t":8,"pi":[{"n":"spriteAtlas","pt":$n[6].SpriteAtlas,"ps":0}],"sn":"LoadAtlas","rt":$n[5].Atlas,"p":[$n[6].SpriteAtlas]},{"a":1,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"ov":true,"a":2,"n":"IsLoaded","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_IsLoaded","t":8,"rt":$n[0].Boolean,"fg":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsLoaded"},{"ov":true,"a":2,"n":"MaterialCount","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_MaterialCount","t":8,"rt":$n[0].Int32,"fg":"MaterialCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"MaterialCount"},{"ov":true,"a":2,"n":"Materials","t":16,"rt":$n[2].IEnumerable$1(UnityEngine.Material),"g":{"ov":true,"a":2,"n":"get_Materials","t":8,"rt":$n[2].IEnumerable$1(UnityEngine.Material),"fg":"Materials"},"fn":"Materials"},{"ov":true,"a":2,"n":"PrimaryMaterial","t":16,"rt":$n[3].Material,"g":{"ov":true,"a":2,"n":"get_PrimaryMaterial","t":8,"rt":$n[3].Material,"fg":"PrimaryMaterial"},"fn":"PrimaryMaterial"},{"a":3,"n":"atlas","t":4,"rt":$n[5].Atlas,"sn":"atlas"},{"a":2,"n":"materials","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materials"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"savedRegions","t":4,"rt":System.Array.type(Spine.Unity.SpineSpriteAtlasAsset.SavedRegionInfo),"sn":"savedRegions"},{"a":2,"n":"spriteAtlasFile","t":4,"rt":$n[6].SpriteAtlas,"sn":"spriteAtlasFile"},{"a":2,"n":"updateRegionsInPlayMode","t":4,"rt":$n[0].Boolean,"sn":"updateRegionsInPlayMode","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SpineSpriteAtlasAsset end.*/

    /*Spine.Unity.SpineSpriteAtlasAsset+SavedRegionInfo start.*/
    $m("Spine.Unity.SpineSpriteAtlasAsset.SavedRegionInfo", function () { return {"td":$n[1].SpineSpriteAtlasAsset,"att":1056772,"a":3,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"height","t":4,"rt":$n[0].Single,"sn":"height","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"packingRotation","t":4,"rt":$n[3].SpritePackingRotation,"sn":"packingRotation","box":function ($v) { return Bridge.box($v, UnityEngine.SpritePackingRotation, System.Enum.toStringFn(UnityEngine.SpritePackingRotation));}},{"a":2,"n":"width","t":4,"rt":$n[0].Single,"sn":"width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Unity.SpineSpriteAtlasAsset+SavedRegionInfo end.*/

    /*Spine.Unity.BoneFollower start.*/
    $m("Spine.Unity.BoneFollower", function () { return {"nested":[$n[1].BoneFollower.AxisOrientation],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.AddComponentMenu.ctor("Spine/BoneFollower"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#BoneFollower")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"HandleRebuildRenderer","t":8,"pi":[{"n":"skeletonRenderer","pt":$n[1].SkeletonRenderer,"ps":0}],"sn":"HandleRebuildRenderer","rt":$n[0].Void,"p":[$n[1].SkeletonRenderer]},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":2,"n":"SetBone","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"SetBone","rt":$n[0].Boolean,"p":[$n[0].String],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SkeletonRenderer","t":16,"rt":$n[1].SkeletonRenderer,"g":{"a":2,"n":"get_SkeletonRenderer","t":8,"rt":$n[1].SkeletonRenderer,"fg":"SkeletonRenderer"},"s":{"a":2,"n":"set_SkeletonRenderer","t":8,"p":[$n[1].SkeletonRenderer],"rt":$n[0].Void,"fs":"SkeletonRenderer"},"fn":"SkeletonRenderer"},{"a":2,"n":"bone","t":4,"rt":$n[5].Bone,"sn":"bone"},{"at":[new Spine.Unity.SpineBone("", "skeletonRenderer", true, false)],"a":2,"n":"boneName","t":4,"rt":$n[0].String,"sn":"boneName"},{"a":2,"n":"followBoneRotation","t":4,"rt":$n[0].Boolean,"sn":"followBoneRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Follows the target bone's local scale."),new UnityEngine.Serialization.FormerlySerializedAsAttribute("followScale")],"a":2,"n":"followLocalScale","t":4,"rt":$n[0].Boolean,"sn":"followLocalScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Includes the parent bone's lossy world scale. BoneFollower cannot inherit rotated/skewed scale because of UnityEngine.Transform property limitations.")],"a":2,"n":"followParentWorldScale","t":4,"rt":$n[0].Boolean,"sn":"followParentWorldScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Follows the skeleton's flip state by controlling this Transform's local scale.")],"a":2,"n":"followSkeletonFlip","t":4,"rt":$n[0].Boolean,"sn":"followSkeletonFlip","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followXYPosition","t":4,"rt":$n[0].Boolean,"sn":"followXYPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followZPosition","t":4,"rt":$n[0].Boolean,"sn":"followZPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("resetOnAwake")],"a":2,"n":"initializeOnAwake","t":4,"rt":$n[0].Boolean,"sn":"initializeOnAwake","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Applies when 'Follow Skeleton Flip' is disabled but 'Follow Bone Rotation' is enabled. When flipping the skeleton by scaling its Transform, this follower's rotation is adjusted instead of its scale to follow the bone orientation. When one of the axes is flipped,  only one axis can be followed, either the X or the Y axis, which is selected here.")],"a":2,"n":"maintainedAxisOrientation","t":4,"rt":$n[1].BoneFollower.AxisOrientation,"sn":"maintainedAxisOrientation","box":function ($v) { return Bridge.box($v, Spine.Unity.BoneFollower.AxisOrientation, System.Enum.toStringFn(Spine.Unity.BoneFollower.AxisOrientation));}},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[1].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":1,"n":"skeletonTransform","t":4,"rt":$n[3].Transform,"sn":"skeletonTransform"},{"a":1,"n":"skeletonTransformIsParent","t":4,"rt":$n[0].Boolean,"sn":"skeletonTransformIsParent","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.BoneFollower end.*/

    /*Spine.Unity.BoneFollower+AxisOrientation start.*/
    $m("Spine.Unity.BoneFollower.AxisOrientation", function () { return {"td":$n[1].BoneFollower,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"XAxis","is":true,"t":4,"rt":$n[1].BoneFollower.AxisOrientation,"sn":"XAxis","box":function ($v) { return Bridge.box($v, Spine.Unity.BoneFollower.AxisOrientation, System.Enum.toStringFn(Spine.Unity.BoneFollower.AxisOrientation));}},{"a":2,"n":"YAxis","is":true,"t":4,"rt":$n[1].BoneFollower.AxisOrientation,"sn":"YAxis","box":function ($v) { return Bridge.box($v, Spine.Unity.BoneFollower.AxisOrientation, System.Enum.toStringFn(Spine.Unity.BoneFollower.AxisOrientation));}}]}; }, $n);
    /*Spine.Unity.BoneFollower+AxisOrientation end.*/

    /*Spine.Unity.BoneFollowerGraphic start.*/
    $m("Spine.Unity.BoneFollowerGraphic", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.ctor(UnityEngine.RectTransform),new UnityEngine.DisallowMultipleComponent(),new UnityEngine.AddComponentMenu.ctor("Spine/UI/BoneFollowerGraphic"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#BoneFollowerGraphic")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":2,"n":"SetBone","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"SetBone","rt":$n[0].Boolean,"p":[$n[0].String],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SkeletonGraphic","t":16,"rt":$n[1].SkeletonGraphic,"g":{"a":2,"n":"get_SkeletonGraphic","t":8,"rt":$n[1].SkeletonGraphic,"fg":"SkeletonGraphic"},"s":{"a":2,"n":"set_SkeletonGraphic","t":8,"p":[$n[1].SkeletonGraphic],"rt":$n[0].Void,"fs":"SkeletonGraphic"},"fn":"SkeletonGraphic"},{"a":2,"n":"bone","t":4,"rt":$n[5].Bone,"sn":"bone"},{"at":[new Spine.Unity.SpineBone("", "skeletonGraphic", true, false)],"a":2,"n":"boneName","t":4,"rt":$n[0].String,"sn":"boneName"},{"a":2,"n":"followBoneRotation","t":4,"rt":$n[0].Boolean,"sn":"followBoneRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Follows the target bone's local scale.")],"a":2,"n":"followLocalScale","t":4,"rt":$n[0].Boolean,"sn":"followLocalScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Includes the parent bone's lossy world scale. BoneFollower cannot inherit rotated/skewed scale because of UnityEngine.Transform property limitations.")],"a":2,"n":"followParentWorldScale","t":4,"rt":$n[0].Boolean,"sn":"followParentWorldScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Follows the skeleton's flip state by controlling this Transform's local scale.")],"a":2,"n":"followSkeletonFlip","t":4,"rt":$n[0].Boolean,"sn":"followSkeletonFlip","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followXYPosition","t":4,"rt":$n[0].Boolean,"sn":"followXYPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followZPosition","t":4,"rt":$n[0].Boolean,"sn":"followZPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initializeOnAwake","t":4,"rt":$n[0].Boolean,"sn":"initializeOnAwake","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Applies when 'Follow Skeleton Flip' is disabled but 'Follow Bone Rotation' is enabled. When flipping the skeleton by scaling its Transform, this follower's rotation is adjusted instead of its scale to follow the bone orientation. When one of the axes is flipped,  only one axis can be followed, either the X or the Y axis, which is selected here.")],"a":2,"n":"maintainedAxisOrientation","t":4,"rt":$n[1].BoneFollower.AxisOrientation,"sn":"maintainedAxisOrientation","box":function ($v) { return Bridge.box($v, Spine.Unity.BoneFollower.AxisOrientation, System.Enum.toStringFn(Spine.Unity.BoneFollower.AxisOrientation));}},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[1].SkeletonGraphic,"sn":"skeletonGraphic"},{"a":1,"n":"skeletonTransform","t":4,"rt":$n[3].Transform,"sn":"skeletonTransform"},{"a":1,"n":"skeletonTransformIsParent","t":4,"rt":$n[0].Boolean,"sn":"skeletonTransformIsParent","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.BoneFollowerGraphic end.*/

    /*Spine.Unity.BoundingBoxFollower start.*/
    $m("Spine.Unity.BoundingBoxFollower", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#BoundingBoxFollower")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AddCollidersForSkin","t":8,"pi":[{"n":"skin","pt":$n[5].Skin,"ps":0},{"n":"slotIndex","pt":$n[0].Int32,"ps":1},{"n":"previousColliders","pt":System.Array.type(UnityEngine.PolygonCollider2D),"ps":2},{"n":"collidersCount","ref":true,"pt":$n[0].Int32,"ps":3}],"sn":"AddCollidersForSkin","rt":$n[0].Void,"p":[$n[5].Skin,$n[0].Int32,System.Array.type(UnityEngine.PolygonCollider2D),$n[0].Int32]},{"a":2,"n":"ClearState","t":8,"sn":"ClearState","rt":$n[0].Void},{"a":1,"n":"DisposeExcessCollidersAfter","t":8,"pi":[{"n":"requiredCount","pt":$n[0].Int32,"ps":0}],"sn":"DisposeExcessCollidersAfter","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"HandleRebuild","t":8,"pi":[{"n":"sr","pt":$n[1].SkeletonRenderer,"ps":0}],"sn":"HandleRebuild","rt":$n[0].Void,"p":[$n[1].SkeletonRenderer]},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"MatchAttachment","t":8,"pi":[{"n":"attachment","pt":spine.Attachment,"ps":0}],"sn":"MatchAttachment","rt":$n[0].Void,"p":[spine.Attachment]},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"CurrentAttachment","t":16,"rt":spine.BoundingBoxAttachment,"g":{"a":2,"n":"get_CurrentAttachment","t":8,"rt":spine.BoundingBoxAttachment,"fg":"CurrentAttachment"},"fn":"CurrentAttachment"},{"a":2,"n":"CurrentAttachmentName","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_CurrentAttachmentName","t":8,"rt":$n[0].String,"fg":"CurrentAttachmentName"},"fn":"CurrentAttachmentName"},{"a":2,"n":"CurrentCollider","t":16,"rt":$n[3].PolygonCollider2D,"g":{"a":2,"n":"get_CurrentCollider","t":8,"rt":$n[3].PolygonCollider2D,"fg":"CurrentCollider"},"fn":"CurrentCollider"},{"a":2,"n":"IsTrigger","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsTrigger","t":8,"rt":$n[0].Boolean,"fg":"IsTrigger","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsTrigger"},{"a":2,"n":"Slot","t":16,"rt":$n[5].Slot,"g":{"a":2,"n":"get_Slot","t":8,"rt":$n[5].Slot,"fg":"Slot"},"fn":"Slot"},{"a":4,"n":"DebugMessages","is":true,"t":4,"rt":$n[0].Boolean,"sn":"DebugMessages","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"clearStateOnDisable","t":4,"rt":$n[0].Boolean,"sn":"clearStateOnDisable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"colliderTable","t":4,"rt":$n[2].Dictionary$2(spine.BoundingBoxAttachment,UnityEngine.PolygonCollider2D),"sn":"colliderTable","ro":true},{"a":1,"n":"currentAttachment","t":4,"rt":spine.BoundingBoxAttachment,"sn":"currentAttachment"},{"a":1,"n":"currentAttachmentName","t":4,"rt":$n[0].String,"sn":"currentAttachmentName"},{"a":1,"n":"currentCollider","t":4,"rt":$n[3].PolygonCollider2D,"sn":"currentCollider"},{"a":2,"n":"isTrigger","t":4,"rt":$n[0].Boolean,"sn":"isTrigger","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"nameTable","t":4,"rt":$n[2].Dictionary$2(spine.BoundingBoxAttachment,System.String),"sn":"nameTable","ro":true},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[1].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":1,"n":"slot","t":4,"rt":$n[5].Slot,"sn":"slot"},{"at":[new Spine.Unity.SpineSlot("", "skeletonRenderer", true, true, false)],"a":2,"n":"slotName","t":4,"rt":$n[0].String,"sn":"slotName"},{"a":2,"n":"usedByComposite","t":4,"rt":$n[0].Boolean,"sn":"usedByComposite","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"usedByEffector","t":4,"rt":$n[0].Boolean,"sn":"usedByEffector","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.BoundingBoxFollower end.*/

    /*Spine.Unity.BoundingBoxFollowerGraphic start.*/
    $m("Spine.Unity.BoundingBoxFollowerGraphic", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#BoundingBoxFollowerGraphic")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AddCollidersForSkin","t":8,"pi":[{"n":"skin","pt":$n[5].Skin,"ps":0},{"n":"slotIndex","pt":$n[0].Int32,"ps":1},{"n":"previousColliders","pt":System.Array.type(UnityEngine.PolygonCollider2D),"ps":2},{"n":"scale","pt":$n[0].Single,"ps":3},{"n":"collidersCount","ref":true,"pt":$n[0].Int32,"ps":4}],"sn":"AddCollidersForSkin","rt":$n[0].Void,"p":[$n[5].Skin,$n[0].Int32,System.Array.type(UnityEngine.PolygonCollider2D),$n[0].Single,$n[0].Int32]},{"a":2,"n":"ClearState","t":8,"sn":"ClearState","rt":$n[0].Void},{"a":1,"n":"DisposeExcessCollidersAfter","t":8,"pi":[{"n":"requiredCount","pt":$n[0].Int32,"ps":0}],"sn":"DisposeExcessCollidersAfter","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"HandleRebuild","t":8,"pi":[{"n":"sr","pt":$n[1].SkeletonGraphic,"ps":0}],"sn":"HandleRebuild","rt":$n[0].Void,"p":[$n[1].SkeletonGraphic]},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"MatchAttachment","t":8,"pi":[{"n":"attachment","pt":spine.Attachment,"ps":0}],"sn":"MatchAttachment","rt":$n[0].Void,"p":[spine.Attachment]},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"CurrentAttachment","t":16,"rt":spine.BoundingBoxAttachment,"g":{"a":2,"n":"get_CurrentAttachment","t":8,"rt":spine.BoundingBoxAttachment,"fg":"CurrentAttachment"},"fn":"CurrentAttachment"},{"a":2,"n":"CurrentAttachmentName","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_CurrentAttachmentName","t":8,"rt":$n[0].String,"fg":"CurrentAttachmentName"},"fn":"CurrentAttachmentName"},{"a":2,"n":"CurrentCollider","t":16,"rt":$n[3].PolygonCollider2D,"g":{"a":2,"n":"get_CurrentCollider","t":8,"rt":$n[3].PolygonCollider2D,"fg":"CurrentCollider"},"fn":"CurrentCollider"},{"a":2,"n":"IsTrigger","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsTrigger","t":8,"rt":$n[0].Boolean,"fg":"IsTrigger","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsTrigger"},{"a":2,"n":"Slot","t":16,"rt":$n[5].Slot,"g":{"a":2,"n":"get_Slot","t":8,"rt":$n[5].Slot,"fg":"Slot"},"fn":"Slot"},{"a":4,"n":"DebugMessages","is":true,"t":4,"rt":$n[0].Boolean,"sn":"DebugMessages","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"clearStateOnDisable","t":4,"rt":$n[0].Boolean,"sn":"clearStateOnDisable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"colliderTable","t":4,"rt":$n[2].Dictionary$2(spine.BoundingBoxAttachment,UnityEngine.PolygonCollider2D),"sn":"colliderTable","ro":true},{"a":1,"n":"currentAttachment","t":4,"rt":spine.BoundingBoxAttachment,"sn":"currentAttachment"},{"a":1,"n":"currentAttachmentName","t":4,"rt":$n[0].String,"sn":"currentAttachmentName"},{"a":1,"n":"currentCollider","t":4,"rt":$n[3].PolygonCollider2D,"sn":"currentCollider"},{"a":2,"n":"isTrigger","t":4,"rt":$n[0].Boolean,"sn":"isTrigger","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"nameTable","t":4,"rt":$n[2].Dictionary$2(spine.BoundingBoxAttachment,System.String),"sn":"nameTable","ro":true},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[1].SkeletonGraphic,"sn":"skeletonGraphic"},{"a":1,"n":"slot","t":4,"rt":$n[5].Slot,"sn":"slot"},{"at":[new Spine.Unity.SpineSlot("", "skeletonGraphic", true, true, false)],"a":2,"n":"slotName","t":4,"rt":$n[0].String,"sn":"slotName"},{"a":2,"n":"usedByComposite","t":4,"rt":$n[0].Boolean,"sn":"usedByComposite","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"usedByEffector","t":4,"rt":$n[0].Boolean,"sn":"usedByEffector","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.BoundingBoxFollowerGraphic end.*/

    /*Spine.Unity.PointFollower start.*/
    $m("Spine.Unity.PointFollower", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.AddComponentMenu.ctor("Spine/Point Follower"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#PointFollower")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"HandleRebuildRenderer","t":8,"pi":[{"n":"skeletonRenderer","pt":$n[1].SkeletonRenderer,"ps":0}],"sn":"HandleRebuildRenderer","rt":$n[0].Void,"p":[$n[1].SkeletonRenderer]},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":1,"n":"UpdateReferences","t":8,"sn":"UpdateReferences","rt":$n[0].Void},{"a":2,"n":"IsValid","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsValid","t":8,"rt":$n[0].Boolean,"fg":"IsValid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsValid"},{"a":2,"n":"SkeletonComponent","t":16,"rt":$n[1].ISkeletonComponent,"g":{"a":2,"n":"get_SkeletonComponent","t":8,"rt":$n[1].ISkeletonComponent,"fg":"SkeletonComponent"},"fn":"SkeletonComponent"},{"a":2,"n":"SkeletonRenderer","t":16,"rt":$n[1].SkeletonRenderer,"g":{"a":2,"n":"get_SkeletonRenderer","t":8,"rt":$n[1].SkeletonRenderer,"fg":"SkeletonRenderer"},"fn":"SkeletonRenderer"},{"a":1,"n":"bone","t":4,"rt":$n[5].Bone,"sn":"bone"},{"a":2,"n":"followRotation","t":4,"rt":$n[0].Boolean,"sn":"followRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followSkeletonFlip","t":4,"rt":$n[0].Boolean,"sn":"followSkeletonFlip","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followSkeletonZPosition","t":4,"rt":$n[0].Boolean,"sn":"followSkeletonZPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"point","t":4,"rt":$n[5].PointAttachment,"sn":"point"},{"at":[new Spine.Unity.SpineAttachment(true, false, false, "slotName", "skeletonRenderer", "", true, true)],"a":2,"n":"pointAttachmentName","t":4,"rt":$n[0].String,"sn":"pointAttachmentName"},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[1].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":1,"n":"skeletonTransform","t":4,"rt":$n[3].Transform,"sn":"skeletonTransform"},{"a":1,"n":"skeletonTransformIsParent","t":4,"rt":$n[0].Boolean,"sn":"skeletonTransformIsParent","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new Spine.Unity.SpineSlot("", "skeletonRenderer", false, true, false)],"a":2,"n":"slotName","t":4,"rt":$n[0].String,"sn":"slotName"},{"a":1,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.PointFollower end.*/

    /*Spine.Unity.SkeletonSubmeshGraphic start.*/
    $m("Spine.Unity.SkeletonSubmeshGraphic", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.CanvasRenderer)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":3,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"ov":true,"a":3,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"ov":true,"a":3,"n":"OnPopulateMesh","t":8,"pi":[{"n":"vh","pt":$n[7].VertexHelper,"ps":0}],"sn":"OnPopulateMesh","rt":$n[0].Void,"p":[$n[7].VertexHelper]},{"ov":true,"a":2,"n":"SetMaterialDirty","t":8,"sn":"SetMaterialDirty","rt":$n[0].Void},{"ov":true,"a":2,"n":"SetVerticesDirty","t":8,"sn":"SetVerticesDirty","rt":$n[0].Void}]}; }, $n);
    /*Spine.Unity.SkeletonSubmeshGraphic end.*/

    /*Spine.Unity.SkeletonMecanimRootMotion start.*/
    $m("Spine.Unity.SkeletonMecanimRootMotion", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonMecanimRootMotion")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":3,"n":"CalculateAnimationsMovementDelta","t":8,"sn":"CalculateAnimationsMovementDelta","rt":$n[3].Vector2},{"ov":true,"a":3,"n":"CalculateAnimationsRotationDelta","t":8,"sn":"CalculateAnimationsRotationDelta","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"ov":true,"a":2,"n":"GetRemainingRootMotion","t":8,"pi":[{"n":"layerIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetRemainingRootMotion","rt":$n[3].Vector2,"p":[$n[0].Int32]},{"ov":true,"a":2,"n":"GetRootMotionInfo","t":8,"pi":[{"n":"layerIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetRootMotionInfo","rt":$n[1].SkeletonRootMotionBase.RootMotionInfo,"p":[$n[0].Int32]},{"a":1,"n":"OnClipApplied","t":8,"pi":[{"n":"animation","pt":$n[5].Animation,"ps":0},{"n":"layerIndex","pt":$n[0].Int32,"ps":1},{"n":"weight","pt":$n[0].Single,"ps":2},{"n":"time","pt":$n[0].Single,"ps":3},{"n":"lastTime","pt":$n[0].Single,"ps":4},{"n":"playsBackward","pt":$n[0].Boolean,"ps":5}],"sn":"OnClipApplied","rt":$n[0].Void,"p":[$n[5].Animation,$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"ov":true,"a":3,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"ov":true,"a":3,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"SkeletonMecanim","t":16,"rt":$n[1].SkeletonMecanim,"g":{"a":2,"n":"get_SkeletonMecanim","t":8,"rt":$n[1].SkeletonMecanim,"fg":"SkeletonMecanim"},"fn":"SkeletonMecanim"},{"a":1,"n":"DefaultMecanimLayerFlags","is":true,"t":4,"rt":$n[0].Int32,"sn":"DefaultMecanimLayerFlags","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"mecanimLayerFlags","t":4,"rt":$n[0].Int32,"sn":"mecanimLayerFlags","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"movementDelta","t":4,"rt":$n[3].Vector2,"sn":"movementDelta"},{"a":3,"n":"rotationDelta","t":4,"rt":$n[0].Single,"sn":"rotationDelta","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"skeletonMecanim","t":4,"rt":$n[1].SkeletonMecanim,"sn":"skeletonMecanim"}]}; }, $n);
    /*Spine.Unity.SkeletonMecanimRootMotion end.*/

    /*Spine.Unity.SkeletonRootMotion start.*/
    $m("Spine.Unity.SkeletonRootMotion", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRootMotion")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"ApplyMixAlphaToDelta","t":8,"pi":[{"n":"currentDelta","ref":true,"pt":$n[0].Single,"ps":0},{"n":"next","pt":$n[5].TrackEntry,"ps":1},{"n":"track","pt":$n[5].TrackEntry,"ps":2}],"sn":"ApplyMixAlphaToDelta","rt":$n[0].Void,"p":[$n[0].Single,$n[5].TrackEntry,$n[5].TrackEntry]},{"a":1,"n":"ApplyMixAlphaToDelta","t":8,"pi":[{"n":"currentDelta","ref":true,"pt":$n[3].Vector2,"ps":0},{"n":"next","pt":$n[5].TrackEntry,"ps":1},{"n":"track","pt":$n[5].TrackEntry,"ps":2}],"sn":"ApplyMixAlphaToDelta$1","rt":$n[0].Void,"p":[$n[3].Vector2,$n[5].TrackEntry,$n[5].TrackEntry]},{"ov":true,"a":3,"n":"CalculateAnimationsMovementDelta","t":8,"sn":"CalculateAnimationsMovementDelta","rt":$n[3].Vector2},{"ov":true,"a":3,"n":"CalculateAnimationsRotationDelta","t":8,"sn":"CalculateAnimationsRotationDelta","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"GetMixAlpha","t":8,"pi":[{"n":"cumulatedMixAlpha","ref":true,"pt":$n[0].Single,"ps":0},{"n":"next","pt":$n[5].TrackEntry,"ps":1},{"n":"track","pt":$n[5].TrackEntry,"ps":2}],"sn":"GetMixAlpha","rt":$n[0].Void,"p":[$n[0].Single,$n[5].TrackEntry,$n[5].TrackEntry]},{"ov":true,"a":2,"n":"GetRemainingRootMotion","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetRemainingRootMotion","rt":$n[3].Vector2,"p":[$n[0].Int32]},{"ov":true,"a":2,"n":"GetRootMotionInfo","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetRootMotionInfo","rt":$n[1].SkeletonRootMotionBase.RootMotionInfo,"p":[$n[0].Int32]},{"ov":true,"a":3,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"ov":true,"a":3,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"ov":true,"a":3,"n":"AdditionalScale","t":16,"rt":$n[0].Single,"g":{"ov":true,"a":3,"n":"get_AdditionalScale","t":8,"rt":$n[0].Single,"fg":"AdditionalScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"AdditionalScale"},{"a":1,"n":"DefaultAnimationTrackFlags","is":true,"t":4,"rt":$n[0].Int32,"sn":"DefaultAnimationTrackFlags","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"animationState","t":4,"rt":$n[5].AnimationState,"sn":"animationState"},{"a":2,"n":"animationTrackFlags","t":4,"rt":$n[0].Int32,"sn":"animationTrackFlags","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"skeletonGraphic","t":4,"rt":$n[1].SkeletonGraphic,"sn":"skeletonGraphic"}]}; }, $n);
    /*Spine.Unity.SkeletonRootMotion end.*/

    /*Spine.Unity.SkeletonRootMotionBase start.*/
    $m("Spine.Unity.SkeletonRootMotionBase", function () { return {"nested":[Function,$n[1].SkeletonRootMotionBase.RootMotionInfo],"att":1048705,"a":2,"at":[new UnityEngine.DefaultExecutionOrder(1)],"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AdjustRootMotionToDistance","t":8,"pi":[{"n":"distanceToTarget","pt":$n[3].Vector2,"ps":0},{"n":"trackIndex","dv":0,"o":true,"pt":$n[0].Int32,"ps":1},{"n":"adjustX","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"adjustY","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"minX","dv":0.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"maxX","dv":3.40282347E+38,"o":true,"pt":$n[0].Single,"ps":5},{"n":"minY","dv":0.0,"o":true,"pt":$n[0].Single,"ps":6},{"n":"maxY","dv":3.40282347E+38,"o":true,"pt":$n[0].Single,"ps":7},{"n":"allowXTranslation","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8},{"n":"allowYTranslation","dv":false,"o":true,"pt":$n[0].Boolean,"ps":9}],"sn":"AdjustRootMotionToDistance","rt":$n[0].Void,"p":[$n[3].Vector2,$n[0].Int32,$n[0].Boolean,$n[0].Boolean,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"ApplyConstraintToPos","t":8,"pi":[{"n":"animation","pt":$n[5].Animation,"ps":0},{"n":"constraint","pt":$n[5].TransformConstraint,"ps":1},{"n":"constraintIndex","pt":$n[0].Int32,"ps":2},{"n":"time","pt":$n[0].Single,"ps":3},{"n":"useLastConstraintPos","pt":$n[0].Boolean,"ps":4},{"n":"pos","ref":true,"pt":$n[3].Vector2,"ps":5}],"sn":"ApplyConstraintToPos","rt":$n[0].Void,"p":[$n[5].Animation,$n[5].TransformConstraint,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[3].Vector2]},{"a":1,"n":"ApplyConstraintToRotation","t":8,"pi":[{"n":"animation","pt":$n[5].Animation,"ps":0},{"n":"constraint","pt":$n[5].TransformConstraint,"ps":1},{"n":"constraintIndex","pt":$n[0].Int32,"ps":2},{"n":"time","pt":$n[0].Single,"ps":3},{"n":"useLastConstraintRotation","pt":$n[0].Boolean,"ps":4},{"n":"rotation","ref":true,"pt":$n[0].Single,"ps":5}],"sn":"ApplyConstraintToRotation","rt":$n[0].Void,"p":[$n[5].Animation,$n[5].TransformConstraint,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[0].Single]},{"a":1,"n":"ApplyRootMotion","t":8,"pi":[{"n":"skeletonTranslationDelta","pt":$n[3].Vector2,"ps":0},{"n":"skeletonRotationDelta","pt":$n[0].Single,"ps":1},{"n":"parentBoneScale","pt":$n[3].Vector2,"ps":2},{"n":"skeletonAnimationUsesFixedUpdate","pt":$n[0].Boolean,"ps":3}],"sn":"ApplyRootMotion","rt":$n[0].Void,"p":[$n[3].Vector2,$n[0].Single,$n[3].Vector2,$n[0].Boolean]},{"a":1,"n":"ApplyTransformConstraints","t":8,"sn":"ApplyTransformConstraints","rt":$n[0].Void},{"ab":true,"a":3,"n":"CalculateAnimationsMovementDelta","t":8,"sn":"CalculateAnimationsMovementDelta","rt":$n[3].Vector2},{"v":true,"a":3,"n":"CalculateAnimationsRotationDelta","t":8,"sn":"CalculateAnimationsRotationDelta","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"ClearEffectiveBoneOffsets","t":8,"pi":[{"n":"parentBoneScale","pt":$n[3].Vector2,"ps":0}],"sn":"ClearEffectiveBoneOffsets","rt":$n[0].Void,"p":[$n[3].Vector2]},{"a":1,"n":"ClearRigidbodyTempMovement","t":8,"sn":"ClearRigidbodyTempMovement","rt":$n[0].Void},{"a":3,"n":"FindRigidbodyComponent","t":8,"sn":"FindRigidbodyComponent","rt":$n[0].Void},{"a":1,"n":"FindTransformConstraintsAffectingBone","t":8,"sn":"FindTransformConstraintsAffectingBone","rt":$n[0].Void},{"v":true,"a":3,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"GatherTopLevelBones","t":8,"sn":"GatherTopLevelBones","rt":$n[0].Void},{"a":2,"n":"GetAnimationRootMotion","t":8,"pi":[{"n":"animation","pt":$n[5].Animation,"ps":0}],"sn":"GetAnimationRootMotion","rt":$n[3].Vector2,"p":[$n[5].Animation]},{"a":2,"n":"GetAnimationRootMotion","t":8,"pi":[{"n":"startTime","pt":$n[0].Single,"ps":0},{"n":"endTime","pt":$n[0].Single,"ps":1},{"n":"animation","pt":$n[5].Animation,"ps":2}],"sn":"GetAnimationRootMotion$1","rt":$n[3].Vector2,"p":[$n[0].Single,$n[0].Single,$n[5].Animation]},{"a":2,"n":"GetAnimationRootMotionInfo","t":8,"pi":[{"n":"animation","pt":$n[5].Animation,"ps":0},{"n":"currentTime","pt":$n[0].Single,"ps":1}],"sn":"GetAnimationRootMotionInfo","rt":$n[1].SkeletonRootMotionBase.RootMotionInfo,"p":[$n[5].Animation,$n[0].Single]},{"a":2,"n":"GetAnimationRootMotionRotation","t":8,"pi":[{"n":"animation","pt":$n[5].Animation,"ps":0}],"sn":"GetAnimationRootMotionRotation","rt":$n[0].Single,"p":[$n[5].Animation],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"GetAnimationRootMotionRotation","t":8,"pi":[{"n":"startTime","pt":$n[0].Single,"ps":0},{"n":"endTime","pt":$n[0].Single,"ps":1},{"n":"animation","pt":$n[5].Animation,"ps":2}],"sn":"GetAnimationRootMotionRotation$1","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[5].Animation],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"GetConstraintLastPosIndex","t":8,"pi":[{"n":"constraintIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetConstraintLastPosIndex","rt":$n[0].Int32,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"ab":true,"a":2,"n":"GetRemainingRootMotion","t":8,"pi":[{"n":"trackIndex","dv":0,"o":true,"pt":$n[0].Int32,"ps":0}],"sn":"GetRemainingRootMotion","rt":$n[3].Vector2,"p":[$n[0].Int32]},{"ab":true,"a":2,"n":"GetRootMotionInfo","t":8,"pi":[{"n":"trackIndex","dv":0,"o":true,"pt":$n[0].Int32,"ps":0}],"sn":"GetRootMotionInfo","rt":$n[1].SkeletonRootMotionBase.RootMotionInfo,"p":[$n[0].Int32]},{"a":1,"n":"GetScaleAffectingRootMotion","t":8,"sn":"GetScaleAffectingRootMotion","rt":$n[3].Vector2},{"a":1,"n":"GetScaleAffectingRootMotion","t":8,"pi":[{"n":"parentBoneScale","out":true,"pt":$n[3].Vector2,"ps":0}],"sn":"GetScaleAffectingRootMotion$1","rt":$n[3].Vector2,"p":[$n[3].Vector2]},{"a":1,"n":"GetSkeletonSpaceMovementDelta","t":8,"pi":[{"n":"boneLocalDelta","pt":$n[3].Vector2,"ps":0},{"n":"parentBoneScale","out":true,"pt":$n[3].Vector2,"ps":1},{"n":"totalScale","out":true,"pt":$n[3].Vector2,"ps":2}],"sn":"GetSkeletonSpaceMovementDelta","rt":$n[3].Vector2,"p":[$n[3].Vector2,$n[3].Vector2,$n[3].Vector2]},{"a":1,"n":"GetSkeletonSpaceRotationDelta","t":8,"pi":[{"n":"boneLocalDelta","pt":$n[0].Single,"ps":0},{"n":"totalScaleAffectingRootMotion","pt":$n[3].Vector2,"ps":1}],"sn":"GetSkeletonSpaceRotationDelta","rt":$n[0].Single,"p":[$n[0].Single,$n[3].Vector2],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"GetTimelineMovementDelta","t":8,"pi":[{"n":"startTime","pt":$n[0].Single,"ps":0},{"n":"endTime","pt":$n[0].Single,"ps":1},{"n":"xTimeline","pt":spine.TranslateXTimeline,"ps":2},{"n":"yTimeline","pt":spine.TranslateYTimeline,"ps":3},{"n":"animation","pt":$n[5].Animation,"ps":4}],"sn":"GetTimelineMovementDelta","rt":$n[3].Vector2,"p":[$n[0].Single,$n[0].Single,spine.TranslateXTimeline,spine.TranslateYTimeline,$n[5].Animation]},{"a":1,"n":"HandleUpdateLocal","t":8,"pi":[{"n":"animatedSkeletonComponent","pt":$n[1].ISkeletonAnimation,"ps":0}],"sn":"HandleUpdateLocal","rt":$n[0].Void,"p":[$n[1].ISkeletonAnimation]},{"v":true,"a":3,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"v":true,"a":3,"n":"PhysicsUpdate","t":8,"pi":[{"n":"skeletonAnimationUsesFixedUpdate","pt":$n[0].Boolean,"ps":0}],"sn":"PhysicsUpdate","rt":$n[0].Void,"p":[$n[0].Boolean]},{"v":true,"a":3,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"a":1,"n":"SetEffectiveBoneOffsetsTo","t":8,"pi":[{"n":"displacementSkeletonSpace","pt":$n[3].Vector2,"ps":0},{"n":"rotationSkeletonSpace","pt":$n[0].Single,"ps":1},{"n":"parentBoneScale","pt":$n[3].Vector2,"ps":2}],"sn":"SetEffectiveBoneOffsetsTo","rt":$n[0].Void,"p":[$n[3].Vector2,$n[0].Single,$n[3].Vector2]},{"a":2,"n":"SetRootMotionBone","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"SetRootMotionBone","rt":$n[0].Void,"p":[$n[0].String]},{"v":true,"a":3,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"UpdateLastConstraintPos","t":8,"pi":[{"n":"transformConstraintsItems","pt":System.Array.type(Spine.TransformConstraint),"ps":0}],"sn":"UpdateLastConstraintPos","rt":$n[0].Void,"p":[System.Array.type(Spine.TransformConstraint)]},{"a":1,"n":"UpdateLastConstraintRotation","t":8,"pi":[{"n":"transformConstraintsItems","pt":System.Array.type(Spine.TransformConstraint),"ps":0}],"sn":"UpdateLastConstraintRotation","rt":$n[0].Void,"p":[System.Array.type(Spine.TransformConstraint)]},{"a":2,"n":"AdditionalRigidbody2DMovement","t":16,"rt":$n[3].Vector2,"g":{"a":2,"n":"get_AdditionalRigidbody2DMovement","t":8,"rt":$n[3].Vector2,"fg":"AdditionalRigidbody2DMovement"},"s":{"a":2,"n":"set_AdditionalRigidbody2DMovement","t":8,"p":[$n[3].Vector2],"rt":$n[0].Void,"fs":"AdditionalRigidbody2DMovement"},"fn":"AdditionalRigidbody2DMovement"},{"v":true,"a":3,"n":"AdditionalScale","t":16,"rt":$n[0].Single,"g":{"v":true,"a":3,"n":"get_AdditionalScale","t":8,"rt":$n[0].Single,"fg":"AdditionalScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"AdditionalScale"},{"a":2,"n":"PreviousRigidbodyRootMotion2D","t":16,"rt":$n[3].Vector2,"g":{"a":2,"n":"get_PreviousRigidbodyRootMotion2D","t":8,"rt":$n[3].Vector2,"fg":"PreviousRigidbodyRootMotion2D"},"fn":"PreviousRigidbodyRootMotion2D"},{"a":2,"n":"PreviousRigidbodyRootMotion3D","t":16,"rt":$n[3].Vector3,"g":{"a":2,"n":"get_PreviousRigidbodyRootMotion3D","t":8,"rt":$n[3].Vector3,"fg":"PreviousRigidbodyRootMotion3D"},"fn":"PreviousRigidbodyRootMotion3D"},{"a":2,"n":"RootMotionBone","t":16,"rt":$n[5].Bone,"g":{"a":2,"n":"get_RootMotionBone","t":8,"rt":$n[5].Bone,"fg":"RootMotionBone"},"fn":"RootMotionBone"},{"a":3,"n":"SkeletonAnimationUsesFixedUpdate","t":16,"rt":$n[0].Boolean,"g":{"a":3,"n":"get_SkeletonAnimationUsesFixedUpdate","t":8,"rt":$n[0].Boolean,"fg":"SkeletonAnimationUsesFixedUpdate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"SkeletonAnimationUsesFixedUpdate"},{"a":2,"n":"TargetSkeletonAnimationComponent","t":16,"rt":$n[1].ISkeletonAnimation,"g":{"a":2,"n":"get_TargetSkeletonAnimationComponent","t":8,"rt":$n[1].ISkeletonAnimation,"fg":"TargetSkeletonAnimationComponent"},"fn":"TargetSkeletonAnimationComponent"},{"a":2,"n":"TargetSkeletonComponent","t":16,"rt":$n[1].ISkeletonComponent,"g":{"a":2,"n":"get_TargetSkeletonComponent","t":8,"rt":$n[1].ISkeletonComponent,"fg":"TargetSkeletonComponent"},"fn":"TargetSkeletonComponent"},{"a":2,"n":"UsesRigidbody","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_UsesRigidbody","t":8,"rt":$n[0].Boolean,"fg":"UsesRigidbody","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"UsesRigidbody"},{"a":3,"n":"accumulatedUntilFixedUpdate","t":4,"rt":$n[0].Boolean,"sn":"accumulatedUntilFixedUpdate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"additionalRigidbody2DMovement","t":4,"rt":$n[3].Vector2,"sn":"additionalRigidbody2DMovement"},{"a":2,"n":"applyRigidbody2DGravity","t":4,"rt":$n[0].Boolean,"sn":"applyRigidbody2DGravity","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"disableOnOverride","t":4,"rt":$n[0].Boolean,"sn":"disableOnOverride","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"initialOffset","t":4,"rt":$n[3].Vector2,"sn":"initialOffset"},{"a":3,"n":"initialOffsetRotation","t":4,"rt":$n[0].Single,"sn":"initialOffsetRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":3,"n":"previousRigidbodyRootMotion","t":4,"rt":$n[3].Vector3,"sn":"previousRigidbodyRootMotion"},{"a":2,"n":"rigidBody","t":4,"rt":$n[3].Rigidbody,"sn":"rigidBody"},{"at":[new UnityEngine.HeaderAttribute("Optional")],"a":2,"n":"rigidBody2D","t":4,"rt":$n[3].Rigidbody2D,"sn":"rigidBody2D"},{"a":3,"n":"rigidbody2DRotation","t":4,"rt":$n[0].Single,"sn":"rigidbody2DRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":3,"n":"rigidbodyDisplacement","t":4,"rt":$n[3].Vector3,"sn":"rigidbodyDisplacement"},{"a":3,"n":"rigidbodyLocalRotation","t":4,"rt":$n[3].Quaternion,"sn":"rigidbodyLocalRotation"},{"a":3,"n":"rootMotionBone","t":4,"rt":$n[5].Bone,"sn":"rootMotionBone"},{"a":3,"n":"rootMotionBoneIndex","t":4,"rt":$n[0].Int32,"sn":"rootMotionBoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new Spine.Unity.SpineBone("", "", true, false),new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"rootMotionBoneName","t":4,"rt":$n[0].String,"sn":"rootMotionBoneName"},{"a":2,"n":"rootMotionScaleRotation","t":4,"rt":$n[0].Single,"sn":"rootMotionScaleRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"rootMotionScaleX","t":4,"rt":$n[0].Single,"sn":"rootMotionScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"rootMotionScaleY","t":4,"rt":$n[0].Single,"sn":"rootMotionScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"rootMotionTranslateXPerY","t":4,"rt":$n[0].Single,"sn":"rootMotionTranslateXPerY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"rootMotionTranslateYPerX","t":4,"rt":$n[0].Single,"sn":"rootMotionTranslateYPerX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":3,"n":"skeletonComponent","t":4,"rt":$n[1].ISkeletonComponent,"sn":"skeletonComponent"},{"a":3,"n":"tempSkeletonDisplacement","t":4,"rt":$n[3].Vector2,"sn":"tempSkeletonDisplacement"},{"a":3,"n":"tempSkeletonRotation","t":4,"rt":$n[0].Single,"sn":"tempSkeletonRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":3,"n":"topLevelBones","t":4,"rt":$n[2].List$1(Spine.Bone),"sn":"topLevelBones"},{"a":3,"n":"transformConstraintIndices","t":4,"rt":$n[2].List$1(System.Int32),"sn":"transformConstraintIndices"},{"a":3,"n":"transformConstraintLastPos","t":4,"rt":$n[2].List$1(UnityEngine.Vector2),"sn":"transformConstraintLastPos"},{"a":3,"n":"transformConstraintLastRotation","t":4,"rt":$n[2].List$1(System.Single),"sn":"transformConstraintLastRotation"},{"a":2,"n":"transformPositionX","t":4,"rt":$n[0].Boolean,"sn":"transformPositionX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"transformPositionY","t":4,"rt":$n[0].Boolean,"sn":"transformPositionY","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"transformRotation","t":4,"rt":$n[0].Boolean,"sn":"transformRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"PhysicsUpdateRootMotionOverride","t":2,"ad":{"a":2,"n":"add_PhysicsUpdateRootMotionOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addPhysicsUpdateRootMotionOverride","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_PhysicsUpdateRootMotionOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removePhysicsUpdateRootMotionOverride","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"ProcessRootMotionOverride","t":2,"ad":{"a":2,"n":"add_ProcessRootMotionOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addProcessRootMotionOverride","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_ProcessRootMotionOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeProcessRootMotionOverride","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonRootMotionBase end.*/

    /*Spine.Unity.SkeletonRootMotionBase+RootMotionInfo start.*/
    $m("Spine.Unity.SkeletonRootMotionBase.RootMotionInfo", function () { return {"td":$n[1].SkeletonRootMotionBase,"att":1048842,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"current","t":4,"rt":$n[3].Vector2,"sn":"current"},{"a":2,"n":"end","t":4,"rt":$n[3].Vector2,"sn":"end"},{"a":2,"n":"mid","t":4,"rt":$n[3].Vector2,"sn":"mid"},{"a":2,"n":"start","t":4,"rt":$n[3].Vector2,"sn":"start"},{"a":2,"n":"timeIsPastMid","t":4,"rt":$n[0].Boolean,"sn":"timeIsPastMid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SkeletonRootMotionBase+RootMotionInfo end.*/

    /*Spine.Unity.SkeletonAnimation start.*/
    $m("Spine.Unity.SkeletonAnimation", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.AddComponentMenu.ctor("Spine/SkeletonAnimation"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonAnimation-Component")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddToGameObject","is":true,"t":8,"pi":[{"n":"gameObject","pt":$n[3].GameObject,"ps":0},{"n":"skeletonDataAsset","pt":$n[1].SkeletonDataAsset,"ps":1},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"AddToGameObject","rt":$n[1].SkeletonAnimation,"p":[$n[3].GameObject,$n[1].SkeletonDataAsset,$n[0].Boolean]},{"a":2,"n":"AfterAnimationApplied","t":8,"sn":"AfterAnimationApplied","rt":$n[0].Void},{"a":3,"n":"ApplyAnimation","t":8,"sn":"ApplyAnimation","rt":$n[0].Void},{"ov":true,"a":2,"n":"ClearState","t":8,"sn":"ClearState","rt":$n[0].Void},{"v":true,"a":3,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"ov":true,"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","pt":$n[0].Boolean,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean,$n[0].Boolean]},{"ov":true,"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":2,"n":"NewSkeletonAnimationGameObject","is":true,"t":8,"pi":[{"n":"skeletonDataAsset","pt":$n[1].SkeletonDataAsset,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"NewSkeletonAnimationGameObject","rt":$n[1].SkeletonAnimation,"p":[$n[1].SkeletonDataAsset,$n[0].Boolean]},{"ov":true,"a":2,"n":"OnBecameVisible","t":8,"sn":"OnBecameVisible","rt":$n[0].Void},{"v":true,"a":3,"n":"Update","t":8,"sn":"Update$1","rt":$n[0].Void},{"a":2,"n":"Update","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"Update","rt":$n[0].Void,"p":[$n[0].Single]},{"a":3,"n":"UpdateAnimationStatus","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"UpdateAnimationStatus","rt":$n[0].Void,"p":[$n[0].Single]},{"a":2,"n":"AnimationName","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_AnimationName","t":8,"rt":$n[0].String,"fg":"AnimationName"},"s":{"a":2,"n":"set_AnimationName","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"AnimationName"},"fn":"AnimationName"},{"a":2,"n":"AnimationState","t":16,"rt":$n[5].AnimationState,"g":{"a":2,"n":"get_AnimationState","t":8,"rt":$n[5].AnimationState,"fg":"AnimationState"},"fn":"AnimationState"},{"a":2,"n":"UnscaledTime","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_UnscaledTime","t":8,"rt":$n[0].Boolean,"fg":"UnscaledTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_UnscaledTime","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"UnscaledTime"},"fn":"UnscaledTime"},{"a":2,"n":"UpdateTiming","t":16,"rt":$n[1].UpdateTiming,"g":{"a":2,"n":"get_UpdateTiming","t":8,"rt":$n[1].UpdateTiming,"fg":"UpdateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},"s":{"a":2,"n":"set_UpdateTiming","t":8,"p":[$n[1].UpdateTiming],"rt":$n[0].Void,"fs":"UpdateTiming"},"fn":"UpdateTiming"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineAnimation("", "", true, false)],"a":1,"n":"_animationName","t":4,"rt":$n[0].String,"sn":"_animationName"},{"a":2,"n":"loop","t":4,"rt":$n[0].Boolean,"sn":"loop","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"state","t":4,"rt":$n[5].AnimationState,"sn":"state"},{"a":2,"n":"timeScale","t":4,"rt":$n[0].Single,"sn":"timeScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"unscaledTime","t":4,"rt":$n[0].Boolean,"sn":"unscaledTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"updateTiming","t":4,"rt":$n[1].UpdateTiming,"sn":"updateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},{"a":1,"n":"wasUpdatedAfterInit","t":4,"rt":$n[0].Boolean,"sn":"wasUpdatedAfterInit","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"BeforeApply","t":2,"ad":{"a":2,"n":"add_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addBeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeBeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnAnimationRebuild","t":2,"ad":{"a":2,"n":"add_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnAnimationRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnAnimationRebuild","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateComplete","t":2,"ad":{"a":2,"n":"add_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateLocal","t":2,"ad":{"a":2,"n":"add_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateWorld","t":2,"ad":{"a":2,"n":"add_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateWorld","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_BeforeApply","t":2,"ad":{"a":3,"n":"add__BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_BeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_BeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_OnAnimationRebuild","t":2,"ad":{"a":3,"n":"add__OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_OnAnimationRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_OnAnimationRebuild","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateComplete","t":2,"ad":{"a":3,"n":"add__UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateLocal","t":2,"ad":{"a":3,"n":"add__UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateWorld","t":2,"ad":{"a":3,"n":"add__UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateWorld","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonAnimation end.*/

    /*Spine.Unity.SkeletonGraphic start.*/
    $m("Spine.Unity.SkeletonGraphic", function () { return {"nested":[$n[1].SkeletonGraphic.LayoutMode,Function,Function,Function,Function],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.$ctor1(UnityEngine.CanvasRenderer, UnityEngine.RectTransform),new UnityEngine.DisallowMultipleComponent(),new UnityEngine.AddComponentMenu.ctor("Spine/SkeletonGraphic (Unity UI Canvas)"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonGraphic-Component")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddSkeletonGraphicComponent","is":true,"t":8,"pi":[{"n":"gameObject","pt":$n[3].GameObject,"ps":0},{"n":"skeletonDataAsset","pt":$n[1].SkeletonDataAsset,"ps":1},{"n":"material","pt":$n[3].Material,"ps":2}],"sn":"AddSkeletonGraphicComponent","rt":$n[1].SkeletonGraphic,"p":[$n[3].GameObject,$n[1].SkeletonDataAsset,$n[3].Material]},{"a":2,"n":"AfterAnimationApplied","t":8,"sn":"AfterAnimationApplied","rt":$n[0].Void},{"a":3,"n":"ApplyAnimation","t":8,"sn":"ApplyAnimation","rt":$n[0].Void},{"ov":true,"a":3,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":3,"n":"DestroyMeshes","t":8,"sn":"DestroyMeshes","rt":$n[0].Void},{"a":3,"n":"DisableUnusedCanvasRenderers","t":8,"pi":[{"n":"usedCount","pt":$n[0].Int32,"ps":0},{"n":"isInRebuild","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"DisableUnusedCanvasRenderers","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Boolean]},{"a":3,"n":"DisposeMeshBuffers","t":8,"sn":"DisposeMeshBuffers","rt":$n[0].Void},{"a":3,"n":"EnsureCanvasRendererCount","t":8,"pi":[{"n":"targetCount","pt":$n[0].Int32,"ps":0}],"sn":"EnsureCanvasRendererCount","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":3,"n":"EnsureMeshesCount","t":8,"pi":[{"n":"targetCount","pt":$n[0].Int32,"ps":0}],"sn":"EnsureMeshesCount","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":3,"n":"EnsureSeparatorPartCount","t":8,"sn":"EnsureSeparatorPartCount","rt":$n[0].Void},{"a":3,"n":"EnsureUsedTexturesAndMaterialsCount","t":8,"pi":[{"n":"targetCount","pt":$n[0].Int32,"ps":0}],"sn":"EnsureUsedTexturesAndMaterialsCount","rt":$n[0].Void,"p":[$n[0].Int32]},{"v":true,"a":3,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"GetCurrentRectSize","t":8,"sn":"GetCurrentRectSize","rt":$n[3].Vector2},{"a":2,"n":"GetLastMesh","t":8,"sn":"GetLastMesh","rt":$n[3].Mesh},{"a":3,"n":"GetLayoutScale","t":8,"pi":[{"n":"mode","pt":$n[1].SkeletonGraphic.LayoutMode,"ps":0}],"sn":"GetLayoutScale","rt":$n[0].Single,"p":[$n[1].SkeletonGraphic.LayoutMode],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"HandleOnDemandLoading","t":8,"sn":"HandleOnDemandLoading","rt":$n[0].Void},{"a":2,"n":"HasMultipleSubmeshInstructions","t":8,"sn":"HasMultipleSubmeshInstructions","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"InitMeshBuffers","t":8,"sn":"InitMeshBuffers","rt":$n[0].Void},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","pt":$n[0].Boolean,"ps":0}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":3,"n":"MatchRectTransformMultipleRenderers","t":8,"sn":"MatchRectTransformMultipleRenderers","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"MatchRectTransformSingleRenderer","t":8,"sn":"MatchRectTransformSingleRenderer","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"MatchRectTransformWithBounds","t":8,"sn":"MatchRectTransformWithBounds","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"NewSkeletonGraphicGameObject","is":true,"t":8,"pi":[{"n":"skeletonDataAsset","pt":$n[1].SkeletonDataAsset,"ps":0},{"n":"parent","pt":$n[3].Transform,"ps":1},{"n":"material","pt":$n[3].Material,"ps":2}],"sn":"NewSkeletonGraphicGameObject","rt":$n[1].SkeletonGraphic,"p":[$n[1].SkeletonDataAsset,$n[3].Transform,$n[3].Material]},{"a":2,"n":"OnBecameInvisible","t":8,"sn":"OnBecameInvisible","rt":$n[0].Void},{"a":2,"n":"OnBecameVisible","t":8,"sn":"OnBecameVisible","rt":$n[0].Void},{"a":3,"n":"OnCullStateChanged","t":8,"pi":[{"n":"culled","pt":$n[0].Boolean,"ps":0}],"sn":"OnCullStateChanged","rt":$n[0].Void,"p":[$n[0].Boolean]},{"ov":true,"a":3,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"ov":true,"a":3,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":2,"n":"PrepareInstructionsAndRenderers","t":8,"pi":[{"n":"isInRebuild","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"PrepareInstructionsAndRenderers","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":3,"n":"PrepareRendererGameObjects","t":8,"pi":[{"n":"currentInstructions","pt":$n[1].SkeletonRendererInstruction,"ps":0},{"n":"isInRebuild","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"PrepareRendererGameObjects","rt":$n[0].Void,"p":[$n[1].SkeletonRendererInstruction,$n[0].Boolean]},{"a":2,"n":"ReapplySeparatorSlotNames","t":8,"sn":"ReapplySeparatorSlotNames","rt":$n[0].Void},{"ov":true,"a":2,"n":"Rebuild","t":8,"pi":[{"n":"update","pt":$n[7].CanvasUpdate,"ps":0}],"sn":"Rebuild","rt":$n[0].Void,"p":[$n[7].CanvasUpdate]},{"a":1,"n":"SetRectTransformBounds","t":8,"pi":[{"n":"combinedBounds","pt":$n[3].Bounds,"ps":0}],"sn":"SetRectTransformBounds","rt":$n[0].Void,"p":[$n[3].Bounds]},{"a":2,"n":"SetRectTransformSize","is":true,"t":8,"pi":[{"n":"targetRectTransform","pt":$n[3].RectTransform,"ps":0},{"n":"size","pt":$n[3].Vector2,"ps":1}],"sn":"SetRectTransformSize","rt":$n[0].Void,"p":[$n[3].RectTransform,$n[3].Vector2]},{"a":2,"n":"SetRectTransformSize","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].Graphic,"ps":0},{"n":"size","pt":$n[3].Vector2,"ps":1}],"sn":"SetRectTransformSize$1","rt":$n[0].Void,"p":[$n[7].Graphic,$n[3].Vector2]},{"a":3,"n":"SyncSubmeshGraphicsWithCanvasRenderers","t":8,"sn":"SyncSubmeshGraphicsWithCanvasRenderers","rt":$n[0].Void},{"a":2,"n":"TrimRenderers","t":8,"sn":"TrimRenderers","rt":$n[0].Void},{"v":true,"a":2,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"v":true,"a":2,"n":"Update","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"Update$1","rt":$n[0].Void,"p":[$n[0].Single]},{"a":3,"n":"UpdateAnimationStatus","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"UpdateAnimationStatus","rt":$n[0].Void,"p":[$n[0].Single]},{"a":3,"n":"UpdateMaterialsMultipleCanvasRenderers","t":8,"pi":[{"n":"currentInstructions","pt":$n[1].SkeletonRendererInstruction,"ps":0}],"sn":"UpdateMaterialsMultipleCanvasRenderers","rt":$n[0].Void,"p":[$n[1].SkeletonRendererInstruction]},{"a":2,"n":"UpdateMesh","t":8,"sn":"UpdateMesh","rt":$n[0].Void},{"a":3,"n":"UpdateMeshMultipleCanvasRenderers","t":8,"pi":[{"n":"currentInstructions","pt":$n[1].SkeletonRendererInstruction,"ps":0}],"sn":"UpdateMeshMultipleCanvasRenderers","rt":$n[0].Void,"p":[$n[1].SkeletonRendererInstruction]},{"a":3,"n":"UpdateMeshSingleCanvasRenderer","t":8,"pi":[{"n":"currentInstructions","pt":$n[1].SkeletonRendererInstruction,"ps":0}],"sn":"UpdateMeshSingleCanvasRenderer","rt":$n[0].Void,"p":[$n[1].SkeletonRendererInstruction]},{"a":2,"n":"UpdateMeshToInstructions","t":8,"sn":"UpdateMeshToInstructions","rt":$n[0].Void},{"a":3,"n":"UpdateSeparatorPartParents","t":8,"sn":"UpdateSeparatorPartParents","rt":$n[0].Void},{"a":2,"n":"AnimationState","t":16,"rt":$n[5].AnimationState,"g":{"a":2,"n":"get_AnimationState","t":8,"rt":$n[5].AnimationState,"fg":"AnimationState"},"fn":"AnimationState"},{"a":2,"n":"CustomMaterialOverride","t":16,"rt":$n[2].Dictionary$2(UnityEngine.Texture,UnityEngine.Material),"g":{"a":2,"n":"get_CustomMaterialOverride","t":8,"rt":$n[2].Dictionary$2(UnityEngine.Texture,UnityEngine.Material),"fg":"CustomMaterialOverride"},"fn":"CustomMaterialOverride"},{"a":2,"n":"CustomTextureOverride","t":16,"rt":$n[2].Dictionary$2(UnityEngine.Texture,UnityEngine.Texture),"g":{"a":2,"n":"get_CustomTextureOverride","t":8,"rt":$n[2].Dictionary$2(UnityEngine.Texture,UnityEngine.Texture),"fg":"CustomTextureOverride"},"fn":"CustomTextureOverride"},{"a":2,"n":"IsValid","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsValid","t":8,"rt":$n[0].Boolean,"fg":"IsValid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsValid"},{"a":2,"n":"MaterialsMultipleCanvasRenderers","t":16,"rt":$n[5].ExposedList$1(UnityEngine.Material),"g":{"a":2,"n":"get_MaterialsMultipleCanvasRenderers","t":8,"rt":$n[5].ExposedList$1(UnityEngine.Material),"fg":"MaterialsMultipleCanvasRenderers"},"fn":"MaterialsMultipleCanvasRenderers"},{"a":2,"n":"MeshGenerator","t":16,"rt":$n[1].MeshGenerator,"g":{"a":2,"n":"get_MeshGenerator","t":8,"rt":$n[1].MeshGenerator,"fg":"MeshGenerator"},"fn":"MeshGenerator"},{"a":2,"n":"MeshScale","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MeshScale","t":8,"rt":$n[0].Single,"fg":"MeshScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"MeshScale"},{"a":2,"n":"MeshesMultipleCanvasRenderers","t":16,"rt":$n[5].ExposedList$1(UnityEngine.Mesh),"g":{"a":2,"n":"get_MeshesMultipleCanvasRenderers","t":8,"rt":$n[5].ExposedList$1(UnityEngine.Mesh),"fg":"MeshesMultipleCanvasRenderers"},"fn":"MeshesMultipleCanvasRenderers"},{"a":2,"n":"OverrideTexture","t":16,"rt":$n[3].Texture,"g":{"a":2,"n":"get_OverrideTexture","t":8,"rt":$n[3].Texture,"fg":"OverrideTexture"},"s":{"a":2,"n":"set_OverrideTexture","t":8,"p":[$n[3].Texture],"rt":$n[0].Void,"fs":"OverrideTexture"},"fn":"OverrideTexture"},{"a":2,"n":"SeparatorParts","t":16,"rt":$n[2].List$1(UnityEngine.Transform),"g":{"a":2,"n":"get_SeparatorParts","t":8,"rt":$n[2].List$1(UnityEngine.Transform),"fg":"SeparatorParts"},"fn":"SeparatorParts"},{"a":2,"n":"Skeleton","t":16,"rt":$n[5].Skeleton,"g":{"a":2,"n":"get_Skeleton","t":8,"rt":$n[5].Skeleton,"fg":"Skeleton"},"s":{"a":2,"n":"set_Skeleton","t":8,"p":[$n[5].Skeleton],"rt":$n[0].Void,"fs":"Skeleton"},"fn":"Skeleton"},{"a":2,"n":"SkeletonData","t":16,"rt":$n[5].SkeletonData,"g":{"a":2,"n":"get_SkeletonData","t":8,"rt":$n[5].SkeletonData,"fg":"SkeletonData"},"fn":"SkeletonData"},{"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[1].SkeletonDataAsset,"g":{"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[1].SkeletonDataAsset,"fg":"SkeletonDataAsset"},"fn":"SkeletonDataAsset"},{"a":2,"n":"TexturesMultipleCanvasRenderers","t":16,"rt":$n[5].ExposedList$1(UnityEngine.Texture),"g":{"a":2,"n":"get_TexturesMultipleCanvasRenderers","t":8,"rt":$n[5].ExposedList$1(UnityEngine.Texture),"fg":"TexturesMultipleCanvasRenderers"},"fn":"TexturesMultipleCanvasRenderers"},{"a":2,"n":"UnscaledTime","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_UnscaledTime","t":8,"rt":$n[0].Boolean,"fg":"UnscaledTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_UnscaledTime","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"UnscaledTime"},"fn":"UnscaledTime"},{"a":2,"n":"UpdateMode","t":16,"rt":$n[1].UpdateMode,"g":{"a":2,"n":"get_UpdateMode","t":8,"rt":$n[1].UpdateMode,"fg":"UpdateMode","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},"s":{"a":2,"n":"set_UpdateMode","t":8,"p":[$n[1].UpdateMode],"rt":$n[0].Void,"fs":"UpdateMode"},"fn":"UpdateMode"},{"a":2,"n":"UpdateTiming","t":16,"rt":$n[1].UpdateTiming,"g":{"a":2,"n":"get_UpdateTiming","t":8,"rt":$n[1].UpdateTiming,"fg":"UpdateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},"s":{"a":2,"n":"set_UpdateTiming","t":8,"p":[$n[1].UpdateTiming],"rt":$n[0].Void,"fs":"UpdateTiming"},"fn":"UpdateTiming"},{"ov":true,"a":2,"n":"mainTexture","t":16,"rt":$n[3].Texture,"g":{"ov":true,"a":2,"n":"get_mainTexture","t":8,"rt":$n[3].Texture,"fg":"mainTexture"},"fn":"mainTexture"},{"a":3,"n":"EditReferenceRect","is":true,"t":4,"rt":$n[0].Boolean,"sn":"EditReferenceRect","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SeparatorPartGameObjectName","is":true,"t":4,"rt":$n[0].String,"sn":"SeparatorPartGameObjectName"},{"a":2,"n":"additiveMaterial","t":4,"rt":$n[3].Material,"sn":"additiveMaterial"},{"a":2,"n":"allowMultipleCanvasRenderers","t":4,"rt":$n[0].Boolean,"sn":"allowMultipleCanvasRenderers","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"baseTexture","t":4,"rt":$n[3].Texture,"sn":"baseTexture"},{"a":2,"n":"canvasRenderers","t":4,"rt":$n[2].List$1(UnityEngine.CanvasRenderer),"sn":"canvasRenderers"},{"a":1,"n":"currentInstructions","t":4,"rt":$n[1].SkeletonRendererInstruction,"sn":"currentInstructions"},{"a":1,"n":"customMaterialOverride","t":4,"rt":$n[2].Dictionary$2(UnityEngine.Texture,UnityEngine.Material),"sn":"customMaterialOverride","ro":true},{"a":1,"n":"customTextureOverride","t":4,"rt":$n[2].Dictionary$2(UnityEngine.Texture,UnityEngine.Texture),"sn":"customTextureOverride","ro":true},{"a":2,"n":"disableMeshAssignmentOnOverride","t":4,"rt":$n[0].Boolean,"sn":"disableMeshAssignmentOnOverride","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"enableSeparatorSlots","t":4,"rt":$n[0].Boolean,"sn":"enableSeparatorSlots","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"freeze","t":4,"rt":$n[0].Boolean,"sn":"freeze","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initialFlipX","t":4,"rt":$n[0].Boolean,"sn":"initialFlipX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initialFlipY","t":4,"rt":$n[0].Boolean,"sn":"initialFlipY","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new Spine.Unity.SpineSkin("", "skeletonDataAsset", true, false, true)],"a":2,"n":"initialSkinName","t":4,"rt":$n[0].String,"sn":"initialSkinName"},{"a":2,"n":"layoutScaleMode","t":4,"rt":$n[1].SkeletonGraphic.LayoutMode,"sn":"layoutScaleMode","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonGraphic.LayoutMode, System.Enum.toStringFn(Spine.Unity.SkeletonGraphic.LayoutMode));}},{"a":1,"n":"meshBuffers","t":4,"rt":$n[1].DoubleBuffered$1(Spine.Unity.MeshRendererBuffers.SmartMesh),"sn":"meshBuffers"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"meshGenerator","t":4,"rt":$n[1].MeshGenerator,"sn":"meshGenerator"},{"a":3,"n":"meshScale","t":4,"rt":$n[0].Single,"sn":"meshScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"meshes","t":4,"rt":$n[5].ExposedList$1(UnityEngine.Mesh),"sn":"meshes","ro":true},{"a":2,"n":"multiplyMaterial","t":4,"rt":$n[3].Material,"sn":"multiplyMaterial"},{"a":1,"n":"overrideTexture","t":4,"rt":$n[3].Texture,"sn":"overrideTexture"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"referenceScale","t":4,"rt":$n[0].Single,"sn":"referenceScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"referenceSize","t":4,"rt":$n[3].Vector2,"sn":"referenceSize"},{"a":2,"n":"screenMaterial","t":4,"rt":$n[3].Material,"sn":"screenMaterial"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"separatorParts","t":4,"rt":$n[2].List$1(UnityEngine.Transform),"sn":"separatorParts"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineSlot("", "", false, true, false)],"a":3,"n":"separatorSlotNames","t":4,"rt":$n[0].Array.type(System.String),"sn":"separatorSlotNames"},{"a":2,"n":"separatorSlots","t":4,"rt":$n[2].List$1(Spine.Slot),"sn":"separatorSlots","ro":true},{"a":3,"n":"skeleton","t":4,"rt":$n[5].Skeleton,"sn":"skeleton"},{"a":2,"n":"skeletonDataAsset","t":4,"rt":$n[1].SkeletonDataAsset,"sn":"skeletonDataAsset"},{"at":[new Spine.Unity.SpineAnimation("", "skeletonDataAsset", true, false)],"a":2,"n":"startingAnimation","t":4,"rt":$n[0].String,"sn":"startingAnimation"},{"a":2,"n":"startingLoop","t":4,"rt":$n[0].Boolean,"sn":"startingLoop","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"state","t":4,"rt":$n[5].AnimationState,"sn":"state"},{"a":3,"n":"submeshGraphics","t":4,"rt":$n[2].List$1(Spine.Unity.SkeletonSubmeshGraphic),"sn":"submeshGraphics"},{"a":2,"n":"timeScale","t":4,"rt":$n[0].Single,"sn":"timeScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"unscaledTime","t":4,"rt":$n[0].Boolean,"sn":"unscaledTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"updateMode","t":4,"rt":$n[1].UpdateMode,"sn":"updateMode","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"updateSeparatorPartLocation","t":4,"rt":$n[0].Boolean,"sn":"updateSeparatorPartLocation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"updateSeparatorPartScale","t":4,"rt":$n[0].Boolean,"sn":"updateSeparatorPartScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"updateTiming","t":4,"rt":$n[1].UpdateTiming,"sn":"updateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},{"a":2,"n":"updateWhenInvisible","t":4,"rt":$n[1].UpdateMode,"sn":"updateWhenInvisible","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":1,"n":"usedMaterials","t":4,"rt":$n[5].ExposedList$1(UnityEngine.Material),"sn":"usedMaterials","ro":true},{"a":3,"n":"usedRenderersCount","t":4,"rt":$n[0].Int32,"sn":"usedRenderersCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"usedTextures","t":4,"rt":$n[5].ExposedList$1(UnityEngine.Texture),"sn":"usedTextures","ro":true},{"a":1,"n":"wasUpdatedAfterInit","t":4,"rt":$n[0].Boolean,"sn":"wasUpdatedAfterInit","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"AssignMeshOverrideMultipleRenderers","t":2,"ad":{"a":2,"n":"add_AssignMeshOverrideMultipleRenderers","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addAssignMeshOverrideMultipleRenderers","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_AssignMeshOverrideMultipleRenderers","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeAssignMeshOverrideMultipleRenderers","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"AssignMeshOverrideSingleRenderer","t":2,"ad":{"a":2,"n":"add_AssignMeshOverrideSingleRenderer","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addAssignMeshOverrideSingleRenderer","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_AssignMeshOverrideSingleRenderer","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeAssignMeshOverrideSingleRenderer","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"BeforeApply","t":2,"ad":{"a":2,"n":"add_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addBeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeBeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnAnimationRebuild","t":2,"ad":{"a":2,"n":"add_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnAnimationRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnAnimationRebuild","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnInstructionsPrepared","t":2,"ad":{"a":2,"n":"add_OnInstructionsPrepared","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnInstructionsPrepared","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnInstructionsPrepared","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnInstructionsPrepared","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnMeshAndMaterialsUpdated","t":2,"ad":{"a":2,"n":"add_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnPostProcessVertices","t":2,"ad":{"a":2,"n":"add_OnPostProcessVertices","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnPostProcessVertices","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnPostProcessVertices","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnPostProcessVertices","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnRebuild","t":2,"ad":{"a":2,"n":"add_OnRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnRebuild","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateComplete","t":2,"ad":{"a":2,"n":"add_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateLocal","t":2,"ad":{"a":2,"n":"add_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateWorld","t":2,"ad":{"a":2,"n":"add_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateWorld","rt":$n[0].Void,"p":[Function]}},{"a":1,"n":"assignMeshOverrideMultiple","t":2,"ad":{"a":1,"n":"add_assignMeshOverrideMultiple","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addassignMeshOverrideMultiple","rt":$n[0].Void,"p":[Function]},"r":{"a":1,"n":"remove_assignMeshOverrideMultiple","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeassignMeshOverrideMultiple","rt":$n[0].Void,"p":[Function]}},{"a":1,"n":"assignMeshOverrideSingle","t":2,"ad":{"a":1,"n":"add_assignMeshOverrideSingle","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addassignMeshOverrideSingle","rt":$n[0].Void,"p":[Function]},"r":{"a":1,"n":"remove_assignMeshOverrideSingle","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeassignMeshOverrideSingle","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonGraphic end.*/

    /*Spine.Unity.SkeletonGraphic+LayoutMode start.*/
    $m("Spine.Unity.SkeletonGraphic.LayoutMode", function () { return {"td":$n[1].SkeletonGraphic,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"EnvelopeParent","is":true,"t":4,"rt":$n[1].SkeletonGraphic.LayoutMode,"sn":"EnvelopeParent","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonGraphic.LayoutMode, System.Enum.toStringFn(Spine.Unity.SkeletonGraphic.LayoutMode));}},{"a":2,"n":"FitInParent","is":true,"t":4,"rt":$n[1].SkeletonGraphic.LayoutMode,"sn":"FitInParent","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonGraphic.LayoutMode, System.Enum.toStringFn(Spine.Unity.SkeletonGraphic.LayoutMode));}},{"a":2,"n":"HeightControlsWidth","is":true,"t":4,"rt":$n[1].SkeletonGraphic.LayoutMode,"sn":"HeightControlsWidth","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonGraphic.LayoutMode, System.Enum.toStringFn(Spine.Unity.SkeletonGraphic.LayoutMode));}},{"a":2,"n":"None","is":true,"t":4,"rt":$n[1].SkeletonGraphic.LayoutMode,"sn":"None","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonGraphic.LayoutMode, System.Enum.toStringFn(Spine.Unity.SkeletonGraphic.LayoutMode));}},{"a":2,"n":"WidthControlsHeight","is":true,"t":4,"rt":$n[1].SkeletonGraphic.LayoutMode,"sn":"WidthControlsHeight","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonGraphic.LayoutMode, System.Enum.toStringFn(Spine.Unity.SkeletonGraphic.LayoutMode));}}]}; }, $n);
    /*Spine.Unity.SkeletonGraphic+LayoutMode end.*/

    /*Spine.Unity.SkeletonMecanim start.*/
    $m("Spine.Unity.SkeletonMecanim", function () { return {"nested":[$n[1].SkeletonMecanim.MecanimTranslator],"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.Animator),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonMecanim-Component")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":3,"n":"ApplyAnimation","t":8,"sn":"ApplyAnimation","rt":$n[0].Void},{"v":true,"a":2,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"ov":true,"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","pt":$n[0].Boolean,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean,$n[0].Boolean]},{"ov":true,"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"ov":true,"a":2,"n":"OnBecameVisible","t":8,"sn":"OnBecameVisible","rt":$n[0].Void},{"v":true,"a":2,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"v":true,"a":2,"n":"Update","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"Update$1","rt":$n[0].Void,"p":[$n[0].Single]},{"a":3,"n":"UpdateAnimation","t":8,"sn":"UpdateAnimation","rt":$n[0].Void},{"a":2,"n":"Translator","t":16,"rt":$n[1].SkeletonMecanim.MecanimTranslator,"g":{"a":2,"n":"get_Translator","t":8,"rt":$n[1].SkeletonMecanim.MecanimTranslator,"fg":"Translator"},"fn":"Translator"},{"a":2,"n":"UpdateTiming","t":16,"rt":$n[1].UpdateTiming,"g":{"a":2,"n":"get_UpdateTiming","t":8,"rt":$n[1].UpdateTiming,"fg":"UpdateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},"s":{"a":2,"n":"set_UpdateTiming","t":8,"p":[$n[1].UpdateTiming],"rt":$n[0].Void,"fs":"UpdateTiming"},"fn":"UpdateTiming"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"translator","t":4,"rt":$n[1].SkeletonMecanim.MecanimTranslator,"sn":"translator"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"updateTiming","t":4,"rt":$n[1].UpdateTiming,"sn":"updateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},{"a":1,"n":"wasUpdatedAfterInit","t":4,"rt":$n[0].Boolean,"sn":"wasUpdatedAfterInit","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"BeforeApply","t":2,"ad":{"a":2,"n":"add_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addBeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeBeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnAnimationRebuild","t":2,"ad":{"a":2,"n":"add_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnAnimationRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnAnimationRebuild","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateComplete","t":2,"ad":{"a":2,"n":"add_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateLocal","t":2,"ad":{"a":2,"n":"add_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateWorld","t":2,"ad":{"a":2,"n":"add_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateWorld","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_BeforeApply","t":2,"ad":{"a":3,"n":"add__BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_BeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_BeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_OnAnimationRebuild","t":2,"ad":{"a":3,"n":"add__OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_OnAnimationRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_OnAnimationRebuild","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateComplete","t":2,"ad":{"a":3,"n":"add__UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateLocal","t":2,"ad":{"a":3,"n":"add__UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateWorld","t":2,"ad":{"a":3,"n":"add__UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateWorld","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator", function () { return {"td":$n[1].SkeletonMecanim,"nested":[Function,$n[1].SkeletonMecanim.MecanimTranslator.MixMode,$n[1].SkeletonMecanim.MecanimTranslator.ClipInfos,$n[1].SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer,$n[1].SkeletonMecanim.MecanimTranslator.IntEqualityComparer],"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AnimationTime","is":true,"t":8,"pi":[{"n":"normalizedTime","pt":$n[0].Single,"ps":0},{"n":"clipLength","pt":$n[0].Single,"ps":1},{"n":"loop","pt":$n[0].Boolean,"ps":2},{"n":"reversed","pt":$n[0].Boolean,"ps":3}],"sn":"AnimationTime","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Boolean,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0}],"sn":"Apply","rt":$n[0].Void,"p":[$n[5].Skeleton]},{"a":1,"n":"ApplyAnimation","t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"info","pt":$n[3].AnimatorClipInfo,"ps":1},{"n":"stateInfo","pt":$n[3].AnimatorStateInfo,"ps":2},{"n":"layerIndex","pt":$n[0].Int32,"ps":3},{"n":"layerWeight","pt":$n[0].Single,"ps":4},{"n":"layerBlendMode","pt":spine.MixBlend,"ps":5},{"n":"useClipWeight1","dv":false,"o":true,"pt":$n[0].Boolean,"ps":6}],"sn":"ApplyAnimation","rt":$n[0].Boolean,"p":[$n[5].Skeleton,$n[3].AnimatorClipInfo,$n[3].AnimatorStateInfo,$n[0].Int32,$n[0].Single,spine.MixBlend,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"ApplyInterruptionAnimation","t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"interpolateWeightTo1","pt":$n[0].Boolean,"ps":1},{"n":"info","pt":$n[3].AnimatorClipInfo,"ps":2},{"n":"stateInfo","pt":$n[3].AnimatorStateInfo,"ps":3},{"n":"layerIndex","pt":$n[0].Int32,"ps":4},{"n":"layerWeight","pt":$n[0].Single,"ps":5},{"n":"layerBlendMode","pt":spine.MixBlend,"ps":6},{"n":"interruptingClipTimeAddition","pt":$n[0].Single,"ps":7},{"n":"useClipWeight1","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8}],"sn":"ApplyInterruptionAnimation","rt":$n[0].Boolean,"p":[$n[5].Skeleton,$n[0].Boolean,$n[3].AnimatorClipInfo,$n[3].AnimatorStateInfo,$n[0].Int32,$n[0].Single,spine.MixBlend,$n[0].Single,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"ClearClipInfosForLayers","t":8,"sn":"ClearClipInfosForLayers","rt":$n[0].Void},{"a":2,"n":"GetActiveAnimationAndTime","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0}],"sn":"GetActiveAnimationAndTime","rt":$n[2].KeyValuePair$2(Spine.Animation,System.Single),"p":[$n[0].Int32]},{"a":1,"n":"GetAnimation","t":8,"pi":[{"n":"clip","pt":$n[3].AnimationClip,"ps":0}],"sn":"GetAnimation","rt":$n[5].Animation,"p":[$n[3].AnimationClip]},{"a":1,"n":"GetAnimatorClipInfos","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0},{"n":"isInterruptionActive","out":true,"pt":$n[0].Boolean,"ps":1},{"n":"clipInfoCount","out":true,"pt":$n[0].Int32,"ps":2},{"n":"nextClipInfoCount","out":true,"pt":$n[0].Int32,"ps":3},{"n":"interruptingClipInfoCount","out":true,"pt":$n[0].Int32,"ps":4},{"n":"clipInfo","out":true,"pt":$n[2].IList$1(UnityEngine.AnimatorClipInfo),"ps":5},{"n":"nextClipInfo","out":true,"pt":$n[2].IList$1(UnityEngine.AnimatorClipInfo),"ps":6},{"n":"interruptingClipInfo","out":true,"pt":$n[2].IList$1(UnityEngine.AnimatorClipInfo),"ps":7},{"n":"shallInterpolateWeightTo1","out":true,"pt":$n[0].Boolean,"ps":8}],"sn":"GetAnimatorClipInfos","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Boolean,$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[2].IList$1(UnityEngine.AnimatorClipInfo),$n[2].IList$1(UnityEngine.AnimatorClipInfo),$n[2].IList$1(UnityEngine.AnimatorClipInfo),$n[0].Boolean]},{"a":1,"n":"GetAnimatorStateInfos","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0},{"n":"isInterruptionActive","out":true,"pt":$n[0].Boolean,"ps":1},{"n":"stateInfo","out":true,"pt":$n[3].AnimatorStateInfo,"ps":2},{"n":"nextStateInfo","out":true,"pt":$n[3].AnimatorStateInfo,"ps":3},{"n":"interruptingStateInfo","out":true,"pt":$n[3].AnimatorStateInfo,"ps":4},{"n":"interruptingClipTimeAddition","out":true,"pt":$n[0].Single,"ps":5}],"sn":"GetAnimatorStateInfos","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Boolean,$n[3].AnimatorStateInfo,$n[3].AnimatorStateInfo,$n[3].AnimatorStateInfo,$n[0].Single]},{"a":1,"n":"GetMixMode","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0},{"n":"layerBlendMode","pt":spine.MixBlend,"ps":1}],"sn":"GetMixMode","rt":$n[1].SkeletonMecanim.MecanimTranslator.MixMode,"p":[$n[0].Int32,spine.MixBlend],"box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode, System.Enum.toStringFn(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode));}},{"a":1,"n":"GetStateUpdatesFromAnimator","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0}],"sn":"GetStateUpdatesFromAnimator","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"InitClipInfosForLayers","t":8,"sn":"InitClipInfosForLayers","rt":$n[0].Void},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"animator","pt":$n[3].Animator,"ps":0},{"n":"skeletonDataAsset","pt":$n[1].SkeletonDataAsset,"ps":1}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[3].Animator,$n[1].SkeletonDataAsset]},{"a":1,"n":"OnClipAppliedCallback","t":8,"pi":[{"n":"clip","pt":$n[5].Animation,"ps":0},{"n":"stateInfo","pt":$n[3].AnimatorStateInfo,"ps":1},{"n":"layerIndex","pt":$n[0].Int32,"ps":2},{"n":"time","pt":$n[0].Single,"ps":3},{"n":"isLooping","pt":$n[0].Boolean,"ps":4},{"n":"weight","pt":$n[0].Single,"ps":5}],"sn":"OnClipAppliedCallback","rt":$n[0].Void,"p":[$n[5].Animation,$n[3].AnimatorStateInfo,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[0].Single]},{"a":1,"n":"ToSpineAnimationTime","is":true,"t":8,"pi":[{"n":"normalizedTime","pt":$n[0].Single,"ps":0},{"n":"clipLength","pt":$n[0].Single,"ps":1},{"n":"loop","pt":$n[0].Boolean,"ps":2},{"n":"reversed","pt":$n[0].Boolean,"ps":3}],"sn":"ToSpineAnimationTime","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Boolean,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Animator","t":16,"rt":$n[3].Animator,"g":{"a":2,"n":"get_Animator","t":8,"rt":$n[3].Animator,"fg":"Animator"},"fn":"Animator"},{"a":2,"n":"MecanimLayerCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_MecanimLayerCount","t":8,"rt":$n[0].Int32,"fg":"MecanimLayerCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"MecanimLayerCount"},{"a":2,"n":"MecanimLayerNames","t":16,"rt":$n[0].Array.type(System.String),"g":{"a":2,"n":"get_MecanimLayerNames","t":8,"rt":$n[0].Array.type(System.String),"fg":"MecanimLayerNames"},"fn":"MecanimLayerNames"},{"a":1,"n":"WeightEpsilon","is":true,"t":4,"rt":$n[0].Single,"sn":"WeightEpsilon","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"animationTable","t":4,"rt":$n[2].Dictionary$2(System.Int32,Spine.Animation),"sn":"animationTable","ro":true},{"a":1,"n":"animator","t":4,"rt":$n[3].Animator,"sn":"animator"},{"a":2,"n":"autoReset","t":4,"rt":$n[0].Boolean,"sn":"autoReset","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"clipNameHashCodeTable","t":4,"rt":$n[2].Dictionary$2(UnityEngine.AnimationClip,System.Int32),"sn":"clipNameHashCodeTable","ro":true},{"a":2,"n":"layerBlendModes","t":4,"rt":System.Array.type(spine.MixBlend),"sn":"layerBlendModes"},{"a":3,"n":"layerClipInfos","t":4,"rt":System.Array.type(Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos),"sn":"layerClipInfos"},{"a":2,"n":"layerMixModes","t":4,"rt":System.Array.type(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode),"sn":"layerMixModes"},{"a":1,"n":"previousAnimations","t":4,"rt":$n[2].List$1(Spine.Animation),"sn":"previousAnimations","ro":true},{"a":2,"n":"useCustomMixMode","t":4,"rt":$n[0].Boolean,"sn":"useCustomMixMode","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"OnClipApplied","t":2,"ad":{"a":2,"n":"add_OnClipApplied","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnClipApplied","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnClipApplied","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnClipApplied","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_OnClipApplied","t":2,"ad":{"a":3,"n":"add__OnClipApplied","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_OnClipApplied","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__OnClipApplied","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_OnClipApplied","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+MixMode start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode", function () { return {"td":$n[1].SkeletonMecanim.MecanimTranslator,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AlwaysMix","is":true,"t":4,"rt":$n[1].SkeletonMecanim.MecanimTranslator.MixMode,"sn":"AlwaysMix","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode, System.Enum.toStringFn(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode));}},{"a":2,"n":"Hard","is":true,"t":4,"rt":$n[1].SkeletonMecanim.MecanimTranslator.MixMode,"sn":"Hard","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode, System.Enum.toStringFn(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode));}},{"a":2,"n":"MixNext","is":true,"t":4,"rt":$n[1].SkeletonMecanim.MecanimTranslator.MixMode,"sn":"MixNext","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode, System.Enum.toStringFn(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode));}}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+MixMode end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+ClipInfos start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos", function () { return {"td":$n[1].SkeletonMecanim.MecanimTranslator,"att":1048580,"a":3,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"clipInfoCount","t":4,"rt":$n[0].Int32,"sn":"clipInfoCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"clipInfos","t":4,"rt":$n[2].List$1(UnityEngine.AnimatorClipInfo),"sn":"clipInfos","ro":true},{"a":2,"n":"interruptingClipInfoCount","t":4,"rt":$n[0].Int32,"sn":"interruptingClipInfoCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"interruptingClipInfos","t":4,"rt":$n[2].List$1(UnityEngine.AnimatorClipInfo),"sn":"interruptingClipInfos","ro":true},{"a":2,"n":"interruptingClipTimeAddition","t":4,"rt":$n[0].Single,"sn":"interruptingClipTimeAddition","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"interruptingStateInfo","t":4,"rt":$n[3].AnimatorStateInfo,"sn":"interruptingStateInfo"},{"a":2,"n":"isInterruptionActive","t":4,"rt":$n[0].Boolean,"sn":"isInterruptionActive","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"isLastFrameOfInterruption","t":4,"rt":$n[0].Boolean,"sn":"isLastFrameOfInterruption","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"nextClipInfoCount","t":4,"rt":$n[0].Int32,"sn":"nextClipInfoCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"nextClipInfos","t":4,"rt":$n[2].List$1(UnityEngine.AnimatorClipInfo),"sn":"nextClipInfos","ro":true},{"a":2,"n":"nextStateInfo","t":4,"rt":$n[3].AnimatorStateInfo,"sn":"nextStateInfo"},{"a":2,"n":"stateInfo","t":4,"rt":$n[3].AnimatorStateInfo,"sn":"stateInfo"}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+ClipInfos end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer", function () { return {"td":$n[1].SkeletonMecanim.MecanimTranslator,"att":1048579,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"x","pt":$n[3].AnimationClip,"ps":0},{"n":"y","pt":$n[3].AnimationClip,"ps":1}],"sn":"equals2","rt":$n[0].Boolean,"p":[$n[3].AnimationClip,$n[3].AnimationClip],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"GetHashCode","t":8,"pi":[{"n":"o","pt":$n[3].AnimationClip,"ps":0}],"sn":"getHashCode2","rt":$n[0].Int32,"p":[$n[3].AnimationClip],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"Instance","is":true,"t":4,"rt":$n[2].IEqualityComparer$1(UnityEngine.AnimationClip),"sn":"Instance","ro":true}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer", function () { return {"td":$n[1].SkeletonMecanim.MecanimTranslator,"att":1048579,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"x","pt":$n[0].Int32,"ps":0},{"n":"y","pt":$n[0].Int32,"ps":1}],"sn":"equals2","rt":$n[0].Boolean,"p":[$n[0].Int32,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"GetHashCode","t":8,"pi":[{"n":"o","pt":$n[0].Int32,"ps":0}],"sn":"getHashCode2","rt":$n[0].Int32,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"Instance","is":true,"t":4,"rt":$n[2].IEqualityComparer$1(System.Int32),"sn":"Instance","ro":true}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer end.*/

    /*Spine.Unity.SkeletonRenderer start.*/
    $m("Spine.Unity.SkeletonRenderer", function () { return {"nested":[$n[1].SkeletonRenderer.SpriteMaskInteractionMaterials,Function,Function],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.ctor(UnityEngine.MeshRenderer),new UnityEngine.DisallowMultipleComponent(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRenderer-Component")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddSpineComponent","is":true,"t":8,"pi":[{"n":"gameObject","pt":$n[3].GameObject,"ps":0},{"n":"skeletonDataAsset","pt":$n[1].SkeletonDataAsset,"ps":1},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"tpc":1,"tprm":["T"],"sn":"AddSpineComponent","rt":System.Object,"p":[$n[3].GameObject,$n[1].SkeletonDataAsset,$n[0].Boolean]},{"a":1,"n":"AssignSpriteMaskMaterials","t":8,"sn":"AssignSpriteMaskMaterials","rt":$n[0].Void},{"v":true,"a":2,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"v":true,"a":2,"n":"ClearState","t":8,"sn":"ClearState","rt":$n[0].Void},{"a":2,"n":"EnsureMeshGeneratorCapacity","t":8,"pi":[{"n":"minimumVertexCount","pt":$n[0].Int32,"ps":0}],"sn":"EnsureMeshGeneratorCapacity","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"FindAndApplySeparatorSlots","t":8,"pi":[{"n":"slotNamePredicate","pt":Function,"ps":0},{"n":"clearExistingSeparators","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"updateStringArray","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"FindAndApplySeparatorSlots","rt":$n[0].Void,"p":[Function,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"FindAndApplySeparatorSlots","t":8,"pi":[{"n":"startsWith","pt":$n[0].String,"ps":0},{"n":"clearExistingSeparators","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"updateStringArray","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"FindAndApplySeparatorSlots$1","rt":$n[0].Void,"p":[$n[0].String,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"HandleOnDemandLoading","t":8,"sn":"HandleOnDemandLoading","rt":$n[0].Void},{"a":1,"n":"InitSpriteMaskMaterialsForMaskType","t":8,"pi":[{"n":"maskFunction","pt":$n[8].CompareFunction,"ps":0},{"n":"materialsToFill","ref":true,"pt":System.Array.type(UnityEngine.Material),"ps":1}],"sn":"InitSpriteMaskMaterialsForMaskType","rt":$n[0].Boolean,"p":[$n[8].CompareFunction,System.Array.type(UnityEngine.Material)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"InitSpriteMaskMaterialsInsideMask","t":8,"sn":"InitSpriteMaskMaterialsInsideMask","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"InitSpriteMaskMaterialsOutsideMask","t":8,"sn":"InitSpriteMaskMaterialsOutsideMask","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"v":true,"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","pt":$n[0].Boolean,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean,$n[0].Boolean]},{"v":true,"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"v":true,"a":2,"n":"LateUpdateMesh","t":8,"sn":"LateUpdateMesh","rt":$n[0].Void},{"a":2,"n":"NewSpineGameObject","is":true,"t":8,"pi":[{"n":"skeletonDataAsset","pt":$n[1].SkeletonDataAsset,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"tpc":1,"tprm":["T"],"sn":"NewSpineGameObject","rt":System.Object,"p":[$n[1].SkeletonDataAsset,$n[0].Boolean]},{"a":2,"n":"OnBecameInvisible","t":8,"sn":"OnBecameInvisible","rt":$n[0].Void},{"v":true,"a":2,"n":"OnBecameVisible","t":8,"sn":"OnBecameVisible","rt":$n[0].Void},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":2,"n":"ReapplySeparatorSlotNames","t":8,"sn":"ReapplySeparatorSlotNames","rt":$n[0].Void},{"a":1,"n":"SetMaterialSettingsToFixDrawOrder","t":8,"sn":"SetMaterialSettingsToFixDrawOrder","rt":$n[0].Void},{"a":2,"n":"SetMeshSettings","t":8,"pi":[{"n":"settings","pt":$n[1].MeshGenerator.Settings,"ps":0}],"sn":"SetMeshSettings","rt":$n[0].Void,"p":[$n[1].MeshGenerator.Settings]},{"a":2,"n":"CustomMaterialOverride","t":16,"rt":$n[2].Dictionary$2(UnityEngine.Material,UnityEngine.Material),"g":{"a":2,"n":"get_CustomMaterialOverride","t":8,"rt":$n[2].Dictionary$2(UnityEngine.Material,UnityEngine.Material),"fg":"CustomMaterialOverride"},"fn":"CustomMaterialOverride"},{"a":2,"n":"CustomSlotMaterials","t":16,"rt":$n[2].Dictionary$2(Spine.Slot,UnityEngine.Material),"g":{"a":2,"n":"get_CustomSlotMaterials","t":8,"rt":$n[2].Dictionary$2(Spine.Slot,UnityEngine.Material),"fg":"CustomSlotMaterials"},"fn":"CustomSlotMaterials"},{"a":2,"n":"Skeleton","t":16,"rt":$n[5].Skeleton,"g":{"a":2,"n":"get_Skeleton","t":8,"rt":$n[5].Skeleton,"fg":"Skeleton"},"fn":"Skeleton"},{"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[1].SkeletonDataAsset,"g":{"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[1].SkeletonDataAsset,"fg":"SkeletonDataAsset"},"fn":"SkeletonDataAsset"},{"a":2,"n":"UpdateMode","t":16,"rt":$n[1].UpdateMode,"g":{"a":2,"n":"get_UpdateMode","t":8,"rt":$n[1].UpdateMode,"fg":"UpdateMode","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},"s":{"a":2,"n":"set_UpdateMode","t":8,"p":[$n[1].UpdateMode],"rt":$n[0].Void,"fs":"UpdateMode"},"fn":"UpdateMode"},{"a":2,"n":"STENCIL_COMP_MASKINTERACTION_NONE","is":true,"t":4,"rt":$n[8].CompareFunction,"sn":"STENCIL_COMP_MASKINTERACTION_NONE","box":function ($v) { return Bridge.box($v, UnityEngine.Rendering.CompareFunction, System.Enum.toStringFn(UnityEngine.Rendering.CompareFunction));}},{"a":2,"n":"STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE","is":true,"t":4,"rt":$n[8].CompareFunction,"sn":"STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE","box":function ($v) { return Bridge.box($v, UnityEngine.Rendering.CompareFunction, System.Enum.toStringFn(UnityEngine.Rendering.CompareFunction));}},{"a":2,"n":"STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE","is":true,"t":4,"rt":$n[8].CompareFunction,"sn":"STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE","box":function ($v) { return Bridge.box($v, UnityEngine.Rendering.CompareFunction, System.Enum.toStringFn(UnityEngine.Rendering.CompareFunction));}},{"a":2,"n":"STENCIL_COMP_PARAM_ID","is":true,"t":4,"rt":$n[0].Int32,"sn":"STENCIL_COMP_PARAM_ID","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"SUBMESH_DUMMY_PARAM_ID","is":true,"t":4,"rt":$n[0].Int32,"sn":"SUBMESH_DUMMY_PARAM_ID","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("calculateNormals")],"a":2,"n":"addNormals","t":4,"rt":$n[0].Boolean,"sn":"addNormals","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"calculateTangents","t":4,"rt":$n[0].Boolean,"sn":"calculateTangents","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"clearStateOnDisable","t":4,"rt":$n[0].Boolean,"sn":"clearStateOnDisable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"currentInstructions","t":4,"rt":$n[1].SkeletonRendererInstruction,"sn":"currentInstructions","ro":true},{"a":1,"n":"customMaterialOverride","t":4,"rt":$n[2].Dictionary$2(UnityEngine.Material,UnityEngine.Material),"sn":"customMaterialOverride","ro":true},{"a":1,"n":"customSlotMaterials","t":4,"rt":$n[2].Dictionary$2(Spine.Slot,UnityEngine.Material),"sn":"customSlotMaterials","ro":true},{"a":2,"n":"disableRenderingOnOverride","t":4,"rt":$n[0].Boolean,"sn":"disableRenderingOnOverride","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"fixDrawOrder","t":4,"rt":$n[0].Boolean,"sn":"fixDrawOrder","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"immutableTriangles","t":4,"rt":$n[0].Boolean,"sn":"immutableTriangles","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initialFlipX","t":4,"rt":$n[0].Boolean,"sn":"initialFlipX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initialFlipY","t":4,"rt":$n[0].Boolean,"sn":"initialFlipY","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new Spine.Unity.SpineSkin("", "", true, false, true)],"a":2,"n":"initialSkinName","t":4,"rt":$n[0].String,"sn":"initialSkinName"},{"a":2,"n":"maskInteraction","t":4,"rt":$n[3].SpriteMaskInteraction,"sn":"maskInteraction","box":function ($v) { return Bridge.box($v, UnityEngine.SpriteMaskInteraction, System.Enum.toStringFn(UnityEngine.SpriteMaskInteraction));}},{"a":2,"n":"maskMaterials","t":4,"rt":$n[1].SkeletonRenderer.SpriteMaskInteractionMaterials,"sn":"maskMaterials"},{"a":1,"n":"meshFilter","t":4,"rt":$n[3].MeshFilter,"sn":"meshFilter"},{"a":1,"n":"meshGenerator","t":4,"rt":$n[1].MeshGenerator,"sn":"meshGenerator","ro":true},{"a":1,"n":"meshRenderer","t":4,"rt":$n[3].MeshRenderer,"sn":"meshRenderer"},{"a":2,"n":"pmaVertexColors","t":4,"rt":$n[0].Boolean,"sn":"pmaVertexColors","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"rendererBuffers","t":4,"rt":$n[1].MeshRendererBuffers,"sn":"rendererBuffers","ro":true},{"a":1,"n":"reusedPropertyBlock","t":4,"rt":$n[3].MaterialPropertyBlock,"sn":"reusedPropertyBlock"},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("submeshSeparators"),new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineSlot("", "", false, true, false)],"a":3,"n":"separatorSlotNames","t":4,"rt":$n[0].Array.type(System.String),"sn":"separatorSlotNames"},{"a":2,"n":"separatorSlots","t":4,"rt":$n[2].List$1(Spine.Slot),"sn":"separatorSlots","ro":true},{"a":2,"n":"singleSubmesh","t":4,"rt":$n[0].Boolean,"sn":"singleSubmesh","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"skeleton","t":4,"rt":$n[5].Skeleton,"sn":"skeleton"},{"a":2,"n":"skeletonDataAsset","t":4,"rt":$n[1].SkeletonDataAsset,"sn":"skeletonDataAsset"},{"a":2,"n":"tintBlack","t":4,"rt":$n[0].Boolean,"sn":"tintBlack","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"updateMode","t":4,"rt":$n[1].UpdateMode,"sn":"updateMode","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"updateWhenInvisible","t":4,"rt":$n[1].UpdateMode,"sn":"updateWhenInvisible","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"useClipping","t":4,"rt":$n[0].Boolean,"sn":"useClipping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.RangeAttribute(-0.1, 0.0)],"a":2,"n":"zSpacing","t":4,"rt":$n[0].Single,"sn":"zSpacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"GenerateMeshOverride","t":2,"ad":{"a":2,"n":"add_GenerateMeshOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addGenerateMeshOverride","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_GenerateMeshOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeGenerateMeshOverride","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnMeshAndMaterialsUpdated","t":2,"ad":{"a":2,"n":"add_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnPostProcessVertices","t":2,"ad":{"a":2,"n":"add_OnPostProcessVertices","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnPostProcessVertices","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnPostProcessVertices","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnPostProcessVertices","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnRebuild","t":2,"ad":{"a":2,"n":"add_OnRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnRebuild","rt":$n[0].Void,"p":[Function]}},{"a":1,"n":"generateMeshOverride","t":2,"ad":{"a":1,"n":"add_generateMeshOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addgenerateMeshOverride","rt":$n[0].Void,"p":[Function]},"r":{"a":1,"n":"remove_generateMeshOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removegenerateMeshOverride","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonRenderer end.*/

    /*Spine.Unity.SkeletonRenderer+SpriteMaskInteractionMaterials start.*/
    $m("Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials", function () { return {"td":$n[1].SkeletonRenderer,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AnyMaterialCreated","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_AnyMaterialCreated","t":8,"rt":$n[0].Boolean,"fg":"AnyMaterialCreated","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"AnyMaterialCreated"},{"a":2,"n":"materialsInsideMask","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materialsInsideMask"},{"a":2,"n":"materialsMaskDisabled","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materialsMaskDisabled"},{"a":2,"n":"materialsOutsideMask","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materialsOutsideMask"}]}; }, $n);
    /*Spine.Unity.SkeletonRenderer+SpriteMaskInteractionMaterials end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials start.*/
    $m("Spine.Unity.SkeletonGraphicCustomMaterials", function () { return {"nested":[$n[1].SkeletonGraphicCustomMaterials.AtlasMaterialOverride,$n[1].SkeletonGraphicCustomMaterials.AtlasTextureOverride],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonGraphicCustomMaterials")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"RemoveCustomMaterialOverrides","t":8,"sn":"RemoveCustomMaterialOverrides","rt":$n[0].Void},{"a":1,"n":"RemoveCustomTextureOverrides","t":8,"sn":"RemoveCustomTextureOverrides","rt":$n[0].Void},{"a":1,"n":"SetCustomMaterialOverrides","t":8,"sn":"SetCustomMaterialOverrides","rt":$n[0].Void},{"a":1,"n":"SetCustomTextureOverrides","t":8,"sn":"SetCustomTextureOverrides","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"customMaterialOverrides","t":4,"rt":$n[2].List$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride),"sn":"customMaterialOverrides"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"customTextureOverrides","t":4,"rt":$n[2].List$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride),"sn":"customTextureOverrides"},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[1].SkeletonGraphic,"sn":"skeletonGraphic"}]}; }, $n);
    /*Spine.Unity.SkeletonGraphicCustomMaterials end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride start.*/
    $m("Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride", function () { return {"td":$n[1].SkeletonGraphicCustomMaterials,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"other","pt":$n[1].SkeletonGraphicCustomMaterials.AtlasMaterialOverride,"ps":0}],"sn":"equalsT","rt":$n[0].Boolean,"p":[$n[1].SkeletonGraphicCustomMaterials.AtlasMaterialOverride],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"originalTexture","t":4,"rt":$n[3].Texture,"sn":"originalTexture"},{"a":2,"n":"overrideEnabled","t":4,"rt":$n[0].Boolean,"sn":"overrideEnabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"replacementMaterial","t":4,"rt":$n[3].Material,"sn":"replacementMaterial"}]}; }, $n);
    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride start.*/
    $m("Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride", function () { return {"td":$n[1].SkeletonGraphicCustomMaterials,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"other","pt":$n[1].SkeletonGraphicCustomMaterials.AtlasTextureOverride,"ps":0}],"sn":"equalsT","rt":$n[0].Boolean,"p":[$n[1].SkeletonGraphicCustomMaterials.AtlasTextureOverride],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"originalTexture","t":4,"rt":$n[3].Texture,"sn":"originalTexture"},{"a":2,"n":"overrideEnabled","t":4,"rt":$n[0].Boolean,"sn":"overrideEnabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"replacementTexture","t":4,"rt":$n[3].Texture,"sn":"replacementTexture"}]}; }, $n);
    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials start.*/
    $m("Spine.Unity.SkeletonRendererCustomMaterials", function () { return {"nested":[$n[1].SkeletonRendererCustomMaterials.SlotMaterialOverride,$n[1].SkeletonRendererCustomMaterials.AtlasMaterialOverride],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRendererCustomMaterials")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"RemoveCustomMaterialOverrides","t":8,"sn":"RemoveCustomMaterialOverrides","rt":$n[0].Void},{"a":1,"n":"RemoveCustomSlotMaterials","t":8,"sn":"RemoveCustomSlotMaterials","rt":$n[0].Void},{"a":1,"n":"SetCustomMaterialOverrides","t":8,"sn":"SetCustomMaterialOverrides","rt":$n[0].Void},{"a":1,"n":"SetCustomSlotMaterials","t":8,"sn":"SetCustomSlotMaterials","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"customMaterialOverrides","t":4,"rt":$n[2].List$1(Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride),"sn":"customMaterialOverrides"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"customSlotMaterials","t":4,"rt":$n[2].List$1(Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride),"sn":"customSlotMaterials"},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[1].SkeletonRenderer,"sn":"skeletonRenderer"}]}; }, $n);
    /*Spine.Unity.SkeletonRendererCustomMaterials end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride start.*/
    $m("Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride", function () { return {"td":$n[1].SkeletonRendererCustomMaterials,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"other","pt":$n[1].SkeletonRendererCustomMaterials.SlotMaterialOverride,"ps":0}],"sn":"equalsT","rt":$n[0].Boolean,"p":[$n[1].SkeletonRendererCustomMaterials.SlotMaterialOverride],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"material","t":4,"rt":$n[3].Material,"sn":"material"},{"a":2,"n":"overrideDisabled","t":4,"rt":$n[0].Boolean,"sn":"overrideDisabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new Spine.Unity.SpineSlot("", "", false, true, false)],"a":2,"n":"slotName","t":4,"rt":$n[0].String,"sn":"slotName"}]}; }, $n);
    /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride start.*/
    $m("Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride", function () { return {"td":$n[1].SkeletonRendererCustomMaterials,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"other","pt":$n[1].SkeletonRendererCustomMaterials.AtlasMaterialOverride,"ps":0}],"sn":"equalsT","rt":$n[0].Boolean,"p":[$n[1].SkeletonRendererCustomMaterials.AtlasMaterialOverride],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"originalMaterial","t":4,"rt":$n[3].Material,"sn":"originalMaterial"},{"a":2,"n":"overrideDisabled","t":4,"rt":$n[0].Boolean,"sn":"overrideDisabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"replacementMaterial","t":4,"rt":$n[3].Material,"sn":"replacementMaterial"}]}; }, $n);
    /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride end.*/

    /*Spine.Unity.SkeletonPartsRenderer start.*/
    $m("Spine.Unity.SkeletonPartsRenderer", function () { return {"nested":[Function],"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.$ctor1(UnityEngine.MeshRenderer, UnityEngine.MeshFilter),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRenderSeparator")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ClearMesh","t":8,"sn":"ClearMesh","rt":$n[0].Void},{"a":1,"n":"LazyIntialize","t":8,"sn":"LazyIntialize","rt":$n[0].Void},{"a":2,"n":"NewPartsRendererGameObject","is":true,"t":8,"pi":[{"n":"parent","pt":$n[3].Transform,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"sortingOrder","dv":0,"o":true,"pt":$n[0].Int32,"ps":2}],"sn":"NewPartsRendererGameObject","rt":$n[1].SkeletonPartsRenderer,"p":[$n[3].Transform,$n[0].String,$n[0].Int32]},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":2,"n":"RenderParts","t":8,"pi":[{"n":"instructions","pt":$n[5].ExposedList$1(Spine.Unity.SubmeshInstruction),"ps":0},{"n":"startSubmesh","pt":$n[0].Int32,"ps":1},{"n":"endSubmesh","pt":$n[0].Int32,"ps":2}],"sn":"RenderParts","rt":$n[0].Void,"p":[$n[5].ExposedList$1(Spine.Unity.SubmeshInstruction),$n[0].Int32,$n[0].Int32]},{"a":2,"n":"SetPropertyBlock","t":8,"pi":[{"n":"block","pt":$n[3].MaterialPropertyBlock,"ps":0}],"sn":"SetPropertyBlock","rt":$n[0].Void,"p":[$n[3].MaterialPropertyBlock]},{"a":2,"n":"MeshFilter","t":16,"rt":$n[3].MeshFilter,"g":{"a":2,"n":"get_MeshFilter","t":8,"rt":$n[3].MeshFilter,"fg":"MeshFilter"},"fn":"MeshFilter"},{"a":2,"n":"MeshGenerator","t":16,"rt":$n[1].MeshGenerator,"g":{"a":2,"n":"get_MeshGenerator","t":8,"rt":$n[1].MeshGenerator,"fg":"MeshGenerator"},"fn":"MeshGenerator"},{"a":2,"n":"MeshRenderer","t":16,"rt":$n[3].MeshRenderer,"g":{"a":2,"n":"get_MeshRenderer","t":8,"rt":$n[3].MeshRenderer,"fg":"MeshRenderer"},"fn":"MeshRenderer"},{"a":1,"n":"buffers","t":4,"rt":$n[1].MeshRendererBuffers,"sn":"buffers"},{"a":1,"n":"currentInstructions","t":4,"rt":$n[1].SkeletonRendererInstruction,"sn":"currentInstructions"},{"a":1,"n":"meshFilter","t":4,"rt":$n[3].MeshFilter,"sn":"meshFilter"},{"a":1,"n":"meshGenerator","t":4,"rt":$n[1].MeshGenerator,"sn":"meshGenerator"},{"a":1,"n":"meshRenderer","t":4,"rt":$n[3].MeshRenderer,"sn":"meshRenderer"},{"a":2,"n":"OnMeshAndMaterialsUpdated","t":2,"ad":{"a":2,"n":"add_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonPartsRenderer end.*/

    /*Spine.Unity.SkeletonRenderSeparator start.*/
    $m("Spine.Unity.SkeletonRenderSeparator", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRenderSeparator")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddPartsRenderer","t":8,"pi":[{"n":"sortingOrderIncrement","dv":5,"o":true,"pt":$n[0].Int32,"ps":0},{"n":"name","dv":null,"o":true,"pt":$n[0].String,"ps":1}],"sn":"AddPartsRenderer","rt":$n[1].SkeletonPartsRenderer,"p":[$n[0].Int32,$n[0].String]},{"a":2,"n":"AddToSkeletonRenderer","is":true,"t":8,"pi":[{"n":"skeletonRenderer","pt":$n[1].SkeletonRenderer,"ps":0},{"n":"sortingLayerID","dv":0,"o":true,"pt":$n[0].Int32,"ps":1},{"n":"extraPartsRenderers","dv":0,"o":true,"pt":$n[0].Int32,"ps":2},{"n":"sortingOrderIncrement","dv":5,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"baseSortingOrder","dv":0,"o":true,"pt":$n[0].Int32,"ps":4},{"n":"addMinimumPartsRenderers","dv":true,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"AddToSkeletonRenderer","rt":$n[1].SkeletonRenderSeparator,"p":[$n[1].SkeletonRenderer,$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[0].Boolean]},{"a":3,"n":"ClearPartsRendererMeshes","t":8,"sn":"ClearPartsRendererMeshes","rt":$n[0].Void},{"a":1,"n":"HandleRender","t":8,"pi":[{"n":"instruction","pt":$n[1].SkeletonRendererInstruction,"ps":0}],"sn":"HandleRender","rt":$n[0].Void,"p":[$n[1].SkeletonRendererInstruction]},{"a":2,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":2,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":2,"n":"SkeletonRenderer","t":16,"rt":$n[1].SkeletonRenderer,"g":{"a":2,"n":"get_SkeletonRenderer","t":8,"rt":$n[1].SkeletonRenderer,"fg":"SkeletonRenderer"},"s":{"a":2,"n":"set_SkeletonRenderer","t":8,"p":[$n[1].SkeletonRenderer],"rt":$n[0].Void,"fs":"SkeletonRenderer"},"fn":"SkeletonRenderer"},{"a":2,"n":"DefaultSortingOrderIncrement","is":true,"t":4,"rt":$n[0].Int32,"sn":"DefaultSortingOrderIncrement","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"copiedBlock","t":4,"rt":$n[3].MaterialPropertyBlock,"sn":"copiedBlock"},{"at":[new UnityEngine.TooltipAttribute("Copies MeshRenderer flags into each parts renderer")],"a":2,"n":"copyMeshRendererFlags","t":4,"rt":$n[0].Boolean,"sn":"copyMeshRendererFlags","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"copyPropertyBlock","t":4,"rt":$n[0].Boolean,"sn":"copyPropertyBlock","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"mainMeshRenderer","t":4,"rt":$n[3].MeshRenderer,"sn":"mainMeshRenderer"},{"a":2,"n":"partsRenderers","t":4,"rt":$n[2].List$1(Spine.Unity.SkeletonPartsRenderer),"sn":"partsRenderers"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"skeletonRenderer","t":4,"rt":$n[1].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":2,"n":"OnMeshAndMaterialsUpdated","t":2,"ad":{"a":2,"n":"add_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonRenderSeparator end.*/

    /*Spine.Unity.ActivateBasedOnFlipDirection start.*/
    $m("Spine.Unity.ActivateBasedOnFlipDirection", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"CompensateMovementAfterFlipX","t":8,"pi":[{"n":"toActivate","pt":$n[3].Transform,"ps":0},{"n":"toDeactivate","pt":$n[3].Transform,"ps":1}],"sn":"CompensateMovementAfterFlipX","rt":$n[0].Void,"p":[$n[3].Transform,$n[3].Transform]},{"a":1,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"HandleFlip","t":8,"pi":[{"n":"isFlippedX","pt":$n[0].Boolean,"ps":0}],"sn":"HandleFlip","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"ResetJointPositions","t":8,"pi":[{"n":"joints","pt":System.Array.type(UnityEngine.HingeJoint2D),"ps":0}],"sn":"ResetJointPositions","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.HingeJoint2D)]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"activeOnFlippedX","t":4,"rt":$n[3].GameObject,"sn":"activeOnFlippedX"},{"a":2,"n":"activeOnNormalX","t":4,"rt":$n[3].GameObject,"sn":"activeOnNormalX"},{"a":1,"n":"jointsFlippedX","t":4,"rt":System.Array.type(UnityEngine.HingeJoint2D),"sn":"jointsFlippedX"},{"a":1,"n":"jointsNormalX","t":4,"rt":System.Array.type(UnityEngine.HingeJoint2D),"sn":"jointsNormalX"},{"a":1,"n":"skeletonComponent","t":4,"rt":$n[1].ISkeletonComponent,"sn":"skeletonComponent"},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[1].SkeletonGraphic,"sn":"skeletonGraphic"},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[1].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":1,"n":"wasFlippedXBefore","t":4,"rt":$n[0].Boolean,"sn":"wasFlippedXBefore","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.ActivateBasedOnFlipDirection end.*/

    /*Spine.Unity.SkeletonUtility start.*/
    $m("Spine.Unity.SkeletonUtility", function () { return {"nested":[Function],"att":1048833,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.ctor(Spine.Unity.ISkeletonAnimation),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonUtility")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddBoneRigidbody2D","is":true,"t":8,"pi":[{"n":"gameObject","pt":$n[3].GameObject,"ps":0},{"n":"isKinematic","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"gravityScale","dv":0.0,"o":true,"pt":$n[0].Single,"ps":2}],"sn":"AddBoneRigidbody2D","rt":$n[3].Rigidbody2D,"p":[$n[3].GameObject,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"AddBoundingBoxAsComponent","is":true,"t":8,"pi":[{"n":"box","pt":spine.BoundingBoxAttachment,"ps":0},{"n":"slot","pt":$n[5].Slot,"ps":1},{"n":"gameObject","pt":$n[3].GameObject,"ps":2},{"n":"isTrigger","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"AddBoundingBoxAsComponent","rt":$n[3].PolygonCollider2D,"p":[spine.BoundingBoxAttachment,$n[5].Slot,$n[3].GameObject,$n[0].Boolean]},{"a":2,"n":"AddBoundingBoxGameObject","is":true,"t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0},{"n":"box","pt":spine.BoundingBoxAttachment,"ps":1},{"n":"slot","pt":$n[5].Slot,"ps":2},{"n":"parent","pt":$n[3].Transform,"ps":3},{"n":"isTrigger","dv":true,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"AddBoundingBoxGameObject$1","rt":$n[3].PolygonCollider2D,"p":[$n[0].String,spine.BoundingBoxAttachment,$n[5].Slot,$n[3].Transform,$n[0].Boolean]},{"a":2,"n":"AddBoundingBoxGameObject","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"skinName","pt":$n[0].String,"ps":1},{"n":"slotName","pt":$n[0].String,"ps":2},{"n":"attachmentName","pt":$n[0].String,"ps":3},{"n":"parent","pt":$n[3].Transform,"ps":4},{"n":"isTrigger","dv":true,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"AddBoundingBoxGameObject","rt":$n[3].PolygonCollider2D,"p":[$n[5].Skeleton,$n[0].String,$n[0].String,$n[0].String,$n[3].Transform,$n[0].Boolean]},{"a":2,"n":"CollectBones","t":8,"sn":"CollectBones","rt":$n[0].Void},{"a":2,"n":"GetBoneRoot","t":8,"sn":"GetBoneRoot","rt":$n[3].Transform},{"a":2,"n":"GetBoundingBoxBounds","is":true,"t":8,"pi":[{"n":"boundingBox","pt":spine.BoundingBoxAttachment,"ps":0},{"n":"depth","dv":0.0,"o":true,"pt":$n[0].Single,"ps":1}],"sn":"GetBoundingBoxBounds","rt":$n[3].Bounds,"p":[spine.BoundingBoxAttachment,$n[0].Single]},{"a":1,"n":"HandleRendererReset","t":8,"pi":[{"n":"g","pt":$n[1].SkeletonGraphic,"ps":0}],"sn":"HandleRendererReset","rt":$n[0].Void,"p":[$n[1].SkeletonGraphic]},{"a":1,"n":"HandleRendererReset","t":8,"pi":[{"n":"r","pt":$n[1].SkeletonRenderer,"ps":0}],"sn":"HandleRendererReset$1","rt":$n[0].Void,"p":[$n[1].SkeletonRenderer]},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":2,"n":"RegisterBone","t":8,"pi":[{"n":"bone","pt":$n[1].SkeletonUtilityBone,"ps":0}],"sn":"RegisterBone","rt":$n[0].Void,"p":[$n[1].SkeletonUtilityBone]},{"a":2,"n":"RegisterConstraint","t":8,"pi":[{"n":"constraint","pt":$n[1].SkeletonUtilityConstraint,"ps":0}],"sn":"RegisterConstraint","rt":$n[0].Void,"p":[$n[1].SkeletonUtilityConstraint]},{"a":2,"n":"ResubscribeEvents","t":8,"sn":"ResubscribeEvents","rt":$n[0].Void},{"a":2,"n":"SetColliderPointsLocal","is":true,"t":8,"pi":[{"n":"collider","pt":$n[3].PolygonCollider2D,"ps":0},{"n":"slot","pt":$n[5].Slot,"ps":1},{"n":"box","pt":spine.BoundingBoxAttachment,"ps":2},{"n":"scale","dv":1.0,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"SetColliderPointsLocal","rt":$n[0].Void,"p":[$n[3].PolygonCollider2D,$n[5].Slot,spine.BoundingBoxAttachment,$n[0].Single]},{"a":2,"n":"SpawnBone","t":8,"pi":[{"n":"bone","pt":$n[5].Bone,"ps":0},{"n":"parent","pt":$n[3].Transform,"ps":1},{"n":"mode","pt":$n[1].SkeletonUtilityBone.Mode,"ps":2},{"n":"pos","pt":$n[0].Boolean,"ps":3},{"n":"rot","pt":$n[0].Boolean,"ps":4},{"n":"sca","pt":$n[0].Boolean,"ps":5}],"sn":"SpawnBone","rt":$n[3].GameObject,"p":[$n[5].Bone,$n[3].Transform,$n[1].SkeletonUtilityBone.Mode,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"SpawnBoneRecursively","t":8,"pi":[{"n":"bone","pt":$n[5].Bone,"ps":0},{"n":"parent","pt":$n[3].Transform,"ps":1},{"n":"mode","pt":$n[1].SkeletonUtilityBone.Mode,"ps":2},{"n":"pos","pt":$n[0].Boolean,"ps":3},{"n":"rot","pt":$n[0].Boolean,"ps":4},{"n":"sca","pt":$n[0].Boolean,"ps":5}],"sn":"SpawnBoneRecursively","rt":$n[3].GameObject,"p":[$n[5].Bone,$n[3].Transform,$n[1].SkeletonUtilityBone.Mode,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"SpawnHierarchy","t":8,"pi":[{"n":"mode","pt":$n[1].SkeletonUtilityBone.Mode,"ps":0},{"n":"pos","pt":$n[0].Boolean,"ps":1},{"n":"rot","pt":$n[0].Boolean,"ps":2},{"n":"sca","pt":$n[0].Boolean,"ps":3}],"sn":"SpawnHierarchy","rt":$n[3].GameObject,"p":[$n[1].SkeletonUtilityBone.Mode,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"SpawnRoot","t":8,"pi":[{"n":"mode","pt":$n[1].SkeletonUtilityBone.Mode,"ps":0},{"n":"pos","pt":$n[0].Boolean,"ps":1},{"n":"rot","pt":$n[0].Boolean,"ps":2},{"n":"sca","pt":$n[0].Boolean,"ps":3}],"sn":"SpawnRoot","rt":$n[3].GameObject,"p":[$n[1].SkeletonUtilityBone.Mode,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"UnregisterBone","t":8,"pi":[{"n":"bone","pt":$n[1].SkeletonUtilityBone,"ps":0}],"sn":"UnregisterBone","rt":$n[0].Void,"p":[$n[1].SkeletonUtilityBone]},{"a":2,"n":"UnregisterConstraint","t":8,"pi":[{"n":"constraint","pt":$n[1].SkeletonUtilityConstraint,"ps":0}],"sn":"UnregisterConstraint","rt":$n[0].Void,"p":[$n[1].SkeletonUtilityConstraint]},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":1,"n":"UpdateAllBones","t":8,"pi":[{"n":"phase","pt":$n[1].SkeletonUtilityBone.UpdatePhase,"ps":0}],"sn":"UpdateAllBones","rt":$n[0].Void,"p":[$n[1].SkeletonUtilityBone.UpdatePhase]},{"a":1,"n":"UpdateComplete","t":8,"pi":[{"n":"anim","pt":$n[1].ISkeletonAnimation,"ps":0}],"sn":"UpdateComplete","rt":$n[0].Void,"p":[$n[1].ISkeletonAnimation]},{"a":1,"n":"UpdateLocal","t":8,"pi":[{"n":"anim","pt":$n[1].ISkeletonAnimation,"ps":0}],"sn":"UpdateLocal","rt":$n[0].Void,"p":[$n[1].ISkeletonAnimation]},{"a":1,"n":"UpdateWorld","t":8,"pi":[{"n":"anim","pt":$n[1].ISkeletonAnimation,"ps":0}],"sn":"UpdateWorld","rt":$n[0].Void,"p":[$n[1].ISkeletonAnimation]},{"a":2,"n":"IsValid","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsValid","t":8,"rt":$n[0].Boolean,"fg":"IsValid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsValid"},{"a":2,"n":"PositionScale","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_PositionScale","t":8,"rt":$n[0].Single,"fg":"PositionScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"PositionScale"},{"a":2,"n":"Skeleton","t":16,"rt":$n[5].Skeleton,"g":{"a":2,"n":"get_Skeleton","t":8,"rt":$n[5].Skeleton,"fg":"Skeleton"},"fn":"Skeleton"},{"a":2,"n":"SkeletonComponent","t":16,"rt":$n[1].ISkeletonComponent,"g":{"a":2,"n":"get_SkeletonComponent","t":8,"rt":$n[1].ISkeletonComponent,"fg":"SkeletonComponent"},"fn":"SkeletonComponent"},{"a":2,"n":"boneComponents","t":4,"rt":$n[2].List$1(Spine.Unity.SkeletonUtilityBone),"sn":"boneComponents"},{"a":2,"n":"boneRoot","t":4,"rt":$n[3].Transform,"sn":"boneRoot"},{"a":2,"n":"constraintComponents","t":4,"rt":$n[2].List$1(Spine.Unity.SkeletonUtilityConstraint),"sn":"constraintComponents"},{"a":2,"n":"flipBy180DegreeRotation","t":4,"rt":$n[0].Boolean,"sn":"flipBy180DegreeRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"hasConstraints","t":4,"rt":$n[0].Boolean,"sn":"hasConstraints","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"hasOverrideBones","t":4,"rt":$n[0].Boolean,"sn":"hasOverrideBones","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"needToReprocessBones","t":4,"rt":$n[0].Boolean,"sn":"needToReprocessBones","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"positionScale","t":4,"rt":$n[0].Single,"sn":"positionScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"skeletonAnimation","t":4,"rt":$n[1].ISkeletonAnimation,"sn":"skeletonAnimation"},{"a":1,"n":"skeletonComponent","t":4,"rt":$n[1].ISkeletonComponent,"sn":"skeletonComponent"},{"at":[new UnityEngine.HideInInspector()],"a":2,"n":"skeletonGraphic","t":4,"rt":$n[1].SkeletonGraphic,"sn":"skeletonGraphic"},{"at":[new UnityEngine.HideInInspector()],"a":2,"n":"skeletonRenderer","t":4,"rt":$n[1].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":2,"n":"OnReset","t":2,"ad":{"a":2,"n":"add_OnReset","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnReset","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnReset","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnReset","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonUtility end.*/

    /*Spine.Unity.SkeletonUtilityBone start.*/
    $m("Spine.Unity.SkeletonUtilityBone", function () { return {"nested":[$n[1].SkeletonUtilityBone.Mode,$n[1].SkeletonUtilityBone.UpdatePhase],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.AddComponentMenu.ctor("Spine/SkeletonUtilityBone"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonUtilityBone")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddBoundingBox","t":8,"pi":[{"n":"skinName","pt":$n[0].String,"ps":0},{"n":"slotName","pt":$n[0].String,"ps":1},{"n":"attachmentName","pt":$n[0].String,"ps":2}],"sn":"AddBoundingBox","rt":$n[0].Void,"p":[$n[0].String,$n[0].String,$n[0].String]},{"a":2,"n":"BoneTransformModeIncompatible","is":true,"t":8,"pi":[{"n":"bone","pt":$n[5].Bone,"ps":0}],"sn":"BoneTransformModeIncompatible","rt":$n[0].Boolean,"p":[$n[5].Bone],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"DoUpdate","t":8,"pi":[{"n":"phase","pt":$n[1].SkeletonUtilityBone.UpdatePhase,"ps":0}],"sn":"DoUpdate","rt":$n[0].Void,"p":[$n[1].SkeletonUtilityBone.UpdatePhase]},{"a":1,"n":"HandleOnReset","t":8,"sn":"HandleOnReset","rt":$n[0].Void},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":2,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"a":2,"n":"IncompatibleTransformMode","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IncompatibleTransformMode","t":8,"rt":$n[0].Boolean,"fg":"IncompatibleTransformMode","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IncompatibleTransformMode"},{"a":2,"n":"bone","t":4,"rt":$n[5].Bone,"sn":"bone"},{"a":2,"n":"boneName","t":4,"rt":$n[0].String,"sn":"boneName"},{"a":1,"n":"cachedTransform","t":4,"rt":$n[3].Transform,"sn":"cachedTransform"},{"a":2,"n":"hierarchy","t":4,"rt":$n[1].SkeletonUtility,"sn":"hierarchy"},{"a":1,"n":"incompatibleTransformMode","t":4,"rt":$n[0].Boolean,"sn":"incompatibleTransformMode","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"mode","t":4,"rt":$n[1].SkeletonUtilityBone.Mode,"sn":"mode","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.Mode, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.Mode));}},{"at":[new UnityEngine.RangeAttribute(0.0, 1.0)],"a":2,"n":"overrideAlpha","t":4,"rt":$n[0].Single,"sn":"overrideAlpha","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"parentReference","t":4,"rt":$n[3].Transform,"sn":"parentReference"},{"a":2,"n":"position","t":4,"rt":$n[0].Boolean,"sn":"position","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"rotation","t":4,"rt":$n[0].Boolean,"sn":"rotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"scale","t":4,"rt":$n[0].Boolean,"sn":"scale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"skeletonTransform","t":4,"rt":$n[3].Transform,"sn":"skeletonTransform"},{"a":2,"n":"transformLerpComplete","t":4,"rt":$n[0].Boolean,"sn":"transformLerpComplete","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"zPosition","t":4,"rt":$n[0].Boolean,"sn":"zPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SkeletonUtilityBone end.*/

    /*Spine.Unity.SkeletonUtilityBone+Mode start.*/
    $m("Spine.Unity.SkeletonUtilityBone.Mode", function () { return {"td":$n[1].SkeletonUtilityBone,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Follow","is":true,"t":4,"rt":$n[1].SkeletonUtilityBone.Mode,"sn":"Follow","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.Mode, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.Mode));}},{"a":2,"n":"Override","is":true,"t":4,"rt":$n[1].SkeletonUtilityBone.Mode,"sn":"Override","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.Mode, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.Mode));}}]}; }, $n);
    /*Spine.Unity.SkeletonUtilityBone+Mode end.*/

    /*Spine.Unity.SkeletonUtilityBone+UpdatePhase start.*/
    $m("Spine.Unity.SkeletonUtilityBone.UpdatePhase", function () { return {"td":$n[1].SkeletonUtilityBone,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Complete","is":true,"t":4,"rt":$n[1].SkeletonUtilityBone.UpdatePhase,"sn":"Complete","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.UpdatePhase, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.UpdatePhase));}},{"a":2,"n":"Local","is":true,"t":4,"rt":$n[1].SkeletonUtilityBone.UpdatePhase,"sn":"Local","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.UpdatePhase, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.UpdatePhase));}},{"a":2,"n":"World","is":true,"t":4,"rt":$n[1].SkeletonUtilityBone.UpdatePhase,"sn":"World","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.UpdatePhase, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.UpdatePhase));}}]}; }, $n);
    /*Spine.Unity.SkeletonUtilityBone+UpdatePhase end.*/

    /*Spine.Unity.SkeletonUtilityConstraint start.*/
    $m("Spine.Unity.SkeletonUtilityConstraint", function () { return {"att":1048705,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.ctor(Spine.Unity.SkeletonUtilityBone),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonUtilityConstraint")],"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ab":true,"a":2,"n":"DoUpdate","t":8,"sn":"DoUpdate","rt":$n[0].Void},{"v":true,"a":3,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"v":true,"a":3,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":3,"n":"bone","t":4,"rt":$n[1].SkeletonUtilityBone,"sn":"bone"},{"a":3,"n":"hierarchy","t":4,"rt":$n[1].SkeletonUtility,"sn":"hierarchy"}]}; }, $n);
    /*Spine.Unity.SkeletonUtilityConstraint end.*/

    /*Spine.Unity.UpdateMode start.*/
    $m("Spine.Unity.UpdateMode", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"EverythingExceptMesh","is":true,"t":4,"rt":$n[1].UpdateMode,"sn":"EverythingExceptMesh","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"FullUpdate","is":true,"t":4,"rt":$n[1].UpdateMode,"sn":"FullUpdate","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"Nothing","is":true,"t":4,"rt":$n[1].UpdateMode,"sn":"Nothing","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"OnlyAnimationStatus","is":true,"t":4,"rt":$n[1].UpdateMode,"sn":"OnlyAnimationStatus","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"OnlyEventTimelines","is":true,"t":4,"rt":$n[1].UpdateMode,"sn":"OnlyEventTimelines","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}}]}; }, $n);
    /*Spine.Unity.UpdateMode end.*/

    /*Spine.Unity.UpdateTiming start.*/
    $m("Spine.Unity.UpdateTiming", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"InFixedUpdate","is":true,"t":4,"rt":$n[1].UpdateTiming,"sn":"InFixedUpdate","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},{"a":2,"n":"InLateUpdate","is":true,"t":4,"rt":$n[1].UpdateTiming,"sn":"InLateUpdate","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},{"a":2,"n":"InUpdate","is":true,"t":4,"rt":$n[1].UpdateTiming,"sn":"InUpdate","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},{"a":2,"n":"ManualUpdate","is":true,"t":4,"rt":$n[1].UpdateTiming,"sn":"ManualUpdate","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}}]}; }, $n);
    /*Spine.Unity.UpdateTiming end.*/

    /*Spine.Unity.ISpineComponent start.*/
    $m("Spine.Unity.ISpineComponent", function () { return {"att":1048737,"a":2}; }, $n);
    /*Spine.Unity.ISpineComponent end.*/

    /*Spine.Unity.ISpineComponentExtensions start.*/
    $m("Spine.Unity.ISpineComponentExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"IsNullOrDestroyed","is":true,"t":8,"pi":[{"n":"component","pt":$n[1].ISpineComponent,"ps":0}],"sn":"IsNullOrDestroyed","rt":$n[0].Boolean,"p":[$n[1].ISpineComponent],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.ISpineComponentExtensions end.*/

    /*Spine.Unity.ISkeletonAnimation start.*/
    $m("Spine.Unity.ISkeletonAnimation", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"Skeleton","t":16,"rt":$n[5].Skeleton,"g":{"ab":true,"a":2,"n":"get_Skeleton","t":8,"rt":$n[5].Skeleton,"fg":"Spine$Unity$ISkeletonAnimation$Skeleton"},"fn":"Spine$Unity$ISkeletonAnimation$Skeleton"},{"ab":true,"a":2,"n":"UpdateTiming","t":16,"rt":$n[1].UpdateTiming,"g":{"ab":true,"a":2,"n":"get_UpdateTiming","t":8,"rt":$n[1].UpdateTiming,"fg":"Spine$Unity$ISkeletonAnimation$UpdateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},"s":{"ab":true,"a":2,"n":"set_UpdateTiming","t":8,"p":[$n[1].UpdateTiming],"rt":$n[0].Void,"fs":"Spine$Unity$ISkeletonAnimation$UpdateTiming"},"fn":"Spine$Unity$ISkeletonAnimation$UpdateTiming"},{"ab":true,"a":2,"n":"OnAnimationRebuild","t":2,"ad":{"ab":true,"a":2,"n":"add_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$addOnAnimationRebuild","rt":$n[0].Void,"p":[Function]},"r":{"ab":true,"a":2,"n":"remove_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$removeOnAnimationRebuild","rt":$n[0].Void,"p":[Function]}},{"ab":true,"a":2,"n":"UpdateComplete","t":2,"ad":{"ab":true,"a":2,"n":"add_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$addUpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"ab":true,"a":2,"n":"remove_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$removeUpdateComplete","rt":$n[0].Void,"p":[Function]}},{"ab":true,"a":2,"n":"UpdateLocal","t":2,"ad":{"ab":true,"a":2,"n":"add_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$addUpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"ab":true,"a":2,"n":"remove_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$removeUpdateLocal","rt":$n[0].Void,"p":[Function]}},{"ab":true,"a":2,"n":"UpdateWorld","t":2,"ad":{"ab":true,"a":2,"n":"add_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$addUpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"ab":true,"a":2,"n":"remove_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$removeUpdateWorld","rt":$n[0].Void,"p":[Function]}},{"a":1,"backing":true,"n":"<Skeleton>k__BackingField","t":4,"rt":$n[5].Skeleton,"sn":"Spine$Unity$ISkeletonAnimation$Skeleton"},{"a":1,"backing":true,"n":"<UpdateTiming>k__BackingField","t":4,"rt":$n[1].UpdateTiming,"sn":"Spine$Unity$ISkeletonAnimation$UpdateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}}]}; }, $n);
    /*Spine.Unity.ISkeletonAnimation end.*/

    /*Spine.Unity.IHasSkeletonDataAsset start.*/
    $m("Spine.Unity.IHasSkeletonDataAsset", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[1].SkeletonDataAsset,"g":{"ab":true,"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[1].SkeletonDataAsset,"fg":"Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset"},"fn":"Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset"},{"a":1,"backing":true,"n":"<SkeletonDataAsset>k__BackingField","t":4,"rt":$n[1].SkeletonDataAsset,"sn":"Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset"}]}; }, $n);
    /*Spine.Unity.IHasSkeletonDataAsset end.*/

    /*Spine.Unity.ISkeletonComponent start.*/
    $m("Spine.Unity.ISkeletonComponent", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"Skeleton","t":16,"rt":$n[5].Skeleton,"g":{"ab":true,"a":2,"n":"get_Skeleton","t":8,"rt":$n[5].Skeleton,"fg":"Spine$Unity$ISkeletonComponent$Skeleton"},"fn":"Spine$Unity$ISkeletonComponent$Skeleton"},{"ab":true,"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[1].SkeletonDataAsset,"g":{"ab":true,"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[1].SkeletonDataAsset,"fg":"Spine$Unity$ISkeletonComponent$SkeletonDataAsset"},"fn":"Spine$Unity$ISkeletonComponent$SkeletonDataAsset"},{"a":1,"backing":true,"n":"<Skeleton>k__BackingField","t":4,"rt":$n[5].Skeleton,"sn":"Spine$Unity$ISkeletonComponent$Skeleton"},{"a":1,"backing":true,"n":"<SkeletonDataAsset>k__BackingField","t":4,"rt":$n[1].SkeletonDataAsset,"sn":"Spine$Unity$ISkeletonComponent$SkeletonDataAsset"}]}; }, $n);
    /*Spine.Unity.ISkeletonComponent end.*/

    /*Spine.Unity.IAnimationStateComponent start.*/
    $m("Spine.Unity.IAnimationStateComponent", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"AnimationState","t":16,"rt":$n[5].AnimationState,"g":{"ab":true,"a":2,"n":"get_AnimationState","t":8,"rt":$n[5].AnimationState,"fg":"Spine$Unity$IAnimationStateComponent$AnimationState"},"fn":"Spine$Unity$IAnimationStateComponent$AnimationState"},{"ab":true,"a":2,"n":"UnscaledTime","t":16,"rt":$n[0].Boolean,"g":{"ab":true,"a":2,"n":"get_UnscaledTime","t":8,"rt":$n[0].Boolean,"fg":"Spine$Unity$IAnimationStateComponent$UnscaledTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"ab":true,"a":2,"n":"set_UnscaledTime","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Spine$Unity$IAnimationStateComponent$UnscaledTime"},"fn":"Spine$Unity$IAnimationStateComponent$UnscaledTime"},{"a":1,"backing":true,"n":"<AnimationState>k__BackingField","t":4,"rt":$n[5].AnimationState,"sn":"Spine$Unity$IAnimationStateComponent$AnimationState"},{"a":1,"backing":true,"n":"<UnscaledTime>k__BackingField","t":4,"rt":$n[0].Boolean,"sn":"Spine$Unity$IAnimationStateComponent$UnscaledTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.IAnimationStateComponent end.*/

    /*Spine.Unity.IHasSkeletonRenderer start.*/
    $m("Spine.Unity.IHasSkeletonRenderer", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"SkeletonRenderer","t":16,"rt":$n[1].SkeletonRenderer,"g":{"ab":true,"a":2,"n":"get_SkeletonRenderer","t":8,"rt":$n[1].SkeletonRenderer,"fg":"Spine$Unity$IHasSkeletonRenderer$SkeletonRenderer"},"fn":"Spine$Unity$IHasSkeletonRenderer$SkeletonRenderer"},{"a":1,"backing":true,"n":"<SkeletonRenderer>k__BackingField","t":4,"rt":$n[1].SkeletonRenderer,"sn":"Spine$Unity$IHasSkeletonRenderer$SkeletonRenderer"}]}; }, $n);
    /*Spine.Unity.IHasSkeletonRenderer end.*/

    /*Spine.Unity.IHasSkeletonComponent start.*/
    $m("Spine.Unity.IHasSkeletonComponent", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"SkeletonComponent","t":16,"rt":$n[1].ISkeletonComponent,"g":{"ab":true,"a":2,"n":"get_SkeletonComponent","t":8,"rt":$n[1].ISkeletonComponent,"fg":"Spine$Unity$IHasSkeletonComponent$SkeletonComponent"},"fn":"Spine$Unity$IHasSkeletonComponent$SkeletonComponent"},{"a":1,"backing":true,"n":"<SkeletonComponent>k__BackingField","t":4,"rt":$n[1].ISkeletonComponent,"sn":"Spine$Unity$IHasSkeletonComponent$SkeletonComponent"}]}; }, $n);
    /*Spine.Unity.IHasSkeletonComponent end.*/

    /*Spine.Unity.DoubleBuffered$1 start.*/
    $m("Spine.Unity.DoubleBuffered$1", function (T) { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"GetCurrent","t":8,"sn":"GetCurrent","rt":T},{"a":2,"n":"GetNext","t":8,"sn":"GetNext","rt":T},{"a":1,"n":"a","t":4,"rt":T,"sn":"a","ro":true},{"a":1,"n":"b","t":4,"rt":T,"sn":"b","ro":true},{"a":1,"n":"usingA","t":4,"rt":$n[0].Boolean,"sn":"usingA","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.DoubleBuffered$1 end.*/

    /*Spine.Unity.MeshGeneratorBuffers start.*/
    $m("Spine.Unity.MeshGeneratorBuffers", function () { return {"att":1048841,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"colorBuffer","t":4,"rt":System.Array.type(UnityEngine.Color32),"sn":"colorBuffer"},{"a":2,"n":"meshGenerator","t":4,"rt":$n[1].MeshGenerator,"sn":"meshGenerator"},{"a":2,"n":"uvBuffer","t":4,"rt":System.Array.type(UnityEngine.Vector2),"sn":"uvBuffer"},{"a":2,"n":"vertexBuffer","t":4,"rt":System.Array.type(UnityEngine.Vector3),"sn":"vertexBuffer"},{"a":2,"n":"vertexCount","t":4,"rt":$n[0].Int32,"sn":"vertexCount","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.Unity.MeshGeneratorBuffers end.*/

    /*Spine.Unity.MeshGenerator start.*/
    $m("Spine.Unity.MeshGenerator", function () { return {"nested":[$n[1].MeshGenerator.Settings],"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AddAttachmentTintBlack","t":8,"pi":[{"n":"r2","pt":$n[0].Single,"ps":0},{"n":"g2","pt":$n[0].Single,"ps":1},{"n":"b2","pt":$n[0].Single,"ps":2},{"n":"a","pt":$n[0].Single,"ps":3},{"n":"vertexCount","pt":$n[0].Int32,"ps":4}],"sn":"AddAttachmentTintBlack","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Int32]},{"a":2,"n":"AddSubmesh","t":8,"pi":[{"n":"instruction","pt":$n[1].SubmeshInstruction,"ps":0},{"n":"updateTriangles","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"AddSubmesh","rt":$n[0].Void,"p":[$n[1].SubmeshInstruction,$n[0].Boolean]},{"a":2,"n":"Begin","t":8,"sn":"Begin","rt":$n[0].Void},{"a":2,"n":"BuildMesh","t":8,"pi":[{"n":"instruction","pt":$n[1].SkeletonRendererInstruction,"ps":0},{"n":"updateTriangles","pt":$n[0].Boolean,"ps":1}],"sn":"BuildMesh","rt":$n[0].Void,"p":[$n[1].SkeletonRendererInstruction,$n[0].Boolean]},{"a":2,"n":"BuildMeshWithArrays","t":8,"pi":[{"n":"instruction","pt":$n[1].SkeletonRendererInstruction,"ps":0},{"n":"updateTriangles","pt":$n[0].Boolean,"ps":1}],"sn":"BuildMeshWithArrays","rt":$n[0].Void,"p":[$n[1].SkeletonRendererInstruction,$n[0].Boolean]},{"a":2,"n":"EnsureVertexCapacity","t":8,"pi":[{"n":"minimumVertexCount","pt":$n[0].Int32,"ps":0},{"n":"inlcudeTintBlack","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"includeTangents","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"includeNormals","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"EnsureVertexCapacity","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"FillLateVertexData","t":8,"pi":[{"n":"mesh","pt":$n[3].Mesh,"ps":0}],"sn":"FillLateVertexData","rt":$n[0].Void,"p":[$n[3].Mesh]},{"a":2,"n":"FillMeshLocal","is":true,"t":8,"pi":[{"n":"mesh","pt":$n[3].Mesh,"ps":0},{"n":"regionAttachment","pt":$n[5].RegionAttachment,"ps":1}],"sn":"FillMeshLocal$1","rt":$n[0].Void,"p":[$n[3].Mesh,$n[5].RegionAttachment]},{"a":2,"n":"FillMeshLocal","is":true,"t":8,"pi":[{"n":"mesh","pt":$n[3].Mesh,"ps":0},{"n":"meshAttachment","pt":$n[5].MeshAttachment,"ps":1},{"n":"skeletonData","pt":$n[5].SkeletonData,"ps":2}],"sn":"FillMeshLocal","rt":$n[0].Void,"p":[$n[3].Mesh,$n[5].MeshAttachment,$n[5].SkeletonData]},{"a":2,"n":"FillTriangles","t":8,"pi":[{"n":"mesh","pt":$n[3].Mesh,"ps":0}],"sn":"FillTriangles","rt":$n[0].Void,"p":[$n[3].Mesh]},{"a":2,"n":"FillVertexData","t":8,"pi":[{"n":"mesh","pt":$n[3].Mesh,"ps":0}],"sn":"FillVertexData","rt":$n[0].Void,"p":[$n[3].Mesh]},{"a":2,"n":"GenerateSingleSubmeshInstruction","is":true,"t":8,"pi":[{"n":"instructionOutput","pt":$n[1].SkeletonRendererInstruction,"ps":0},{"n":"skeleton","pt":$n[5].Skeleton,"ps":1},{"n":"material","pt":$n[3].Material,"ps":2}],"sn":"GenerateSingleSubmeshInstruction","rt":$n[0].Void,"p":[$n[1].SkeletonRendererInstruction,$n[5].Skeleton,$n[3].Material]},{"a":2,"n":"GenerateSkeletonRendererInstruction","is":true,"t":8,"pi":[{"n":"instructionOutput","pt":$n[1].SkeletonRendererInstruction,"ps":0},{"n":"skeleton","pt":$n[5].Skeleton,"ps":1},{"n":"customSlotMaterials","pt":$n[2].Dictionary$2(Spine.Slot,UnityEngine.Material),"ps":2},{"n":"separatorSlots","pt":$n[2].List$1(Spine.Slot),"ps":3},{"n":"generateMeshOverride","pt":$n[0].Boolean,"ps":4},{"n":"immutableTriangles","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"GenerateSkeletonRendererInstruction","rt":$n[0].Void,"p":[$n[1].SkeletonRendererInstruction,$n[5].Skeleton,$n[2].Dictionary$2(Spine.Slot,UnityEngine.Material),$n[2].List$1(Spine.Slot),$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"GetMeshBounds","t":8,"sn":"GetMeshBounds","rt":$n[3].Bounds},{"a":2,"n":"RequiresMultipleSubmeshesByDrawOrder","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0}],"sn":"RequiresMultipleSubmeshesByDrawOrder","rt":$n[0].Boolean,"p":[$n[5].Skeleton],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"ScaleVertexData","t":8,"pi":[{"n":"scale","pt":$n[0].Single,"ps":0}],"sn":"ScaleVertexData","rt":$n[0].Void,"p":[$n[0].Single]},{"a":4,"n":"SolveTangents2DBuffer","is":true,"t":8,"pi":[{"n":"tangents","pt":System.Array.type(UnityEngine.Vector4),"ps":0},{"n":"tempTanBuffer","pt":System.Array.type(UnityEngine.Vector2),"ps":1},{"n":"vertexCount","pt":$n[0].Int32,"ps":2}],"sn":"SolveTangents2DBuffer","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.Vector4),System.Array.type(UnityEngine.Vector2),$n[0].Int32]},{"a":4,"n":"SolveTangents2DEnsureSize","is":true,"t":8,"pi":[{"n":"tangentBuffer","ref":true,"pt":System.Array.type(UnityEngine.Vector4),"ps":0},{"n":"tempTanBuffer","ref":true,"pt":System.Array.type(UnityEngine.Vector2),"ps":1},{"n":"vertexCount","pt":$n[0].Int32,"ps":2},{"n":"vertexBufferLength","pt":$n[0].Int32,"ps":3}],"sn":"SolveTangents2DEnsureSize","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.Vector4),System.Array.type(UnityEngine.Vector2),$n[0].Int32,$n[0].Int32]},{"a":4,"n":"SolveTangents2DTriangles","is":true,"t":8,"pi":[{"n":"tempTanBuffer","pt":System.Array.type(UnityEngine.Vector2),"ps":0},{"n":"triangles","pt":$n[0].Array.type(System.Int32),"ps":1},{"n":"triangleCount","pt":$n[0].Int32,"ps":2},{"n":"vertices","pt":System.Array.type(UnityEngine.Vector3),"ps":3},{"n":"uvs","pt":System.Array.type(UnityEngine.Vector2),"ps":4},{"n":"vertexCount","pt":$n[0].Int32,"ps":5}],"sn":"SolveTangents2DTriangles","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.Vector2),$n[0].Array.type(System.Int32),$n[0].Int32,System.Array.type(UnityEngine.Vector3),System.Array.type(UnityEngine.Vector2),$n[0].Int32]},{"a":2,"n":"SubmeshIndexCount","t":8,"pi":[{"n":"submeshIndex","pt":$n[0].Int32,"ps":0}],"sn":"SubmeshIndexCount","rt":$n[0].Int32,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"TrimExcess","t":8,"sn":"TrimExcess","rt":$n[0].Void},{"a":2,"n":"TryReplaceMaterials","is":true,"t":8,"pi":[{"n":"workingSubmeshInstructions","pt":$n[5].ExposedList$1(Spine.Unity.SubmeshInstruction),"ps":0},{"n":"customMaterialOverride","pt":$n[2].Dictionary$2(UnityEngine.Material,UnityEngine.Material),"ps":1}],"sn":"TryReplaceMaterials","rt":$n[0].Void,"p":[$n[5].ExposedList$1(Spine.Unity.SubmeshInstruction),$n[2].Dictionary$2(UnityEngine.Material,UnityEngine.Material)]},{"a":2,"n":"Buffers","t":16,"rt":$n[1].MeshGeneratorBuffers,"g":{"a":2,"n":"get_Buffers","t":8,"rt":$n[1].MeshGeneratorBuffers,"fg":"Buffers"},"fn":"Buffers"},{"a":2,"n":"VertexCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_VertexCount","t":8,"rt":$n[0].Int32,"fg":"VertexCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"VertexCount"},{"a":1,"n":"AttachmentColors32","is":true,"t":4,"rt":$n[2].List$1(UnityEngine.Color32),"sn":"AttachmentColors32"},{"a":1,"n":"AttachmentIndices","is":true,"t":4,"rt":$n[2].List$1(System.Int32),"sn":"AttachmentIndices"},{"a":1,"n":"AttachmentUVs","is":true,"t":4,"rt":$n[2].List$1(UnityEngine.Vector2),"sn":"AttachmentUVs"},{"a":1,"n":"AttachmentVerts","is":true,"t":4,"rt":$n[2].List$1(UnityEngine.Vector3),"sn":"AttachmentVerts"},{"a":1,"n":"BoundsMaxDefault","is":true,"t":4,"rt":$n[0].Single,"sn":"BoundsMaxDefault","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"BoundsMinDefault","is":true,"t":4,"rt":$n[0].Single,"sn":"BoundsMinDefault","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"clipper","t":4,"rt":$n[5].SkeletonClipping,"sn":"clipper"},{"a":3,"n":"colorBuffer","t":4,"rt":$n[5].ExposedList$1(UnityEngine.Color32),"sn":"colorBuffer","ro":true},{"a":1,"n":"meshBoundsMax","t":4,"rt":$n[3].Vector2,"sn":"meshBoundsMax"},{"a":1,"n":"meshBoundsMin","t":4,"rt":$n[3].Vector2,"sn":"meshBoundsMin"},{"a":1,"n":"meshBoundsThickness","t":4,"rt":$n[0].Single,"sn":"meshBoundsThickness","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"normals","t":4,"rt":System.Array.type(UnityEngine.Vector3),"sn":"normals"},{"a":1,"n":"regionTriangles","t":4,"rt":$n[0].Array.type(System.Int32),"sn":"regionTriangles"},{"a":2,"n":"settings","t":4,"rt":$n[1].MeshGenerator.Settings,"sn":"settings"},{"a":1,"n":"submeshIndex","t":4,"rt":$n[0].Int32,"sn":"submeshIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"submeshes","t":4,"rt":$n[5].ExposedList$1(Spine.ExposedList$1(System.Int32)),"sn":"submeshes","ro":true},{"a":1,"n":"tangents","t":4,"rt":System.Array.type(UnityEngine.Vector4),"sn":"tangents"},{"a":1,"n":"tempTanBuffer","t":4,"rt":System.Array.type(UnityEngine.Vector2),"sn":"tempTanBuffer"},{"a":1,"n":"tempVerts","t":4,"rt":$n[0].Array.type(System.Single),"sn":"tempVerts"},{"a":1,"n":"uv2","t":4,"rt":$n[5].ExposedList$1(UnityEngine.Vector2),"sn":"uv2"},{"a":1,"n":"uv3","t":4,"rt":$n[5].ExposedList$1(UnityEngine.Vector2),"sn":"uv3"},{"a":3,"n":"uvBuffer","t":4,"rt":$n[5].ExposedList$1(UnityEngine.Vector2),"sn":"uvBuffer","ro":true},{"a":3,"n":"vertexBuffer","t":4,"rt":$n[5].ExposedList$1(UnityEngine.Vector3),"sn":"vertexBuffer","ro":true}]}; }, $n);
    /*Spine.Unity.MeshGenerator end.*/

    /*Spine.Unity.MeshGenerator+Settings start.*/
    $m("Spine.Unity.MeshGenerator.Settings", function () { return {"td":$n[1].MeshGenerator,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Default","is":true,"t":16,"rt":$n[1].MeshGenerator.Settings,"g":{"a":2,"n":"get_Default","t":8,"rt":$n[1].MeshGenerator.Settings,"fg":"Default","is":true},"fn":"Default"},{"a":2,"n":"addNormals","t":4,"rt":$n[0].Boolean,"sn":"addNormals","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"calculateTangents","t":4,"rt":$n[0].Boolean,"sn":"calculateTangents","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Enable when using Additive blend mode at SkeletonGraphic under a CanvasGroup. When enabled, Additive alpha value is stored at uv2.g instead of color.a to capture CanvasGroup modifying color.a.")],"a":2,"n":"canvasGroupTintBlack","t":4,"rt":$n[0].Boolean,"sn":"canvasGroupTintBlack","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"immutableTriangles","t":4,"rt":$n[0].Boolean,"sn":"immutableTriangles","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.HeaderAttribute("Vertex Data")],"a":2,"n":"pmaVertexColors","t":4,"rt":$n[0].Boolean,"sn":"pmaVertexColors","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"tintBlack","t":4,"rt":$n[0].Boolean,"sn":"tintBlack","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"useClipping","t":4,"rt":$n[0].Boolean,"sn":"useClipping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.RangeAttribute(-0.1, 0.0)],"a":2,"n":"zSpacing","t":4,"rt":$n[0].Single,"sn":"zSpacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Unity.MeshGenerator+Settings end.*/

    /*Spine.Unity.MeshRendererBuffers start.*/
    $m("Spine.Unity.MeshRendererBuffers", function () { return {"nested":[$n[1].MeshRendererBuffers.SmartMesh],"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":2,"n":"GetNextMesh","t":8,"sn":"GetNextMesh","rt":$n[1].MeshRendererBuffers.SmartMesh},{"a":2,"n":"GetUpdatedSharedMaterialsArray","t":8,"sn":"GetUpdatedSharedMaterialsArray","rt":System.Array.type(UnityEngine.Material)},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"MaterialsChangedInLastUpdate","t":8,"sn":"MaterialsChangedInLastUpdate","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"UpdateSharedMaterials","t":8,"pi":[{"n":"instructions","pt":$n[5].ExposedList$1(Spine.Unity.SubmeshInstruction),"ps":0}],"sn":"UpdateSharedMaterials","rt":$n[0].Void,"p":[$n[5].ExposedList$1(Spine.Unity.SubmeshInstruction)]},{"a":1,"n":"doubleBufferedMesh","t":4,"rt":$n[1].DoubleBuffered$1(Spine.Unity.MeshRendererBuffers.SmartMesh),"sn":"doubleBufferedMesh"},{"a":4,"n":"sharedMaterials","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"sharedMaterials"},{"a":4,"n":"submeshMaterials","t":4,"rt":$n[5].ExposedList$1(UnityEngine.Material),"sn":"submeshMaterials","ro":true}]}; }, $n);
    /*Spine.Unity.MeshRendererBuffers end.*/

    /*Spine.Unity.MeshRendererBuffers+SmartMesh start.*/
    $m("Spine.Unity.MeshRendererBuffers.SmartMesh", function () { return {"td":$n[1].MeshRendererBuffers,"att":1048578,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":2,"n":"instructionUsed","t":4,"rt":$n[1].SkeletonRendererInstruction,"sn":"instructionUsed"},{"a":2,"n":"mesh","t":4,"rt":$n[3].Mesh,"sn":"mesh"}]}; }, $n);
    /*Spine.Unity.MeshRendererBuffers+SmartMesh end.*/

    /*Spine.Unity.SkeletonRendererInstruction start.*/
    $m("Spine.Unity.SkeletonRendererInstruction", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":2,"n":"GeometryNotEqual","is":true,"t":8,"pi":[{"n":"a","pt":$n[1].SkeletonRendererInstruction,"ps":0},{"n":"b","pt":$n[1].SkeletonRendererInstruction,"ps":1}],"sn":"GeometryNotEqual","rt":$n[0].Boolean,"p":[$n[1].SkeletonRendererInstruction,$n[1].SkeletonRendererInstruction],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Set","t":8,"pi":[{"n":"other","pt":$n[1].SkeletonRendererInstruction,"ps":0}],"sn":"Set","rt":$n[0].Void,"p":[$n[1].SkeletonRendererInstruction]},{"a":2,"n":"SetWithSubset","t":8,"pi":[{"n":"instructions","pt":$n[5].ExposedList$1(Spine.Unity.SubmeshInstruction),"ps":0},{"n":"startSubmesh","pt":$n[0].Int32,"ps":1},{"n":"endSubmesh","pt":$n[0].Int32,"ps":2}],"sn":"SetWithSubset","rt":$n[0].Void,"p":[$n[5].ExposedList$1(Spine.Unity.SubmeshInstruction),$n[0].Int32,$n[0].Int32]},{"a":2,"n":"attachments","t":4,"rt":$n[5].ExposedList$1(spine.Attachment),"sn":"attachments","ro":true},{"a":2,"n":"hasActiveClipping","t":4,"rt":$n[0].Boolean,"sn":"hasActiveClipping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"immutableTriangles","t":4,"rt":$n[0].Boolean,"sn":"immutableTriangles","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"rawVertexCount","t":4,"rt":$n[0].Int32,"sn":"rawVertexCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"submeshInstructions","t":4,"rt":$n[5].ExposedList$1(Spine.Unity.SubmeshInstruction),"sn":"submeshInstructions","ro":true}]}; }, $n);
    /*Spine.Unity.SkeletonRendererInstruction end.*/

    /*Spine.Unity.SpineMesh start.*/
    $m("Spine.Unity.SpineMesh", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"NewSkeletonMesh","is":true,"t":8,"sn":"NewSkeletonMesh","rt":$n[3].Mesh},{"a":4,"n":"MeshHideflags","is":true,"t":4,"rt":$n[3].HideFlags,"sn":"MeshHideflags","box":function ($v) { return Bridge.box($v, UnityEngine.HideFlags, System.Enum.toStringFn(UnityEngine.HideFlags));}}]}; }, $n);
    /*Spine.Unity.SpineMesh end.*/

    /*Spine.Unity.SubmeshInstruction start.*/
    $m("Spine.Unity.SubmeshInstruction", function () { return {"att":1048841,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"SlotCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SlotCount","t":8,"rt":$n[0].Int32,"fg":"SlotCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"SlotCount"},{"a":2,"n":"endSlot","t":4,"rt":$n[0].Int32,"sn":"endSlot","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"forceSeparate","t":4,"rt":$n[0].Boolean,"sn":"forceSeparate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"hasClipping","t":4,"rt":$n[0].Boolean,"sn":"hasClipping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"hasPMAAdditiveSlot","t":4,"rt":$n[0].Boolean,"sn":"hasPMAAdditiveSlot","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"material","t":4,"rt":$n[3].Material,"sn":"material"},{"a":2,"n":"preActiveClippingSlotSource","t":4,"rt":$n[0].Int32,"sn":"preActiveClippingSlotSource","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"rawFirstVertexIndex","t":4,"rt":$n[0].Int32,"sn":"rawFirstVertexIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"rawTriangleCount","t":4,"rt":$n[0].Int32,"sn":"rawTriangleCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"rawVertexCount","t":4,"rt":$n[0].Int32,"sn":"rawVertexCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"skeleton","t":4,"rt":$n[5].Skeleton,"sn":"skeleton"},{"a":2,"n":"startSlot","t":4,"rt":$n[0].Int32,"sn":"startSlot","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.Unity.SubmeshInstruction end.*/

    /*Spine.Unity.BlendModeMaterialsAsset start.*/
    $m("Spine.Unity.BlendModeMaterialsAsset", function () { return {"nested":[$n[1].BlendModeMaterialsAsset.AtlasMaterialCache],"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Spine/SkeletonData Modifiers/Blend Mode Materials", order: 200
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeletonData","pt":$n[5].SkeletonData,"ps":0}],"sn":"Apply","rt":$n[0].Void,"p":[$n[5].SkeletonData]},{"a":2,"n":"ApplyMaterials","is":true,"t":8,"pi":[{"n":"skeletonData","pt":$n[5].SkeletonData,"ps":0},{"n":"multiplyTemplate","pt":$n[3].Material,"ps":1},{"n":"screenTemplate","pt":$n[3].Material,"ps":2},{"n":"additiveTemplate","pt":$n[3].Material,"ps":3},{"n":"includeAdditiveSlots","pt":$n[0].Boolean,"ps":4}],"sn":"ApplyMaterials","rt":$n[0].Void,"p":[$n[5].SkeletonData,$n[3].Material,$n[3].Material,$n[3].Material,$n[0].Boolean]},{"a":2,"n":"additiveMaterialTemplate","t":4,"rt":$n[3].Material,"sn":"additiveMaterialTemplate"},{"a":2,"n":"applyAdditiveMaterial","t":4,"rt":$n[0].Boolean,"sn":"applyAdditiveMaterial","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"multiplyMaterialTemplate","t":4,"rt":$n[3].Material,"sn":"multiplyMaterialTemplate"},{"a":2,"n":"screenMaterialTemplate","t":4,"rt":$n[3].Material,"sn":"screenMaterialTemplate"}]}; }, $n);
    /*Spine.Unity.BlendModeMaterialsAsset end.*/

    /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache start.*/
    $m("Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache", function () { return {"td":$n[1].BlendModeMaterialsAsset,"att":1048579,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"CloneAtlasRegionWithMaterial","t":8,"pi":[{"n":"originalRegion","pt":$n[5].AtlasRegion,"ps":0},{"n":"materialTemplate","pt":$n[3].Material,"ps":1}],"sn":"CloneAtlasRegionWithMaterial","rt":$n[5].AtlasRegion,"p":[$n[5].AtlasRegion,$n[3].Material]},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":1,"n":"GetAtlasPageWithMaterial","t":8,"pi":[{"n":"originalPage","pt":$n[5].AtlasPage,"ps":0},{"n":"materialTemplate","pt":$n[3].Material,"ps":1}],"sn":"GetAtlasPageWithMaterial","rt":$n[5].AtlasPage,"p":[$n[5].AtlasPage,$n[3].Material]},{"a":1,"n":"cache","t":4,"rt":$n[2].Dictionary$2(System.Collections.Generic.KeyValuePair$2(Spine.AtlasPage,UnityEngine.Material),Spine.AtlasPage),"sn":"cache","ro":true}]}; }, $n);
    /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache end.*/

    /*Spine.Unity.SpineAttributeBase start.*/
    $m("Spine.Unity.SpineAttributeBase", function () { return {"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"dataField","t":4,"rt":$n[0].String,"sn":"dataField"},{"a":2,"n":"fallbackToTextField","t":4,"rt":$n[0].Boolean,"sn":"fallbackToTextField","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"includeNone","t":4,"rt":$n[0].Boolean,"sn":"includeNone","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"startsWith","t":4,"rt":$n[0].String,"sn":"startsWith"}]}; }, $n);
    /*Spine.Unity.SpineAttributeBase end.*/

    /*Spine.Unity.SpineBone start.*/
    $m("Spine.Unity.SpineBone", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"},{"a":2,"n":"GetBone","is":true,"t":8,"pi":[{"n":"boneName","pt":$n[0].String,"ps":0},{"n":"renderer","pt":$n[1].SkeletonRenderer,"ps":1}],"sn":"getBone","rt":$n[5].Bone,"p":[$n[0].String,$n[1].SkeletonRenderer]},{"a":2,"n":"GetBoneData","is":true,"t":8,"pi":[{"n":"boneName","pt":$n[0].String,"ps":0},{"n":"skeletonDataAsset","pt":$n[1].SkeletonDataAsset,"ps":1}],"sn":"getBoneData","rt":spine.BoneData,"p":[$n[0].String,$n[1].SkeletonDataAsset]}]}; }, $n);
    /*Spine.Unity.SpineBone end.*/

    /*Spine.Unity.SpineSlot start.*/
    $m("Spine.Unity.SpineSlot", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"containsBoundingBoxes","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"ctor"},{"a":2,"n":"containsBoundingBoxes","t":4,"rt":$n[0].Boolean,"sn":"containsBoundingBoxes","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SpineSlot end.*/

    /*Spine.Unity.SpineAnimation start.*/
    $m("Spine.Unity.SpineAnimation", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"}]}; }, $n);
    /*Spine.Unity.SpineAnimation end.*/

    /*Spine.Unity.SpineEvent start.*/
    $m("Spine.Unity.SpineEvent", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"audioOnly","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"ctor"},{"a":2,"n":"audioOnly","t":4,"rt":$n[0].Boolean,"sn":"audioOnly","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SpineEvent end.*/

    /*Spine.Unity.SpineIkConstraint start.*/
    $m("Spine.Unity.SpineIkConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"}]}; }, $n);
    /*Spine.Unity.SpineIkConstraint end.*/

    /*Spine.Unity.SpineTransformConstraint start.*/
    $m("Spine.Unity.SpineTransformConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"}]}; }, $n);
    /*Spine.Unity.SpineTransformConstraint end.*/

    /*Spine.Unity.SpinePathConstraint start.*/
    $m("Spine.Unity.SpinePathConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"}]}; }, $n);
    /*Spine.Unity.SpinePathConstraint end.*/

    /*Spine.Unity.SpineSkin start.*/
    $m("Spine.Unity.SpineSkin", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"defaultAsEmptyString","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"ctor"},{"a":2,"n":"defaultAsEmptyString","t":4,"rt":$n[0].Boolean,"sn":"defaultAsEmptyString","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SpineSkin end.*/

    /*Spine.Unity.SpineAttachment start.*/
    $m("Spine.Unity.SpineAttachment", function () { return {"nested":[$n[1].SpineAttachment.Hierarchy],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Boolean,$n[0].Boolean,$n[0].Boolean,$n[0].String,$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"currentSkinOnly","dv":true,"o":true,"pt":$n[0].Boolean,"ps":0},{"n":"returnAttachmentPath","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"placeholdersOnly","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"slotField","dv":"","o":true,"pt":$n[0].String,"ps":3},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":4},{"n":"skinField","dv":"","o":true,"pt":$n[0].String,"ps":5},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":6},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":7}],"sn":"ctor"},{"a":2,"n":"GetAttachment","is":true,"t":8,"pi":[{"n":"attachmentPath","pt":$n[0].String,"ps":0},{"n":"skeletonData","pt":$n[5].SkeletonData,"ps":1}],"sn":"getAttachment","rt":spine.Attachment,"p":[$n[0].String,$n[5].SkeletonData]},{"a":2,"n":"GetAttachment","is":true,"t":8,"pi":[{"n":"attachmentPath","pt":$n[0].String,"ps":0},{"n":"skeletonDataAsset","pt":$n[1].SkeletonDataAsset,"ps":1}],"sn":"getAttachment$1","rt":spine.Attachment,"p":[$n[0].String,$n[1].SkeletonDataAsset]},{"a":2,"n":"GetHierarchy","is":true,"t":8,"pi":[{"n":"fullPath","pt":$n[0].String,"ps":0}],"sn":"getHierarchy","rt":$n[1].SpineAttachment.Hierarchy,"p":[$n[0].String]},{"a":2,"n":"currentSkinOnly","t":4,"rt":$n[0].Boolean,"sn":"currentSkinOnly","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"placeholdersOnly","t":4,"rt":$n[0].Boolean,"sn":"placeholdersOnly","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"returnAttachmentPath","t":4,"rt":$n[0].Boolean,"sn":"returnAttachmentPath","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"skinField","t":4,"rt":$n[0].String,"sn":"skinField"},{"a":2,"n":"slotField","t":4,"rt":$n[0].String,"sn":"slotField"}]}; }, $n);
    /*Spine.Unity.SpineAttachment end.*/

    /*Spine.Unity.SpineAttachment+Hierarchy start.*/
    $m("Spine.Unity.SpineAttachment.Hierarchy", function () { return {"td":$n[1].SpineAttachment,"att":1048842,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"fullPath","pt":$n[0].String,"ps":0}],"sn":"$ctor1"},{"a":2,"n":"name","t":4,"rt":$n[0].String,"sn":"name"},{"a":2,"n":"skin","t":4,"rt":$n[0].String,"sn":"skin"},{"a":2,"n":"slot","t":4,"rt":$n[0].String,"sn":"slot"}]}; }, $n);
    /*Spine.Unity.SpineAttachment+Hierarchy end.*/

    /*Spine.Unity.SpineAtlasRegion start.*/
    $m("Spine.Unity.SpineAtlasRegion", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"atlasAssetField","dv":"","o":true,"pt":$n[0].String,"ps":0}],"sn":"ctor"},{"a":2,"n":"atlasAssetField","t":4,"rt":$n[0].String,"sn":"atlasAssetField"}]}; }, $n);
    /*Spine.Unity.SpineAtlasRegion end.*/

    /*Spine.Unity.MathUtilities start.*/
    $m("Spine.Unity.MathUtilities", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"InverseLerp","is":true,"t":8,"pi":[{"n":"a","pt":$n[0].Single,"ps":0},{"n":"b","pt":$n[0].Single,"ps":1},{"n":"value","pt":$n[0].Single,"ps":2}],"sn":"InverseLerp","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"InverseLerp","is":true,"t":8,"pi":[{"n":"a","pt":$n[3].Vector2,"ps":0},{"n":"b","pt":$n[3].Vector2,"ps":1},{"n":"value","pt":$n[3].Vector2,"ps":2}],"sn":"InverseLerp$1","rt":$n[3].Vector2,"p":[$n[3].Vector2,$n[3].Vector2,$n[3].Vector2]},{"a":2,"n":"InverseLerp","is":true,"t":8,"pi":[{"n":"a","pt":$n[3].Vector3,"ps":0},{"n":"b","pt":$n[3].Vector3,"ps":1},{"n":"value","pt":$n[3].Vector3,"ps":2}],"sn":"InverseLerp$2","rt":$n[3].Vector3,"p":[$n[3].Vector3,$n[3].Vector3,$n[3].Vector3]},{"a":2,"n":"InverseLerp","is":true,"t":8,"pi":[{"n":"a","pt":$n[3].Vector4,"ps":0},{"n":"b","pt":$n[3].Vector4,"ps":1},{"n":"value","pt":$n[3].Vector4,"ps":2}],"sn":"InverseLerp$3","rt":$n[3].Vector4,"p":[$n[3].Vector4,$n[3].Vector4,$n[3].Vector4]}]}; }, $n);
    /*Spine.Unity.MathUtilities end.*/

    /*Spine.Unity.SkeletonExtensions start.*/
    $m("Spine.Unity.SkeletonExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"GetColor","is":true,"t":8,"pi":[{"n":"a","pt":$n[5].MeshAttachment,"ps":0}],"sn":"GetColor","rt":$n[3].Color,"p":[$n[5].MeshAttachment]},{"a":2,"n":"GetColor","is":true,"t":8,"pi":[{"n":"a","pt":$n[5].RegionAttachment,"ps":0}],"sn":"GetColor$1","rt":$n[3].Color,"p":[$n[5].RegionAttachment]},{"a":2,"n":"GetColor","is":true,"t":8,"pi":[{"n":"s","pt":$n[5].Skeleton,"ps":0}],"sn":"GetColor$2","rt":$n[3].Color,"p":[$n[5].Skeleton]},{"a":2,"n":"GetColor","is":true,"t":8,"pi":[{"n":"s","pt":$n[5].Slot,"ps":0}],"sn":"GetColor$3","rt":$n[3].Color,"p":[$n[5].Slot]},{"a":2,"n":"GetColorTintBlack","is":true,"t":8,"pi":[{"n":"s","pt":$n[5].Slot,"ps":0}],"sn":"GetColorTintBlack","rt":$n[3].Color,"p":[$n[5].Slot]},{"a":2,"n":"GetLocalPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[5].Bone,"ps":0}],"sn":"GetLocalPosition","rt":$n[3].Vector2,"p":[$n[5].Bone]},{"a":2,"n":"GetLocalQuaternion","is":true,"t":8,"pi":[{"n":"bone","pt":$n[5].Bone,"ps":0}],"sn":"GetLocalQuaternion","rt":$n[3].Quaternion,"p":[$n[5].Bone]},{"a":2,"n":"GetLocalScale","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0}],"sn":"GetLocalScale","rt":$n[3].Vector2,"p":[$n[5].Skeleton]},{"a":2,"n":"GetLocalVertices","is":true,"t":8,"pi":[{"n":"va","pt":spine.VertexAttachment,"ps":0},{"n":"slot","pt":$n[5].Slot,"ps":1},{"n":"buffer","pt":System.Array.type(UnityEngine.Vector2),"ps":2}],"sn":"GetLocalVertices","rt":System.Array.type(UnityEngine.Vector2),"p":[spine.VertexAttachment,$n[5].Slot,System.Array.type(UnityEngine.Vector2)]},{"a":2,"n":"GetMaterial","is":true,"t":8,"pi":[{"n":"a","pt":spine.Attachment,"ps":0}],"sn":"GetMaterial","rt":$n[3].Material,"p":[spine.Attachment]},{"a":2,"n":"GetMatrix4x4","is":true,"t":8,"pi":[{"n":"bone","pt":$n[5].Bone,"ps":0}],"sn":"GetMatrix4x4","rt":$n[3].Matrix4x4,"p":[$n[5].Bone]},{"a":2,"n":"GetQuaternion","is":true,"t":8,"pi":[{"n":"bone","pt":$n[5].Bone,"ps":0}],"sn":"GetQuaternion","rt":$n[3].Quaternion,"p":[$n[5].Bone]},{"a":2,"n":"GetSkeletonSpacePosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[5].Bone,"ps":0}],"sn":"GetSkeletonSpacePosition","rt":$n[3].Vector2,"p":[$n[5].Bone]},{"a":2,"n":"GetSkeletonSpacePosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[5].Bone,"ps":0},{"n":"boneLocal","pt":$n[3].Vector2,"ps":1}],"sn":"GetSkeletonSpacePosition$1","rt":$n[3].Vector2,"p":[$n[5].Bone,$n[3].Vector2]},{"a":2,"n":"GetWorldPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[5].Bone,"ps":0},{"n":"spineGameObjectTransform","pt":$n[3].Transform,"ps":1}],"sn":"GetWorldPosition","rt":$n[3].Vector3,"p":[$n[5].Bone,$n[3].Transform]},{"a":2,"n":"GetWorldPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[5].Bone,"ps":0},{"n":"spineGameObjectTransform","pt":$n[3].Transform,"ps":1},{"n":"positionScale","pt":$n[0].Single,"ps":2}],"sn":"GetWorldPosition$1","rt":$n[3].Vector3,"p":[$n[5].Bone,$n[3].Transform,$n[0].Single]},{"a":2,"n":"GetWorldPosition","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[5].PointAttachment,"ps":0},{"n":"bone","pt":$n[5].Bone,"ps":1},{"n":"spineGameObjectTransform","pt":$n[3].Transform,"ps":2}],"sn":"GetWorldPosition$2","rt":$n[3].Vector3,"p":[$n[5].PointAttachment,$n[5].Bone,$n[3].Transform]},{"a":2,"n":"GetWorldPosition","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[5].PointAttachment,"ps":0},{"n":"slot","pt":$n[5].Slot,"ps":1},{"n":"spineGameObjectTransform","pt":$n[3].Transform,"ps":2}],"sn":"GetWorldPosition$3","rt":$n[3].Vector3,"p":[$n[5].PointAttachment,$n[5].Slot,$n[3].Transform]},{"a":2,"n":"GetWorldToLocalMatrix","is":true,"t":8,"pi":[{"n":"bone","pt":$n[5].Bone,"ps":0},{"n":"ia","out":true,"pt":$n[0].Single,"ps":1},{"n":"ib","out":true,"pt":$n[0].Single,"ps":2},{"n":"ic","out":true,"pt":$n[0].Single,"ps":3},{"n":"id","out":true,"pt":$n[0].Single,"ps":4}],"sn":"GetWorldToLocalMatrix","rt":$n[0].Void,"p":[$n[5].Bone,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"GetWorldVertices","is":true,"t":8,"pi":[{"n":"a","pt":spine.VertexAttachment,"ps":0},{"n":"slot","pt":$n[5].Slot,"ps":1},{"n":"buffer","pt":System.Array.type(UnityEngine.Vector2),"ps":2}],"sn":"GetWorldVertices","rt":System.Array.type(UnityEngine.Vector2),"p":[spine.VertexAttachment,$n[5].Slot,System.Array.type(UnityEngine.Vector2)]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[5].MeshAttachment,"ps":0},{"n":"color","pt":$n[3].Color,"ps":1}],"sn":"SetColor","rt":$n[0].Void,"p":[$n[5].MeshAttachment,$n[3].Color]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[5].MeshAttachment,"ps":0},{"n":"color","pt":$n[3].Color32,"ps":1}],"sn":"SetColor$1","rt":$n[0].Void,"p":[$n[5].MeshAttachment,$n[3].Color32]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[5].RegionAttachment,"ps":0},{"n":"color","pt":$n[3].Color,"ps":1}],"sn":"SetColor$2","rt":$n[0].Void,"p":[$n[5].RegionAttachment,$n[3].Color]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[5].RegionAttachment,"ps":0},{"n":"color","pt":$n[3].Color32,"ps":1}],"sn":"SetColor$3","rt":$n[0].Void,"p":[$n[5].RegionAttachment,$n[3].Color32]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"color","pt":$n[3].Color,"ps":1}],"sn":"SetColor$4","rt":$n[0].Void,"p":[$n[5].Skeleton,$n[3].Color]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"color","pt":$n[3].Color32,"ps":1}],"sn":"SetColor$5","rt":$n[0].Void,"p":[$n[5].Skeleton,$n[3].Color32]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"slot","pt":$n[5].Slot,"ps":0},{"n":"color","pt":$n[3].Color,"ps":1}],"sn":"SetColor$6","rt":$n[0].Void,"p":[$n[5].Slot,$n[3].Color]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"slot","pt":$n[5].Slot,"ps":0},{"n":"color","pt":$n[3].Color32,"ps":1}],"sn":"SetColor$7","rt":$n[0].Void,"p":[$n[5].Slot,$n[3].Color32]},{"a":2,"n":"SetLocalPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[5].Bone,"ps":0},{"n":"position","pt":$n[3].Vector2,"ps":1}],"sn":"SetLocalPosition","rt":$n[0].Void,"p":[$n[5].Bone,$n[3].Vector2]},{"a":2,"n":"SetLocalPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[5].Bone,"ps":0},{"n":"position","pt":$n[3].Vector3,"ps":1}],"sn":"SetLocalPosition$1","rt":$n[0].Void,"p":[$n[5].Bone,$n[3].Vector3]},{"a":2,"n":"SetLocalScale","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"scale","pt":$n[3].Vector2,"ps":1}],"sn":"SetLocalScale","rt":$n[0].Void,"p":[$n[5].Skeleton,$n[3].Vector2]},{"a":2,"n":"SetPositionSkeletonSpace","is":true,"t":8,"pi":[{"n":"bone","pt":$n[5].Bone,"ps":0},{"n":"skeletonSpacePosition","pt":$n[3].Vector2,"ps":1}],"sn":"SetPositionSkeletonSpace","rt":$n[3].Vector2,"p":[$n[5].Bone,$n[3].Vector2]},{"a":2,"n":"WorldToLocal","is":true,"t":8,"pi":[{"n":"bone","pt":$n[5].Bone,"ps":0},{"n":"worldPosition","pt":$n[3].Vector2,"ps":1}],"sn":"WorldToLocal","rt":$n[3].Vector2,"p":[$n[5].Bone,$n[3].Vector2]},{"a":1,"n":"ByteToFloat","is":true,"t":4,"rt":$n[0].Single,"sn":"ByteToFloat","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Unity.SkeletonExtensions end.*/

    /*Spine.Unity.WaitForSpineAnimation start.*/
    $m("Spine.Unity.WaitForSpineAnimation", function () { return {"nested":[$n[1].WaitForSpineAnimation.AnimationEventTypes],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[5].TrackEntry,$n[1].WaitForSpineAnimation.AnimationEventTypes],"pi":[{"n":"trackEntry","pt":$n[5].TrackEntry,"ps":0},{"n":"eventsToWaitFor","pt":$n[1].WaitForSpineAnimation.AnimationEventTypes,"ps":1}],"sn":"ctor"},{"a":1,"n":"HandleComplete","t":8,"pi":[{"n":"trackEntry","pt":$n[5].TrackEntry,"ps":0}],"sn":"HandleComplete","rt":$n[0].Void,"p":[$n[5].TrackEntry]},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"trackEntry","pt":$n[5].TrackEntry,"ps":0},{"n":"eventsToWaitFor","pt":$n[1].WaitForSpineAnimation.AnimationEventTypes,"ps":1}],"sn":"NowWaitFor","rt":$n[1].WaitForSpineAnimation,"p":[$n[5].TrackEntry,$n[1].WaitForSpineAnimation.AnimationEventTypes]},{"a":3,"n":"SafeSubscribe","t":8,"pi":[{"n":"trackEntry","pt":$n[5].TrackEntry,"ps":0},{"n":"eventsToWaitFor","pt":$n[1].WaitForSpineAnimation.AnimationEventTypes,"ps":1}],"sn":"SafeSubscribe","rt":$n[0].Void,"p":[$n[5].TrackEntry,$n[1].WaitForSpineAnimation.AnimationEventTypes]},{"a":1,"n":"m_WasFired","t":4,"rt":$n[0].Boolean,"sn":"m_WasFired","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.WaitForSpineAnimation end.*/

    /*Spine.Unity.WaitForSpineAnimation+AnimationEventTypes start.*/
    $m("Spine.Unity.WaitForSpineAnimation.AnimationEventTypes", function () { return {"td":$n[1].WaitForSpineAnimation,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Complete","is":true,"t":4,"rt":$n[1].WaitForSpineAnimation.AnimationEventTypes,"sn":"Complete","box":function ($v) { return Bridge.box($v, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes, System.Enum.toStringFn(Spine.Unity.WaitForSpineAnimation.AnimationEventTypes));}},{"a":2,"n":"Dispose","is":true,"t":4,"rt":$n[1].WaitForSpineAnimation.AnimationEventTypes,"sn":"Dispose","box":function ($v) { return Bridge.box($v, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes, System.Enum.toStringFn(Spine.Unity.WaitForSpineAnimation.AnimationEventTypes));}},{"a":2,"n":"End","is":true,"t":4,"rt":$n[1].WaitForSpineAnimation.AnimationEventTypes,"sn":"End","box":function ($v) { return Bridge.box($v, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes, System.Enum.toStringFn(Spine.Unity.WaitForSpineAnimation.AnimationEventTypes));}},{"a":2,"n":"Interrupt","is":true,"t":4,"rt":$n[1].WaitForSpineAnimation.AnimationEventTypes,"sn":"Interrupt","box":function ($v) { return Bridge.box($v, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes, System.Enum.toStringFn(Spine.Unity.WaitForSpineAnimation.AnimationEventTypes));}},{"a":2,"n":"Start","is":true,"t":4,"rt":$n[1].WaitForSpineAnimation.AnimationEventTypes,"sn":"Start","box":function ($v) { return Bridge.box($v, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes, System.Enum.toStringFn(Spine.Unity.WaitForSpineAnimation.AnimationEventTypes));}}]}; }, $n);
    /*Spine.Unity.WaitForSpineAnimation+AnimationEventTypes end.*/

    /*Spine.Unity.WaitForSpineAnimationComplete start.*/
    $m("Spine.Unity.WaitForSpineAnimationComplete", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[5].TrackEntry,$n[0].Boolean],"pi":[{"n":"trackEntry","pt":$n[5].TrackEntry,"ps":0},{"n":"includeEndEvent","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"ctor"},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"trackEntry","pt":$n[5].TrackEntry,"ps":0},{"n":"includeEndEvent","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"NowWaitFor$1","rt":$n[1].WaitForSpineAnimationComplete,"p":[$n[5].TrackEntry,$n[0].Boolean]}]}; }, $n);
    /*Spine.Unity.WaitForSpineAnimationComplete end.*/

    /*Spine.Unity.WaitForSpineAnimationEnd start.*/
    $m("Spine.Unity.WaitForSpineAnimationEnd", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[5].TrackEntry],"pi":[{"n":"trackEntry","pt":$n[5].TrackEntry,"ps":0}],"sn":"ctor"},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"trackEntry","pt":$n[5].TrackEntry,"ps":0}],"sn":"NowWaitFor$1","rt":$n[1].WaitForSpineAnimationEnd,"p":[$n[5].TrackEntry]}]}; }, $n);
    /*Spine.Unity.WaitForSpineAnimationEnd end.*/

    /*Spine.Unity.WaitForSpineEvent start.*/
    $m("Spine.Unity.WaitForSpineEvent", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[5].AnimationState,spine.EventData,$n[0].Boolean],"pi":[{"n":"state","pt":$n[5].AnimationState,"ps":0},{"n":"eventDataReference","pt":spine.EventData,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[5].AnimationState,$n[0].String,$n[0].Boolean],"pi":[{"n":"state","pt":$n[5].AnimationState,"ps":0},{"n":"eventName","pt":$n[0].String,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"$ctor1"},{"a":2,"n":".ctor","t":1,"p":[$n[1].SkeletonAnimation,spine.EventData,$n[0].Boolean],"pi":[{"n":"skeletonAnimation","pt":$n[1].SkeletonAnimation,"ps":0},{"n":"eventDataReference","pt":spine.EventData,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"$ctor2"},{"a":2,"n":".ctor","t":1,"p":[$n[1].SkeletonAnimation,$n[0].String,$n[0].Boolean],"pi":[{"n":"skeletonAnimation","pt":$n[1].SkeletonAnimation,"ps":0},{"n":"eventName","pt":$n[0].String,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"$ctor3"},{"a":1,"n":"Clear","t":8,"pi":[{"n":"state","pt":$n[5].AnimationState,"ps":0}],"sn":"Clear","rt":$n[0].Void,"p":[$n[5].AnimationState]},{"a":1,"n":"HandleAnimationStateEvent","t":8,"pi":[{"n":"trackEntry","pt":$n[5].TrackEntry,"ps":0},{"n":"e","pt":spine.Event,"ps":1}],"sn":"HandleAnimationStateEvent","rt":$n[0].Void,"p":[$n[5].TrackEntry,spine.Event]},{"a":1,"n":"HandleAnimationStateEventByName","t":8,"pi":[{"n":"trackEntry","pt":$n[5].TrackEntry,"ps":0},{"n":"e","pt":spine.Event,"ps":1}],"sn":"HandleAnimationStateEventByName","rt":$n[0].Void,"p":[$n[5].TrackEntry,spine.Event]},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"state","pt":$n[5].AnimationState,"ps":0},{"n":"eventDataReference","pt":spine.EventData,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"NowWaitFor","rt":$n[1].WaitForSpineEvent,"p":[$n[5].AnimationState,spine.EventData,$n[0].Boolean]},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"state","pt":$n[5].AnimationState,"ps":0},{"n":"eventName","pt":$n[0].String,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"NowWaitFor$1","rt":$n[1].WaitForSpineEvent,"p":[$n[5].AnimationState,$n[0].String,$n[0].Boolean]},{"a":1,"n":"Subscribe","t":8,"pi":[{"n":"state","pt":$n[5].AnimationState,"ps":0},{"n":"eventDataReference","pt":spine.EventData,"ps":1},{"n":"unsubscribe","pt":$n[0].Boolean,"ps":2}],"sn":"Subscribe","rt":$n[0].Void,"p":[$n[5].AnimationState,spine.EventData,$n[0].Boolean]},{"a":1,"n":"SubscribeByName","t":8,"pi":[{"n":"state","pt":$n[5].AnimationState,"ps":0},{"n":"eventName","pt":$n[0].String,"ps":1},{"n":"unsubscribe","pt":$n[0].Boolean,"ps":2}],"sn":"SubscribeByName","rt":$n[0].Void,"p":[$n[5].AnimationState,$n[0].String,$n[0].Boolean]},{"a":2,"n":"WillUnsubscribeAfterFiring","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_WillUnsubscribeAfterFiring","t":8,"rt":$n[0].Boolean,"fg":"WillUnsubscribeAfterFiring","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_WillUnsubscribeAfterFiring","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"WillUnsubscribeAfterFiring"},"fn":"WillUnsubscribeAfterFiring"},{"a":1,"n":"m_AnimationState","t":4,"rt":$n[5].AnimationState,"sn":"m_AnimationState"},{"a":1,"n":"m_EventName","t":4,"rt":$n[0].String,"sn":"m_EventName"},{"a":1,"n":"m_TargetEvent","t":4,"rt":spine.EventData,"sn":"m_TargetEvent"},{"a":1,"n":"m_WasFired","t":4,"rt":$n[0].Boolean,"sn":"m_WasFired","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"m_unsubscribeAfterFiring","t":4,"rt":$n[0].Boolean,"sn":"m_unsubscribeAfterFiring","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.WaitForSpineEvent end.*/

    /*Spine.Unity.AnimationTools.TimelineExtensions start.*/
    $m("Spine.Unity.AnimationTools.TimelineExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"Evaluate","is":true,"t":8,"pi":[{"n":"timeline","pt":spine.RotateTimeline,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"skeletonData","dv":null,"o":true,"pt":$n[5].SkeletonData,"ps":2}],"sn":"Evaluate","rt":$n[0].Single,"p":[spine.RotateTimeline,$n[0].Single,$n[5].SkeletonData],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Evaluate","is":true,"t":8,"pi":[{"n":"timeline","pt":spine.TranslateTimeline,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"skeletonData","dv":null,"o":true,"pt":$n[5].SkeletonData,"ps":2}],"sn":"Evaluate$1","rt":$n[3].Vector2,"p":[spine.TranslateTimeline,$n[0].Single,$n[5].SkeletonData]},{"a":2,"n":"Evaluate","is":true,"t":8,"pi":[{"n":"xTimeline","pt":spine.TranslateXTimeline,"ps":0},{"n":"yTimeline","pt":spine.TranslateYTimeline,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"skeletonData","dv":null,"o":true,"pt":$n[5].SkeletonData,"ps":3}],"sn":"Evaluate$2","rt":$n[3].Vector2,"p":[spine.TranslateXTimeline,spine.TranslateYTimeline,$n[0].Single,$n[5].SkeletonData]},{"a":2,"n":"EvaluateRotateMix","is":true,"t":8,"pi":[{"n":"timeline","pt":spine.TransformConstraintTimeline,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1}],"sn":"EvaluateRotateMix","rt":$n[0].Single,"p":[spine.TransformConstraintTimeline,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"EvaluateTranslateXYMix","is":true,"t":8,"pi":[{"n":"timeline","pt":spine.TransformConstraintTimeline,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1}],"sn":"EvaluateTranslateXYMix","rt":$n[3].Vector2,"p":[spine.TransformConstraintTimeline,$n[0].Single]},{"a":2,"n":"FindTimelineForBone","is":true,"t":8,"pi":[{"n":"a","pt":$n[5].Animation,"ps":0},{"n":"boneIndex","pt":$n[0].Int32,"ps":1}],"tpc":1,"tprm":["T"],"sn":"FindTimelineForBone","rt":System.Object,"p":[$n[5].Animation,$n[0].Int32]},{"a":2,"n":"FindTransformConstraintTimeline","is":true,"t":8,"pi":[{"n":"a","pt":$n[5].Animation,"ps":0},{"n":"transformConstraintIndex","pt":$n[0].Int32,"ps":1}],"sn":"FindTransformConstraintTimeline","rt":spine.TransformConstraintTimeline,"p":[$n[5].Animation,$n[0].Int32]},{"a":2,"n":"FindTranslateTimelineForBone","is":true,"t":8,"pi":[{"n":"a","pt":$n[5].Animation,"ps":0},{"n":"boneIndex","pt":$n[0].Int32,"ps":1}],"sn":"FindTranslateTimelineForBone","rt":spine.TranslateTimeline,"p":[$n[5].Animation,$n[0].Int32]}]}; }, $n);
    /*Spine.Unity.AnimationTools.TimelineExtensions end.*/

    /*Spine.Unity.AttachmentTools.AtlasUtilities start.*/
    $m("Spine.Unity.AttachmentTools.AtlasUtilities", function () { return {"nested":[$n[9].AtlasUtilities.IntAndAtlasRegionKey],"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"ClearCache","is":true,"t":8,"sn":"ClearCache","rt":$n[0].Void},{"a":1,"n":"CopyTexture","is":true,"t":8,"pi":[{"n":"source","pt":$n[3].Texture2D,"ps":0},{"n":"sourceRect","pt":$n[3].Rect,"ps":1},{"n":"destination","pt":$n[3].Texture2D,"ps":2}],"sn":"CopyTexture","rt":$n[0].Void,"p":[$n[3].Texture2D,$n[3].Rect,$n[3].Texture2D]},{"a":1,"n":"CopyTextureApplyPMA","is":true,"t":8,"pi":[{"n":"source","pt":$n[3].Texture2D,"ps":0},{"n":"sourceRect","pt":$n[3].Rect,"ps":1},{"n":"destination","pt":$n[3].Texture2D,"ps":2}],"sn":"CopyTextureApplyPMA","rt":$n[0].Void,"p":[$n[3].Texture2D,$n[3].Rect,$n[3].Texture2D]},{"a":1,"n":"CopyTextureAttributesFrom","is":true,"t":8,"pi":[{"n":"destination","pt":$n[3].Texture2D,"ps":0},{"n":"source","pt":$n[3].Texture2D,"ps":1}],"sn":"CopyTextureAttributesFrom","rt":$n[0].Void,"p":[$n[3].Texture2D,$n[3].Texture2D]},{"a":1,"n":"GetClone","is":true,"t":8,"pi":[{"n":"t","pt":$n[3].Texture2D,"ps":0},{"n":"textureFormat","dv":4,"o":true,"pt":$n[3].TextureFormat,"ps":1},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"linear","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"applyPMA","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"GetClone","rt":$n[3].Texture2D,"p":[$n[3].Texture2D,$n[3].TextureFormat,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"GetMainTexture","is":true,"t":8,"pi":[{"n":"region","pt":$n[5].AtlasRegion,"ps":0}],"sn":"GetMainTexture","rt":$n[3].Texture2D,"p":[$n[5].AtlasRegion]},{"a":2,"n":"GetRepackedAttachments","is":true,"t":8,"pi":[{"n":"sourceAttachments","pt":$n[2].List$1(spine.Attachment),"ps":0},{"n":"outputAttachments","pt":$n[2].List$1(spine.Attachment),"ps":1},{"n":"materialPropertySource","pt":$n[3].Material,"ps":2},{"n":"outputMaterial","out":true,"pt":$n[3].Material,"ps":3},{"n":"outputTexture","out":true,"pt":$n[3].Texture2D,"ps":4},{"n":"maxAtlasSize","dv":1024,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"padding","dv":2,"o":true,"pt":$n[0].Int32,"ps":6},{"n":"textureFormat","dv":4,"o":true,"pt":$n[3].TextureFormat,"ps":7},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8},{"n":"newAssetName","dv":"Repacked Attachments","o":true,"pt":$n[0].String,"ps":9},{"n":"clearCache","dv":false,"o":true,"pt":$n[0].Boolean,"ps":10},{"n":"useOriginalNonrenderables","dv":true,"o":true,"pt":$n[0].Boolean,"ps":11},{"n":"additionalTexturePropertyIDsToCopy","dv":null,"o":true,"pt":$n[0].Array.type(System.Int32),"ps":12},{"n":"additionalOutputTextures","dv":null,"o":true,"pt":System.Array.type(UnityEngine.Texture2D),"ps":13},{"n":"additionalTextureFormats","dv":null,"o":true,"pt":System.Array.type(UnityEngine.TextureFormat),"ps":14},{"n":"additionalTextureIsLinear","dv":null,"o":true,"pt":$n[0].Array.type(System.Boolean),"ps":15}],"sn":"GetRepackedAttachments","rt":$n[0].Void,"p":[$n[2].List$1(spine.Attachment),$n[2].List$1(spine.Attachment),$n[3].Material,$n[3].Material,$n[3].Texture2D,$n[0].Int32,$n[0].Int32,$n[3].TextureFormat,$n[0].Boolean,$n[0].String,$n[0].Boolean,$n[0].Boolean,$n[0].Array.type(System.Int32),System.Array.type(UnityEngine.Texture2D),System.Array.type(UnityEngine.TextureFormat),$n[0].Array.type(System.Boolean)]},{"a":2,"n":"GetRepackedAttachments","is":true,"t":8,"pi":[{"n":"sourceAttachments","pt":$n[2].List$1(spine.Attachment),"ps":0},{"n":"outputAttachments","pt":$n[2].List$1(spine.Attachment),"ps":1},{"n":"shader","pt":$n[3].Shader,"ps":2},{"n":"outputMaterial","out":true,"pt":$n[3].Material,"ps":3},{"n":"outputTexture","out":true,"pt":$n[3].Texture2D,"ps":4},{"n":"maxAtlasSize","dv":1024,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"padding","dv":2,"o":true,"pt":$n[0].Int32,"ps":6},{"n":"textureFormat","dv":4,"o":true,"pt":$n[3].TextureFormat,"ps":7},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8},{"n":"newAssetName","dv":"Repacked Attachments","o":true,"pt":$n[0].String,"ps":9},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[3].Material,"ps":10},{"n":"clearCache","dv":false,"o":true,"pt":$n[0].Boolean,"ps":11},{"n":"useOriginalNonrenderables","dv":true,"o":true,"pt":$n[0].Boolean,"ps":12},{"n":"additionalTexturePropertyIDsToCopy","dv":null,"o":true,"pt":$n[0].Array.type(System.Int32),"ps":13},{"n":"additionalOutputTextures","dv":null,"o":true,"pt":System.Array.type(UnityEngine.Texture2D),"ps":14},{"n":"additionalTextureFormats","dv":null,"o":true,"pt":System.Array.type(UnityEngine.TextureFormat),"ps":15},{"n":"additionalTextureIsLinear","dv":null,"o":true,"pt":$n[0].Array.type(System.Boolean),"ps":16}],"sn":"GetRepackedAttachments$1","rt":$n[0].Void,"p":[$n[2].List$1(spine.Attachment),$n[2].List$1(spine.Attachment),$n[3].Shader,$n[3].Material,$n[3].Texture2D,$n[0].Int32,$n[0].Int32,$n[3].TextureFormat,$n[0].Boolean,$n[0].String,$n[3].Material,$n[0].Boolean,$n[0].Boolean,$n[0].Array.type(System.Int32),System.Array.type(UnityEngine.Texture2D),System.Array.type(UnityEngine.TextureFormat),$n[0].Array.type(System.Boolean)]},{"a":2,"n":"GetRepackedSkin","is":true,"t":8,"pi":[{"n":"o","pt":$n[5].Skin,"ps":0},{"n":"newName","pt":$n[0].String,"ps":1},{"n":"materialPropertySource","pt":$n[3].Material,"ps":2},{"n":"outputMaterial","out":true,"pt":$n[3].Material,"ps":3},{"n":"outputTexture","out":true,"pt":$n[3].Texture2D,"ps":4},{"n":"maxAtlasSize","dv":1024,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"padding","dv":2,"o":true,"pt":$n[0].Int32,"ps":6},{"n":"textureFormat","dv":4,"o":true,"pt":$n[3].TextureFormat,"ps":7},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8},{"n":"useOriginalNonrenderables","dv":true,"o":true,"pt":$n[0].Boolean,"ps":9},{"n":"clearCache","dv":false,"o":true,"pt":$n[0].Boolean,"ps":10},{"n":"additionalTexturePropertyIDsToCopy","dv":null,"o":true,"pt":$n[0].Array.type(System.Int32),"ps":11},{"n":"additionalOutputTextures","dv":null,"o":true,"pt":System.Array.type(UnityEngine.Texture2D),"ps":12},{"n":"additionalTextureFormats","dv":null,"o":true,"pt":System.Array.type(UnityEngine.TextureFormat),"ps":13},{"n":"additionalTextureIsLinear","dv":null,"o":true,"pt":$n[0].Array.type(System.Boolean),"ps":14}],"sn":"GetRepackedSkin","rt":$n[5].Skin,"p":[$n[5].Skin,$n[0].String,$n[3].Material,$n[3].Material,$n[3].Texture2D,$n[0].Int32,$n[0].Int32,$n[3].TextureFormat,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean,$n[0].Array.type(System.Int32),System.Array.type(UnityEngine.Texture2D),System.Array.type(UnityEngine.TextureFormat),$n[0].Array.type(System.Boolean)]},{"a":2,"n":"GetRepackedSkin","is":true,"t":8,"pi":[{"n":"o","pt":$n[5].Skin,"ps":0},{"n":"newName","pt":$n[0].String,"ps":1},{"n":"shader","pt":$n[3].Shader,"ps":2},{"n":"outputMaterial","out":true,"pt":$n[3].Material,"ps":3},{"n":"outputTexture","out":true,"pt":$n[3].Texture2D,"ps":4},{"n":"maxAtlasSize","dv":1024,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"padding","dv":2,"o":true,"pt":$n[0].Int32,"ps":6},{"n":"textureFormat","dv":4,"o":true,"pt":$n[3].TextureFormat,"ps":7},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[3].Material,"ps":9},{"n":"clearCache","dv":false,"o":true,"pt":$n[0].Boolean,"ps":10},{"n":"useOriginalNonrenderables","dv":true,"o":true,"pt":$n[0].Boolean,"ps":11},{"n":"additionalTexturePropertyIDsToCopy","dv":null,"o":true,"pt":$n[0].Array.type(System.Int32),"ps":12},{"n":"additionalOutputTextures","dv":null,"o":true,"pt":System.Array.type(UnityEngine.Texture2D),"ps":13},{"n":"additionalTextureFormats","dv":null,"o":true,"pt":System.Array.type(UnityEngine.TextureFormat),"ps":14},{"n":"additionalTextureIsLinear","dv":null,"o":true,"pt":$n[0].Array.type(System.Boolean),"ps":15}],"sn":"GetRepackedSkin$1","rt":$n[5].Skin,"p":[$n[5].Skin,$n[0].String,$n[3].Shader,$n[3].Material,$n[3].Texture2D,$n[0].Int32,$n[0].Int32,$n[3].TextureFormat,$n[0].Boolean,$n[3].Material,$n[0].Boolean,$n[0].Boolean,$n[0].Array.type(System.Int32),System.Array.type(UnityEngine.Texture2D),System.Array.type(UnityEngine.TextureFormat),$n[0].Array.type(System.Boolean)]},{"a":1,"n":"GetSpineAtlasRect","is":true,"t":8,"pi":[{"n":"region","pt":$n[5].AtlasRegion,"ps":0},{"n":"includeRotate","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"GetSpineAtlasRect","rt":$n[3].Rect,"p":[$n[5].AtlasRegion,$n[0].Boolean]},{"a":1,"n":"GetTexture","is":true,"t":8,"pi":[{"n":"region","pt":$n[5].AtlasRegion,"ps":0},{"n":"texturePropertyId","pt":$n[0].Int32,"ps":1}],"sn":"GetTexture","rt":$n[3].Texture2D,"p":[$n[5].AtlasRegion,$n[0].Int32]},{"a":1,"n":"GetTexture","is":true,"t":8,"pi":[{"n":"region","pt":$n[5].AtlasRegion,"ps":0},{"n":"texturePropertyName","pt":$n[0].String,"ps":1}],"sn":"GetTexture$1","rt":$n[3].Texture2D,"p":[$n[5].AtlasRegion,$n[0].String]},{"a":1,"n":"GetUnityRect","is":true,"t":8,"pi":[{"n":"region","pt":$n[5].AtlasRegion,"ps":0}],"sn":"GetUnityRect","rt":$n[3].Rect,"p":[$n[5].AtlasRegion]},{"a":1,"n":"GetUnityRect","is":true,"t":8,"pi":[{"n":"region","pt":$n[5].AtlasRegion,"ps":0},{"n":"textureHeight","pt":$n[0].Int32,"ps":1}],"sn":"GetUnityRect$1","rt":$n[3].Rect,"p":[$n[5].AtlasRegion,$n[0].Int32]},{"at":[new UnityEngine.RuntimeInitializeOnLoadMethodAttribute.$ctor1(4)],"a":1,"n":"Init","is":true,"t":8,"sn":"Init","rt":$n[0].Void},{"a":1,"n":"InverseLerp","is":true,"t":8,"pi":[{"n":"a","pt":$n[0].Single,"ps":0},{"n":"b","pt":$n[0].Single,"ps":1},{"n":"value","pt":$n[0].Single,"ps":2}],"sn":"InverseLerp","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"IsRenderable","is":true,"t":8,"pi":[{"n":"a","pt":spine.Attachment,"ps":0}],"sn":"IsRenderable","rt":$n[0].Boolean,"p":[spine.Attachment],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"SpineUnityFlipRect","is":true,"t":8,"pi":[{"n":"rect","pt":$n[3].Rect,"ps":0},{"n":"textureHeight","pt":$n[0].Int32,"ps":1}],"sn":"SpineUnityFlipRect","rt":$n[3].Rect,"p":[$n[3].Rect,$n[0].Int32]},{"a":1,"n":"TextureRectToUVRect","is":true,"t":8,"pi":[{"n":"textureRect","pt":$n[3].Rect,"ps":0},{"n":"texWidth","pt":$n[0].Int32,"ps":1},{"n":"texHeight","pt":$n[0].Int32,"ps":2}],"sn":"TextureRectToUVRect","rt":$n[3].Rect,"p":[$n[3].Rect,$n[0].Int32,$n[0].Int32]},{"a":2,"n":"ToAtlasRegion","is":true,"t":8,"pi":[{"n":"s","pt":$n[3].Sprite,"ps":0},{"n":"page","pt":$n[5].AtlasPage,"ps":1}],"sn":"ToAtlasRegion","rt":$n[5].AtlasRegion,"p":[$n[3].Sprite,$n[5].AtlasPage]},{"a":4,"n":"ToAtlasRegion","is":true,"t":8,"pi":[{"n":"s","pt":$n[3].Sprite,"ps":0},{"n":"isolatedTexture","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"ToAtlasRegion$4","rt":$n[5].AtlasRegion,"p":[$n[3].Sprite,$n[0].Boolean]},{"a":2,"n":"ToAtlasRegion","is":true,"t":8,"pi":[{"n":"s","pt":$n[3].Sprite,"ps":0},{"n":"material","pt":$n[3].Material,"ps":1}],"sn":"ToAtlasRegion$1","rt":$n[5].AtlasRegion,"p":[$n[3].Sprite,$n[3].Material]},{"a":2,"n":"ToAtlasRegion","is":true,"t":8,"pi":[{"n":"t","pt":$n[3].Texture2D,"ps":0},{"n":"materialPropertySource","pt":$n[3].Material,"ps":1},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":2}],"sn":"ToAtlasRegion$2","rt":$n[5].AtlasRegion,"p":[$n[3].Texture2D,$n[3].Material,$n[0].Single]},{"a":2,"n":"ToAtlasRegion","is":true,"t":8,"pi":[{"n":"t","pt":$n[3].Texture2D,"ps":0},{"n":"shader","pt":$n[3].Shader,"ps":1},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":2},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[3].Material,"ps":3}],"sn":"ToAtlasRegion$3","rt":$n[5].AtlasRegion,"p":[$n[3].Texture2D,$n[3].Shader,$n[0].Single,$n[3].Material]},{"a":2,"n":"ToAtlasRegionPMAClone","is":true,"t":8,"pi":[{"n":"s","pt":$n[3].Sprite,"ps":0},{"n":"materialPropertySource","pt":$n[3].Material,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[3].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ToAtlasRegionPMAClone","rt":$n[5].AtlasRegion,"p":[$n[3].Sprite,$n[3].Material,$n[3].TextureFormat,$n[0].Boolean]},{"a":2,"n":"ToAtlasRegionPMAClone","is":true,"t":8,"pi":[{"n":"t","pt":$n[3].Texture2D,"ps":0},{"n":"materialPropertySource","pt":$n[3].Material,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[3].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ToAtlasRegionPMAClone$2","rt":$n[5].AtlasRegion,"p":[$n[3].Texture2D,$n[3].Material,$n[3].TextureFormat,$n[0].Boolean]},{"a":2,"n":"ToAtlasRegionPMAClone","is":true,"t":8,"pi":[{"n":"s","pt":$n[3].Sprite,"ps":0},{"n":"shader","pt":$n[3].Shader,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[3].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[3].Material,"ps":4}],"sn":"ToAtlasRegionPMAClone$1","rt":$n[5].AtlasRegion,"p":[$n[3].Sprite,$n[3].Shader,$n[3].TextureFormat,$n[0].Boolean,$n[3].Material]},{"a":2,"n":"ToAtlasRegionPMAClone","is":true,"t":8,"pi":[{"n":"t","pt":$n[3].Texture2D,"ps":0},{"n":"shader","pt":$n[3].Shader,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[3].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[3].Material,"ps":4}],"sn":"ToAtlasRegionPMAClone$3","rt":$n[5].AtlasRegion,"p":[$n[3].Texture2D,$n[3].Shader,$n[3].TextureFormat,$n[0].Boolean,$n[3].Material]},{"a":2,"n":"ToSpineAtlasPage","is":true,"t":8,"pi":[{"n":"m","pt":$n[3].Material,"ps":0}],"sn":"ToSpineAtlasPage","rt":$n[5].AtlasPage,"p":[$n[3].Material]},{"a":2,"n":"ToSprite","is":true,"t":8,"pi":[{"n":"ar","pt":$n[5].AtlasRegion,"ps":0},{"n":"pixelsPerUnit","dv":100.0,"o":true,"pt":$n[0].Single,"ps":1}],"sn":"ToSprite","rt":$n[3].Sprite,"p":[$n[5].AtlasRegion,$n[0].Single]},{"a":1,"n":"ToTexture","is":true,"t":8,"pi":[{"n":"s","pt":$n[3].Sprite,"ps":0},{"n":"textureFormat","dv":4,"o":true,"pt":$n[3].TextureFormat,"ps":1},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"linear","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"applyPMA","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"ToTexture$1","rt":$n[3].Texture2D,"p":[$n[3].Sprite,$n[3].TextureFormat,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"ToTexture","is":true,"t":8,"pi":[{"n":"ar","pt":$n[5].AtlasRegion,"ps":0},{"n":"textureFormat","dv":4,"o":true,"pt":$n[3].TextureFormat,"ps":1},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"texturePropertyId","dv":0,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"linear","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4},{"n":"applyPMA","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"ToTexture","rt":$n[3].Texture2D,"p":[$n[5].AtlasRegion,$n[3].TextureFormat,$n[0].Boolean,$n[0].Int32,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"UVRectToAtlasRegion","is":true,"t":8,"pi":[{"n":"uvRect","pt":$n[3].Rect,"ps":0},{"n":"referenceRegion","pt":$n[5].AtlasRegion,"ps":1},{"n":"page","pt":$n[5].AtlasPage,"ps":2}],"sn":"UVRectToAtlasRegion","rt":$n[5].AtlasRegion,"p":[$n[3].Rect,$n[5].AtlasRegion,$n[5].AtlasPage]},{"a":1,"n":"UVRectToTextureRect","is":true,"t":8,"pi":[{"n":"uvRect","pt":$n[3].Rect,"ps":0},{"n":"texWidth","pt":$n[0].Int32,"ps":1},{"n":"texHeight","pt":$n[0].Int32,"ps":2}],"sn":"UVRectToTextureRect","rt":$n[3].Rect,"p":[$n[3].Rect,$n[0].Int32,$n[0].Int32]},{"a":1,"n":"CachedRegionTextures","is":true,"t":4,"rt":$n[2].Dictionary$2(Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey,UnityEngine.Texture2D),"sn":"CachedRegionTextures"},{"a":1,"n":"CachedRegionTexturesList","is":true,"t":4,"rt":$n[2].List$1(UnityEngine.Texture2D),"sn":"CachedRegionTexturesList"},{"a":4,"n":"DefaultMipmapBias","is":true,"t":4,"rt":$n[0].Single,"sn":"DefaultMipmapBias","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"DefaultScale","is":true,"t":4,"rt":$n[0].Single,"sn":"DefaultScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"NonrenderingRegion","is":true,"t":4,"rt":$n[0].Int32,"sn":"NonrenderingRegion","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"SpineTextureFormat","is":true,"t":4,"rt":$n[3].TextureFormat,"sn":"SpineTextureFormat","box":function ($v) { return Bridge.box($v, UnityEngine.TextureFormat, System.Enum.toStringFn(UnityEngine.TextureFormat));}},{"a":4,"n":"UseMipMaps","is":true,"t":4,"rt":$n[0].Boolean,"sn":"UseMipMaps","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"existingRegions","is":true,"t":4,"rt":$n[2].Dictionary$2(Spine.AtlasRegion,System.Int32),"sn":"existingRegions","ro":true},{"a":1,"n":"inoutAttachments","is":true,"t":4,"rt":$n[2].List$1(spine.Attachment),"sn":"inoutAttachments"},{"a":1,"n":"originalRegions","is":true,"t":4,"rt":$n[2].List$1(Spine.AtlasRegion),"sn":"originalRegions","ro":true},{"a":1,"n":"regionIndices","is":true,"t":4,"rt":$n[2].List$1(System.Int32),"sn":"regionIndices","ro":true},{"a":1,"n":"repackedRegions","is":true,"t":4,"rt":$n[2].List$1(Spine.AtlasRegion),"sn":"repackedRegions","ro":true},{"a":1,"n":"texturesToPackAtParam","is":true,"t":4,"rt":System.Array.type(System.Collections.Generic.List$1(UnityEngine.Texture2D)),"sn":"texturesToPackAtParam"}]}; }, $n);
    /*Spine.Unity.AttachmentTools.AtlasUtilities end.*/

    /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey start.*/
    $m("Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey", function () { return {"td":$n[9].AtlasUtilities,"att":1048843,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[5].AtlasRegion],"pi":[{"n":"i","pt":$n[0].Int32,"ps":0},{"n":"region","pt":$n[5].AtlasRegion,"ps":1}],"sn":"$ctor1"},{"ov":true,"a":2,"n":"GetHashCode","t":8,"sn":"getHashCode","rt":$n[0].Int32,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"i","t":4,"rt":$n[0].Int32,"sn":"i","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"region","t":4,"rt":$n[5].AtlasRegion,"sn":"region"}]}; }, $n);
    /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey end.*/

    /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions start.*/
    $m("Spine.Unity.AttachmentTools.AttachmentCloneExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"GetRemappedClone","is":true,"t":8,"pi":[{"n":"o","pt":spine.Attachment,"ps":0},{"n":"atlasRegion","pt":$n[5].AtlasRegion,"ps":1},{"n":"cloneMeshAsLinked","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"useOriginalRegionSize","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":4}],"sn":"GetRemappedClone","rt":spine.Attachment,"p":[spine.Attachment,$n[5].AtlasRegion,$n[0].Boolean,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"GetRemappedClone","is":true,"t":8,"pi":[{"n":"o","pt":spine.Attachment,"ps":0},{"n":"sprite","pt":$n[3].Sprite,"ps":1},{"n":"sourceMaterial","pt":$n[3].Material,"ps":2},{"n":"premultiplyAlpha","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"cloneMeshAsLinked","dv":true,"o":true,"pt":$n[0].Boolean,"ps":4},{"n":"useOriginalRegionSize","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5},{"n":"pivotShiftsMeshUVCoords","dv":true,"o":true,"pt":$n[0].Boolean,"ps":6},{"n":"useOriginalRegionScale","dv":false,"o":true,"pt":$n[0].Boolean,"ps":7},{"n":"pmaCloneTextureFormat","dv":4,"o":true,"pt":$n[3].TextureFormat,"ps":8},{"n":"pmaCloneMipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":9}],"sn":"GetRemappedClone$1","rt":spine.Attachment,"p":[spine.Attachment,$n[3].Sprite,$n[3].Material,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean,$n[3].TextureFormat,$n[0].Boolean]}]}; }, $n);
    /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions end.*/

    /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions start.*/
    $m("Spine.Unity.AttachmentTools.AttachmentRegionExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"SetPositionOffset","is":true,"t":8,"pi":[{"n":"regionAttachment","pt":$n[5].RegionAttachment,"ps":0},{"n":"offset","pt":$n[3].Vector2,"ps":1}],"sn":"SetPositionOffset$1","rt":$n[0].Void,"p":[$n[5].RegionAttachment,$n[3].Vector2]},{"a":2,"n":"SetPositionOffset","is":true,"t":8,"pi":[{"n":"regionAttachment","pt":$n[5].RegionAttachment,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1},{"n":"y","pt":$n[0].Single,"ps":2}],"sn":"SetPositionOffset","rt":$n[0].Void,"p":[$n[5].RegionAttachment,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetRotation","is":true,"t":8,"pi":[{"n":"regionAttachment","pt":$n[5].RegionAttachment,"ps":0},{"n":"rotation","pt":$n[0].Single,"ps":1}],"sn":"SetRotation","rt":$n[0].Void,"p":[$n[5].RegionAttachment,$n[0].Single]},{"a":2,"n":"SetScale","is":true,"t":8,"pi":[{"n":"regionAttachment","pt":$n[5].RegionAttachment,"ps":0},{"n":"scale","pt":$n[3].Vector2,"ps":1}],"sn":"SetScale$1","rt":$n[0].Void,"p":[$n[5].RegionAttachment,$n[3].Vector2]},{"a":2,"n":"SetScale","is":true,"t":8,"pi":[{"n":"regionAttachment","pt":$n[5].RegionAttachment,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1},{"n":"y","pt":$n[0].Single,"ps":2}],"sn":"SetScale","rt":$n[0].Void,"p":[$n[5].RegionAttachment,$n[0].Single,$n[0].Single]},{"a":2,"n":"ToRegionAttachment","is":true,"t":8,"pi":[{"n":"sprite","pt":$n[3].Sprite,"ps":0},{"n":"page","pt":$n[5].AtlasPage,"ps":1},{"n":"rotation","dv":0.0,"o":true,"pt":$n[0].Single,"ps":2}],"sn":"ToRegionAttachment$1","rt":$n[5].RegionAttachment,"p":[$n[3].Sprite,$n[5].AtlasPage,$n[0].Single]},{"a":2,"n":"ToRegionAttachment","is":true,"t":8,"pi":[{"n":"sprite","pt":$n[3].Sprite,"ps":0},{"n":"material","pt":$n[3].Material,"ps":1},{"n":"rotation","dv":0.0,"o":true,"pt":$n[0].Single,"ps":2}],"sn":"ToRegionAttachment$2","rt":$n[5].RegionAttachment,"p":[$n[3].Sprite,$n[3].Material,$n[0].Single]},{"a":2,"n":"ToRegionAttachment","is":true,"t":8,"pi":[{"n":"region","pt":$n[5].AtlasRegion,"ps":0},{"n":"attachmentName","pt":$n[0].String,"ps":1},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":2},{"n":"rotation","dv":0.0,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"ToRegionAttachment","rt":$n[5].RegionAttachment,"p":[$n[5].AtlasRegion,$n[0].String,$n[0].Single,$n[0].Single]},{"a":2,"n":"ToRegionAttachmentPMAClone","is":true,"t":8,"pi":[{"n":"sprite","pt":$n[3].Sprite,"ps":0},{"n":"materialPropertySource","pt":$n[3].Material,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[3].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"rotation","dv":0.0,"o":true,"pt":$n[0].Single,"ps":4}],"sn":"ToRegionAttachmentPMAClone","rt":$n[5].RegionAttachment,"p":[$n[3].Sprite,$n[3].Material,$n[3].TextureFormat,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"ToRegionAttachmentPMAClone","is":true,"t":8,"pi":[{"n":"sprite","pt":$n[3].Sprite,"ps":0},{"n":"shader","pt":$n[3].Shader,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[3].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[3].Material,"ps":4},{"n":"rotation","dv":0.0,"o":true,"pt":$n[0].Single,"ps":5}],"sn":"ToRegionAttachmentPMAClone$1","rt":$n[5].RegionAttachment,"p":[$n[3].Sprite,$n[3].Shader,$n[3].TextureFormat,$n[0].Boolean,$n[3].Material,$n[0].Single]}]}; }, $n);
    /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions end.*/

    /*Spine.Unity.Prototyping.SkeletonColorInitialize start.*/
    $m("Spine.Unity.Prototyping.SkeletonColorInitialize", function () { return {"nested":[$n[10].SkeletonColorInitialize.SlotSettings],"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"ApplySettings","t":8,"sn":"ApplySettings","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"skeletonColor","t":4,"rt":$n[3].Color,"sn":"skeletonColor"},{"a":2,"n":"slotSettings","t":4,"rt":$n[2].List$1(Spine.Unity.Prototyping.SkeletonColorInitialize.SlotSettings),"sn":"slotSettings"}]}; }, $n);
    /*Spine.Unity.Prototyping.SkeletonColorInitialize end.*/

    /*Spine.Unity.Prototyping.SkeletonColorInitialize+SlotSettings start.*/
    $m("Spine.Unity.Prototyping.SkeletonColorInitialize.SlotSettings", function () { return {"td":$n[10].SkeletonColorInitialize,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"color","t":4,"rt":$n[3].Color,"sn":"color"},{"at":[new Spine.Unity.SpineSlot("", "", false, true, false)],"a":2,"n":"slot","t":4,"rt":$n[0].String,"sn":"slot"}]}; }, $n);
    /*Spine.Unity.Prototyping.SkeletonColorInitialize+SlotSettings end.*/

    /*Spine.Unity.Prototyping.SpineEventUnityHandler start.*/
    $m("Spine.Unity.Prototyping.SpineEventUnityHandler", function () { return {"nested":[$n[10].SpineEventUnityHandler.EventPair],"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"animationStateComponent","t":4,"rt":$n[1].IAnimationStateComponent,"sn":"animationStateComponent"},{"a":2,"n":"events","t":4,"rt":$n[2].List$1(Spine.Unity.Prototyping.SpineEventUnityHandler.EventPair),"sn":"events"},{"a":1,"n":"skeletonComponent","t":4,"rt":$n[1].ISkeletonComponent,"sn":"skeletonComponent"}]}; }, $n);
    /*Spine.Unity.Prototyping.SpineEventUnityHandler end.*/

    /*Spine.Unity.Prototyping.SpineEventUnityHandler+EventPair start.*/
    $m("Spine.Unity.Prototyping.SpineEventUnityHandler.EventPair", function () { return {"td":$n[10].SpineEventUnityHandler,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"eventDelegate","t":4,"rt":Function,"sn":"eventDelegate"},{"at":[new Spine.Unity.SpineEvent("", "", true, false, false)],"a":2,"n":"spineEvent","t":4,"rt":$n[0].String,"sn":"spineEvent"},{"a":2,"n":"unityHandler","t":4,"rt":$n[11].UnityEvent,"sn":"unityHandler"}]}; }, $n);
    /*Spine.Unity.Prototyping.SpineEventUnityHandler+EventPair end.*/

    /*Spine.Unity.Examples.SpineAnimationTesterTool start.*/
    $m("Spine.Unity.Examples.SpineAnimationTesterTool", function () { return {"nested":[$n[12].SpineAnimationTesterTool.AnimationControl,$n[12].SpineAnimationTesterTool.ControlledTrack],"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnValidate","t":8,"sn":"OnValidate","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"SkeletonComponent","t":16,"rt":$n[1].ISkeletonComponent,"g":{"a":2,"n":"get_SkeletonComponent","t":8,"rt":$n[1].ISkeletonComponent,"fg":"SkeletonComponent"},"fn":"SkeletonComponent"},{"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[1].SkeletonDataAsset,"g":{"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[1].SkeletonDataAsset,"fg":"SkeletonDataAsset"},"fn":"SkeletonDataAsset"},{"at":[new UnityEngine.RangeAttribute(0.0, 1.0)],"a":2,"n":"attachmentThreshold","t":4,"rt":$n[0].Single,"sn":"attachmentThreshold","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.HeaderAttribute("UI")],"a":2,"n":"boundAnimationsText","t":4,"rt":$n[7].Text,"sn":"boundAnimationsText"},{"at":[new UnityEngine.RangeAttribute(0.0, 1.0)],"a":2,"n":"drawOrderThreshold","t":4,"rt":$n[0].Single,"sn":"drawOrderThreshold","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"overrideMixDuration","t":4,"rt":$n[0].Single,"sn":"overrideMixDuration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"skeletonAnimation","t":4,"rt":$n[1].SkeletonAnimation,"sn":"skeletonAnimation"},{"a":2,"n":"skeletonNameText","t":4,"rt":$n[7].Text,"sn":"skeletonNameText"},{"at":[new UnityEngine.SpaceAttribute.ctor()],"a":2,"n":"trackControls","t":4,"rt":$n[2].List$1(Spine.Unity.Examples.SpineAnimationTesterTool.ControlledTrack),"sn":"trackControls"},{"a":2,"n":"useOverrideAttachmentThreshold","t":4,"rt":$n[0].Boolean,"sn":"useOverrideAttachmentThreshold","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"useOverrideDrawOrderThreshold","t":4,"rt":$n[0].Boolean,"sn":"useOverrideDrawOrderThreshold","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"useOverrideMixDuration","t":4,"rt":$n[0].Boolean,"sn":"useOverrideMixDuration","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.Examples.SpineAnimationTesterTool end.*/

    /*Spine.Unity.Examples.SpineAnimationTesterTool+AnimationControl start.*/
    $m("Spine.Unity.Examples.SpineAnimationTesterTool.AnimationControl", function () { return {"td":$n[12].SpineAnimationTesterTool,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"at":[new Spine.Unity.SpineAnimation("", "", true, false)],"a":2,"n":"animationName","t":4,"rt":$n[0].String,"sn":"animationName"},{"a":2,"n":"key","t":4,"rt":$n[3].KeyCode,"sn":"key","box":function ($v) { return Bridge.box($v, UnityEngine.KeyCode, System.Enum.toStringFn(UnityEngine.KeyCode));}},{"a":2,"n":"loop","t":4,"rt":$n[0].Boolean,"sn":"loop","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"mixDuration","t":4,"rt":$n[0].Single,"sn":"mixDuration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SpaceAttribute.ctor()],"a":2,"n":"useCustomMixDuration","t":4,"rt":$n[0].Boolean,"sn":"useCustomMixDuration","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.Examples.SpineAnimationTesterTool+AnimationControl end.*/

    /*Spine.Unity.Examples.SpineAnimationTesterTool+ControlledTrack start.*/
    $m("Spine.Unity.Examples.SpineAnimationTesterTool.ControlledTrack", function () { return {"td":$n[12].SpineAnimationTesterTool,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"controls","t":4,"rt":$n[2].List$1(Spine.Unity.Examples.SpineAnimationTesterTool.AnimationControl),"sn":"controls"}]}; }, $n);
    /*Spine.Unity.Examples.SpineAnimationTesterTool+ControlledTrack end.*/

    /*Spine.Unity.Examples.AttackSpineboy start.*/
    $m("Spine.Unity.Examples.AttackSpineboy", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"attackerSpineboy","t":4,"rt":$n[1].SkeletonAnimation,"sn":"attackerSpineboy"},{"a":1,"n":"currentHealth","t":4,"rt":$n[0].Int32,"sn":"currentHealth","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"death","t":4,"rt":$n[1].AnimationReferenceAsset,"sn":"death"},{"a":2,"n":"gauge","t":4,"rt":$n[12].SpineGauge,"sn":"gauge"},{"a":2,"n":"healthText","t":4,"rt":$n[7].Text,"sn":"healthText"},{"a":2,"n":"hit","t":4,"rt":$n[1].AnimationReferenceAsset,"sn":"hit"},{"a":2,"n":"idle","t":4,"rt":$n[1].AnimationReferenceAsset,"sn":"idle"},{"a":1,"n":"maxHealth","is":true,"t":4,"rt":$n[0].Int32,"sn":"maxHealth","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"onAttack","t":4,"rt":$n[11].UnityEvent,"sn":"onAttack"},{"a":2,"n":"shoot","t":4,"rt":$n[1].AnimationReferenceAsset,"sn":"shoot"},{"a":2,"n":"spineboy","t":4,"rt":$n[1].SkeletonAnimation,"sn":"spineboy"}]}; }, $n);
    /*Spine.Unity.Examples.AttackSpineboy end.*/

    /*Spine.Unity.Examples.FootSoldierExample start.*/
    $m("Spine.Unity.Examples.FootSoldierExample", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Apply","t":8,"pi":[{"n":"skeletonRenderer","pt":$n[1].SkeletonRenderer,"ps":0}],"sn":"Apply","rt":$n[0].Void,"p":[$n[1].SkeletonRenderer]},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"Blink","t":8,"sn":"Blink","rt":$n[4].IEnumerator},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"at":[new Spine.Unity.SpineAnimation("", "", true, false)],"a":2,"n":"attackAnimation","t":4,"rt":$n[0].String,"sn":"attackAnimation"},{"a":2,"n":"attackKey","t":4,"rt":$n[3].KeyCode,"sn":"attackKey","box":function ($v) { return Bridge.box($v, UnityEngine.KeyCode, System.Enum.toStringFn(UnityEngine.KeyCode));}},{"at":[new Spine.Unity.SpineAttachment(true, false, false, "eyesSlot", "", "", true, false)],"a":2,"n":"blinkAttachment","t":4,"rt":$n[0].String,"sn":"blinkAttachment"},{"at":[new UnityEngine.RangeAttribute(0.0, 0.2)],"a":2,"n":"blinkDuration","t":4,"rt":$n[0].Single,"sn":"blinkDuration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new Spine.Unity.SpineAttachment(true, false, false, "eyesSlot", "", "", true, false)],"a":2,"n":"eyesOpenAttachment","t":4,"rt":$n[0].String,"sn":"eyesOpenAttachment"},{"at":[new Spine.Unity.SpineSlot("", "", false, true, false)],"a":2,"n":"eyesSlot","t":4,"rt":$n[0].String,"sn":"eyesSlot"},{"at":[new Spine.Unity.SpineAnimation("Idle", "", true, false)],"a":2,"n":"idleAnimation","t":4,"rt":$n[0].String,"sn":"idleAnimation"},{"a":2,"n":"leftKey","t":4,"rt":$n[3].KeyCode,"sn":"leftKey","box":function ($v) { return Bridge.box($v, UnityEngine.KeyCode, System.Enum.toStringFn(UnityEngine.KeyCode));}},{"at":[new Spine.Unity.SpineAnimation("", "", true, false)],"a":2,"n":"moveAnimation","t":4,"rt":$n[0].String,"sn":"moveAnimation"},{"a":2,"n":"moveSpeed","t":4,"rt":$n[0].Single,"sn":"moveSpeed","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"rightKey","t":4,"rt":$n[3].KeyCode,"sn":"rightKey","box":function ($v) { return Bridge.box($v, UnityEngine.KeyCode, System.Enum.toStringFn(UnityEngine.KeyCode));}},{"a":1,"n":"skeletonAnimation","t":4,"rt":$n[1].SkeletonAnimation,"sn":"skeletonAnimation"}]}; }, $n);
    /*Spine.Unity.Examples.FootSoldierExample end.*/

    /*Spine.Unity.Examples.BasicPlatformerController start.*/
    $m("Spine.Unity.Examples.BasicPlatformerController", function () { return {"nested":[$n[12].BasicPlatformerController.CharacterState],"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.CharacterController)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"HandleStateChanged","t":8,"sn":"HandleStateChanged","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"JumpButton","t":4,"rt":$n[0].String,"sn":"JumpButton"},{"at":[new UnityEngine.HeaderAttribute("Controls")],"a":2,"n":"XAxis","t":4,"rt":$n[0].String,"sn":"XAxis"},{"a":2,"n":"YAxis","t":4,"rt":$n[0].String,"sn":"YAxis"},{"at":[new UnityEngine.HeaderAttribute("Animation")],"a":2,"n":"animationHandle","t":4,"rt":$n[12].SkeletonAnimationHandleExample,"sn":"animationHandle"},{"at":[new UnityEngine.HeaderAttribute("Components")],"a":2,"n":"controller","t":4,"rt":$n[3].CharacterController,"sn":"controller"},{"a":1,"n":"currentState","t":4,"rt":$n[12].BasicPlatformerController.CharacterState,"sn":"currentState","box":function ($v) { return Bridge.box($v, Spine.Unity.Examples.BasicPlatformerController.CharacterState, System.Enum.toStringFn(Spine.Unity.Examples.BasicPlatformerController.CharacterState));}},{"a":2,"n":"forceCrouchDuration","t":4,"rt":$n[0].Single,"sn":"forceCrouchDuration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"forceCrouchEndTime","t":4,"rt":$n[0].Single,"sn":"forceCrouchEndTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"forceCrouchVelocity","t":4,"rt":$n[0].Single,"sn":"forceCrouchVelocity","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"gravityScale","t":4,"rt":$n[0].Single,"sn":"gravityScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"input","t":4,"rt":$n[3].Vector2,"sn":"input"},{"a":2,"n":"jumpInterruptFactor","t":4,"rt":$n[0].Single,"sn":"jumpInterruptFactor","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.HeaderAttribute("Jumping")],"a":2,"n":"jumpSpeed","t":4,"rt":$n[0].Single,"sn":"jumpSpeed","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"minimumJumpDuration","t":4,"rt":$n[0].Single,"sn":"minimumJumpDuration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"minimumJumpEndTime","t":4,"rt":$n[0].Single,"sn":"minimumJumpEndTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"previousState","t":4,"rt":$n[12].BasicPlatformerController.CharacterState,"sn":"previousState","box":function ($v) { return Bridge.box($v, Spine.Unity.Examples.BasicPlatformerController.CharacterState, System.Enum.toStringFn(Spine.Unity.Examples.BasicPlatformerController.CharacterState));}},{"a":2,"n":"runSpeed","t":4,"rt":$n[0].Single,"sn":"runSpeed","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"velocity","t":4,"rt":$n[3].Vector3,"sn":"velocity"},{"at":[new UnityEngine.HeaderAttribute("Moving")],"a":2,"n":"walkSpeed","t":4,"rt":$n[0].Single,"sn":"walkSpeed","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"wasGrounded","t":4,"rt":$n[0].Boolean,"sn":"wasGrounded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"OnHardLand","t":2,"ad":{"a":2,"n":"add_OnHardLand","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnHardLand","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnHardLand","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnHardLand","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnJump","t":2,"ad":{"a":2,"n":"add_OnJump","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnJump","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnJump","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnJump","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnLand","t":2,"ad":{"a":2,"n":"add_OnLand","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnLand","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnLand","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnLand","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.Examples.BasicPlatformerController end.*/

    /*Spine.Unity.Examples.BasicPlatformerController+CharacterState start.*/
    $m("Spine.Unity.Examples.BasicPlatformerController.CharacterState", function () { return {"td":$n[12].BasicPlatformerController,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Attack","is":true,"t":4,"rt":$n[12].BasicPlatformerController.CharacterState,"sn":"Attack","box":function ($v) { return Bridge.box($v, Spine.Unity.Examples.BasicPlatformerController.CharacterState, System.Enum.toStringFn(Spine.Unity.Examples.BasicPlatformerController.CharacterState));}},{"a":2,"n":"Crouch","is":true,"t":4,"rt":$n[12].BasicPlatformerController.CharacterState,"sn":"Crouch","box":function ($v) { return Bridge.box($v, Spine.Unity.Examples.BasicPlatformerController.CharacterState, System.Enum.toStringFn(Spine.Unity.Examples.BasicPlatformerController.CharacterState));}},{"a":2,"n":"Fall","is":true,"t":4,"rt":$n[12].BasicPlatformerController.CharacterState,"sn":"Fall","box":function ($v) { return Bridge.box($v, Spine.Unity.Examples.BasicPlatformerController.CharacterState, System.Enum.toStringFn(Spine.Unity.Examples.BasicPlatformerController.CharacterState));}},{"a":2,"n":"Idle","is":true,"t":4,"rt":$n[12].BasicPlatformerController.CharacterState,"sn":"Idle","box":function ($v) { return Bridge.box($v, Spine.Unity.Examples.BasicPlatformerController.CharacterState, System.Enum.toStringFn(Spine.Unity.Examples.BasicPlatformerController.CharacterState));}},{"a":2,"n":"None","is":true,"t":4,"rt":$n[12].BasicPlatformerController.CharacterState,"sn":"None","box":function ($v) { return Bridge.box($v, Spine.Unity.Examples.BasicPlatformerController.CharacterState, System.Enum.toStringFn(Spine.Unity.Examples.BasicPlatformerController.CharacterState));}},{"a":2,"n":"Rise","is":true,"t":4,"rt":$n[12].BasicPlatformerController.CharacterState,"sn":"Rise","box":function ($v) { return Bridge.box($v, Spine.Unity.Examples.BasicPlatformerController.CharacterState, System.Enum.toStringFn(Spine.Unity.Examples.BasicPlatformerController.CharacterState));}},{"a":2,"n":"Run","is":true,"t":4,"rt":$n[12].BasicPlatformerController.CharacterState,"sn":"Run","box":function ($v) { return Bridge.box($v, Spine.Unity.Examples.BasicPlatformerController.CharacterState, System.Enum.toStringFn(Spine.Unity.Examples.BasicPlatformerController.CharacterState));}},{"a":2,"n":"Walk","is":true,"t":4,"rt":$n[12].BasicPlatformerController.CharacterState,"sn":"Walk","box":function ($v) { return Bridge.box($v, Spine.Unity.Examples.BasicPlatformerController.CharacterState, System.Enum.toStringFn(Spine.Unity.Examples.BasicPlatformerController.CharacterState));}}]}; }, $n);
    /*Spine.Unity.Examples.BasicPlatformerController+CharacterState end.*/

    /*Spine.Unity.Examples.Raptor start.*/
    $m("Spine.Unity.Examples.Raptor", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"GunGrabRoutine","t":8,"sn":"GunGrabRoutine","rt":$n[4].IEnumerator},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"gungrab","t":4,"rt":$n[1].AnimationReferenceAsset,"sn":"gungrab"},{"a":2,"n":"gunkeep","t":4,"rt":$n[1].AnimationReferenceAsset,"sn":"gunkeep"},{"a":1,"n":"skeletonAnimation","t":4,"rt":$n[1].SkeletonAnimation,"sn":"skeletonAnimation"},{"a":2,"n":"walk","t":4,"rt":$n[1].AnimationReferenceAsset,"sn":"walk"}]}; }, $n);
    /*Spine.Unity.Examples.Raptor end.*/

    /*Spine.Unity.Examples.SpineBeginnerTwo start.*/
    $m("Spine.Unity.Examples.SpineBeginnerTwo", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"DoDemoRoutine","t":8,"sn":"DoDemoRoutine","rt":$n[4].IEnumerator},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"at":[new Spine.Unity.SpineAnimation("", "", true, false)],"a":2,"n":"idleAnimationName","t":4,"rt":$n[0].String,"sn":"idleAnimationName"},{"at":[new UnityEngine.HeaderAttribute("Transitions"),new Spine.Unity.SpineAnimation("", "", true, false)],"a":2,"n":"idleTurnAnimationName","t":4,"rt":$n[0].String,"sn":"idleTurnAnimationName"},{"at":[new Spine.Unity.SpineAnimation("", "", true, false)],"a":2,"n":"runAnimationName","t":4,"rt":$n[0].String,"sn":"runAnimationName"},{"at":[new Spine.Unity.SpineAnimation("", "", true, false)],"a":2,"n":"runToIdleAnimationName","t":4,"rt":$n[0].String,"sn":"runToIdleAnimationName"},{"a":2,"n":"runWalkDuration","t":4,"rt":$n[0].Single,"sn":"runWalkDuration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new Spine.Unity.SpineAnimation("", "", true, false)],"a":2,"n":"shootAnimationName","t":4,"rt":$n[0].String,"sn":"shootAnimationName"},{"a":2,"n":"skeleton","t":4,"rt":$n[5].Skeleton,"sn":"skeleton"},{"a":1,"n":"skeletonAnimation","t":4,"rt":$n[1].SkeletonAnimation,"sn":"skeletonAnimation"},{"a":2,"n":"spineAnimationState","t":4,"rt":$n[5].AnimationState,"sn":"spineAnimationState"},{"at":[new Spine.Unity.SpineAnimation("", "", true, false)],"a":2,"n":"walkAnimationName","t":4,"rt":$n[0].String,"sn":"walkAnimationName"}]}; }, $n);
    /*Spine.Unity.Examples.SpineBeginnerTwo end.*/

    /*Spine.Unity.Examples.SpineBlinkPlayer start.*/
    $m("Spine.Unity.Examples.SpineBlinkPlayer", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[4].IEnumerator},{"a":1,"n":"BlinkTrack","is":true,"t":4,"rt":$n[0].Int32,"sn":"BlinkTrack","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"blinkAnimation","t":4,"rt":$n[1].AnimationReferenceAsset,"sn":"blinkAnimation"},{"a":2,"n":"maximumDelay","t":4,"rt":$n[0].Single,"sn":"maximumDelay","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"minimumDelay","t":4,"rt":$n[0].Single,"sn":"minimumDelay","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Unity.Examples.SpineBlinkPlayer end.*/

    /*Spine.Unity.Examples.SpineboyBeginnerInput start.*/
    $m("Spine.Unity.Examples.SpineboyBeginnerInput", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnValidate","t":8,"sn":"OnValidate","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"aimButton","t":4,"rt":$n[0].String,"sn":"aimButton"},{"a":2,"n":"attackButton","t":4,"rt":$n[0].String,"sn":"attackButton"},{"a":2,"n":"horizontalAxis","t":4,"rt":$n[0].String,"sn":"horizontalAxis"},{"a":2,"n":"jumpButton","t":4,"rt":$n[0].String,"sn":"jumpButton"},{"a":2,"n":"model","t":4,"rt":$n[12].SpineboyBeginnerModel,"sn":"model"}]}; }, $n);
    /*Spine.Unity.Examples.SpineboyBeginnerInput end.*/

    /*Spine.Unity.Examples.SpineboyBeginnerModel start.*/
    $m("Spine.Unity.Examples.SpineboyBeginnerModel", function () { return {"att":1048577,"a":2,"at":[new SelectionBase()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"JumpRoutine","t":8,"sn":"JumpRoutine","rt":$n[4].IEnumerator},{"a":2,"n":"StartAim","t":8,"sn":"StartAim","rt":$n[0].Void},{"a":2,"n":"StopAim","t":8,"sn":"StopAim","rt":$n[0].Void},{"a":2,"n":"TryJump","t":8,"sn":"TryJump","rt":$n[0].Void},{"a":2,"n":"TryMove","t":8,"pi":[{"n":"speed","pt":$n[0].Single,"ps":0}],"sn":"TryMove","rt":$n[0].Void,"p":[$n[0].Single]},{"a":2,"n":"TryShoot","t":8,"sn":"TryShoot","rt":$n[0].Void},{"at":[new UnityEngine.RangeAttribute(-1.0, 1.0)],"a":2,"n":"currentSpeed","t":4,"rt":$n[0].Single,"sn":"currentSpeed","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"facingLeft","t":4,"rt":$n[0].Boolean,"sn":"facingLeft","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"lastShootTime","t":4,"rt":$n[0].Single,"sn":"lastShootTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.HeaderAttribute("Balance")],"a":2,"n":"shootInterval","t":4,"rt":$n[0].Single,"sn":"shootInterval","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.HeaderAttribute("Current State")],"a":2,"n":"state","t":4,"rt":$n[12].SpineBeginnerBodyState,"sn":"state","box":function ($v) { return Bridge.box($v, Spine.Unity.Examples.SpineBeginnerBodyState, System.Enum.toStringFn(Spine.Unity.Examples.SpineBeginnerBodyState));}},{"a":2,"n":"ShootEvent","t":2,"ad":{"a":2,"n":"add_ShootEvent","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addShootEvent","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_ShootEvent","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeShootEvent","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"StartAimEvent","t":2,"ad":{"a":2,"n":"add_StartAimEvent","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addStartAimEvent","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_StartAimEvent","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeStartAimEvent","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"StopAimEvent","t":2,"ad":{"a":2,"n":"add_StopAimEvent","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addStopAimEvent","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_StopAimEvent","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeStopAimEvent","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.Examples.SpineboyBeginnerModel end.*/

    /*Spine.Unity.Examples.SpineBeginnerBodyState start.*/
    $m("Spine.Unity.Examples.SpineBeginnerBodyState", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Idle","is":true,"t":4,"rt":$n[12].SpineBeginnerBodyState,"sn":"Idle","box":function ($v) { return Bridge.box($v, Spine.Unity.Examples.SpineBeginnerBodyState, System.Enum.toStringFn(Spine.Unity.Examples.SpineBeginnerBodyState));}},{"a":2,"n":"Jumping","is":true,"t":4,"rt":$n[12].SpineBeginnerBodyState,"sn":"Jumping","box":function ($v) { return Bridge.box($v, Spine.Unity.Examples.SpineBeginnerBodyState, System.Enum.toStringFn(Spine.Unity.Examples.SpineBeginnerBodyState));}},{"a":2,"n":"Running","is":true,"t":4,"rt":$n[12].SpineBeginnerBodyState,"sn":"Running","box":function ($v) { return Bridge.box($v, Spine.Unity.Examples.SpineBeginnerBodyState, System.Enum.toStringFn(Spine.Unity.Examples.SpineBeginnerBodyState));}}]}; }, $n);
    /*Spine.Unity.Examples.SpineBeginnerBodyState end.*/

    /*Spine.Unity.Examples.SpineboyBeginnerView start.*/
    $m("Spine.Unity.Examples.SpineboyBeginnerView", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"at":[new UnityEngine.ContextMenu.ctor("Check Tracks")],"a":1,"n":"CheckTracks","t":8,"sn":"CheckTracks","rt":$n[0].Void},{"a":2,"n":"GetRandomPitch","t":8,"pi":[{"n":"maxPitchOffset","pt":$n[0].Single,"ps":0}],"sn":"GetRandomPitch","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"HandleEvent","t":8,"pi":[{"n":"trackEntry","pt":$n[5].TrackEntry,"ps":0},{"n":"e","pt":spine.Event,"ps":1}],"sn":"HandleEvent","rt":$n[0].Void,"p":[$n[5].TrackEntry,spine.Event]},{"a":1,"n":"PlayFootstepSound","t":8,"sn":"PlayFootstepSound","rt":$n[0].Void},{"a":1,"n":"PlayNewStableAnimation","t":8,"sn":"PlayNewStableAnimation","rt":$n[0].Void},{"a":2,"n":"PlayShoot","t":8,"sn":"PlayShoot","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"StartPlayingAim","t":8,"sn":"StartPlayingAim","rt":$n[0].Void},{"a":2,"n":"StopPlayingAim","t":8,"sn":"StopPlayingAim","rt":$n[0].Void},{"a":2,"n":"Turn","t":8,"pi":[{"n":"facingLeft","pt":$n[0].Boolean,"ps":0}],"sn":"Turn","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"aim","t":4,"rt":$n[1].AnimationReferenceAsset,"sn":"aim"},{"a":2,"n":"footstepEvent","t":4,"rt":$n[1].EventDataReferenceAsset,"sn":"footstepEvent"},{"at":[new UnityEngine.HeaderAttribute("Audio")],"a":2,"n":"footstepPitchOffset","t":4,"rt":$n[0].Single,"sn":"footstepPitchOffset","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"footstepSource","t":4,"rt":$n[3].AudioSource,"sn":"footstepSource"},{"at":[new UnityEngine.HeaderAttribute("Effects")],"a":2,"n":"gunParticles","t":4,"rt":$n[3].ParticleSystem,"sn":"gunParticles"},{"a":2,"n":"gunSource","t":4,"rt":$n[3].AudioSource,"sn":"gunSource"},{"a":2,"n":"gunsoundPitchOffset","t":4,"rt":$n[0].Single,"sn":"gunsoundPitchOffset","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"idle","t":4,"rt":$n[1].AnimationReferenceAsset,"sn":"idle"},{"a":2,"n":"jump","t":4,"rt":$n[1].AnimationReferenceAsset,"sn":"jump"},{"a":2,"n":"jumpSource","t":4,"rt":$n[3].AudioSource,"sn":"jumpSource"},{"at":[new UnityEngine.HeaderAttribute("Components")],"a":2,"n":"model","t":4,"rt":$n[12].SpineboyBeginnerModel,"sn":"model"},{"a":1,"n":"previousViewState","t":4,"rt":$n[12].SpineBeginnerBodyState,"sn":"previousViewState","box":function ($v) { return Bridge.box($v, Spine.Unity.Examples.SpineBeginnerBodyState, System.Enum.toStringFn(Spine.Unity.Examples.SpineBeginnerBodyState));}},{"a":2,"n":"run","t":4,"rt":$n[1].AnimationReferenceAsset,"sn":"run"},{"a":2,"n":"shoot","t":4,"rt":$n[1].AnimationReferenceAsset,"sn":"shoot"},{"a":2,"n":"skeletonAnimation","t":4,"rt":$n[1].SkeletonAnimation,"sn":"skeletonAnimation"}]}; }, $n);
    /*Spine.Unity.Examples.SpineboyBeginnerView end.*/

    /*Spine.Unity.Examples.SpineboyBeginnerViewGraphic start.*/
    $m("Spine.Unity.Examples.SpineboyBeginnerViewGraphic", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"at":[new UnityEngine.ContextMenu.ctor("Check Tracks")],"a":1,"n":"CheckTracks","t":8,"sn":"CheckTracks","rt":$n[0].Void},{"a":2,"n":"GetRandomPitch","t":8,"pi":[{"n":"maxPitchOffset","pt":$n[0].Single,"ps":0}],"sn":"GetRandomPitch","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"HandleEvent","t":8,"pi":[{"n":"trackEntry","pt":$n[5].TrackEntry,"ps":0},{"n":"e","pt":spine.Event,"ps":1}],"sn":"HandleEvent","rt":$n[0].Void,"p":[$n[5].TrackEntry,spine.Event]},{"a":1,"n":"PlayFootstepSound","t":8,"sn":"PlayFootstepSound","rt":$n[0].Void},{"a":1,"n":"PlayNewStableAnimation","t":8,"sn":"PlayNewStableAnimation","rt":$n[0].Void},{"a":2,"n":"PlayShoot","t":8,"sn":"PlayShoot","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"StartPlayingAim","t":8,"sn":"StartPlayingAim","rt":$n[0].Void},{"a":2,"n":"StopPlayingAim","t":8,"sn":"StopPlayingAim","rt":$n[0].Void},{"a":2,"n":"Turn","t":8,"pi":[{"n":"facingLeft","pt":$n[0].Boolean,"ps":0}],"sn":"Turn","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"aim","t":4,"rt":$n[1].AnimationReferenceAsset,"sn":"aim"},{"a":2,"n":"footstepEvent","t":4,"rt":$n[1].EventDataReferenceAsset,"sn":"footstepEvent"},{"at":[new UnityEngine.HeaderAttribute("Audio")],"a":2,"n":"footstepPitchOffset","t":4,"rt":$n[0].Single,"sn":"footstepPitchOffset","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"footstepSource","t":4,"rt":$n[3].AudioSource,"sn":"footstepSource"},{"at":[new UnityEngine.HeaderAttribute("Effects")],"a":2,"n":"gunParticles","t":4,"rt":$n[3].ParticleSystem,"sn":"gunParticles"},{"a":2,"n":"gunSource","t":4,"rt":$n[3].AudioSource,"sn":"gunSource"},{"a":2,"n":"gunsoundPitchOffset","t":4,"rt":$n[0].Single,"sn":"gunsoundPitchOffset","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"idle","t":4,"rt":$n[1].AnimationReferenceAsset,"sn":"idle"},{"a":2,"n":"jump","t":4,"rt":$n[1].AnimationReferenceAsset,"sn":"jump"},{"a":2,"n":"jumpSource","t":4,"rt":$n[3].AudioSource,"sn":"jumpSource"},{"at":[new UnityEngine.HeaderAttribute("Components")],"a":2,"n":"model","t":4,"rt":$n[12].SpineboyBeginnerModel,"sn":"model"},{"a":1,"n":"previousViewState","t":4,"rt":$n[12].SpineBeginnerBodyState,"sn":"previousViewState","box":function ($v) { return Bridge.box($v, Spine.Unity.Examples.SpineBeginnerBodyState, System.Enum.toStringFn(Spine.Unity.Examples.SpineBeginnerBodyState));}},{"a":2,"n":"run","t":4,"rt":$n[1].AnimationReferenceAsset,"sn":"run"},{"a":2,"n":"shoot","t":4,"rt":$n[1].AnimationReferenceAsset,"sn":"shoot"},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[1].SkeletonGraphic,"sn":"skeletonGraphic"}]}; }, $n);
    /*Spine.Unity.Examples.SpineboyBeginnerViewGraphic end.*/

    /*Spine.Unity.Examples.SpineboyTargetController start.*/
    $m("Spine.Unity.Examples.SpineboyTargetController", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnValidate","t":8,"sn":"OnValidate","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":1,"n":"bone","t":4,"rt":$n[5].Bone,"sn":"bone"},{"at":[new Spine.Unity.SpineBone("", "skeletonAnimation", true, false)],"a":2,"n":"boneName","t":4,"rt":$n[0].String,"sn":"boneName"},{"a":2,"n":"cam","t":4,"rt":$n[3].Camera,"sn":"cam"},{"a":2,"n":"skeletonAnimation","t":4,"rt":$n[1].SkeletonAnimation,"sn":"skeletonAnimation"}]}; }, $n);
    /*Spine.Unity.Examples.SpineboyTargetController end.*/

    /*Spine.Unity.Examples.SpineboyTargetControllerGraphic start.*/
    $m("Spine.Unity.Examples.SpineboyTargetControllerGraphic", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnValidate","t":8,"sn":"OnValidate","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":1,"n":"bone","t":4,"rt":$n[5].Bone,"sn":"bone"},{"at":[new Spine.Unity.SpineBone("", "skeletonGraphic", true, false)],"a":2,"n":"boneName","t":4,"rt":$n[0].String,"sn":"boneName"},{"a":2,"n":"cam","t":4,"rt":$n[3].Camera,"sn":"cam"},{"a":2,"n":"canvas","t":4,"rt":$n[3].Canvas,"sn":"canvas"},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[1].SkeletonGraphic,"sn":"skeletonGraphic"}]}; }, $n);
    /*Spine.Unity.Examples.SpineboyTargetControllerGraphic end.*/

    /*Spine.Unity.Examples.TransitionDictionaryExample start.*/
    $m("Spine.Unity.Examples.TransitionDictionaryExample", function () { return {"nested":[$n[12].TransitionDictionaryExample.SerializedEntry],"att":1048833,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"GetTransition","t":8,"pi":[{"n":"from","pt":$n[5].Animation,"ps":0},{"n":"to","pt":$n[5].Animation,"ps":1}],"sn":"GetTransition","rt":$n[5].Animation,"p":[$n[5].Animation,$n[5].Animation]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"dictionary","t":4,"rt":$n[2].Dictionary$2(spine.AnimationStateData.AnimationPair,Spine.Animation),"sn":"dictionary","ro":true},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"transitions","t":4,"rt":$n[2].List$1(Spine.Unity.Examples.TransitionDictionaryExample.SerializedEntry),"sn":"transitions"}]}; }, $n);
    /*Spine.Unity.Examples.TransitionDictionaryExample end.*/

    /*Spine.Unity.Examples.TransitionDictionaryExample+SerializedEntry start.*/
    $m("Spine.Unity.Examples.TransitionDictionaryExample.SerializedEntry", function () { return {"td":$n[12].TransitionDictionaryExample,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"from","t":4,"rt":$n[1].AnimationReferenceAsset,"sn":"from"},{"a":2,"n":"to","t":4,"rt":$n[1].AnimationReferenceAsset,"sn":"to"},{"a":2,"n":"transition","t":4,"rt":$n[1].AnimationReferenceAsset,"sn":"transition"}]}; }, $n);
    /*Spine.Unity.Examples.TransitionDictionaryExample+SerializedEntry end.*/

    /*Spine.Unity.Examples.Goblins start.*/
    $m("Spine.Unity.Examples.Goblins", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"OnMouseDown","t":8,"sn":"OnMouseDown","rt":$n[0].Void},{"a":2,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"UpdateLocal","t":8,"pi":[{"n":"skeletonRenderer","pt":$n[1].ISkeletonAnimation,"ps":0}],"sn":"UpdateLocal","rt":$n[0].Void,"p":[$n[1].ISkeletonAnimation]},{"at":[new UnityEngine.RangeAttribute(-360.0, 360.0)],"a":2,"n":"extraRotation","t":4,"rt":$n[0].Single,"sn":"extraRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"girlSkin","t":4,"rt":$n[0].Boolean,"sn":"girlSkin","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"headBone","t":4,"rt":$n[5].Bone,"sn":"headBone"},{"a":1,"n":"skeletonAnimation","t":4,"rt":$n[1].SkeletonAnimation,"sn":"skeletonAnimation"}]}; }, $n);
    /*Spine.Unity.Examples.Goblins end.*/

    /*Spine.Unity.Examples.HandleEventWithAudioExample start.*/
    $m("Spine.Unity.Examples.HandleEventWithAudioExample", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"HandleAnimationStateEvent","t":8,"pi":[{"n":"trackEntry","pt":$n[5].TrackEntry,"ps":0},{"n":"e","pt":spine.Event,"ps":1}],"sn":"HandleAnimationStateEvent","rt":$n[0].Void,"p":[$n[5].TrackEntry,spine.Event]},{"a":1,"n":"OnValidate","t":8,"sn":"OnValidate","rt":$n[0].Void},{"a":2,"n":"Play","t":8,"sn":"Play","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"audioClip","t":4,"rt":$n[3].AudioClip,"sn":"audioClip"},{"at":[new UnityEngine.SpaceAttribute.ctor()],"a":2,"n":"audioSource","t":4,"rt":$n[3].AudioSource,"sn":"audioSource"},{"a":2,"n":"basePitch","t":4,"rt":$n[0].Single,"sn":"basePitch","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"eventData","t":4,"rt":spine.EventData,"sn":"eventData"},{"at":[new Spine.Unity.SpineEvent("", "skeletonAnimation", true, true, false)],"a":2,"n":"eventName","t":4,"rt":$n[0].String,"sn":"eventName"},{"at":[new UnityEngine.SpaceAttribute.ctor()],"a":2,"n":"logDebugMessage","t":4,"rt":$n[0].Boolean,"sn":"logDebugMessage","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"randomPitchOffset","t":4,"rt":$n[0].Single,"sn":"randomPitchOffset","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"skeletonAnimation","t":4,"rt":$n[1].SkeletonAnimation,"sn":"skeletonAnimation"}]}; }, $n);
    /*Spine.Unity.Examples.HandleEventWithAudioExample end.*/

    /*Spine.Unity.Examples.HeroEffectsHandlerExample start.*/
    $m("Spine.Unity.Examples.HeroEffectsHandlerExample", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"OnHardLand","t":4,"rt":$n[11].UnityEvent,"sn":"OnHardLand"},{"a":2,"n":"OnJump","t":4,"rt":$n[11].UnityEvent,"sn":"OnJump"},{"a":2,"n":"OnLand","t":4,"rt":$n[11].UnityEvent,"sn":"OnLand"},{"a":2,"n":"eventSource","t":4,"rt":$n[12].BasicPlatformerController,"sn":"eventSource"}]}; }, $n);
    /*Spine.Unity.Examples.HeroEffectsHandlerExample end.*/

    /*Spine.Unity.Examples.MaterialReplacementExample start.*/
    $m("Spine.Unity.Examples.MaterialReplacementExample", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"SetReplacementEnabled","t":8,"pi":[{"n":"active","pt":$n[0].Boolean,"ps":0}],"sn":"SetReplacementEnabled","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":1,"n":"mpb","t":4,"rt":$n[3].MaterialPropertyBlock,"sn":"mpb"},{"a":2,"n":"originalMaterial","t":4,"rt":$n[3].Material,"sn":"originalMaterial"},{"at":[new UnityEngine.RangeAttribute(0.0, 1.0)],"a":2,"n":"phase","t":4,"rt":$n[0].Single,"sn":"phase","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SpaceAttribute.ctor()],"a":2,"n":"phasePropertyName","t":4,"rt":$n[0].String,"sn":"phasePropertyName"},{"a":1,"n":"previousEnabled","t":4,"rt":$n[0].Boolean,"sn":"previousEnabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"replacementEnabled","t":4,"rt":$n[0].Boolean,"sn":"replacementEnabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"replacementMaterial","t":4,"rt":$n[3].Material,"sn":"replacementMaterial"},{"a":2,"n":"skeletonAnimation","t":4,"rt":$n[1].SkeletonAnimation,"sn":"skeletonAnimation"}]}; }, $n);
    /*Spine.Unity.Examples.MaterialReplacementExample end.*/

    /*Spine.Unity.Examples.DummyMecanimControllerExample start.*/
    $m("Spine.Unity.Examples.DummyMecanimControllerExample", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"FakeJump","t":8,"sn":"FakeJump","rt":$n[4].IEnumerator},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"animationHandle","t":4,"rt":$n[12].SkeletonAnimationHandleExample,"sn":"animationHandle"},{"a":2,"n":"groundedProperty","t":4,"rt":$n[0].String,"sn":"groundedProperty"},{"at":[new UnityEngine.HeaderAttribute("Animator Properties")],"a":2,"n":"horizontalSpeedProperty","t":4,"rt":$n[0].String,"sn":"horizontalSpeedProperty"},{"a":2,"n":"isGrounded","t":4,"rt":$n[0].Boolean,"sn":"isGrounded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"jumpButton","t":4,"rt":$n[3].KeyCode,"sn":"jumpButton","box":function ($v) { return Bridge.box($v, UnityEngine.KeyCode, System.Enum.toStringFn(UnityEngine.KeyCode));}},{"at":[new UnityEngine.HeaderAttribute("Fake Physics")],"a":2,"n":"jumpDuration","t":4,"rt":$n[0].Single,"sn":"jumpDuration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"logicAnimator","t":4,"rt":$n[3].Animator,"sn":"logicAnimator"},{"a":2,"n":"speed","t":4,"rt":$n[3].Vector2,"sn":"speed"},{"a":2,"n":"verticalSpeedProperty","t":4,"rt":$n[0].String,"sn":"verticalSpeedProperty"},{"at":[new UnityEngine.HeaderAttribute("Controls")],"a":2,"n":"walkButton","t":4,"rt":$n[3].KeyCode,"sn":"walkButton","box":function ($v) { return Bridge.box($v, UnityEngine.KeyCode, System.Enum.toStringFn(UnityEngine.KeyCode));}}]}; }, $n);
    /*Spine.Unity.Examples.DummyMecanimControllerExample end.*/

    /*Spine.Unity.Examples.MecanimToAnimationHandleExample start.*/
    $m("Spine.Unity.Examples.MecanimToAnimationHandleExample", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"OnStateEnter","t":8,"pi":[{"n":"animator","pt":$n[3].Animator,"ps":0},{"n":"stateInfo","pt":$n[3].AnimatorStateInfo,"ps":1},{"n":"layerIndex","pt":$n[0].Int32,"ps":2}],"sn":"OnStateEnter","rt":$n[0].Void,"p":[$n[3].Animator,$n[3].AnimatorStateInfo,$n[0].Int32]},{"a":1,"n":"animationHandle","t":4,"rt":$n[12].SkeletonAnimationHandleExample,"sn":"animationHandle"},{"a":1,"n":"initialized","t":4,"rt":$n[0].Boolean,"sn":"initialized","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.Examples.MecanimToAnimationHandleExample end.*/

    /*Spine.Unity.Examples.SkeletonAnimationHandleExample start.*/
    $m("Spine.Unity.Examples.SkeletonAnimationHandleExample", function () { return {"nested":[$n[12].SkeletonAnimationHandleExample.StateNameToAnimationReference,$n[12].SkeletonAnimationHandleExample.AnimationTransition],"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"GetAnimationForState","t":8,"pi":[{"n":"shortNameHash","pt":$n[0].Int32,"ps":0}],"sn":"GetAnimationForState","rt":$n[5].Animation,"p":[$n[0].Int32]},{"a":2,"n":"GetAnimationForState","t":8,"pi":[{"n":"stateShortName","pt":$n[0].String,"ps":0}],"sn":"GetAnimationForState$1","rt":$n[5].Animation,"p":[$n[0].String]},{"a":1,"n":"GetCurrentAnimation","t":8,"pi":[{"n":"layerIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetCurrentAnimation","rt":$n[5].Animation,"p":[$n[0].Int32]},{"a":2,"n":"PlayAnimationForState","t":8,"pi":[{"n":"shortNameHash","pt":$n[0].Int32,"ps":0},{"n":"layerIndex","pt":$n[0].Int32,"ps":1}],"sn":"PlayAnimationForState","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Int32]},{"a":2,"n":"PlayAnimationForState","t":8,"pi":[{"n":"stateShortName","pt":$n[0].String,"ps":0},{"n":"layerIndex","pt":$n[0].Int32,"ps":1}],"sn":"PlayAnimationForState$1","rt":$n[0].Void,"p":[$n[0].String,$n[0].Int32]},{"a":2,"n":"PlayNewAnimation","t":8,"pi":[{"n":"target","pt":$n[5].Animation,"ps":0},{"n":"layerIndex","pt":$n[0].Int32,"ps":1}],"sn":"PlayNewAnimation","rt":$n[0].Void,"p":[$n[5].Animation,$n[0].Int32]},{"a":2,"n":"PlayOneShot","t":8,"pi":[{"n":"oneShot","pt":$n[5].Animation,"ps":0},{"n":"layerIndex","pt":$n[0].Int32,"ps":1}],"sn":"PlayOneShot","rt":$n[0].Void,"p":[$n[5].Animation,$n[0].Int32]},{"a":2,"n":"SetFlip","t":8,"pi":[{"n":"horizontal","pt":$n[0].Single,"ps":0}],"sn":"SetFlip","rt":$n[0].Void,"p":[$n[0].Single]},{"a":1,"n":"StringToHash","t":8,"pi":[{"n":"s","pt":$n[0].String,"ps":0}],"sn":"StringToHash","rt":$n[0].Int32,"p":[$n[0].String],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"TryGetTransition","t":8,"pi":[{"n":"from","pt":$n[5].Animation,"ps":0},{"n":"to","pt":$n[5].Animation,"ps":1}],"sn":"TryGetTransition","rt":$n[5].Animation,"p":[$n[5].Animation,$n[5].Animation]},{"a":2,"n":"TargetAnimation","t":16,"rt":$n[5].Animation,"g":{"a":2,"n":"get_TargetAnimation","t":8,"rt":$n[5].Animation,"fg":"TargetAnimation"},"s":{"a":1,"n":"set_TargetAnimation","t":8,"p":[$n[5].Animation],"rt":$n[0].Void,"fs":"TargetAnimation"},"fn":"TargetAnimation"},{"a":2,"n":"skeletonAnimation","t":4,"rt":$n[1].SkeletonAnimation,"sn":"skeletonAnimation"},{"a":2,"n":"statesAndAnimations","t":4,"rt":$n[2].List$1(Spine.Unity.Examples.SkeletonAnimationHandleExample.StateNameToAnimationReference),"sn":"statesAndAnimations"},{"a":2,"n":"transitions","t":4,"rt":$n[2].List$1(Spine.Unity.Examples.SkeletonAnimationHandleExample.AnimationTransition),"sn":"transitions"},{"a":1,"backing":true,"n":"<TargetAnimation>k__BackingField","t":4,"rt":$n[5].Animation,"sn":"TargetAnimation"}]}; }, $n);
    /*Spine.Unity.Examples.SkeletonAnimationHandleExample end.*/

    /*Spine.Unity.Examples.SkeletonAnimationHandleExample+StateNameToAnimationReference start.*/
    $m("Spine.Unity.Examples.SkeletonAnimationHandleExample.StateNameToAnimationReference", function () { return {"td":$n[12].SkeletonAnimationHandleExample,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"animation","t":4,"rt":$n[1].AnimationReferenceAsset,"sn":"animation"},{"a":2,"n":"stateName","t":4,"rt":$n[0].String,"sn":"stateName"}]}; }, $n);
    /*Spine.Unity.Examples.SkeletonAnimationHandleExample+StateNameToAnimationReference end.*/

    /*Spine.Unity.Examples.SkeletonAnimationHandleExample+AnimationTransition start.*/
    $m("Spine.Unity.Examples.SkeletonAnimationHandleExample.AnimationTransition", function () { return {"td":$n[12].SkeletonAnimationHandleExample,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"from","t":4,"rt":$n[1].AnimationReferenceAsset,"sn":"from"},{"a":2,"n":"to","t":4,"rt":$n[1].AnimationReferenceAsset,"sn":"to"},{"a":2,"n":"transition","t":4,"rt":$n[1].AnimationReferenceAsset,"sn":"transition"}]}; }, $n);
    /*Spine.Unity.Examples.SkeletonAnimationHandleExample+AnimationTransition end.*/

    /*Spine.Unity.Examples.AnimationMatchModifierAsset start.*/
    $m("Spine.Unity.Examples.AnimationMatchModifierAsset", function () { return {"nested":[$n[12].AnimationMatchModifierAsset.AnimationTools],"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeletonData","pt":$n[5].SkeletonData,"ps":0}],"sn":"Apply","rt":$n[0].Void,"p":[$n[5].SkeletonData]},{"a":2,"n":"matchAllAnimations","t":4,"rt":$n[0].Boolean,"sn":"matchAllAnimations","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.Examples.AnimationMatchModifierAsset end.*/

    /*Spine.Unity.Examples.AnimationMatchModifierAsset+AnimationTools start.*/
    $m("Spine.Unity.Examples.AnimationMatchModifierAsset.AnimationTools", function () { return {"td":$n[12].AnimationMatchModifierAsset,"att":1048962,"a":2,"s":true,"m":[{"a":1,"n":"GetFillerTimeline","is":true,"t":8,"pi":[{"n":"timeline","pt":spine.AttachmentTimeline,"ps":0},{"n":"skeletonData","pt":$n[5].SkeletonData,"ps":1}],"sn":"GetFillerTimeline","rt":spine.AttachmentTimeline,"p":[spine.AttachmentTimeline,$n[5].SkeletonData]},{"a":1,"n":"GetFillerTimeline","is":true,"t":8,"pi":[{"n":"timeline","pt":spine.DeformTimeline,"ps":0},{"n":"skeletonData","pt":$n[5].SkeletonData,"ps":1}],"sn":"GetFillerTimeline$1","rt":spine.DeformTimeline,"p":[spine.DeformTimeline,$n[5].SkeletonData]},{"a":1,"n":"GetFillerTimeline","is":true,"t":8,"pi":[{"n":"timeline","pt":spine.DrawOrderTimeline,"ps":0},{"n":"skeletonData","pt":$n[5].SkeletonData,"ps":1}],"sn":"GetFillerTimeline$2","rt":spine.DrawOrderTimeline,"p":[spine.DrawOrderTimeline,$n[5].SkeletonData]},{"a":1,"n":"GetFillerTimeline","is":true,"t":8,"pi":[{"n":"timeline","pt":spine.IkConstraintTimeline,"ps":0},{"n":"skeletonData","pt":$n[5].SkeletonData,"ps":1}],"sn":"GetFillerTimeline$3","rt":spine.IkConstraintTimeline,"p":[spine.IkConstraintTimeline,$n[5].SkeletonData]},{"a":1,"n":"GetFillerTimeline","is":true,"t":8,"pi":[{"n":"timeline","pt":spine.PathConstraintMixTimeline,"ps":0},{"n":"skeletonData","pt":$n[5].SkeletonData,"ps":1}],"sn":"GetFillerTimeline$4","rt":spine.PathConstraintMixTimeline,"p":[spine.PathConstraintMixTimeline,$n[5].SkeletonData]},{"a":1,"n":"GetFillerTimeline","is":true,"t":8,"pi":[{"n":"timeline","pt":spine.PathConstraintPositionTimeline,"ps":0},{"n":"skeletonData","pt":$n[5].SkeletonData,"ps":1}],"sn":"GetFillerTimeline$5","rt":spine.PathConstraintPositionTimeline,"p":[spine.PathConstraintPositionTimeline,$n[5].SkeletonData]},{"a":1,"n":"GetFillerTimeline","is":true,"t":8,"pi":[{"n":"timeline","pt":spine.PathConstraintSpacingTimeline,"ps":0},{"n":"skeletonData","pt":$n[5].SkeletonData,"ps":1}],"sn":"GetFillerTimeline$6","rt":spine.PathConstraintSpacingTimeline,"p":[spine.PathConstraintSpacingTimeline,$n[5].SkeletonData]},{"a":1,"n":"GetFillerTimeline","is":true,"t":8,"pi":[{"n":"timeline","pt":spine.RGBA2Timeline,"ps":0},{"n":"skeletonData","pt":$n[5].SkeletonData,"ps":1}],"sn":"GetFillerTimeline$7","rt":spine.RGBA2Timeline,"p":[spine.RGBA2Timeline,$n[5].SkeletonData]},{"a":1,"n":"GetFillerTimeline","is":true,"t":8,"pi":[{"n":"timeline","pt":spine.RGBATimeline,"ps":0},{"n":"skeletonData","pt":$n[5].SkeletonData,"ps":1}],"sn":"GetFillerTimeline$8","rt":spine.RGBATimeline,"p":[spine.RGBATimeline,$n[5].SkeletonData]},{"a":1,"n":"GetFillerTimeline","is":true,"t":8,"pi":[{"n":"timeline","pt":spine.RotateTimeline,"ps":0},{"n":"skeletonData","pt":$n[5].SkeletonData,"ps":1}],"sn":"GetFillerTimeline$9","rt":spine.RotateTimeline,"p":[spine.RotateTimeline,$n[5].SkeletonData]},{"a":1,"n":"GetFillerTimeline","is":true,"t":8,"pi":[{"n":"timeline","pt":spine.ScaleTimeline,"ps":0},{"n":"skeletonData","pt":$n[5].SkeletonData,"ps":1}],"sn":"GetFillerTimeline$10","rt":spine.ScaleTimeline,"p":[spine.ScaleTimeline,$n[5].SkeletonData]},{"a":1,"n":"GetFillerTimeline","is":true,"t":8,"pi":[{"n":"timeline","pt":spine.ShearTimeline,"ps":0},{"n":"skeletonData","pt":$n[5].SkeletonData,"ps":1}],"sn":"GetFillerTimeline$11","rt":spine.ShearTimeline,"p":[spine.ShearTimeline,$n[5].SkeletonData]},{"a":1,"n":"GetFillerTimeline","is":true,"t":8,"pi":[{"n":"timeline","pt":spine.Timeline,"ps":0},{"n":"skeletonData","pt":$n[5].SkeletonData,"ps":1}],"sn":"GetFillerTimeline$12","rt":spine.Timeline,"p":[spine.Timeline,$n[5].SkeletonData]},{"a":1,"n":"GetFillerTimeline","is":true,"t":8,"pi":[{"n":"timeline","pt":spine.TransformConstraintTimeline,"ps":0},{"n":"skeletonData","pt":$n[5].SkeletonData,"ps":1}],"sn":"GetFillerTimeline$13","rt":spine.TransformConstraintTimeline,"p":[spine.TransformConstraintTimeline,$n[5].SkeletonData]},{"a":1,"n":"GetFillerTimeline","is":true,"t":8,"pi":[{"n":"timeline","pt":spine.TranslateTimeline,"ps":0},{"n":"skeletonData","pt":$n[5].SkeletonData,"ps":1}],"sn":"GetFillerTimeline$14","rt":spine.TranslateTimeline,"p":[spine.TranslateTimeline,$n[5].SkeletonData]},{"a":2,"n":"MatchAnimationTimelines","is":true,"t":8,"pi":[{"n":"animations","pt":$n[2].IEnumerable$1(Spine.Animation),"ps":0},{"n":"skeletonData","pt":$n[5].SkeletonData,"ps":1}],"sn":"MatchAnimationTimelines","rt":$n[0].Void,"p":[$n[2].IEnumerable$1(Spine.Animation),$n[5].SkeletonData]}]}; }, $n);
    /*Spine.Unity.Examples.AnimationMatchModifierAsset+AnimationTools end.*/

    /*Spine.Unity.Examples.EquipAssetExample start.*/
    $m("Spine.Unity.Examples.EquipAssetExample", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"description","t":4,"rt":$n[0].String,"sn":"description"},{"a":2,"n":"equipType","t":4,"rt":$n[12].EquipSystemExample.EquipType,"sn":"equipType","box":function ($v) { return Bridge.box($v, Spine.Unity.Examples.EquipSystemExample.EquipType, System.Enum.toStringFn(Spine.Unity.Examples.EquipSystemExample.EquipType));}},{"a":2,"n":"sprite","t":4,"rt":$n[3].Sprite,"sn":"sprite"},{"a":2,"n":"yourStats","t":4,"rt":$n[0].Int32,"sn":"yourStats","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.Unity.Examples.EquipAssetExample end.*/

    /*Spine.Unity.Examples.EquipButtonExample start.*/
    $m("Spine.Unity.Examples.EquipButtonExample", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"MatchImage","t":8,"sn":"MatchImage","rt":$n[0].Void},{"a":1,"n":"OnValidate","t":8,"sn":"OnValidate","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"asset","t":4,"rt":$n[12].EquipAssetExample,"sn":"asset"},{"a":2,"n":"equipSystem","t":4,"rt":$n[12].EquipSystemExample,"sn":"equipSystem"},{"a":2,"n":"inventoryImage","t":4,"rt":$n[7].Image,"sn":"inventoryImage"}]}; }, $n);
    /*Spine.Unity.Examples.EquipButtonExample end.*/

    /*Spine.Unity.Examples.EquipsVisualsComponentExample start.*/
    $m("Spine.Unity.Examples.EquipsVisualsComponentExample", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equip","t":8,"pi":[{"n":"slotIndex","pt":$n[0].Int32,"ps":0},{"n":"attachmentName","pt":$n[0].String,"ps":1},{"n":"attachment","pt":spine.Attachment,"ps":2}],"sn":"Equip","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].String,spine.Attachment]},{"a":2,"n":"OptimizeSkin","t":8,"sn":"OptimizeSkin","rt":$n[0].Void},{"a":1,"n":"RefreshSkeletonAttachments","t":8,"sn":"RefreshSkeletonAttachments","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"collectedSkin","t":4,"rt":$n[5].Skin,"sn":"collectedSkin"},{"a":1,"n":"equipsSkin","t":4,"rt":$n[5].Skin,"sn":"equipsSkin"},{"a":2,"n":"runtimeAtlas","t":4,"rt":$n[3].Texture2D,"sn":"runtimeAtlas"},{"a":2,"n":"runtimeMaterial","t":4,"rt":$n[3].Material,"sn":"runtimeMaterial"},{"a":2,"n":"skeletonAnimation","t":4,"rt":$n[1].SkeletonAnimation,"sn":"skeletonAnimation"},{"at":[new Spine.Unity.SpineSkin("", "", true, false, false)],"a":2,"n":"templateSkinName","t":4,"rt":$n[0].String,"sn":"templateSkinName"}]}; }, $n);
    /*Spine.Unity.Examples.EquipsVisualsComponentExample end.*/

    /*Spine.Unity.Examples.EquipSystemExample start.*/
    $m("Spine.Unity.Examples.EquipSystemExample", function () { return {"nested":[$n[12].EquipSystemExample.EquipHook,$n[12].EquipSystemExample.EquipType],"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Done","t":8,"sn":"Done","rt":$n[0].Void},{"a":2,"n":"Equip","t":8,"pi":[{"n":"asset","pt":$n[12].EquipAssetExample,"ps":0}],"sn":"Equip","rt":$n[0].Void,"p":[$n[12].EquipAssetExample]},{"a":1,"n":"GenerateAttachmentFromEquipAsset","t":8,"pi":[{"n":"asset","pt":$n[12].EquipAssetExample,"ps":0},{"n":"slotIndex","pt":$n[0].Int32,"ps":1},{"n":"templateSkinName","pt":$n[0].String,"ps":2},{"n":"templateAttachmentName","pt":$n[0].String,"ps":3}],"sn":"GenerateAttachmentFromEquipAsset","rt":spine.Attachment,"p":[$n[12].EquipAssetExample,$n[0].Int32,$n[0].String,$n[0].String]},{"a":2,"n":"applyPMA","t":4,"rt":$n[0].Boolean,"sn":"applyPMA","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"cachedAttachments","t":4,"rt":$n[2].Dictionary$2(Spine.Unity.Examples.EquipAssetExample,spine.Attachment),"sn":"cachedAttachments"},{"a":2,"n":"equippables","t":4,"rt":$n[2].List$1(Spine.Unity.Examples.EquipSystemExample.EquipHook),"sn":"equippables"},{"a":2,"n":"skeletonDataAsset","t":4,"rt":$n[1].SkeletonDataAsset,"sn":"skeletonDataAsset"},{"a":2,"n":"sourceMaterial","t":4,"rt":$n[3].Material,"sn":"sourceMaterial"},{"a":2,"n":"target","t":4,"rt":$n[12].EquipsVisualsComponentExample,"sn":"target"}]}; }, $n);
    /*Spine.Unity.Examples.EquipSystemExample end.*/

    /*Spine.Unity.Examples.EquipSystemExample+EquipHook start.*/
    $m("Spine.Unity.Examples.EquipSystemExample.EquipHook", function () { return {"td":$n[12].EquipSystemExample,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"at":[new Spine.Unity.SpineSlot("", "", false, true, false)],"a":2,"n":"slot","t":4,"rt":$n[0].String,"sn":"slot"},{"at":[new Spine.Unity.SpineAttachment(true, false, false, "", "", "templateSkin", true, false)],"a":2,"n":"templateAttachment","t":4,"rt":$n[0].String,"sn":"templateAttachment"},{"at":[new Spine.Unity.SpineSkin("", "", true, false, false)],"a":2,"n":"templateSkin","t":4,"rt":$n[0].String,"sn":"templateSkin"},{"a":2,"n":"type","t":4,"rt":$n[12].EquipSystemExample.EquipType,"sn":"type","box":function ($v) { return Bridge.box($v, Spine.Unity.Examples.EquipSystemExample.EquipType, System.Enum.toStringFn(Spine.Unity.Examples.EquipSystemExample.EquipType));}}]}; }, $n);
    /*Spine.Unity.Examples.EquipSystemExample+EquipHook end.*/

    /*Spine.Unity.Examples.EquipSystemExample+EquipType start.*/
    $m("Spine.Unity.Examples.EquipSystemExample.EquipType", function () { return {"td":$n[12].EquipSystemExample,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Goggles","is":true,"t":4,"rt":$n[12].EquipSystemExample.EquipType,"sn":"Goggles","box":function ($v) { return Bridge.box($v, Spine.Unity.Examples.EquipSystemExample.EquipType, System.Enum.toStringFn(Spine.Unity.Examples.EquipSystemExample.EquipType));}},{"a":2,"n":"Gun","is":true,"t":4,"rt":$n[12].EquipSystemExample.EquipType,"sn":"Gun","box":function ($v) { return Bridge.box($v, Spine.Unity.Examples.EquipSystemExample.EquipType, System.Enum.toStringFn(Spine.Unity.Examples.EquipSystemExample.EquipType));}}]}; }, $n);
    /*Spine.Unity.Examples.EquipSystemExample+EquipType end.*/

    /*Spine.Unity.Examples.MixAndMatchSkinsButtonExample start.*/
    $m("Spine.Unity.Examples.MixAndMatchSkinsButtonExample", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"at":[new Spine.Unity.SpineSkin("", "skeletonDataAsset", true, false, false)],"a":2,"n":"itemSkin","t":4,"rt":$n[0].String,"sn":"itemSkin"},{"a":2,"n":"itemType","t":4,"rt":$n[12].MixAndMatchSkinsExample.ItemType,"sn":"itemType","box":function ($v) { return Bridge.box($v, Spine.Unity.Examples.MixAndMatchSkinsExample.ItemType, System.Enum.toStringFn(Spine.Unity.Examples.MixAndMatchSkinsExample.ItemType));}},{"a":2,"n":"skeletonDataAsset","t":4,"rt":$n[1].SkeletonDataAsset,"sn":"skeletonDataAsset"},{"a":2,"n":"skinsSystem","t":4,"rt":$n[12].MixAndMatchSkinsExample,"sn":"skinsSystem"}]}; }, $n);
    /*Spine.Unity.Examples.MixAndMatchSkinsButtonExample end.*/

    /*Spine.Unity.Examples.MixAndMatchSkinsExample start.*/
    $m("Spine.Unity.Examples.MixAndMatchSkinsExample", function () { return {"nested":[$n[12].MixAndMatchSkinsExample.ItemType],"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AddEquipmentSkinsTo","t":8,"pi":[{"n":"combinedSkin","pt":$n[5].Skin,"ps":0}],"sn":"AddEquipmentSkinsTo","rt":$n[0].Void,"p":[$n[5].Skin]},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"Equip","t":8,"pi":[{"n":"itemSkin","pt":$n[0].String,"ps":0},{"n":"itemType","pt":$n[12].MixAndMatchSkinsExample.ItemType,"ps":1}],"sn":"Equip","rt":$n[0].Void,"p":[$n[0].String,$n[12].MixAndMatchSkinsExample.ItemType]},{"a":2,"n":"NextEyesSkin","t":8,"sn":"NextEyesSkin","rt":$n[0].Void},{"a":2,"n":"NextHairSkin","t":8,"sn":"NextHairSkin","rt":$n[0].Void},{"a":2,"n":"NextNoseSkin","t":8,"sn":"NextNoseSkin","rt":$n[0].Void},{"a":2,"n":"OptimizeSkin","t":8,"sn":"OptimizeSkin","rt":$n[0].Void},{"a":2,"n":"PrevEyesSkin","t":8,"sn":"PrevEyesSkin","rt":$n[0].Void},{"a":2,"n":"PrevHairSkin","t":8,"sn":"PrevHairSkin","rt":$n[0].Void},{"a":2,"n":"PrevNoseSkin","t":8,"sn":"PrevNoseSkin","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"UpdateCharacterSkin","t":8,"sn":"UpdateCharacterSkin","rt":$n[0].Void},{"a":1,"n":"UpdateCombinedSkin","t":8,"sn":"UpdateCombinedSkin","rt":$n[0].Void},{"a":2,"n":"activeEyesIndex","t":4,"rt":$n[0].Int32,"sn":"activeEyesIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"activeHairIndex","t":4,"rt":$n[0].Int32,"sn":"activeHairIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"activeNoseIndex","t":4,"rt":$n[0].Int32,"sn":"activeNoseIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new Spine.Unity.SpineSkin("", "", true, false, false)],"a":2,"n":"bagSkin","t":4,"rt":$n[0].String,"sn":"bagSkin"},{"at":[new Spine.Unity.SpineSkin("", "", true, false, false)],"a":2,"n":"baseSkin","t":4,"rt":$n[0].String,"sn":"baseSkin"},{"a":1,"n":"characterSkin","t":4,"rt":$n[5].Skin,"sn":"characterSkin"},{"at":[new Spine.Unity.SpineSkin("", "", true, false, false)],"a":2,"n":"clothesSkin","t":4,"rt":$n[0].String,"sn":"clothesSkin"},{"at":[new Spine.Unity.SpineSkin("", "", true, false, false)],"a":2,"n":"eyelidsSkin","t":4,"rt":$n[0].String,"sn":"eyelidsSkin"},{"at":[new Spine.Unity.SpineSkin("", "", true, false, false)],"a":2,"n":"eyesSkins","t":4,"rt":$n[0].Array.type(System.String),"sn":"eyesSkins"},{"at":[new Spine.Unity.SpineSkin("", "", true, false, false)],"a":2,"n":"hairSkins","t":4,"rt":$n[0].Array.type(System.String),"sn":"hairSkins"},{"at":[new Spine.Unity.SpineSkin("", "", true, false, false)],"a":2,"n":"hatSkin","t":4,"rt":$n[0].String,"sn":"hatSkin"},{"at":[new Spine.Unity.SpineSkin("", "", true, false, false)],"a":2,"n":"noseSkins","t":4,"rt":$n[0].Array.type(System.String),"sn":"noseSkins"},{"at":[new Spine.Unity.SpineSkin("", "", true, false, false)],"a":2,"n":"pantsSkin","t":4,"rt":$n[0].String,"sn":"pantsSkin"},{"a":2,"n":"runtimeAtlas","t":4,"rt":$n[3].Texture2D,"sn":"runtimeAtlas"},{"a":2,"n":"runtimeMaterial","t":4,"rt":$n[3].Material,"sn":"runtimeMaterial"},{"a":1,"n":"skeletonAnimation","t":4,"rt":$n[1].SkeletonAnimation,"sn":"skeletonAnimation"}]}; }, $n);
    /*Spine.Unity.Examples.MixAndMatchSkinsExample end.*/

    /*Spine.Unity.Examples.MixAndMatchSkinsExample+ItemType start.*/
    $m("Spine.Unity.Examples.MixAndMatchSkinsExample.ItemType", function () { return {"td":$n[12].MixAndMatchSkinsExample,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Bag","is":true,"t":4,"rt":$n[12].MixAndMatchSkinsExample.ItemType,"sn":"Bag","box":function ($v) { return Bridge.box($v, Spine.Unity.Examples.MixAndMatchSkinsExample.ItemType, System.Enum.toStringFn(Spine.Unity.Examples.MixAndMatchSkinsExample.ItemType));}},{"a":2,"n":"Cloth","is":true,"t":4,"rt":$n[12].MixAndMatchSkinsExample.ItemType,"sn":"Cloth","box":function ($v) { return Bridge.box($v, Spine.Unity.Examples.MixAndMatchSkinsExample.ItemType, System.Enum.toStringFn(Spine.Unity.Examples.MixAndMatchSkinsExample.ItemType));}},{"a":2,"n":"Hat","is":true,"t":4,"rt":$n[12].MixAndMatchSkinsExample.ItemType,"sn":"Hat","box":function ($v) { return Bridge.box($v, Spine.Unity.Examples.MixAndMatchSkinsExample.ItemType, System.Enum.toStringFn(Spine.Unity.Examples.MixAndMatchSkinsExample.ItemType));}},{"a":2,"n":"Pants","is":true,"t":4,"rt":$n[12].MixAndMatchSkinsExample.ItemType,"sn":"Pants","box":function ($v) { return Bridge.box($v, Spine.Unity.Examples.MixAndMatchSkinsExample.ItemType, System.Enum.toStringFn(Spine.Unity.Examples.MixAndMatchSkinsExample.ItemType));}}]}; }, $n);
    /*Spine.Unity.Examples.MixAndMatchSkinsExample+ItemType end.*/

    /*Spine.Unity.Examples.MixAndMatch start.*/
    $m("Spine.Unity.Examples.MixAndMatch", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Apply","t":8,"sn":"Apply","rt":$n[0].Void},{"a":1,"n":"OnValidate","t":8,"sn":"OnValidate","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[4].IEnumerator},{"a":2,"n":"bbFollower","t":4,"rt":$n[1].BoundingBoxFollower,"sn":"bbFollower"},{"a":1,"n":"customSkin","t":4,"rt":$n[5].Skin,"sn":"customSkin"},{"at":[new Spine.Unity.SpineAttachment(true, false, false, "gunSlot", "", "baseSkinName", true, false)],"a":2,"n":"gunKey","t":4,"rt":$n[0].String,"sn":"gunKey"},{"at":[new Spine.Unity.SpineSlot("", "", false, true, false)],"a":2,"n":"gunSlot","t":4,"rt":$n[0].String,"sn":"gunSlot"},{"at":[new UnityEngine.HeaderAttribute("Gun")],"a":2,"n":"gunSprite","t":4,"rt":$n[3].Sprite,"sn":"gunSprite"},{"at":[new UnityEngine.HeaderAttribute("Runtime Repack")],"a":2,"n":"repack","t":4,"rt":$n[0].Boolean,"sn":"repack","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HeaderAttribute("Do not assign")],"a":2,"n":"runtimeAtlas","t":4,"rt":$n[3].Texture2D,"sn":"runtimeAtlas"},{"a":2,"n":"runtimeMaterial","t":4,"rt":$n[3].Material,"sn":"runtimeMaterial"},{"a":2,"n":"sourceMaterial","t":4,"rt":$n[3].Material,"sn":"sourceMaterial"},{"at":[new Spine.Unity.SpineSkin("", "", true, false, false)],"a":2,"n":"templateAttachmentsSkin","t":4,"rt":$n[0].String,"sn":"templateAttachmentsSkin"},{"at":[new Spine.Unity.SpineAttachment(true, false, false, "visorSlot", "", "baseSkinName", true, false)],"a":2,"n":"visorKey","t":4,"rt":$n[0].String,"sn":"visorKey"},{"at":[new Spine.Unity.SpineSlot("", "", false, true, false)],"a":2,"n":"visorSlot","t":4,"rt":$n[0].String,"sn":"visorSlot"},{"at":[new UnityEngine.HeaderAttribute("Visor")],"a":2,"n":"visorSprite","t":4,"rt":$n[3].Sprite,"sn":"visorSprite"}]}; }, $n);
    /*Spine.Unity.Examples.MixAndMatch end.*/

    /*Spine.Unity.Examples.MixAndMatchGraphic start.*/
    $m("Spine.Unity.Examples.MixAndMatchGraphic", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"at":[new UnityEngine.ContextMenu.ctor("Apply")],"a":1,"n":"Apply","t":8,"sn":"Apply","rt":$n[0].Void},{"a":1,"n":"OnValidate","t":8,"sn":"OnValidate","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[4].IEnumerator},{"at":[new Spine.Unity.SpineSkin("", "", true, false, false)],"a":2,"n":"baseSkinName","t":4,"rt":$n[0].String,"sn":"baseSkinName"},{"a":1,"n":"customSkin","t":4,"rt":$n[5].Skin,"sn":"customSkin"},{"at":[new Spine.Unity.SpineAttachment(true, false, false, "gunSlot", "", "baseSkinName", true, false)],"a":2,"n":"gunKey","t":4,"rt":$n[0].String,"sn":"gunKey"},{"at":[new Spine.Unity.SpineSlot("", "", false, true, false)],"a":2,"n":"gunSlot","t":4,"rt":$n[0].String,"sn":"gunSlot"},{"at":[new UnityEngine.HeaderAttribute("Gun")],"a":2,"n":"gunSprite","t":4,"rt":$n[3].Sprite,"sn":"gunSprite"},{"at":[new UnityEngine.HeaderAttribute("Runtime Repack Required!!")],"a":2,"n":"repack","t":4,"rt":$n[0].Boolean,"sn":"repack","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HeaderAttribute("Do not assign")],"a":2,"n":"runtimeAtlas","t":4,"rt":$n[3].Texture2D,"sn":"runtimeAtlas"},{"a":2,"n":"runtimeMaterial","t":4,"rt":$n[3].Material,"sn":"runtimeMaterial"},{"a":2,"n":"sourceMaterial","t":4,"rt":$n[3].Material,"sn":"sourceMaterial"},{"at":[new Spine.Unity.SpineAttachment(true, false, false, "visorSlot", "", "baseSkinName", true, false)],"a":2,"n":"visorKey","t":4,"rt":$n[0].String,"sn":"visorKey"},{"at":[new Spine.Unity.SpineSlot("", "", false, true, false)],"a":2,"n":"visorSlot","t":4,"rt":$n[0].String,"sn":"visorSlot"},{"at":[new UnityEngine.HeaderAttribute("Visor")],"a":2,"n":"visorSprite","t":4,"rt":$n[3].Sprite,"sn":"visorSprite"}]}; }, $n);
    /*Spine.Unity.Examples.MixAndMatchGraphic end.*/

    /*Spine.Unity.Examples.RaggedySpineboy start.*/
    $m("Spine.Unity.Examples.RaggedySpineboy", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AddRigidbody","t":8,"sn":"AddRigidbody","rt":$n[0].Void},{"a":1,"n":"Launch","t":8,"sn":"Launch","rt":$n[0].Void},{"a":1,"n":"OnMouseUp","t":8,"sn":"OnMouseUp","rt":$n[0].Void},{"a":1,"n":"RemoveRigidbody","t":8,"sn":"RemoveRigidbody","rt":$n[0].Void},{"a":1,"n":"Restore","t":8,"sn":"Restore","rt":$n[4].IEnumerator},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"WaitUntilStopped","t":8,"sn":"WaitUntilStopped","rt":$n[4].IEnumerator},{"a":2,"n":"groundMask","t":4,"rt":$n[3].LayerMask,"sn":"groundMask"},{"a":2,"n":"launchVelocity","t":4,"rt":$n[3].Vector2,"sn":"launchVelocity"},{"a":1,"n":"naturalCollider","t":4,"rt":$n[3].Collider2D,"sn":"naturalCollider"},{"a":1,"n":"ragdoll","t":4,"rt":$n[12].SkeletonRagdoll2D,"sn":"ragdoll"},{"a":2,"n":"restoreDuration","t":4,"rt":$n[0].Single,"sn":"restoreDuration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Unity.Examples.RaggedySpineboy end.*/

    /*Spine.Unity.Examples.RenderTextureFadeoutExample start.*/
    $m("Spine.Unity.Examples.RenderTextureFadeoutExample", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"DisableGameObject","t":8,"pi":[{"n":"target","pt":$n[12].SkeletonRenderTextureFadeout,"ps":0}],"sn":"DisableGameObject","rt":$n[0].Void,"p":[$n[12].SkeletonRenderTextureFadeout]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[4].IEnumerator},{"a":1,"n":"StartFadeoutBad","t":8,"sn":"StartFadeoutBad","rt":$n[0].Void},{"a":1,"n":"StartFadeoutGood","t":8,"pi":[{"n":"fadeoutComponent","pt":$n[12].SkeletonRenderTextureFadeout,"ps":0}],"sn":"StartFadeoutGood","rt":$n[0].Void,"p":[$n[12].SkeletonRenderTextureFadeout]},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":1,"n":"UpdateBadFadeOutAlpha","t":8,"sn":"UpdateBadFadeOutAlpha","rt":$n[0].Void},{"a":1,"n":"fadeoutSeconds","t":4,"rt":$n[0].Single,"sn":"fadeoutSeconds","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"fadeoutSecondsRemaining","t":4,"rt":$n[0].Single,"sn":"fadeoutSecondsRemaining","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"normalSkeletonRenderer","t":4,"rt":$n[1].SkeletonRenderer,"sn":"normalSkeletonRenderer"},{"a":2,"n":"renderTextureFadeout","t":4,"rt":$n[12].SkeletonRenderTextureFadeout,"sn":"renderTextureFadeout"},{"a":2,"n":"renderTextureFadeoutCanvas","t":4,"rt":$n[12].SkeletonRenderTextureFadeout,"sn":"renderTextureFadeoutCanvas"}]}; }, $n);
    /*Spine.Unity.Examples.RenderTextureFadeoutExample end.*/

    /*Spine.Unity.Examples.RuntimeLoadFromExportsExample start.*/
    $m("Spine.Unity.Examples.RuntimeLoadFromExportsExample", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"CreateRuntimeAssetsAndGameObject","t":8,"sn":"CreateRuntimeAssetsAndGameObject","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[4].IEnumerator},{"a":2,"n":"animationName","t":4,"rt":$n[0].String,"sn":"animationName"},{"a":2,"n":"atlasText","t":4,"rt":$n[3].TextAsset,"sn":"atlasText"},{"a":2,"n":"delay","t":4,"rt":$n[0].Single,"sn":"delay","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"materialPropertySource","t":4,"rt":$n[3].Material,"sn":"materialPropertySource"},{"a":1,"n":"runtimeAtlasAsset","t":4,"rt":$n[1].SpineAtlasAsset,"sn":"runtimeAtlasAsset"},{"a":1,"n":"runtimeSkeletonAnimation","t":4,"rt":$n[1].SkeletonAnimation,"sn":"runtimeSkeletonAnimation"},{"a":1,"n":"runtimeSkeletonDataAsset","t":4,"rt":$n[1].SkeletonDataAsset,"sn":"runtimeSkeletonDataAsset"},{"a":2,"n":"skeletonJson","t":4,"rt":$n[3].TextAsset,"sn":"skeletonJson"},{"a":2,"n":"skinName","t":4,"rt":$n[0].String,"sn":"skinName"},{"a":2,"n":"textures","t":4,"rt":System.Array.type(UnityEngine.Texture2D),"sn":"textures"}]}; }, $n);
    /*Spine.Unity.Examples.RuntimeLoadFromExportsExample end.*/

    /*Spine.Unity.Examples.BoneLocalOverride start.*/
    $m("Spine.Unity.Examples.BoneLocalOverride", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"OverrideLocal","t":8,"pi":[{"n":"animated","pt":$n[1].ISkeletonAnimation,"ps":0}],"sn":"OverrideLocal","rt":$n[0].Void,"p":[$n[1].ISkeletonAnimation]},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.RangeAttribute(0.0, 1.0)],"a":2,"n":"alpha","t":4,"rt":$n[0].Single,"sn":"alpha","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"bone","t":4,"rt":$n[5].Bone,"sn":"bone"},{"at":[new Spine.Unity.SpineBone("", "", true, false)],"a":2,"n":"boneName","t":4,"rt":$n[0].String,"sn":"boneName"},{"a":2,"n":"localPosition","t":4,"rt":$n[3].Vector2,"sn":"localPosition"},{"at":[new UnityEngine.SpaceAttribute.ctor()],"a":2,"n":"overridePosition","t":4,"rt":$n[0].Boolean,"sn":"overridePosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SpaceAttribute.ctor()],"a":2,"n":"overrideRotation","t":4,"rt":$n[0].Boolean,"sn":"overrideRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.RangeAttribute(0.0, 360.0)],"a":2,"n":"rotation","t":4,"rt":$n[0].Single,"sn":"rotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"spineComponent","t":4,"rt":$n[1].ISkeletonAnimation,"sn":"spineComponent"}]}; }, $n);
    /*Spine.Unity.Examples.BoneLocalOverride end.*/

    /*Spine.Unity.Examples.CombinedSkin start.*/
    $m("Spine.Unity.Examples.CombinedSkin", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"combinedSkin","t":4,"rt":$n[5].Skin,"sn":"combinedSkin"},{"at":[new Spine.Unity.SpineSkin("", "", true, false, false)],"a":2,"n":"skinsToCombine","t":4,"rt":$n[2].List$1(System.String),"sn":"skinsToCombine"}]}; }, $n);
    /*Spine.Unity.Examples.CombinedSkin end.*/

    /*Spine.Unity.Examples.SkeletonGhost start.*/
    $m("Spine.Unity.Examples.SkeletonGhost", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(Spine.Unity.SkeletonRenderer)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Ghosting","t":8,"pi":[{"n":"val","pt":$n[0].Single,"ps":0}],"sn":"Ghosting","rt":$n[0].Void,"p":[$n[0].Single]},{"a":1,"n":"HexToColor","is":true,"t":8,"pi":[{"n":"hex","pt":$n[0].String,"ps":0}],"sn":"HexToColor","rt":$n[3].Color32,"p":[$n[0].String]},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","pt":$n[0].Boolean,"ps":0}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":1,"n":"OnEvent","t":8,"pi":[{"n":"trackEntry","pt":$n[5].TrackEntry,"ps":0},{"n":"e","pt":spine.Event,"ps":1}],"sn":"OnEvent","rt":$n[0].Void,"p":[$n[5].TrackEntry,spine.Event]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":1,"n":"GhostHideFlags","is":true,"t":4,"rt":$n[3].HideFlags,"sn":"GhostHideFlags","box":function ($v) { return Bridge.box($v, UnityEngine.HideFlags, System.Enum.toStringFn(UnityEngine.HideFlags));}},{"a":1,"n":"GhostingShaderName","is":true,"t":4,"rt":$n[0].String,"sn":"GhostingShaderName"},{"at":[new UnityEngine.TooltipAttribute("Remember to set color alpha to 0 if Additive is true")],"a":2,"n":"additive","t":4,"rt":$n[0].Boolean,"sn":"additive","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"color","t":4,"rt":$n[3].Color32,"sn":"color"},{"a":2,"n":"fadeSpeed","t":4,"rt":$n[0].Single,"sn":"fadeSpeed","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.HeaderAttribute("Rendering")],"a":2,"n":"ghostShader","t":4,"rt":$n[3].Shader,"sn":"ghostShader"},{"at":[new UnityEngine.HeaderAttribute("Animation")],"a":2,"n":"ghostingEnabled","t":4,"rt":$n[0].Boolean,"sn":"ghostingEnabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"materialTable","t":4,"rt":$n[2].Dictionary$2(UnityEngine.Material,UnityEngine.Material),"sn":"materialTable","ro":true},{"at":[new UnityEngine.TooltipAttribute("Maximum number of ghosts that can exist at a time. If the fade speed is not fast enough, the oldest ghost will immediately disappear to enforce the maximum number.")],"a":2,"n":"maximumGhosts","t":4,"rt":$n[0].Int32,"sn":"maximumGhosts","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"meshFilter","t":4,"rt":$n[3].MeshFilter,"sn":"meshFilter"},{"a":1,"n":"meshRenderer","t":4,"rt":$n[3].MeshRenderer,"sn":"meshRenderer"},{"a":1,"n":"nextSpawnTime","t":4,"rt":$n[0].Single,"sn":"nextSpawnTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"pool","t":4,"rt":System.Array.type(Spine.Unity.Examples.SkeletonGhostRenderer),"sn":"pool"},{"a":1,"n":"poolIndex","t":4,"rt":$n[0].Int32,"sn":"poolIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"skeletonRenderer","t":4,"rt":$n[1].SkeletonRenderer,"sn":"skeletonRenderer"},{"at":[new UnityEngine.HeaderAttribute("Sorting")],"a":2,"n":"sortWithDistanceOnly","t":4,"rt":$n[0].Boolean,"sn":"sortWithDistanceOnly","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("The time between invididual ghost pieces being spawned."),new UnityEngine.Serialization.FormerlySerializedAsAttribute("spawnRate")],"a":2,"n":"spawnInterval","t":4,"rt":$n[0].Single,"sn":"spawnInterval","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("0 is Color and Alpha, 1 is Alpha only."),new UnityEngine.RangeAttribute(0.0, 1.0)],"a":2,"n":"textureFade","t":4,"rt":$n[0].Single,"sn":"textureFade","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"zOffset","t":4,"rt":$n[0].Single,"sn":"zOffset","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Unity.Examples.SkeletonGhost end.*/

    /*Spine.Unity.Examples.SkeletonGhostRenderer start.*/
    $m("Spine.Unity.Examples.SkeletonGhostRenderer", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"Cleanup","t":8,"sn":"Cleanup","rt":$n[0].Void},{"a":1,"n":"Fade","t":8,"sn":"Fade","rt":$n[4].IEnumerator},{"a":1,"n":"FadeAdditive","t":8,"sn":"FadeAdditive","rt":$n[4].IEnumerator},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"mesh","pt":$n[3].Mesh,"ps":0},{"n":"materials","pt":System.Array.type(UnityEngine.Material),"ps":1},{"n":"color","pt":$n[3].Color32,"ps":2},{"n":"additive","pt":$n[0].Boolean,"ps":3},{"n":"speed","pt":$n[0].Single,"ps":4},{"n":"sortingLayerID","pt":$n[0].Int32,"ps":5},{"n":"sortingOrder","pt":$n[0].Int32,"ps":6}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[3].Mesh,System.Array.type(UnityEngine.Material),$n[3].Color32,$n[0].Boolean,$n[0].Single,$n[0].Int32,$n[0].Int32]},{"a":1,"n":"TransparentBlack","is":true,"t":4,"rt":$n[3].Color32,"sn":"TransparentBlack","ro":true},{"a":1,"n":"colorId","t":4,"rt":$n[0].Int32,"sn":"colorId","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"colorPropertyName","is":true,"t":4,"rt":$n[0].String,"sn":"colorPropertyName"},{"a":1,"n":"fadeSpeed","t":4,"rt":$n[0].Single,"sn":"fadeSpeed","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"meshFilter","t":4,"rt":$n[3].MeshFilter,"sn":"meshFilter"},{"a":1,"n":"meshRenderer","t":4,"rt":$n[3].MeshRenderer,"sn":"meshRenderer"},{"a":1,"n":"mpb","t":4,"rt":$n[3].MaterialPropertyBlock,"sn":"mpb"},{"a":1,"n":"startColor","t":4,"rt":$n[3].Color32,"sn":"startColor"}]}; }, $n);
    /*Spine.Unity.Examples.SkeletonGhostRenderer end.*/

    /*Spine.Unity.Examples.AtlasRegionAttacher start.*/
    $m("Spine.Unity.Examples.AtlasRegionAttacher", function () { return {"nested":[$n[12].AtlasRegionAttacher.SlotRegionPair],"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Apply","t":8,"pi":[{"n":"skeletonRenderer","pt":$n[1].SkeletonRenderer,"ps":0}],"sn":"Apply","rt":$n[0].Void,"p":[$n[1].SkeletonRenderer]},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"atlas","t":4,"rt":$n[5].Atlas,"sn":"atlas"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"atlasAsset","t":4,"rt":$n[1].SpineAtlasAsset,"sn":"atlasAsset"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"attachments","t":4,"rt":$n[2].List$1(Spine.Unity.Examples.AtlasRegionAttacher.SlotRegionPair),"sn":"attachments"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"inheritProperties","t":4,"rt":$n[0].Boolean,"sn":"inheritProperties","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.Examples.AtlasRegionAttacher end.*/

    /*Spine.Unity.Examples.AtlasRegionAttacher+SlotRegionPair start.*/
    $m("Spine.Unity.Examples.AtlasRegionAttacher.SlotRegionPair", function () { return {"td":$n[12].AtlasRegionAttacher,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"at":[new Spine.Unity.SpineAtlasRegion("")],"a":2,"n":"region","t":4,"rt":$n[0].String,"sn":"region"},{"at":[new Spine.Unity.SpineSlot("", "", false, true, false)],"a":2,"n":"slot","t":4,"rt":$n[0].String,"sn":"slot"}]}; }, $n);
    /*Spine.Unity.Examples.AtlasRegionAttacher+SlotRegionPair end.*/

    /*Spine.Unity.Examples.SpriteAttacher start.*/
    $m("Spine.Unity.Examples.SpriteAttacher", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AnimationOverrideSpriteAttach","t":8,"pi":[{"n":"animated","pt":$n[1].ISkeletonAnimation,"ps":0}],"sn":"AnimationOverrideSpriteAttach","rt":$n[0].Void,"p":[$n[1].ISkeletonAnimation]},{"a":2,"n":"Attach","t":8,"sn":"Attach","rt":$n[0].Void},{"a":1,"n":"GetPageFor","is":true,"t":8,"pi":[{"n":"texture","pt":$n[3].Texture,"ps":0},{"n":"shader","pt":$n[3].Shader,"ps":1}],"sn":"GetPageFor","rt":$n[5].AtlasPage,"p":[$n[3].Texture,$n[3].Shader]},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","dv":true,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"DefaultPMAShader","is":true,"t":4,"rt":$n[0].String,"sn":"DefaultPMAShader"},{"a":2,"n":"DefaultStraightAlphaShader","is":true,"t":4,"rt":$n[0].String,"sn":"DefaultStraightAlphaShader"},{"a":1,"n":"applyPMA","t":4,"rt":$n[0].Boolean,"sn":"applyPMA","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"atlasPageCache","is":true,"t":4,"rt":$n[2].Dictionary$2(UnityEngine.Texture,Spine.AtlasPage),"sn":"atlasPageCache"},{"a":2,"n":"attachOnStart","t":4,"rt":$n[0].Boolean,"sn":"attachOnStart","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"attachment","t":4,"rt":$n[5].RegionAttachment,"sn":"attachment"},{"a":2,"n":"overrideAnimation","t":4,"rt":$n[0].Boolean,"sn":"overrideAnimation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new Spine.Unity.SpineSlot("", "", false, true, false)],"a":2,"n":"slot","t":4,"rt":$n[0].String,"sn":"slot"},{"a":1,"n":"spineSlot","t":4,"rt":$n[5].Slot,"sn":"spineSlot"},{"a":2,"n":"sprite","t":4,"rt":$n[3].Sprite,"sn":"sprite"}]}; }, $n);
    /*Spine.Unity.Examples.SpriteAttacher end.*/

    /*Spine.Unity.Examples.SpriteAttachmentExtensions start.*/
    $m("Spine.Unity.Examples.SpriteAttachmentExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"AddUnitySprite","is":true,"t":8,"pi":[{"n":"skeletonData","pt":$n[5].SkeletonData,"ps":0},{"n":"slotName","pt":$n[0].String,"ps":1},{"n":"sprite","pt":$n[3].Sprite,"ps":2},{"n":"skinName","dv":"","o":true,"pt":$n[0].String,"ps":3},{"n":"shaderName","dv":"Spine/Skeleton","o":true,"pt":$n[0].String,"ps":4},{"n":"applyPMA","dv":true,"o":true,"pt":$n[0].Boolean,"ps":5},{"n":"rotation","dv":0.0,"o":true,"pt":$n[0].Single,"ps":6}],"sn":"AddUnitySprite","rt":$n[5].RegionAttachment,"p":[$n[5].SkeletonData,$n[0].String,$n[3].Sprite,$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"AddUnitySprite","is":true,"t":8,"pi":[{"n":"skeletonData","pt":$n[5].SkeletonData,"ps":0},{"n":"slotName","pt":$n[0].String,"ps":1},{"n":"sprite","pt":$n[3].Sprite,"ps":2},{"n":"skinName","pt":$n[0].String,"ps":3},{"n":"shader","pt":$n[3].Shader,"ps":4},{"n":"applyPMA","pt":$n[0].Boolean,"ps":5},{"n":"rotation","dv":0.0,"o":true,"pt":$n[0].Single,"ps":6}],"sn":"AddUnitySprite$1","rt":$n[5].RegionAttachment,"p":[$n[5].SkeletonData,$n[0].String,$n[3].Sprite,$n[0].String,$n[3].Shader,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"AttachUnitySprite","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"slotName","pt":$n[0].String,"ps":1},{"n":"sprite","pt":$n[3].Sprite,"ps":2},{"n":"shaderName","dv":"Spine/Skeleton","o":true,"pt":$n[0].String,"ps":3},{"n":"applyPMA","dv":true,"o":true,"pt":$n[0].Boolean,"ps":4},{"n":"rotation","dv":0.0,"o":true,"pt":$n[0].Single,"ps":5}],"sn":"AttachUnitySprite","rt":$n[5].RegionAttachment,"p":[$n[5].Skeleton,$n[0].String,$n[3].Sprite,$n[0].String,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"AttachUnitySprite","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"slotName","pt":$n[0].String,"ps":1},{"n":"sprite","pt":$n[3].Sprite,"ps":2},{"n":"shader","pt":$n[3].Shader,"ps":3},{"n":"applyPMA","pt":$n[0].Boolean,"ps":4},{"n":"rotation","dv":0.0,"o":true,"pt":$n[0].Single,"ps":5}],"sn":"AttachUnitySprite$1","rt":$n[5].RegionAttachment,"p":[$n[5].Skeleton,$n[0].String,$n[3].Sprite,$n[3].Shader,$n[0].Boolean,$n[0].Single]}]}; }, $n);
    /*Spine.Unity.Examples.SpriteAttachmentExtensions end.*/

    /*Spine.Unity.Examples.OutlineSkeletonGraphic start.*/
    $m("Spine.Unity.Examples.OutlineSkeletonGraphic", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"DisableOutlineRendering","t":8,"sn":"DisableOutlineRendering","rt":$n[0].Void},{"a":2,"n":"EnableOutlineRendering","t":8,"sn":"EnableOutlineRendering","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":2,"n":"materialWithOutline","t":4,"rt":$n[3].Material,"sn":"materialWithOutline"},{"a":2,"n":"materialWithoutOutline","t":4,"rt":$n[3].Material,"sn":"materialWithoutOutline"},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[1].SkeletonGraphic,"sn":"skeletonGraphic"}]}; }, $n);
    /*Spine.Unity.Examples.OutlineSkeletonGraphic end.*/

    /*Spine.Unity.Examples.RenderExistingMesh start.*/
    $m("Spine.Unity.Examples.RenderExistingMesh", function () { return {"nested":[$n[12].RenderExistingMesh.MaterialReplacement],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.ctor(UnityEngine.MeshRenderer),new UnityEngine.RequireComponent.ctor(UnityEngine.MeshFilter)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"InitializeDict","t":8,"sn":"InitializeDict","rt":$n[0].Void},{"a":1,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"UpdateMaterials","t":8,"sn":"UpdateMaterials","rt":$n[0].Void},{"a":1,"n":"UpdateOnCallback","t":8,"pi":[{"n":"r","pt":$n[1].SkeletonRenderer,"ps":0}],"sn":"UpdateOnCallback","rt":$n[0].Void,"p":[$n[1].SkeletonRenderer]},{"a":1,"n":"ownMeshFilter","t":4,"rt":$n[3].MeshFilter,"sn":"ownMeshFilter"},{"a":1,"n":"ownRenderer","t":4,"rt":$n[3].MeshRenderer,"sn":"ownRenderer"},{"a":1,"n":"referenceMeshFilter","t":4,"rt":$n[3].MeshFilter,"sn":"referenceMeshFilter"},{"a":2,"n":"referenceRenderer","t":4,"rt":$n[3].MeshRenderer,"sn":"referenceRenderer"},{"a":1,"n":"replacementMaterialDict","t":4,"rt":$n[2].Dictionary$2(UnityEngine.Material,UnityEngine.Material),"sn":"replacementMaterialDict"},{"a":2,"n":"replacementMaterials","t":4,"rt":System.Array.type(Spine.Unity.Examples.RenderExistingMesh.MaterialReplacement),"sn":"replacementMaterials"},{"a":1,"n":"sharedMaterials","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"sharedMaterials"},{"a":1,"n":"updateViaSkeletonCallback","t":4,"rt":$n[0].Boolean,"sn":"updateViaSkeletonCallback","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.Examples.RenderExistingMesh end.*/

    /*Spine.Unity.Examples.RenderExistingMesh+MaterialReplacement start.*/
    $m("Spine.Unity.Examples.RenderExistingMesh.MaterialReplacement", function () { return {"td":$n[12].RenderExistingMesh,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"originalMaterial","t":4,"rt":$n[3].Material,"sn":"originalMaterial"},{"a":2,"n":"replacementMaterial","t":4,"rt":$n[3].Material,"sn":"replacementMaterial"}]}; }, $n);
    /*Spine.Unity.Examples.RenderExistingMesh+MaterialReplacement end.*/

    /*Spine.Unity.Examples.RootMotionDeltaCompensation start.*/
    $m("Spine.Unity.Examples.RootMotionDeltaCompensation", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AdjustDelta","t":8,"sn":"AdjustDelta","rt":$n[0].Void},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"adjustX","t":4,"rt":$n[0].Boolean,"sn":"adjustX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"adjustY","t":4,"rt":$n[0].Boolean,"sn":"adjustY","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"allowXTranslation","t":4,"rt":$n[0].Boolean,"sn":"allowXTranslation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"allowYTranslation","t":4,"rt":$n[0].Boolean,"sn":"allowYTranslation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"maxScaleX","t":4,"rt":$n[0].Single,"sn":"maxScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"maxScaleY","t":4,"rt":$n[0].Single,"sn":"maxScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"minScaleX","t":4,"rt":$n[0].Single,"sn":"minScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"minScaleY","t":4,"rt":$n[0].Single,"sn":"minScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"rootMotion","t":4,"rt":$n[1].SkeletonRootMotionBase,"sn":"rootMotion"},{"a":2,"n":"targetPosition","t":4,"rt":$n[3].Transform,"sn":"targetPosition"},{"a":2,"n":"trackIndex","t":4,"rt":$n[0].Int32,"sn":"trackIndex","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.Unity.Examples.RootMotionDeltaCompensation end.*/

    /*Spine.Unity.Examples.JitterEffectExample start.*/
    $m("Spine.Unity.Examples.JitterEffectExample", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"ProcessVertices","t":8,"pi":[{"n":"buffers","pt":$n[1].MeshGeneratorBuffers,"ps":0}],"sn":"ProcessVertices","rt":$n[0].Void,"p":[$n[1].MeshGeneratorBuffers]},{"at":[new UnityEngine.RangeAttribute(0.0, 0.8)],"a":2,"n":"jitterMagnitude","t":4,"rt":$n[0].Single,"sn":"jitterMagnitude","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"skeletonRenderer","t":4,"rt":$n[1].SkeletonRenderer,"sn":"skeletonRenderer"}]}; }, $n);
    /*Spine.Unity.Examples.JitterEffectExample end.*/

    /*Spine.Unity.Examples.TwoByTwoTransformEffectExample start.*/
    $m("Spine.Unity.Examples.TwoByTwoTransformEffectExample", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"ProcessVertices","t":8,"pi":[{"n":"buffers","pt":$n[1].MeshGeneratorBuffers,"ps":0}],"sn":"ProcessVertices","rt":$n[0].Void,"p":[$n[1].MeshGeneratorBuffers]},{"a":1,"n":"skeletonRenderer","t":4,"rt":$n[1].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":2,"n":"xAxis","t":4,"rt":$n[3].Vector2,"sn":"xAxis"},{"a":2,"n":"yAxis","t":4,"rt":$n[3].Vector2,"sn":"yAxis"}]}; }, $n);
    /*Spine.Unity.Examples.TwoByTwoTransformEffectExample end.*/

    /*Spine.Unity.Examples.SkeletonGraphicMirror start.*/
    $m("Spine.Unity.Examples.SkeletonGraphicMirror", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":2,"n":"RestoreIndependentSkeleton","t":8,"sn":"RestoreIndependentSkeleton","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"StartMirroring","t":8,"sn":"StartMirroring","rt":$n[0].Void},{"a":2,"n":"UpdateTexture","t":8,"pi":[{"n":"newOverrideTexture","pt":$n[3].Texture2D,"ps":0}],"sn":"UpdateTexture","rt":$n[0].Void,"p":[$n[3].Texture2D]},{"a":2,"n":"mirrorOnStart","t":4,"rt":$n[0].Boolean,"sn":"mirrorOnStart","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"originalFreeze","t":4,"rt":$n[0].Boolean,"sn":"originalFreeze","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"originalSkeleton","t":4,"rt":$n[5].Skeleton,"sn":"originalSkeleton"},{"a":1,"n":"overrideTexture","t":4,"rt":$n[3].Texture2D,"sn":"overrideTexture"},{"a":2,"n":"restoreOnDisable","t":4,"rt":$n[0].Boolean,"sn":"restoreOnDisable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"skeletonGraphic","t":4,"rt":$n[1].SkeletonGraphic,"sn":"skeletonGraphic"},{"a":2,"n":"source","t":4,"rt":$n[1].SkeletonRenderer,"sn":"source"}]}; }, $n);
    /*Spine.Unity.Examples.SkeletonGraphicMirror end.*/

    /*Spine.Unity.Examples.SkeletonGraphicRenderTexture start.*/
    $m("Spine.Unity.Examples.SkeletonGraphicRenderTexture", function () { return {"nested":[$n[12].SkeletonGraphicRenderTexture.TextureMaterialPair],"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(Spine.Unity.SkeletonGraphic)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":3,"n":"AssignMeshAtRenderer","t":8,"sn":"AssignMeshAtRenderer","rt":$n[0].Void},{"ov":true,"a":3,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"CreateQuadChild","t":8,"sn":"CreateQuadChild","rt":$n[0].Void},{"a":3,"n":"MeshRendererMaterialForTexture","t":8,"pi":[{"n":"texture","pt":$n[3].Texture,"ps":0}],"sn":"MeshRendererMaterialForTexture","rt":$n[3].Material,"p":[$n[3].Texture]},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":3,"n":"PrepareCommandBuffer","t":8,"pi":[{"n":"targetCamera","pt":$n[3].Camera,"ps":0},{"n":"screenSpaceMin","pt":$n[3].Vector3,"ps":1},{"n":"screenSpaceMax","pt":$n[3].Vector3,"ps":2}],"sn":"PrepareCommandBuffer","rt":$n[0].Void,"p":[$n[3].Camera,$n[3].Vector3,$n[3].Vector3]},{"a":3,"n":"PrepareForMesh","t":8,"sn":"PrepareForMesh","rt":$n[0].Void},{"a":1,"n":"PrepareQuad","t":8,"pi":[{"n":"instruction","pt":$n[1].SkeletonRendererInstruction,"ps":0}],"sn":"PrepareQuad","rt":$n[0].Void,"p":[$n[1].SkeletonRendererInstruction]},{"a":3,"n":"RenderMultipleMeshesToRenderTexture","t":8,"pi":[{"n":"meshCount","pt":$n[0].Int32,"ps":0},{"n":"meshes","pt":System.Array.type(UnityEngine.Mesh),"ps":1},{"n":"graphicMaterials","pt":System.Array.type(UnityEngine.Material),"ps":2},{"n":"textures","pt":System.Array.type(UnityEngine.Texture),"ps":3}],"sn":"RenderMultipleMeshesToRenderTexture","rt":$n[0].Void,"p":[$n[0].Int32,System.Array.type(UnityEngine.Mesh),System.Array.type(UnityEngine.Material),System.Array.type(UnityEngine.Texture)]},{"a":1,"n":"RenderOntoQuad","t":8,"pi":[{"n":"skeletonRenderer","pt":$n[1].SkeletonGraphic,"ps":0}],"sn":"RenderOntoQuad","rt":$n[0].Void,"p":[$n[1].SkeletonGraphic]},{"a":3,"n":"RenderSingleMeshToRenderTexture","t":8,"pi":[{"n":"mesh","pt":$n[3].Mesh,"ps":0},{"n":"graphicMaterial","pt":$n[3].Material,"ps":1},{"n":"texture","pt":$n[3].Texture,"ps":2}],"sn":"RenderSingleMeshToRenderTexture","rt":$n[0].Void,"p":[$n[3].Mesh,$n[3].Material,$n[3].Texture]},{"a":1,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"a":3,"n":"SetupQuad","t":8,"sn":"SetupQuad","rt":$n[0].Void},{"a":2,"n":"customRenderRect","t":4,"rt":$n[3].RectTransform,"sn":"customRenderRect"},{"a":2,"n":"meshRendererMaterialForTexture","t":4,"rt":$n[2].List$1(Spine.Unity.Examples.SkeletonGraphicRenderTexture.TextureMaterialPair),"sn":"meshRendererMaterialForTexture"},{"a":3,"n":"quadCanvasRenderer","t":4,"rt":$n[3].CanvasRenderer,"sn":"quadCanvasRenderer"},{"a":3,"n":"quadRawImage","t":4,"rt":$n[7].RawImage,"sn":"quadRawImage"},{"a":3,"n":"skeletonGraphic","t":4,"rt":$n[1].SkeletonGraphic,"sn":"skeletonGraphic"},{"a":3,"n":"worldCorners","t":4,"rt":System.Array.type(UnityEngine.Vector3),"sn":"worldCorners","ro":true}]}; }, $n);
    /*Spine.Unity.Examples.SkeletonGraphicRenderTexture end.*/

    /*Spine.Unity.Examples.SkeletonGraphicRenderTexture+TextureMaterialPair start.*/
    $m("Spine.Unity.Examples.SkeletonGraphicRenderTexture.TextureMaterialPair", function () { return {"td":$n[12].SkeletonGraphicRenderTexture,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[3].Texture,$n[3].Material],"pi":[{"n":"texture","pt":$n[3].Texture,"ps":0},{"n":"material","pt":$n[3].Material,"ps":1}],"sn":"$ctor1"},{"a":2,"n":"material","t":4,"rt":$n[3].Material,"sn":"material"},{"a":2,"n":"texture","t":4,"rt":$n[3].Texture,"sn":"texture"}]}; }, $n);
    /*Spine.Unity.Examples.SkeletonGraphicRenderTexture+TextureMaterialPair end.*/

    /*Spine.Unity.Examples.SkeletonRenderTexture start.*/
    $m("Spine.Unity.Examples.SkeletonRenderTexture", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(Spine.Unity.SkeletonRenderer)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":3,"n":"AssignMeshAtRenderer","t":8,"sn":"AssignMeshAtRenderer","rt":$n[0].Void},{"ov":true,"a":3,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"CreateQuadChild","t":8,"sn":"CreateQuadChild","rt":$n[0].Void},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":3,"n":"PrepareCommandBuffer","t":8,"pi":[{"n":"targetCamera","pt":$n[3].Camera,"ps":0},{"n":"screenSpaceMin","pt":$n[3].Vector3,"ps":1},{"n":"screenSpaceMax","pt":$n[3].Vector3,"ps":2}],"sn":"PrepareCommandBuffer","rt":$n[0].Void,"p":[$n[3].Camera,$n[3].Vector3,$n[3].Vector3]},{"a":3,"n":"PrepareForMesh","t":8,"sn":"PrepareForMesh","rt":$n[0].Void},{"a":1,"n":"RenderOntoQuad","t":8,"pi":[{"n":"skeletonRenderer","pt":$n[1].SkeletonRenderer,"ps":0}],"sn":"RenderOntoQuad","rt":$n[0].Void,"p":[$n[1].SkeletonRenderer]},{"a":3,"n":"RenderToRenderTexture","t":8,"sn":"RenderToRenderTexture","rt":$n[0].Void},{"a":1,"n":"materials","t":4,"rt":$n[2].List$1(UnityEngine.Material),"sn":"materials","ro":true},{"a":3,"n":"meshFilter","t":4,"rt":$n[3].MeshFilter,"sn":"meshFilter"},{"a":3,"n":"meshRenderer","t":4,"rt":$n[3].MeshRenderer,"sn":"meshRenderer"},{"a":1,"n":"propertyBlock","t":4,"rt":$n[3].MaterialPropertyBlock,"sn":"propertyBlock"},{"a":2,"n":"quadMaterial","t":4,"rt":$n[3].Material,"sn":"quadMaterial"},{"a":3,"n":"quadMeshFilter","t":4,"rt":$n[3].MeshFilter,"sn":"quadMeshFilter"},{"a":3,"n":"quadMeshRenderer","t":4,"rt":$n[3].MeshRenderer,"sn":"quadMeshRenderer"},{"a":3,"n":"skeletonRenderer","t":4,"rt":$n[1].SkeletonRenderer,"sn":"skeletonRenderer"}]}; }, $n);
    /*Spine.Unity.Examples.SkeletonRenderTexture end.*/

    /*Spine.Unity.Examples.SkeletonRenderTextureBase start.*/
    $m("Spine.Unity.Examples.SkeletonRenderTextureBase", function () { return {"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":3,"n":"AssignAtQuad","t":8,"sn":"AssignAtQuad","rt":$n[0].Void},{"ab":true,"a":3,"n":"AssignMeshAtRenderer","t":8,"sn":"AssignMeshAtRenderer","rt":$n[0].Void},{"v":true,"a":3,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":3,"n":"PrepareRenderTexture","t":8,"sn":"PrepareRenderTexture","rt":$n[0].Void},{"a":3,"n":"PrepareTextureMapping","t":8,"pi":[{"n":"screenSpaceMin","out":true,"pt":$n[3].Vector3,"ps":0},{"n":"screenSpaceMax","out":true,"pt":$n[3].Vector3,"ps":1},{"n":"screenCorner0","pt":$n[3].Vector3,"ps":2},{"n":"screenCorner1","pt":$n[3].Vector3,"ps":3},{"n":"screenCorner2","pt":$n[3].Vector3,"ps":4},{"n":"screenCorner3","pt":$n[3].Vector3,"ps":5}],"sn":"PrepareTextureMapping","rt":$n[0].Void,"p":[$n[3].Vector3,$n[3].Vector3,$n[3].Vector3,$n[3].Vector3,$n[3].Vector3,$n[3].Vector3]},{"a":3,"n":"allocatedRenderTextureSize","t":4,"rt":$n[3].Vector2Int,"sn":"allocatedRenderTextureSize"},{"a":2,"n":"color","t":4,"rt":$n[3].Color,"sn":"color"},{"a":3,"n":"commandBuffer","t":4,"rt":$n[8].CommandBuffer,"sn":"commandBuffer"},{"a":3,"n":"downScaleFactor","t":4,"rt":$n[3].Vector2,"sn":"downScaleFactor"},{"a":2,"n":"maxRenderTextureSize","t":4,"rt":$n[0].Int32,"sn":"maxRenderTextureSize","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"quad","t":4,"rt":$n[3].GameObject,"sn":"quad"},{"a":3,"n":"quadMesh","t":4,"rt":$n[3].Mesh,"sn":"quadMesh"},{"a":2,"n":"renderTexture","t":4,"rt":$n[3].RenderTexture,"sn":"renderTexture"},{"a":3,"n":"screenSize","t":4,"rt":$n[3].Vector2Int,"sn":"screenSize"},{"a":2,"n":"targetCamera","t":4,"rt":$n[3].Camera,"sn":"targetCamera"},{"a":3,"n":"usedRenderTextureSize","t":4,"rt":$n[3].Vector2Int,"sn":"usedRenderTextureSize"},{"a":3,"n":"uvCorner0","t":4,"rt":$n[3].Vector2,"sn":"uvCorner0"},{"a":3,"n":"uvCorner1","t":4,"rt":$n[3].Vector2,"sn":"uvCorner1"},{"a":3,"n":"uvCorner2","t":4,"rt":$n[3].Vector2,"sn":"uvCorner2"},{"a":3,"n":"uvCorner3","t":4,"rt":$n[3].Vector2,"sn":"uvCorner3"},{"a":3,"n":"worldCornerNoDistortion0","t":4,"rt":$n[3].Vector3,"sn":"worldCornerNoDistortion0"},{"a":3,"n":"worldCornerNoDistortion1","t":4,"rt":$n[3].Vector3,"sn":"worldCornerNoDistortion1"},{"a":3,"n":"worldCornerNoDistortion2","t":4,"rt":$n[3].Vector3,"sn":"worldCornerNoDistortion2"},{"a":3,"n":"worldCornerNoDistortion3","t":4,"rt":$n[3].Vector3,"sn":"worldCornerNoDistortion3"}]}; }, $n);
    /*Spine.Unity.Examples.SkeletonRenderTextureBase end.*/

    /*Spine.Unity.Examples.SkeletonRenderTextureFadeout start.*/
    $m("Spine.Unity.Examples.SkeletonRenderTextureFadeout", function () { return {"nested":[Function],"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(Spine.Unity.Examples.SkeletonRenderTextureBase)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":3,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":3,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":3,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"fadeoutSeconds","t":4,"rt":$n[0].Single,"sn":"fadeoutSeconds","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":3,"n":"fadeoutSecondsRemaining","t":4,"rt":$n[0].Single,"sn":"fadeoutSecondsRemaining","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"skeletonRenderTexture","t":4,"rt":$n[12].SkeletonRenderTextureBase,"sn":"skeletonRenderTexture"},{"a":2,"n":"OnFadeoutComplete","t":2,"ad":{"a":2,"n":"add_OnFadeoutComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnFadeoutComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnFadeoutComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnFadeoutComplete","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.Examples.SkeletonRenderTextureFadeout end.*/

    /*Spine.Unity.Examples.SkeletonRagdoll start.*/
    $m("Spine.Unity.Examples.SkeletonRagdoll", function () { return {"nested":[$n[12].SkeletonRagdoll.BoneFlipEntry,$n[12].SkeletonRagdoll.LayerFieldAttribute],"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(Spine.Unity.SkeletonRenderer)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Apply","t":8,"sn":"Apply","rt":$n[0].Void},{"a":1,"n":"AttachBoundingBoxRagdollColliders","t":8,"pi":[{"n":"b","pt":$n[5].Bone,"ps":0}],"sn":"AttachBoundingBoxRagdollColliders","rt":$n[2].List$1(UnityEngine.Collider),"p":[$n[5].Bone]},{"a":2,"n":"GetRigidbody","t":8,"pi":[{"n":"boneName","pt":$n[0].String,"ps":0}],"sn":"GetRigidbody","rt":$n[3].Rigidbody,"p":[$n[0].String]},{"a":1,"n":"GetStartBoneParentFlipState","t":8,"pi":[{"n":"parentFlipX","out":true,"pt":$n[0].Boolean,"ps":0},{"n":"parentFlipY","out":true,"pt":$n[0].Boolean,"ps":1}],"sn":"GetStartBoneParentFlipState","rt":$n[0].Void,"p":[$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"RecursivelyCreateBoneProxies","t":8,"pi":[{"n":"b","pt":$n[5].Bone,"ps":0}],"sn":"RecursivelyCreateBoneProxies","rt":$n[0].Void,"p":[$n[5].Bone]},{"a":2,"n":"Remove","t":8,"sn":"Remove","rt":$n[0].Void},{"a":2,"n":"SetSkeletonPosition","t":8,"pi":[{"n":"worldPosition","pt":$n[3].Vector3,"ps":0}],"sn":"SetSkeletonPosition","rt":$n[0].Void,"p":[$n[3].Vector3]},{"a":2,"n":"SmoothMix","t":8,"pi":[{"n":"target","pt":$n[0].Single,"ps":0},{"n":"duration","pt":$n[0].Single,"ps":1}],"sn":"SmoothMix","rt":$n[3].Coroutine,"p":[$n[0].Single,$n[0].Single]},{"a":1,"n":"SmoothMixCoroutine","t":8,"pi":[{"n":"target","pt":$n[0].Single,"ps":0},{"n":"duration","pt":$n[0].Single,"ps":1}],"sn":"SmoothMixCoroutine","rt":$n[4].IEnumerator,"p":[$n[0].Single,$n[0].Single]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[4].IEnumerator},{"a":1,"n":"UpdateSpineSkeleton","t":8,"pi":[{"n":"skeletonRenderer","pt":$n[1].ISkeletonAnimation,"ps":0}],"sn":"UpdateSpineSkeleton","rt":$n[0].Void,"p":[$n[1].ISkeletonAnimation]},{"a":2,"n":"EstimatedSkeletonPosition","t":16,"rt":$n[3].Vector3,"g":{"a":2,"n":"get_EstimatedSkeletonPosition","t":8,"rt":$n[3].Vector3,"fg":"EstimatedSkeletonPosition"},"fn":"EstimatedSkeletonPosition"},{"a":2,"n":"IsActive","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsActive","t":8,"rt":$n[0].Boolean,"fg":"IsActive","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsActive"},{"a":2,"n":"RigidbodyArray","t":16,"rt":System.Array.type(UnityEngine.Rigidbody),"g":{"a":2,"n":"get_RigidbodyArray","t":8,"rt":System.Array.type(UnityEngine.Rigidbody),"fg":"RigidbodyArray"},"fn":"RigidbodyArray"},{"a":2,"n":"RootOffset","t":16,"rt":$n[3].Vector3,"g":{"a":2,"n":"get_RootOffset","t":8,"rt":$n[3].Vector3,"fg":"RootOffset"},"fn":"RootOffset"},{"a":2,"n":"RootRigidbody","t":16,"rt":$n[3].Rigidbody,"g":{"a":2,"n":"get_RootRigidbody","t":8,"rt":$n[3].Rigidbody,"fg":"RootRigidbody"},"s":{"a":1,"n":"set_RootRigidbody","t":8,"p":[$n[3].Rigidbody],"rt":$n[0].Void,"fs":"RootRigidbody"},"fn":"RootRigidbody"},{"a":2,"n":"StartingBone","t":16,"rt":$n[5].Bone,"g":{"a":2,"n":"get_StartingBone","t":8,"rt":$n[5].Bone,"fg":"StartingBone"},"s":{"a":1,"n":"set_StartingBone","t":8,"p":[$n[5].Bone],"rt":$n[0].Void,"fs":"StartingBone"},"fn":"StartingBone"},{"at":[new UnityEngine.HeaderAttribute("Parameters")],"a":2,"n":"applyOnStart","t":4,"rt":$n[0].Boolean,"sn":"applyOnStart","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"boneFlipTable","t":4,"rt":$n[2].Dictionary$2(Spine.Bone,Spine.Unity.Examples.SkeletonRagdoll.BoneFlipEntry),"sn":"boneFlipTable"},{"a":1,"n":"boneTable","t":4,"rt":$n[2].Dictionary$2(Spine.Bone,UnityEngine.Transform),"sn":"boneTable"},{"at":[new UnityEngine.TooltipAttribute("The layer assigned to all of the rigidbody parts.")],"a":2,"n":"colliderLayer","t":4,"rt":$n[0].Int32,"sn":"colliderLayer","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.TooltipAttribute("Warning! You will have to re-enable and tune mix values manually if attempting to remove the ragdoll system.")],"a":2,"n":"disableIK","t":4,"rt":$n[0].Boolean,"sn":"disableIK","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"disableOtherConstraints","t":4,"rt":$n[0].Boolean,"sn":"disableOtherConstraints","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Enable Collision between adjacent ragdoll elements (IE: Neck and Head)")],"a":2,"n":"enableJointCollision","t":4,"rt":$n[0].Boolean,"sn":"enableJointCollision","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"isActive","t":4,"rt":$n[0].Boolean,"sn":"isActive","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("If your ragdoll seems unstable or uneffected by limits, try lowering this value."),new UnityEngine.RangeAttribute(0.01, 1.0)],"a":2,"n":"massFalloffFactor","t":4,"rt":$n[0].Single,"sn":"massFalloffFactor","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.RangeAttribute(0.0, 1.0)],"a":2,"n":"mix","t":4,"rt":$n[0].Single,"sn":"mix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"oldRagdollBehaviour","t":4,"rt":$n[0].Boolean,"sn":"oldRagdollBehaviour","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"parentSpaceHelper","is":true,"t":4,"rt":$n[3].Transform,"sn":"parentSpaceHelper"},{"at":[new UnityEngine.SpaceAttribute.$ctor1(18.0),new UnityEngine.TooltipAttribute("Set RootRigidbody IsKinematic to true when Apply is called.")],"a":2,"n":"pinStartBone","t":4,"rt":$n[0].Boolean,"sn":"pinStartBone","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"ragdollRoot","t":4,"rt":$n[3].Transform,"sn":"ragdollRoot"},{"a":2,"n":"rootMass","t":4,"rt":$n[0].Single,"sn":"rootMass","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"rootOffset","t":4,"rt":$n[3].Vector3,"sn":"rootOffset"},{"at":[new UnityEngine.TooltipAttribute("Default rotational limit value. Min is negative this value, Max is this value.")],"a":2,"n":"rotationLimit","t":4,"rt":$n[0].Single,"sn":"rotationLimit","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"skeleton","t":4,"rt":$n[5].Skeleton,"sn":"skeleton"},{"at":[new UnityEngine.HeaderAttribute("Hierarchy"),new Spine.Unity.SpineBone("", "", true, false)],"a":2,"n":"startingBoneName","t":4,"rt":$n[0].String,"sn":"startingBoneName"},{"at":[new Spine.Unity.SpineBone("", "", true, false)],"a":2,"n":"stopBoneNames","t":4,"rt":$n[2].List$1(System.String),"sn":"stopBoneNames"},{"a":1,"n":"targetSkeletonComponent","t":4,"rt":$n[1].ISkeletonAnimation,"sn":"targetSkeletonComponent"},{"at":[new UnityEngine.TooltipAttribute("If no BoundingBox Attachment is attached to a bone, this becomes the default Width or Radius of a Bone's ragdoll Rigidbody")],"a":2,"n":"thickness","t":4,"rt":$n[0].Single,"sn":"thickness","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"useGravity","t":4,"rt":$n[0].Boolean,"sn":"useGravity","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"backing":true,"n":"<RootRigidbody>k__BackingField","t":4,"rt":$n[3].Rigidbody,"sn":"RootRigidbody"},{"a":1,"backing":true,"n":"<StartingBone>k__BackingField","t":4,"rt":$n[5].Bone,"sn":"StartingBone"}]}; }, $n);
    /*Spine.Unity.Examples.SkeletonRagdoll end.*/

    /*Spine.Unity.Examples.SkeletonRagdoll+BoneFlipEntry start.*/
    $m("Spine.Unity.Examples.SkeletonRagdoll.BoneFlipEntry", function () { return {"td":$n[12].SkeletonRagdoll,"att":1048843,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"flipX","pt":$n[0].Boolean,"ps":0},{"n":"flipY","pt":$n[0].Boolean,"ps":1}],"sn":"$ctor1"},{"a":2,"n":"flipX","t":4,"rt":$n[0].Boolean,"sn":"flipX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"flipY","t":4,"rt":$n[0].Boolean,"sn":"flipY","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.Examples.SkeletonRagdoll+BoneFlipEntry end.*/

    /*Spine.Unity.Examples.SkeletonRagdoll+LayerFieldAttribute start.*/
    $m("Spine.Unity.Examples.SkeletonRagdoll.LayerFieldAttribute", function () { return {"td":$n[12].SkeletonRagdoll,"att":1048578,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*Spine.Unity.Examples.SkeletonRagdoll+LayerFieldAttribute end.*/

    /*Spine.Unity.Examples.SkeletonRagdoll2D start.*/
    $m("Spine.Unity.Examples.SkeletonRagdoll2D", function () { return {"nested":[$n[12].SkeletonRagdoll2D.BoneFlipEntry],"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(Spine.Unity.SkeletonRenderer)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Apply","t":8,"sn":"Apply","rt":$n[0].Void},{"a":1,"n":"AttachBoundingBoxRagdollColliders","is":true,"t":8,"pi":[{"n":"b","pt":$n[5].Bone,"ps":0},{"n":"go","pt":$n[3].GameObject,"ps":1},{"n":"skeleton","pt":$n[5].Skeleton,"ps":2},{"n":"gravityScale","pt":$n[0].Single,"ps":3}],"sn":"AttachBoundingBoxRagdollColliders","rt":$n[2].List$1(UnityEngine.Collider2D),"p":[$n[5].Bone,$n[3].GameObject,$n[5].Skeleton,$n[0].Single]},{"a":1,"n":"FlipScale","is":true,"t":8,"pi":[{"n":"flipX","pt":$n[0].Boolean,"ps":0},{"n":"flipY","pt":$n[0].Boolean,"ps":1}],"sn":"FlipScale","rt":$n[3].Vector3,"p":[$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"GetRigidbody","t":8,"pi":[{"n":"boneName","pt":$n[0].String,"ps":0}],"sn":"GetRigidbody","rt":$n[3].Rigidbody2D,"p":[$n[0].String]},{"a":1,"n":"GetStartBoneParentFlipState","t":8,"pi":[{"n":"parentFlipX","out":true,"pt":$n[0].Boolean,"ps":0},{"n":"parentFlipY","out":true,"pt":$n[0].Boolean,"ps":1}],"sn":"GetStartBoneParentFlipState","rt":$n[0].Void,"p":[$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"RecursivelyCreateBoneProxies","t":8,"pi":[{"n":"b","pt":$n[5].Bone,"ps":0}],"sn":"RecursivelyCreateBoneProxies","rt":$n[0].Void,"p":[$n[5].Bone]},{"a":2,"n":"Remove","t":8,"sn":"Remove","rt":$n[0].Void},{"a":2,"n":"SetSkeletonPosition","t":8,"pi":[{"n":"worldPosition","pt":$n[3].Vector3,"ps":0}],"sn":"SetSkeletonPosition","rt":$n[0].Void,"p":[$n[3].Vector3]},{"a":2,"n":"SmoothMix","t":8,"pi":[{"n":"target","pt":$n[0].Single,"ps":0},{"n":"duration","pt":$n[0].Single,"ps":1}],"sn":"SmoothMix","rt":$n[3].Coroutine,"p":[$n[0].Single,$n[0].Single]},{"a":1,"n":"SmoothMixCoroutine","t":8,"pi":[{"n":"target","pt":$n[0].Single,"ps":0},{"n":"duration","pt":$n[0].Single,"ps":1}],"sn":"SmoothMixCoroutine","rt":$n[4].IEnumerator,"p":[$n[0].Single,$n[0].Single]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[4].IEnumerator},{"a":1,"n":"UpdateSpineSkeleton","t":8,"pi":[{"n":"animatedSkeleton","pt":$n[1].ISkeletonAnimation,"ps":0}],"sn":"UpdateSpineSkeleton","rt":$n[0].Void,"p":[$n[1].ISkeletonAnimation]},{"a":2,"n":"EstimatedSkeletonPosition","t":16,"rt":$n[3].Vector3,"g":{"a":2,"n":"get_EstimatedSkeletonPosition","t":8,"rt":$n[3].Vector3,"fg":"EstimatedSkeletonPosition"},"fn":"EstimatedSkeletonPosition"},{"a":2,"n":"IsActive","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsActive","t":8,"rt":$n[0].Boolean,"fg":"IsActive","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsActive"},{"a":2,"n":"RigidbodyArray","t":16,"rt":System.Array.type(UnityEngine.Rigidbody2D),"g":{"a":2,"n":"get_RigidbodyArray","t":8,"rt":System.Array.type(UnityEngine.Rigidbody2D),"fg":"RigidbodyArray"},"fn":"RigidbodyArray"},{"a":2,"n":"RootOffset","t":16,"rt":$n[3].Vector3,"g":{"a":2,"n":"get_RootOffset","t":8,"rt":$n[3].Vector3,"fg":"RootOffset"},"fn":"RootOffset"},{"a":2,"n":"RootRigidbody","t":16,"rt":$n[3].Rigidbody2D,"g":{"a":2,"n":"get_RootRigidbody","t":8,"rt":$n[3].Rigidbody2D,"fg":"RootRigidbody"},"s":{"a":1,"n":"set_RootRigidbody","t":8,"p":[$n[3].Rigidbody2D],"rt":$n[0].Void,"fs":"RootRigidbody"},"fn":"RootRigidbody"},{"a":2,"n":"StartingBone","t":16,"rt":$n[5].Bone,"g":{"a":2,"n":"get_StartingBone","t":8,"rt":$n[5].Bone,"fg":"StartingBone"},"s":{"a":1,"n":"set_StartingBone","t":8,"p":[$n[5].Bone],"rt":$n[0].Void,"fs":"StartingBone"},"fn":"StartingBone"},{"at":[new UnityEngine.HeaderAttribute("Parameters")],"a":2,"n":"applyOnStart","t":4,"rt":$n[0].Boolean,"sn":"applyOnStart","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"boneFlipTable","t":4,"rt":$n[2].Dictionary$2(Spine.Bone,Spine.Unity.Examples.SkeletonRagdoll2D.BoneFlipEntry),"sn":"boneFlipTable"},{"a":1,"n":"boneTable","t":4,"rt":$n[2].Dictionary$2(Spine.Bone,UnityEngine.Transform),"sn":"boneTable"},{"at":[new UnityEngine.TooltipAttribute("The layer assigned to all of the rigidbody parts."),new Spine.Unity.Examples.SkeletonRagdoll.LayerFieldAttribute()],"a":2,"n":"colliderLayer","t":4,"rt":$n[0].Int32,"sn":"colliderLayer","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.TooltipAttribute("Warning! You will have to re-enable and tune mix values manually if attempting to remove the ragdoll system.")],"a":2,"n":"disableIK","t":4,"rt":$n[0].Boolean,"sn":"disableIK","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"disableOtherConstraints","t":4,"rt":$n[0].Boolean,"sn":"disableOtherConstraints","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"gravityScale","t":4,"rt":$n[0].Single,"sn":"gravityScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"isActive","t":4,"rt":$n[0].Boolean,"sn":"isActive","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("If your ragdoll seems unstable or uneffected by limits, try lowering this value."),new UnityEngine.RangeAttribute(0.01, 1.0)],"a":2,"n":"massFalloffFactor","t":4,"rt":$n[0].Single,"sn":"massFalloffFactor","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.RangeAttribute(0.0, 1.0)],"a":2,"n":"mix","t":4,"rt":$n[0].Single,"sn":"mix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"oldRagdollBehaviour","t":4,"rt":$n[0].Boolean,"sn":"oldRagdollBehaviour","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"parentSpaceHelper","is":true,"t":4,"rt":$n[3].Transform,"sn":"parentSpaceHelper"},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.TooltipAttribute("Set RootRigidbody IsKinematic to true when Apply is called.")],"a":2,"n":"pinStartBone","t":4,"rt":$n[0].Boolean,"sn":"pinStartBone","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"ragdollRoot","t":4,"rt":$n[3].Transform,"sn":"ragdollRoot"},{"a":2,"n":"rootMass","t":4,"rt":$n[0].Single,"sn":"rootMass","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"rootOffset","t":4,"rt":$n[3].Vector2,"sn":"rootOffset"},{"at":[new UnityEngine.TooltipAttribute("Default rotational limit value. Min is negative this value, Max is this value.")],"a":2,"n":"rotationLimit","t":4,"rt":$n[0].Single,"sn":"rotationLimit","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"skeleton","t":4,"rt":$n[5].Skeleton,"sn":"skeleton"},{"at":[new UnityEngine.HeaderAttribute("Hierarchy"),new Spine.Unity.SpineBone("", "", true, false)],"a":2,"n":"startingBoneName","t":4,"rt":$n[0].String,"sn":"startingBoneName"},{"at":[new Spine.Unity.SpineBone("", "", true, false)],"a":2,"n":"stopBoneNames","t":4,"rt":$n[2].List$1(System.String),"sn":"stopBoneNames"},{"a":1,"n":"targetSkeletonComponent","t":4,"rt":$n[1].ISkeletonAnimation,"sn":"targetSkeletonComponent"},{"at":[new UnityEngine.TooltipAttribute("If no BoundingBox Attachment is attached to a bone, this becomes the default Width or Radius of a Bone's ragdoll Rigidbody")],"a":2,"n":"thickness","t":4,"rt":$n[0].Single,"sn":"thickness","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"backing":true,"n":"<RootRigidbody>k__BackingField","t":4,"rt":$n[3].Rigidbody2D,"sn":"RootRigidbody"},{"a":1,"backing":true,"n":"<StartingBone>k__BackingField","t":4,"rt":$n[5].Bone,"sn":"StartingBone"}]}; }, $n);
    /*Spine.Unity.Examples.SkeletonRagdoll2D end.*/

    /*Spine.Unity.Examples.SkeletonRagdoll2D+BoneFlipEntry start.*/
    $m("Spine.Unity.Examples.SkeletonRagdoll2D.BoneFlipEntry", function () { return {"td":$n[12].SkeletonRagdoll2D,"att":1048843,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"flipX","pt":$n[0].Boolean,"ps":0},{"n":"flipY","pt":$n[0].Boolean,"ps":1}],"sn":"$ctor1"},{"a":2,"n":"flipX","t":4,"rt":$n[0].Boolean,"sn":"flipX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"flipY","t":4,"rt":$n[0].Boolean,"sn":"flipY","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.Examples.SkeletonRagdoll2D+BoneFlipEntry end.*/

    /*Spine.Unity.Examples.SkeletonUtilityEyeConstraint start.*/
    $m("Spine.Unity.Examples.SkeletonUtilityEyeConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"DoUpdate","t":8,"sn":"DoUpdate","rt":$n[0].Void},{"ov":true,"a":3,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"ov":true,"a":3,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"centerPoint","t":4,"rt":$n[3].Vector3,"sn":"centerPoint"},{"a":2,"n":"eyes","t":4,"rt":System.Array.type(UnityEngine.Transform),"sn":"eyes"},{"a":1,"n":"origins","t":4,"rt":System.Array.type(UnityEngine.Vector3),"sn":"origins"},{"a":2,"n":"radius","t":4,"rt":$n[0].Single,"sn":"radius","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"speed","t":4,"rt":$n[0].Single,"sn":"speed","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"target","t":4,"rt":$n[3].Transform,"sn":"target"},{"a":2,"n":"targetPosition","t":4,"rt":$n[3].Vector3,"sn":"targetPosition"}]}; }, $n);
    /*Spine.Unity.Examples.SkeletonUtilityEyeConstraint end.*/

    /*Spine.Unity.Examples.SkeletonUtilityGroundConstraint start.*/
    $m("Spine.Unity.Examples.SkeletonUtilityGroundConstraint", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.ctor(Spine.Unity.SkeletonUtilityBone)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"DoUpdate","t":8,"sn":"DoUpdate","rt":$n[0].Void},{"a":1,"n":"OnDrawGizmos","t":8,"sn":"OnDrawGizmos","rt":$n[0].Void},{"ov":true,"a":3,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"at":[new UnityEngine.TooltipAttribute("How fast the target IK position adjusts to the ground. Use smaller values to prevent snapping")],"a":2,"n":"adjustSpeed","t":4,"rt":$n[0].Single,"sn":"adjustSpeed","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("How high above the target bone to begin casting from")],"a":2,"n":"castDistance","t":4,"rt":$n[0].Single,"sn":"castDistance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("X-Axis adjustment")],"a":2,"n":"castOffset","t":4,"rt":$n[0].Single,"sn":"castOffset","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("The Radius")],"a":2,"n":"castRadius","t":4,"rt":$n[0].Single,"sn":"castRadius","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("LayerMask for what objects to raycast against")],"a":2,"n":"groundMask","t":4,"rt":$n[3].LayerMask,"sn":"groundMask"},{"at":[new UnityEngine.TooltipAttribute("Y-Axis adjustment")],"a":2,"n":"groundOffset","t":4,"rt":$n[0].Single,"sn":"groundOffset","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"hitY","t":4,"rt":$n[0].Single,"sn":"hitY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"lastHitY","t":4,"rt":$n[0].Single,"sn":"lastHitY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"rayDir","t":4,"rt":$n[3].Vector3,"sn":"rayDir"},{"a":1,"n":"rayOrigin","t":4,"rt":$n[3].Vector3,"sn":"rayOrigin"},{"at":[new UnityEngine.TooltipAttribute("Use 2D")],"a":2,"n":"use2D","t":4,"rt":$n[0].Boolean,"sn":"use2D","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Uses SphereCast for 3D mode and CircleCast for 2D mode")],"a":2,"n":"useRadius","t":4,"rt":$n[0].Boolean,"sn":"useRadius","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.Examples.SkeletonUtilityGroundConstraint end.*/

    /*Spine.Unity.Examples.SkeletonUtilityKinematicShadow start.*/
    $m("Spine.Unity.Examples.SkeletonUtilityKinematicShadow", function () { return {"nested":[$n[12].SkeletonUtilityKinematicShadow.TransformPair,$n[12].SkeletonUtilityKinematicShadow.PhysicsSystem],"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"DestroyComponents","is":true,"t":8,"pi":[{"n":"components","pt":System.Array.type(UnityEngine.Component),"ps":0}],"sn":"DestroyComponents","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.Component)]},{"a":1,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"at":[new UnityEngine.TooltipAttribute("If checked, the hinge chain can inherit your root transform's velocity or position/rotation changes.")],"a":2,"n":"detachedShadow","t":4,"rt":$n[0].Boolean,"sn":"detachedShadow","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"hideShadow","t":4,"rt":$n[0].Boolean,"sn":"hideShadow","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"parent","t":4,"rt":$n[3].Transform,"sn":"parent"},{"a":2,"n":"physicsSystem","t":4,"rt":$n[12].SkeletonUtilityKinematicShadow.PhysicsSystem,"sn":"physicsSystem","box":function ($v) { return Bridge.box($v, Spine.Unity.Examples.SkeletonUtilityKinematicShadow.PhysicsSystem, System.Enum.toStringFn(Spine.Unity.Examples.SkeletonUtilityKinematicShadow.PhysicsSystem));}},{"a":1,"n":"shadowRoot","t":4,"rt":$n[3].GameObject,"sn":"shadowRoot"},{"a":1,"n":"shadowTable","t":4,"rt":$n[2].List$1(Spine.Unity.Examples.SkeletonUtilityKinematicShadow.TransformPair),"sn":"shadowTable","ro":true}]}; }, $n);
    /*Spine.Unity.Examples.SkeletonUtilityKinematicShadow end.*/

    /*Spine.Unity.Examples.SkeletonUtilityKinematicShadow+TransformPair start.*/
    $m("Spine.Unity.Examples.SkeletonUtilityKinematicShadow.TransformPair", function () { return {"td":$n[12].SkeletonUtilityKinematicShadow,"att":1048843,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"dest","t":4,"rt":$n[3].Transform,"sn":"dest"},{"a":2,"n":"src","t":4,"rt":$n[3].Transform,"sn":"src"}]}; }, $n);
    /*Spine.Unity.Examples.SkeletonUtilityKinematicShadow+TransformPair end.*/

    /*Spine.Unity.Examples.SkeletonUtilityKinematicShadow+PhysicsSystem start.*/
    $m("Spine.Unity.Examples.SkeletonUtilityKinematicShadow.PhysicsSystem", function () { return {"td":$n[12].SkeletonUtilityKinematicShadow,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Physics2D","is":true,"t":4,"rt":$n[12].SkeletonUtilityKinematicShadow.PhysicsSystem,"sn":"Physics2D","box":function ($v) { return Bridge.box($v, Spine.Unity.Examples.SkeletonUtilityKinematicShadow.PhysicsSystem, System.Enum.toStringFn(Spine.Unity.Examples.SkeletonUtilityKinematicShadow.PhysicsSystem));}},{"a":2,"n":"Physics3D","is":true,"t":4,"rt":$n[12].SkeletonUtilityKinematicShadow.PhysicsSystem,"sn":"Physics3D","box":function ($v) { return Bridge.box($v, Spine.Unity.Examples.SkeletonUtilityKinematicShadow.PhysicsSystem, System.Enum.toStringFn(Spine.Unity.Examples.SkeletonUtilityKinematicShadow.PhysicsSystem));}}]}; }, $n);
    /*Spine.Unity.Examples.SkeletonUtilityKinematicShadow+PhysicsSystem end.*/

    /*Spine.Unity.Examples.SlotTintBlackFollower start.*/
    $m("Spine.Unity.Examples.SlotTintBlackFollower", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","pt":$n[0].Boolean,"ps":0}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":1,"n":"blackPropertyId","t":4,"rt":$n[0].Int32,"sn":"blackPropertyId","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"blackPropertyName","t":4,"rt":$n[0].String,"sn":"blackPropertyName"},{"a":1,"n":"colorPropertyId","t":4,"rt":$n[0].Int32,"sn":"colorPropertyId","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"colorPropertyName","t":4,"rt":$n[0].String,"sn":"colorPropertyName"},{"a":1,"n":"mb","t":4,"rt":$n[3].MaterialPropertyBlock,"sn":"mb"},{"a":1,"n":"mr","t":4,"rt":$n[3].MeshRenderer,"sn":"mr"},{"a":2,"n":"slot","t":4,"rt":$n[5].Slot,"sn":"slot"},{"at":[new Spine.Unity.SpineSlot("", "", false, true, false),new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"slotName","t":4,"rt":$n[0].String,"sn":"slotName"}]}; }, $n);
    /*Spine.Unity.Examples.SlotTintBlackFollower end.*/

    /*Spine.Unity.Examples.SpawnFromSkeletonDataExample start.*/
    $m("Spine.Unity.Examples.SpawnFromSkeletonDataExample", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"DoExtraStuff","t":8,"pi":[{"n":"sa","pt":$n[1].SkeletonAnimation,"ps":0},{"n":"spineAnimation","pt":$n[5].Animation,"ps":1}],"sn":"DoExtraStuff","rt":$n[0].Void,"p":[$n[1].SkeletonAnimation,$n[5].Animation]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[4].IEnumerator},{"at":[new UnityEngine.RangeAttribute(0.0, 100.0)],"a":2,"n":"count","t":4,"rt":$n[0].Int32,"sn":"count","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"skeletonDataAsset","t":4,"rt":$n[1].SkeletonDataAsset,"sn":"skeletonDataAsset"},{"at":[new Spine.Unity.SpineAnimation("", "skeletonDataAsset", true, false)],"a":2,"n":"startingAnimation","t":4,"rt":$n[0].String,"sn":"startingAnimation"}]}; }, $n);
    /*Spine.Unity.Examples.SpawnFromSkeletonDataExample end.*/

    /*Spine.Unity.Examples.SpawnSkeletonGraphicExample start.*/
    $m("Spine.Unity.Examples.SpawnSkeletonGraphicExample", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[4].IEnumerator},{"a":2,"n":"skeletonDataAsset","t":4,"rt":$n[1].SkeletonDataAsset,"sn":"skeletonDataAsset"},{"a":2,"n":"skeletonGraphicMaterial","t":4,"rt":$n[3].Material,"sn":"skeletonGraphicMaterial"},{"at":[new Spine.Unity.SpineAnimation("", "skeletonDataAsset", true, false)],"a":2,"n":"startingAnimation","t":4,"rt":$n[0].String,"sn":"startingAnimation"},{"at":[new Spine.Unity.SpineSkin("", "skeletonDataAsset", true, false, false)],"a":2,"n":"startingSkin","t":4,"rt":$n[0].String,"sn":"startingSkin"}]}; }, $n);
    /*Spine.Unity.Examples.SpawnSkeletonGraphicExample end.*/

    /*Spine.Unity.Examples.Spineboy start.*/
    $m("Spine.Unity.Examples.Spineboy", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"HandleEvent","t":8,"pi":[{"n":"trackEntry","pt":$n[5].TrackEntry,"ps":0},{"n":"e","pt":spine.Event,"ps":1}],"sn":"HandleEvent","rt":$n[0].Void,"p":[$n[5].TrackEntry,spine.Event]},{"a":2,"n":"OnMouseDown","t":8,"sn":"OnMouseDown","rt":$n[0].Void},{"a":2,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"skeletonAnimation","t":4,"rt":$n[1].SkeletonAnimation,"sn":"skeletonAnimation"}]}; }, $n);
    /*Spine.Unity.Examples.Spineboy end.*/

    /*Spine.Unity.Examples.SpineboyBodyTilt start.*/
    $m("Spine.Unity.Examples.SpineboyBodyTilt", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"UpdateLocal","t":8,"pi":[{"n":"animated","pt":$n[1].ISkeletonAnimation,"ps":0}],"sn":"UpdateLocal","rt":$n[0].Void,"p":[$n[1].ISkeletonAnimation]},{"a":2,"n":"baseHeadRotation","t":4,"rt":$n[0].Single,"sn":"baseHeadRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new Spine.Unity.SpineBone("", "", true, false)],"a":2,"n":"head","t":4,"rt":$n[0].String,"sn":"head"},{"a":1,"n":"headBone","t":4,"rt":$n[5].Bone,"sn":"headBone"},{"a":2,"n":"headTiltScale","t":4,"rt":$n[0].Single,"sn":"headTiltScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new Spine.Unity.SpineBone("", "", true, false)],"a":2,"n":"hip","t":4,"rt":$n[0].String,"sn":"hip"},{"a":1,"n":"hipBone","t":4,"rt":$n[5].Bone,"sn":"hipBone"},{"a":2,"n":"hipRotationMoveScale","t":4,"rt":$n[0].Single,"sn":"hipRotationMoveScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"hipRotationSmoothed","t":4,"rt":$n[0].Single,"sn":"hipRotationSmoothed","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.HeaderAttribute("Debug")],"a":2,"n":"hipRotationTarget","t":4,"rt":$n[0].Single,"sn":"hipRotationTarget","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"hipTiltScale","t":4,"rt":$n[0].Single,"sn":"hipTiltScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.HeaderAttribute("Settings")],"a":2,"n":"planter","t":4,"rt":$n[12].SpineboyFootplanter,"sn":"planter"}]}; }, $n);
    /*Spine.Unity.Examples.SpineboyBodyTilt end.*/

    /*Spine.Unity.Examples.SpineboyFacialExpression start.*/
    $m("Spine.Unity.Examples.SpineboyFacialExpression", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"balanceThreshold","t":4,"rt":$n[0].Single,"sn":"balanceThreshold","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"eyeSlot","t":4,"rt":$n[5].Slot,"sn":"eyeSlot"},{"at":[new Spine.Unity.SpineSlot("", "", false, true, false)],"a":2,"n":"eyeSlotName","t":4,"rt":$n[0].String,"sn":"eyeSlotName"},{"a":2,"n":"footPlanter","t":4,"rt":$n[12].SpineboyFootplanter,"sn":"footPlanter"},{"a":2,"n":"mouthSlot","t":4,"rt":$n[5].Slot,"sn":"mouthSlot"},{"at":[new Spine.Unity.SpineSlot("", "", false, true, false)],"a":2,"n":"mouthSlotName","t":4,"rt":$n[0].String,"sn":"mouthSlotName"},{"a":2,"n":"normalEye","t":4,"rt":spine.Attachment,"sn":"normalEye"},{"at":[new Spine.Unity.SpineAttachment(true, false, false, "eyeSlotName", "", "", true, false)],"a":2,"n":"normalEyeName","t":4,"rt":$n[0].String,"sn":"normalEyeName"},{"a":2,"n":"normalMouth","t":4,"rt":spine.Attachment,"sn":"normalMouth"},{"at":[new Spine.Unity.SpineAttachment(true, false, false, "mouthSlotName", "", "", true, false)],"a":2,"n":"normalMouthName","t":4,"rt":$n[0].String,"sn":"normalMouthName"},{"a":2,"n":"shockDuration","t":4,"rt":$n[0].Single,"sn":"shockDuration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"shockEye","t":4,"rt":spine.Attachment,"sn":"shockEye"},{"at":[new Spine.Unity.SpineAttachment(true, false, false, "eyeSlotName", "", "", true, false)],"a":2,"n":"shockEyeName","t":4,"rt":$n[0].String,"sn":"shockEyeName"},{"a":2,"n":"shockMouth","t":4,"rt":spine.Attachment,"sn":"shockMouth"},{"at":[new Spine.Unity.SpineAttachment(true, false, false, "mouthSlotName", "", "", true, false)],"a":2,"n":"shockMouthName","t":4,"rt":$n[0].String,"sn":"shockMouthName"},{"at":[new UnityEngine.HeaderAttribute("Debug")],"a":2,"n":"shockTimer","t":4,"rt":$n[0].Single,"sn":"shockTimer","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Unity.Examples.SpineboyFacialExpression end.*/

    /*Spine.Unity.Examples.SpineboyFootplanter start.*/
    $m("Spine.Unity.Examples.SpineboyFootplanter", function () { return {"nested":[$n[12].SpineboyFootplanter.FootMovement,$n[12].SpineboyFootplanter.Foot],"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnDrawGizmos","t":8,"sn":"OnDrawGizmos","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"UpdateLocal","t":8,"pi":[{"n":"animated","pt":$n[1].ISkeletonAnimation,"ps":0}],"sn":"UpdateLocal","rt":$n[0].Void,"p":[$n[1].ISkeletonAnimation]},{"a":2,"n":"Balance","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Balance","t":8,"rt":$n[0].Single,"fg":"Balance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"Balance"},{"a":2,"n":"backward","t":4,"rt":$n[12].SpineboyFootplanter.FootMovement,"sn":"backward"},{"at":[new UnityEngine.HeaderAttribute("Debug"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"balance","t":4,"rt":$n[0].Single,"sn":"balance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"baseLerpSpeed","t":4,"rt":$n[0].Single,"sn":"baseLerpSpeed","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"centerOfGravityXOffset","t":4,"rt":$n[0].Single,"sn":"centerOfGravityXOffset","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"comfyDistance","t":4,"rt":$n[0].Single,"sn":"comfyDistance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"distanceBetweenFeet","t":4,"rt":$n[0].Single,"sn":"distanceBetweenFeet","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new Spine.Unity.SpineBone("", "", true, false)],"a":2,"n":"farBoneName","t":4,"rt":$n[0].String,"sn":"farBoneName"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"farFoot","t":4,"rt":$n[12].SpineboyFootplanter.Foot,"sn":"farFoot"},{"a":1,"n":"farFootBone","t":4,"rt":$n[5].Bone,"sn":"farFootBone"},{"a":2,"n":"feetTooFarApartThreshold","t":4,"rt":$n[0].Single,"sn":"feetTooFarApartThreshold","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"footRayRaise","t":4,"rt":$n[0].Single,"sn":"footRayRaise","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.HeaderAttribute("Settings")],"a":2,"n":"footSize","t":4,"rt":$n[3].Vector2,"sn":"footSize"},{"a":2,"n":"forward","t":4,"rt":$n[12].SpineboyFootplanter.FootMovement,"sn":"forward"},{"a":1,"n":"hits","t":4,"rt":System.Array.type(UnityEngine.RaycastHit2D),"sn":"hits"},{"a":2,"n":"maxNewStepDisplacement","t":4,"rt":$n[0].Single,"sn":"maxNewStepDisplacement","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"minimumSpaceBetweenFeet","t":4,"rt":$n[0].Single,"sn":"minimumSpaceBetweenFeet","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new Spine.Unity.SpineBone("", "", true, false)],"a":2,"n":"nearBoneName","t":4,"rt":$n[0].String,"sn":"nearBoneName"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"nearFoot","t":4,"rt":$n[12].SpineboyFootplanter.Foot,"sn":"nearFoot"},{"a":1,"n":"nearFootBone","t":4,"rt":$n[5].Bone,"sn":"nearFootBone"},{"a":2,"n":"offBalanceThreshold","t":4,"rt":$n[0].Single,"sn":"offBalanceThreshold","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"shuffleDistance","t":4,"rt":$n[0].Single,"sn":"shuffleDistance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"skeleton","t":4,"rt":$n[5].Skeleton,"sn":"skeleton"},{"a":2,"n":"timeScale","t":4,"rt":$n[0].Single,"sn":"timeScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Unity.Examples.SpineboyFootplanter end.*/

    /*Spine.Unity.Examples.SpineboyFootplanter+FootMovement start.*/
    $m("Spine.Unity.Examples.SpineboyFootplanter.FootMovement", function () { return {"td":$n[12].SpineboyFootplanter,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"maxDistanceCompensate","t":4,"rt":$n[0].Single,"sn":"maxDistanceCompensate","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"maxRaise","t":4,"rt":$n[0].Single,"sn":"maxRaise","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"minDistanceCompensate","t":4,"rt":$n[0].Single,"sn":"minDistanceCompensate","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"raiseCurve","t":4,"rt":pc.AnimationCurve,"sn":"raiseCurve"},{"a":2,"n":"xMoveCurve","t":4,"rt":pc.AnimationCurve,"sn":"xMoveCurve"}]}; }, $n);
    /*Spine.Unity.Examples.SpineboyFootplanter+FootMovement end.*/

    /*Spine.Unity.Examples.SpineboyFootplanter+Foot start.*/
    $m("Spine.Unity.Examples.SpineboyFootplanter.Foot", function () { return {"td":$n[12].SpineboyFootplanter,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"GetNewDisplacement","is":true,"t":8,"pi":[{"n":"otherLegDisplacementFromCenter","pt":$n[0].Single,"ps":0},{"n":"comfyDistance","pt":$n[0].Single,"ps":1},{"n":"minimumFootDistanceX","pt":$n[0].Single,"ps":2},{"n":"maxNewStepDisplacement","pt":$n[0].Single,"ps":3},{"n":"forwardMovement","pt":$n[12].SpineboyFootplanter.FootMovement,"ps":4},{"n":"backwardMovement","pt":$n[12].SpineboyFootplanter.FootMovement,"ps":5}],"sn":"GetNewDisplacement","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[12].SpineboyFootplanter.FootMovement,$n[12].SpineboyFootplanter.FootMovement],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"StartNewStep","t":8,"pi":[{"n":"newDistance","pt":$n[0].Single,"ps":0},{"n":"centerOfGravityX","pt":$n[0].Single,"ps":1},{"n":"tentativeY","pt":$n[0].Single,"ps":2},{"n":"footRayRaise","pt":$n[0].Single,"ps":3},{"n":"hits","pt":System.Array.type(UnityEngine.RaycastHit2D),"ps":4},{"n":"footSize","pt":$n[3].Vector2,"ps":5}],"sn":"StartNewStep","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,System.Array.type(UnityEngine.RaycastHit2D),$n[3].Vector2]},{"a":2,"n":"UpdateDistance","t":8,"pi":[{"n":"centerOfGravityX","pt":$n[0].Single,"ps":0}],"sn":"UpdateDistance","rt":$n[0].Void,"p":[$n[0].Single]},{"a":2,"n":"UpdateStepProgress","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0},{"n":"stepSpeed","pt":$n[0].Single,"ps":1},{"n":"shuffleDistance","pt":$n[0].Single,"ps":2},{"n":"forwardMovement","pt":$n[12].SpineboyFootplanter.FootMovement,"ps":3},{"n":"backwardMovement","pt":$n[12].SpineboyFootplanter.FootMovement,"ps":4}],"sn":"UpdateStepProgress","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[12].SpineboyFootplanter.FootMovement,$n[12].SpineboyFootplanter.FootMovement]},{"a":2,"n":"IsPrettyMuchDoneStepping","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsPrettyMuchDoneStepping","t":8,"rt":$n[0].Boolean,"fg":"IsPrettyMuchDoneStepping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsPrettyMuchDoneStepping"},{"a":2,"n":"IsStepInProgress","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsStepInProgress","t":8,"rt":$n[0].Boolean,"fg":"IsStepInProgress","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsStepInProgress"},{"a":2,"n":"displacementFromCenter","t":4,"rt":$n[0].Single,"sn":"displacementFromCenter","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"distanceFromCenter","t":4,"rt":$n[0].Single,"sn":"distanceFromCenter","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SpaceAttribute.ctor()],"a":2,"n":"lerp","t":4,"rt":$n[0].Single,"sn":"lerp","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"worldPos","t":4,"rt":$n[3].Vector2,"sn":"worldPos"},{"a":2,"n":"worldPosNext","t":4,"rt":$n[3].Vector2,"sn":"worldPosNext"},{"a":2,"n":"worldPosPrev","t":4,"rt":$n[3].Vector2,"sn":"worldPosPrev"}]}; }, $n);
    /*Spine.Unity.Examples.SpineboyFootplanter+Foot end.*/

    /*Spine.Unity.Examples.SpineboyFreeze start.*/
    $m("Spine.Unity.Examples.SpineboyFreeze", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[4].IEnumerator},{"a":2,"n":"blackTintProperty","t":4,"rt":$n[0].String,"sn":"blackTintProperty"},{"a":1,"n":"block","t":4,"rt":$n[3].MaterialPropertyBlock,"sn":"block"},{"a":2,"n":"colorProperty","t":4,"rt":$n[0].String,"sn":"colorProperty"},{"a":2,"n":"freeze","t":4,"rt":$n[1].AnimationReferenceAsset,"sn":"freeze"},{"a":2,"n":"freezeBlackColor","t":4,"rt":$n[3].Color,"sn":"freezeBlackColor"},{"a":2,"n":"freezeColor","t":4,"rt":$n[3].Color,"sn":"freezeColor"},{"a":2,"n":"freezePoint","t":4,"rt":$n[0].Single,"sn":"freezePoint","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"idle","t":4,"rt":$n[1].AnimationReferenceAsset,"sn":"idle"},{"a":1,"n":"meshRenderer","t":4,"rt":$n[3].MeshRenderer,"sn":"meshRenderer"},{"a":2,"n":"particles","t":4,"rt":$n[3].ParticleSystem,"sn":"particles"},{"a":2,"n":"skeletonAnimation","t":4,"rt":$n[1].SkeletonAnimation,"sn":"skeletonAnimation"}]}; }, $n);
    /*Spine.Unity.Examples.SpineboyFreeze end.*/

    /*Spine.Unity.Examples.SpineboyPole start.*/
    $m("Spine.Unity.Examples.SpineboyPole", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"SetXPosition","t":8,"pi":[{"n":"x","pt":$n[0].Single,"ps":0}],"sn":"SetXPosition","rt":$n[0].Void,"p":[$n[0].Single]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[4].IEnumerator},{"a":1,"n":"RunTimeScale","is":true,"t":4,"rt":$n[0].Single,"sn":"RunTimeScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"Speed","is":true,"t":4,"rt":$n[0].Single,"sn":"Speed","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"endX","t":4,"rt":$n[0].Single,"sn":"endX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"pole","t":4,"rt":$n[1].AnimationReferenceAsset,"sn":"pole"},{"at":[new UnityEngine.SpaceAttribute.$ctor1(18.0)],"a":2,"n":"run","t":4,"rt":$n[1].AnimationReferenceAsset,"sn":"run"},{"a":2,"n":"separator","t":4,"rt":$n[1].SkeletonRenderSeparator,"sn":"separator"},{"a":2,"n":"skeletonAnimation","t":4,"rt":$n[1].SkeletonAnimation,"sn":"skeletonAnimation"},{"a":2,"n":"startX","t":4,"rt":$n[0].Single,"sn":"startX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Unity.Examples.SpineboyPole end.*/

    /*Spine.Unity.Examples.SpineboyPoleGraphic start.*/
    $m("Spine.Unity.Examples.SpineboyPoleGraphic", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"SetXPosition","t":8,"pi":[{"n":"x","pt":$n[0].Single,"ps":0}],"sn":"SetXPosition","rt":$n[0].Void,"p":[$n[0].Single]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[4].IEnumerator},{"a":1,"n":"RunTimeScale","is":true,"t":4,"rt":$n[0].Single,"sn":"RunTimeScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"Speed","is":true,"t":4,"rt":$n[0].Single,"sn":"Speed","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"endX","t":4,"rt":$n[0].Single,"sn":"endX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"pole","t":4,"rt":$n[1].AnimationReferenceAsset,"sn":"pole"},{"at":[new UnityEngine.SpaceAttribute.$ctor1(18.0)],"a":2,"n":"run","t":4,"rt":$n[1].AnimationReferenceAsset,"sn":"run"},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[1].SkeletonGraphic,"sn":"skeletonGraphic"},{"a":2,"n":"startX","t":4,"rt":$n[0].Single,"sn":"startX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Unity.Examples.SpineboyPoleGraphic end.*/

    /*Spine.Unity.Examples.SpineGauge start.*/
    $m("Spine.Unity.Examples.SpineGauge", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteInEditModeAttribute(),new UnityEngine.RequireComponent.ctor(Spine.Unity.SkeletonRenderer)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"SetGaugePercent","t":8,"pi":[{"n":"percent","pt":$n[0].Single,"ps":0}],"sn":"SetGaugePercent","rt":$n[0].Void,"p":[$n[0].Single]},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"fillAnimation","t":4,"rt":$n[1].AnimationReferenceAsset,"sn":"fillAnimation"},{"at":[new UnityEngine.RangeAttribute(0.0, 1.0)],"a":2,"n":"fillPercent","t":4,"rt":$n[0].Single,"sn":"fillPercent","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"skeletonRenderer","t":4,"rt":$n[1].SkeletonRenderer,"sn":"skeletonRenderer"}]}; }, $n);
    /*Spine.Unity.Examples.SpineGauge end.*/

    /*DG.Tweening.DOTweenModuleAudio start.*/
    $m("DG.Tweening.DOTweenModuleAudio", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOComplete","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0},{"n":"withCallbacks","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"DOComplete","rt":$n[0].Int32,"p":[$n[13].AudioMixer,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].AudioSource,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade","rt":$n[14].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[3].AudioSource,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFlip","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0}],"sn":"DOFlip","rt":$n[0].Int32,"p":[$n[13].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOGoto","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0},{"n":"to","pt":$n[0].Single,"ps":1},{"n":"andPlay","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"DOGoto","rt":$n[0].Int32,"p":[$n[13].AudioMixer,$n[0].Single,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOKill","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0},{"n":"complete","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"DOKill","rt":$n[0].Int32,"p":[$n[13].AudioMixer,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOPause","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0}],"sn":"DOPause","rt":$n[0].Int32,"p":[$n[13].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOPitch","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].AudioSource,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOPitch","rt":$n[14].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[3].AudioSource,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOPlay","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0}],"sn":"DOPlay","rt":$n[0].Int32,"p":[$n[13].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOPlayBackwards","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0}],"sn":"DOPlayBackwards","rt":$n[0].Int32,"p":[$n[13].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOPlayForward","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0}],"sn":"DOPlayForward","rt":$n[0].Int32,"p":[$n[13].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DORestart","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0}],"sn":"DORestart","rt":$n[0].Int32,"p":[$n[13].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DORewind","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0}],"sn":"DORewind","rt":$n[0].Int32,"p":[$n[13].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOSetFloat","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0},{"n":"floatName","pt":$n[0].String,"ps":1},{"n":"endValue","pt":$n[0].Single,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3}],"sn":"DOSetFloat","rt":$n[14].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[13].AudioMixer,$n[0].String,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOSmoothRewind","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0}],"sn":"DOSmoothRewind","rt":$n[0].Int32,"p":[$n[13].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOTogglePause","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0}],"sn":"DOTogglePause","rt":$n[0].Int32,"p":[$n[13].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*DG.Tweening.DOTweenModuleAudio end.*/

    /*DG.Tweening.DOTweenModulePhysics start.*/
    $m("DG.Tweening.DOTweenModulePhysics", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOJump","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Rigidbody,"ps":0},{"n":"endValue","pt":$n[3].Vector3,"ps":1},{"n":"jumpPower","pt":$n[0].Single,"ps":2},{"n":"numJumps","pt":$n[0].Int32,"ps":3},{"n":"duration","pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOJump","rt":$n[15].Sequence,"p":[$n[3].Rigidbody,$n[3].Vector3,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean]},{"a":4,"n":"DOLocalPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Rigidbody,"ps":0},{"n":"path","pt":$n[16].Path,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathMode","dv":1,"o":true,"pt":$n[15].PathMode,"ps":3}],"sn":"DOLocalPath$1","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[3].Rigidbody,$n[16].Path,$n[0].Single,$n[15].PathMode]},{"a":2,"n":"DOLocalPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Rigidbody,"ps":0},{"n":"path","pt":System.Array.type(UnityEngine.Vector3),"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathType","dv":0,"o":true,"pt":$n[15].PathType,"ps":3},{"n":"pathMode","dv":1,"o":true,"pt":$n[15].PathMode,"ps":4},{"n":"resolution","dv":10,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"gizmoColor","dv":null,"o":true,"pt":$n[0].Nullable$1(UnityEngine.Color),"ps":6}],"sn":"DOLocalPath","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[3].Rigidbody,System.Array.type(UnityEngine.Vector3),$n[0].Single,$n[15].PathType,$n[15].PathMode,$n[0].Int32,$n[0].Nullable$1(UnityEngine.Color)]},{"a":2,"n":"DOLookAt","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Rigidbody,"ps":0},{"n":"towards","pt":$n[3].Vector3,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"axisConstraint","dv":0,"o":true,"pt":$n[15].AxisConstraint,"ps":3},{"n":"up","dv":null,"o":true,"pt":$n[0].Nullable$1(UnityEngine.Vector3),"ps":4}],"sn":"DOLookAt","rt":$n[14].TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions),"p":[$n[3].Rigidbody,$n[3].Vector3,$n[0].Single,$n[15].AxisConstraint,$n[0].Nullable$1(UnityEngine.Vector3)]},{"a":2,"n":"DOMove","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Rigidbody,"ps":0},{"n":"endValue","pt":$n[3].Vector3,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMove","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].Rigidbody,$n[3].Vector3,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMoveX","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Rigidbody,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMoveX","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].Rigidbody,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMoveY","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Rigidbody,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMoveY","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].Rigidbody,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMoveZ","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Rigidbody,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMoveZ","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].Rigidbody,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":4,"n":"DOPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Rigidbody,"ps":0},{"n":"path","pt":$n[16].Path,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathMode","dv":1,"o":true,"pt":$n[15].PathMode,"ps":3}],"sn":"DOPath$1","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[3].Rigidbody,$n[16].Path,$n[0].Single,$n[15].PathMode]},{"a":2,"n":"DOPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Rigidbody,"ps":0},{"n":"path","pt":System.Array.type(UnityEngine.Vector3),"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathType","dv":0,"o":true,"pt":$n[15].PathType,"ps":3},{"n":"pathMode","dv":1,"o":true,"pt":$n[15].PathMode,"ps":4},{"n":"resolution","dv":10,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"gizmoColor","dv":null,"o":true,"pt":$n[0].Nullable$1(UnityEngine.Color),"ps":6}],"sn":"DOPath","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[3].Rigidbody,System.Array.type(UnityEngine.Vector3),$n[0].Single,$n[15].PathType,$n[15].PathMode,$n[0].Int32,$n[0].Nullable$1(UnityEngine.Color)]},{"a":2,"n":"DORotate","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Rigidbody,"ps":0},{"n":"endValue","pt":$n[3].Vector3,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"mode","dv":0,"o":true,"pt":$n[15].RotateMode,"ps":3}],"sn":"DORotate","rt":$n[14].TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions),"p":[$n[3].Rigidbody,$n[3].Vector3,$n[0].Single,$n[15].RotateMode]}]}; }, $n);
    /*DG.Tweening.DOTweenModulePhysics end.*/

    /*DG.Tweening.DOTweenModulePhysics2D start.*/
    $m("DG.Tweening.DOTweenModulePhysics2D", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOJump","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[3].Vector2,"ps":1},{"n":"jumpPower","pt":$n[0].Single,"ps":2},{"n":"numJumps","pt":$n[0].Int32,"ps":3},{"n":"duration","pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOJump","rt":$n[15].Sequence,"p":[$n[3].Rigidbody2D,$n[3].Vector2,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean]},{"a":4,"n":"DOLocalPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Rigidbody2D,"ps":0},{"n":"path","pt":$n[16].Path,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathMode","dv":1,"o":true,"pt":$n[15].PathMode,"ps":3}],"sn":"DOLocalPath$1","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[3].Rigidbody2D,$n[16].Path,$n[0].Single,$n[15].PathMode]},{"a":2,"n":"DOLocalPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Rigidbody2D,"ps":0},{"n":"path","pt":System.Array.type(UnityEngine.Vector2),"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathType","dv":0,"o":true,"pt":$n[15].PathType,"ps":3},{"n":"pathMode","dv":1,"o":true,"pt":$n[15].PathMode,"ps":4},{"n":"resolution","dv":10,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"gizmoColor","dv":null,"o":true,"pt":$n[0].Nullable$1(UnityEngine.Color),"ps":6}],"sn":"DOLocalPath","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[3].Rigidbody2D,System.Array.type(UnityEngine.Vector2),$n[0].Single,$n[15].PathType,$n[15].PathMode,$n[0].Int32,$n[0].Nullable$1(UnityEngine.Color)]},{"a":2,"n":"DOMove","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[3].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMove","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].Rigidbody2D,$n[3].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMoveX","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMoveX","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].Rigidbody2D,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMoveY","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMoveY","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].Rigidbody2D,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":4,"n":"DOPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Rigidbody2D,"ps":0},{"n":"path","pt":$n[16].Path,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathMode","dv":1,"o":true,"pt":$n[15].PathMode,"ps":3}],"sn":"DOPath$1","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[3].Rigidbody2D,$n[16].Path,$n[0].Single,$n[15].PathMode]},{"a":2,"n":"DOPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Rigidbody2D,"ps":0},{"n":"path","pt":System.Array.type(UnityEngine.Vector2),"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathType","dv":0,"o":true,"pt":$n[15].PathType,"ps":3},{"n":"pathMode","dv":1,"o":true,"pt":$n[15].PathMode,"ps":4},{"n":"resolution","dv":10,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"gizmoColor","dv":null,"o":true,"pt":$n[0].Nullable$1(UnityEngine.Color),"ps":6}],"sn":"DOPath","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[3].Rigidbody2D,System.Array.type(UnityEngine.Vector2),$n[0].Single,$n[15].PathType,$n[15].PathMode,$n[0].Int32,$n[0].Nullable$1(UnityEngine.Color)]},{"a":2,"n":"DORotate","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DORotate","rt":$n[14].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[3].Rigidbody2D,$n[0].Single,$n[0].Single]}]}; }, $n);
    /*DG.Tweening.DOTweenModulePhysics2D end.*/

    /*DG.Tweening.DOTweenModuleSprite start.*/
    $m("DG.Tweening.DOTweenModuleSprite", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].SpriteRenderer,"ps":0},{"n":"endValue","pt":$n[3].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOBlendableColor","rt":$n[15].Tweener,"p":[$n[3].SpriteRenderer,$n[3].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].SpriteRenderer,"ps":0},{"n":"endValue","pt":$n[3].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor","rt":$n[14].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[3].SpriteRenderer,$n[3].Color,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].SpriteRenderer,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade","rt":$n[14].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[3].SpriteRenderer,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].SpriteRenderer,"ps":0},{"n":"gradient","pt":pc.ColorGradient,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOGradientColor","rt":$n[15].Sequence,"p":[$n[3].SpriteRenderer,pc.ColorGradient,$n[0].Single]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleSprite end.*/

    /*DG.Tweening.DOTweenModuleUI start.*/
    $m("DG.Tweening.DOTweenModuleUI", function () { return {"nested":[$n[15].DOTweenModuleUI.Utils],"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOAnchorMax","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].RectTransform,"ps":0},{"n":"endValue","pt":$n[3].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorMax","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].RectTransform,$n[3].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorMin","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].RectTransform,"ps":0},{"n":"endValue","pt":$n[3].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorMin","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].RectTransform,$n[3].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].RectTransform,"ps":0},{"n":"endValue","pt":$n[3].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].RectTransform,$n[3].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos3D","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].RectTransform,"ps":0},{"n":"endValue","pt":$n[3].Vector3,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos3D","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].RectTransform,$n[3].Vector3,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos3DX","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos3DX","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos3DY","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos3DY","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos3DZ","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos3DZ","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPosX","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPosX","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPosY","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPosY","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].Graphic,"ps":0},{"n":"endValue","pt":$n[3].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOBlendableColor","rt":$n[15].Tweener,"p":[$n[7].Graphic,$n[3].Color,$n[0].Single]},{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].Image,"ps":0},{"n":"endValue","pt":$n[3].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOBlendableColor$1","rt":$n[15].Tweener,"p":[$n[7].Image,$n[3].Color,$n[0].Single]},{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].Text,"ps":0},{"n":"endValue","pt":$n[3].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOBlendableColor$2","rt":$n[15].Tweener,"p":[$n[7].Text,$n[3].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].Graphic,"ps":0},{"n":"endValue","pt":$n[3].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor","rt":$n[14].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[7].Graphic,$n[3].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].Image,"ps":0},{"n":"endValue","pt":$n[3].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor$1","rt":$n[14].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[7].Image,$n[3].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].Outline,"ps":0},{"n":"endValue","pt":$n[3].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor$2","rt":$n[14].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[7].Outline,$n[3].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].Text,"ps":0},{"n":"endValue","pt":$n[3].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor$3","rt":$n[14].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[7].Text,$n[3].Color,$n[0].Single]},{"a":2,"n":"DOCounter","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].Text,"ps":0},{"n":"fromValue","pt":$n[0].Int32,"ps":1},{"n":"endValue","pt":$n[0].Int32,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3},{"n":"addThousandsSeparator","dv":true,"o":true,"pt":$n[0].Boolean,"ps":4},{"n":"culture","dv":null,"o":true,"pt":$n[17].CultureInfo,"ps":5}],"sn":"DOCounter","rt":$n[14].TweenerCore$3(System.Int32,System.Int32,DG.Tweening.Plugins.Options.NoOptions),"p":[$n[7].Text,$n[0].Int32,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[17].CultureInfo]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].CanvasGroup,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade","rt":$n[14].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[3].CanvasGroup,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].Graphic,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade$1","rt":$n[14].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[7].Graphic,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].Image,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade$2","rt":$n[14].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[7].Image,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].Outline,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade$3","rt":$n[14].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[7].Outline,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].Text,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade$4","rt":$n[14].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[7].Text,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFillAmount","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].Image,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFillAmount","rt":$n[14].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[7].Image,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFlexibleSize","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].LayoutElement,"ps":0},{"n":"endValue","pt":$n[3].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOFlexibleSize","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[7].LayoutElement,$n[3].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].Image,"ps":0},{"n":"gradient","pt":pc.ColorGradient,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOGradientColor","rt":$n[15].Sequence,"p":[$n[7].Image,pc.ColorGradient,$n[0].Single]},{"a":2,"n":"DOHorizontalNormalizedPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].ScrollRect,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOHorizontalNormalizedPos","rt":$n[15].Tweener,"p":[$n[7].ScrollRect,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOJumpAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].RectTransform,"ps":0},{"n":"endValue","pt":$n[3].Vector2,"ps":1},{"n":"jumpPower","pt":$n[0].Single,"ps":2},{"n":"numJumps","pt":$n[0].Int32,"ps":3},{"n":"duration","pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOJumpAnchorPos","rt":$n[15].Sequence,"p":[$n[3].RectTransform,$n[3].Vector2,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMinSize","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].LayoutElement,"ps":0},{"n":"endValue","pt":$n[3].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMinSize","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[7].LayoutElement,$n[3].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DONormalizedPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].ScrollRect,"ps":0},{"n":"endValue","pt":$n[3].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DONormalizedPos","rt":$n[15].Tweener,"p":[$n[7].ScrollRect,$n[3].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOPivot","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].RectTransform,"ps":0},{"n":"endValue","pt":$n[3].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOPivot","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].RectTransform,$n[3].Vector2,$n[0].Single]},{"a":2,"n":"DOPivotX","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOPivotX","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].RectTransform,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOPivotY","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOPivotY","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].RectTransform,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOPreferredSize","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].LayoutElement,"ps":0},{"n":"endValue","pt":$n[3].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOPreferredSize","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[7].LayoutElement,$n[3].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOPunchAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].RectTransform,"ps":0},{"n":"punch","pt":$n[3].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"vibrato","dv":10,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"elasticity","dv":1.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOPunchAnchorPos","rt":$n[15].Tweener,"p":[$n[3].RectTransform,$n[3].Vector2,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOScale","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].Outline,"ps":0},{"n":"endValue","pt":$n[3].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOScale","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[7].Outline,$n[3].Vector2,$n[0].Single]},{"a":2,"n":"DOShakeAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].RectTransform,"ps":0},{"n":"duration","pt":$n[0].Single,"ps":1},{"n":"strength","dv":100.0,"o":true,"pt":$n[0].Single,"ps":2},{"n":"vibrato","dv":10,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"randomness","dv":90.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5},{"n":"fadeOut","dv":true,"o":true,"pt":$n[0].Boolean,"ps":6},{"n":"randomnessMode","dv":0,"o":true,"pt":$n[15].ShakeRandomnessMode,"ps":7}],"sn":"DOShakeAnchorPos","rt":$n[15].Tweener,"p":[$n[3].RectTransform,$n[0].Single,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[0].Boolean,$n[15].ShakeRandomnessMode]},{"a":2,"n":"DOShakeAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].RectTransform,"ps":0},{"n":"duration","pt":$n[0].Single,"ps":1},{"n":"strength","pt":$n[3].Vector2,"ps":2},{"n":"vibrato","dv":10,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"randomness","dv":90.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5},{"n":"fadeOut","dv":true,"o":true,"pt":$n[0].Boolean,"ps":6},{"n":"randomnessMode","dv":0,"o":true,"pt":$n[15].ShakeRandomnessMode,"ps":7}],"sn":"DOShakeAnchorPos$1","rt":$n[15].Tweener,"p":[$n[3].RectTransform,$n[0].Single,$n[3].Vector2,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[0].Boolean,$n[15].ShakeRandomnessMode]},{"a":2,"n":"DOShapeCircle","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].RectTransform,"ps":0},{"n":"center","pt":$n[3].Vector2,"ps":1},{"n":"endValueDegrees","pt":$n[0].Single,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3},{"n":"relativeCenter","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOShapeCircle","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.CircleOptions),"p":[$n[3].RectTransform,$n[3].Vector2,$n[0].Single,$n[0].Single,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"DOSizeDelta","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].RectTransform,"ps":0},{"n":"endValue","pt":$n[3].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOSizeDelta","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].RectTransform,$n[3].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOText","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].Text,"ps":0},{"n":"endValue","pt":$n[0].String,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"richTextEnabled","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"scrambleMode","dv":0,"o":true,"pt":$n[15].ScrambleMode,"ps":4},{"n":"scrambleChars","dv":null,"o":true,"pt":$n[0].String,"ps":5}],"sn":"DOText","rt":$n[14].TweenerCore$3(System.String,System.String,DG.Tweening.Plugins.Options.StringOptions),"p":[$n[7].Text,$n[0].String,$n[0].Single,$n[0].Boolean,$n[15].ScrambleMode,$n[0].String]},{"a":2,"n":"DOValue","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].Slider,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOValue","rt":$n[14].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[7].Slider,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOVerticalNormalizedPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].ScrollRect,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOVerticalNormalizedPos","rt":$n[15].Tweener,"p":[$n[7].ScrollRect,$n[0].Single,$n[0].Single,$n[0].Boolean]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUI end.*/

    /*DG.Tweening.DOTweenModuleUI+Utils start.*/
    $m("DG.Tweening.DOTweenModuleUI.Utils", function () { return {"td":$n[15].DOTweenModuleUI,"att":1048962,"a":2,"s":true,"m":[{"a":2,"n":"SwitchToRectTransform","is":true,"t":8,"pi":[{"n":"from","pt":$n[3].RectTransform,"ps":0},{"n":"to","pt":$n[3].RectTransform,"ps":1}],"sn":"SwitchToRectTransform","rt":$n[3].Vector2,"p":[$n[3].RectTransform,$n[3].RectTransform]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUI+Utils end.*/

    /*DG.Tweening.DOTweenModuleUnityVersion start.*/
    $m("DG.Tweening.DOTweenModuleUnityVersion", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Material,"ps":0},{"n":"gradient","pt":pc.ColorGradient,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOGradientColor","rt":$n[15].Sequence,"p":[$n[3].Material,pc.ColorGradient,$n[0].Single]},{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Material,"ps":0},{"n":"gradient","pt":pc.ColorGradient,"ps":1},{"n":"property","pt":$n[0].String,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3}],"sn":"DOGradientColor$1","rt":$n[15].Sequence,"p":[$n[3].Material,pc.ColorGradient,$n[0].String,$n[0].Single]},{"a":2,"n":"DOOffset","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Material,"ps":0},{"n":"endValue","pt":$n[3].Vector2,"ps":1},{"n":"propertyID","pt":$n[0].Int32,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3}],"sn":"DOOffset","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].Material,$n[3].Vector2,$n[0].Int32,$n[0].Single]},{"a":2,"n":"DOTiling","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Material,"ps":0},{"n":"endValue","pt":$n[3].Vector2,"ps":1},{"n":"propertyID","pt":$n[0].Int32,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3}],"sn":"DOTiling","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].Material,$n[3].Vector2,$n[0].Int32,$n[0].Single]},{"a":2,"n":"WaitForCompletion","is":true,"t":8,"pi":[{"n":"t","pt":$n[15].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":1}],"sn":"WaitForCompletion","rt":$n[3].CustomYieldInstruction,"p":[$n[15].Tween,$n[0].Boolean]},{"a":2,"n":"WaitForElapsedLoops","is":true,"t":8,"pi":[{"n":"t","pt":$n[15].Tween,"ps":0},{"n":"elapsedLoops","pt":$n[0].Int32,"ps":1},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":2}],"sn":"WaitForElapsedLoops","rt":$n[3].CustomYieldInstruction,"p":[$n[15].Tween,$n[0].Int32,$n[0].Boolean]},{"a":2,"n":"WaitForKill","is":true,"t":8,"pi":[{"n":"t","pt":$n[15].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":1}],"sn":"WaitForKill","rt":$n[3].CustomYieldInstruction,"p":[$n[15].Tween,$n[0].Boolean]},{"a":2,"n":"WaitForPosition","is":true,"t":8,"pi":[{"n":"t","pt":$n[15].Tween,"ps":0},{"n":"position","pt":$n[0].Single,"ps":1},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":2}],"sn":"WaitForPosition","rt":$n[3].CustomYieldInstruction,"p":[$n[15].Tween,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"WaitForRewind","is":true,"t":8,"pi":[{"n":"t","pt":$n[15].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":1}],"sn":"WaitForRewind","rt":$n[3].CustomYieldInstruction,"p":[$n[15].Tween,$n[0].Boolean]},{"a":2,"n":"WaitForStart","is":true,"t":8,"pi":[{"n":"t","pt":$n[15].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":1}],"sn":"WaitForStart","rt":$n[3].CustomYieldInstruction,"p":[$n[15].Tween,$n[0].Boolean]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUnityVersion end.*/

    /*DG.Tweening.DOTweenCYInstruction start.*/
    $m("DG.Tweening.DOTweenCYInstruction", function () { return {"nested":[$n[15].DOTweenCYInstruction.WaitForCompletion,$n[15].DOTweenCYInstruction.WaitForRewind,$n[15].DOTweenCYInstruction.WaitForKill,$n[15].DOTweenCYInstruction.WaitForElapsedLoops,$n[15].DOTweenCYInstruction.WaitForPosition,$n[15].DOTweenCYInstruction.WaitForStart],"att":1048961,"a":2,"s":true}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForCompletion", function () { return {"td":$n[15].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[15].Tween],"pi":[{"n":"tween","pt":$n[15].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[15].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForRewind", function () { return {"td":$n[15].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[15].Tween],"pi":[{"n":"tween","pt":$n[15].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[15].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForKill start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForKill", function () { return {"td":$n[15].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[15].Tween],"pi":[{"n":"tween","pt":$n[15].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[15].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForKill end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops", function () { return {"td":$n[15].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[15].Tween,$n[0].Int32],"pi":[{"n":"tween","pt":$n[15].Tween,"ps":0},{"n":"elapsedLoops","pt":$n[0].Int32,"ps":1}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"elapsedLoops","t":4,"rt":$n[0].Int32,"sn":"elapsedLoops","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"t","t":4,"rt":$n[15].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForPosition", function () { return {"td":$n[15].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[15].Tween,$n[0].Single],"pi":[{"n":"tween","pt":$n[15].Tween,"ps":0},{"n":"position","pt":$n[0].Single,"ps":1}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"position","t":4,"rt":$n[0].Single,"sn":"position","ro":true,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"t","t":4,"rt":$n[15].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForStart start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForStart", function () { return {"td":$n[15].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[15].Tween],"pi":[{"n":"tween","pt":$n[15].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[15].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForStart end.*/

    /*DG.Tweening.DOTweenModuleUtils start.*/
    $m("DG.Tweening.DOTweenModuleUtils", function () { return {"nested":[$n[15].DOTweenModuleUtils.Physics],"att":1048961,"a":2,"s":true,"m":[{"at":[new UnityEngine.Scripting.PreserveAttribute()],"a":2,"n":"Init","is":true,"t":8,"sn":"Init","rt":$n[0].Void},{"at":[new UnityEngine.Scripting.PreserveAttribute()],"a":1,"n":"Preserver","is":true,"t":8,"sn":"Preserver","rt":$n[0].Void},{"a":1,"n":"_initialized","is":true,"t":4,"rt":$n[0].Boolean,"sn":"_initialized","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUtils end.*/

    /*DG.Tweening.DOTweenModuleUtils+Physics start.*/
    $m("DG.Tweening.DOTweenModuleUtils.Physics", function () { return {"td":$n[15].DOTweenModuleUtils,"att":1048962,"a":2,"s":true,"m":[{"at":[new UnityEngine.Scripting.PreserveAttribute()],"a":2,"n":"CreateDOTweenPathTween","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].MonoBehaviour,"ps":0},{"n":"tweenRigidbody","pt":$n[0].Boolean,"ps":1},{"n":"isLocal","pt":$n[0].Boolean,"ps":2},{"n":"path","pt":$n[16].Path,"ps":3},{"n":"duration","pt":$n[0].Single,"ps":4},{"n":"pathMode","pt":$n[15].PathMode,"ps":5}],"sn":"CreateDOTweenPathTween","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[3].MonoBehaviour,$n[0].Boolean,$n[0].Boolean,$n[16].Path,$n[0].Single,$n[15].PathMode]},{"at":[new UnityEngine.Scripting.PreserveAttribute()],"a":2,"n":"HasRigidbody","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Component,"ps":0}],"sn":"HasRigidbody","rt":$n[0].Boolean,"p":[$n[3].Component],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"HasRigidbody2D","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Component,"ps":0}],"sn":"HasRigidbody2D","rt":$n[0].Boolean,"p":[$n[3].Component],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SetOrientationOnPath","is":true,"t":8,"pi":[{"n":"options","pt":$n[18].PathOptions,"ps":0},{"n":"t","pt":$n[15].Tween,"ps":1},{"n":"newRot","pt":$n[3].Quaternion,"ps":2},{"n":"trans","pt":$n[3].Transform,"ps":3}],"sn":"SetOrientationOnPath","rt":$n[0].Void,"p":[$n[18].PathOptions,$n[15].Tween,$n[3].Quaternion,$n[3].Transform]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUtils+Physics end.*/

    }});
